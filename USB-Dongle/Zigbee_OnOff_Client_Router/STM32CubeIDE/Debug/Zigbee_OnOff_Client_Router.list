
Zigbee_OnOff_Client_Router.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00019244  08000140  08000140  00010140  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000a10  08019388  08019388  00029388  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08019d98  08019d98  00029d98  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08019d9c  08019d9c  00029d9c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000168  20000008  08019da0  00030008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 SYSTEM_DRIVER_CONTEXT 00000011  20000170  08019f08  00030170  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00002774  20000184  08019f19  00030184  2**2
                  ALLOC
  8 ._user_heap_stack 0001a000  200028f8  08019f19  000328f8  2**0
                  ALLOC
  9 .ARM.attributes 00000034  00000000  00000000  00030181  2**0
                  CONTENTS, READONLY
 10 MAPPING_TABLE 00000028  20030000  20030000  00040000  2**2
                  ALLOC
 11 MB_MEM1       000000bc  20030028  20030028  00040000  2**2
                  ALLOC
 12 MB_MEM2       00000a76  200300e4  200300e4  00040000  2**2
                  ALLOC
 13 .comment      00006512  00000000  00000000  000301b5  2**0
                  CONTENTS, READONLY
 14 .iar.rtmodel  00000288  00000000  00000000  000366c7  2**0
                  CONTENTS, READONLY
 15 .iar_vfe_header 00000030  00000000  00000000  00036950  2**2
                  CONTENTS, READONLY
 16 .debug_info   00045689  00000000  00000000  00036980  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00008b92  00000000  00000000  0007c009  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00003b78  00000000  00000000  00084ba0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00002343  00000000  00000000  00088718  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0002eee1  00000000  00000000  0008aa5b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0003d1f2  00000000  00000000  000b993c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    001040f9  00000000  00000000  000f6b2e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_frame  0000df80  00000000  00000000  001fac28  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_line_str 000000d2  00000000  00000000  00208ba8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_loc    00005acd  00000000  00000000  00208c7a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 26 .debug_pubnames 00001451  00000000  00000000  0020e747  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 27 .debug_macinfo 00000665  00000000  00000000  0020fb98  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 28 .debug_types  0000284b  00000000  00000000  002101fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 29 .debug_ranges 00000018  00000000  00000000  00212a48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000140 <__do_global_dtors_aux>:
 8000140:	b510      	push	{r4, lr}
 8000142:	4c05      	ldr	r4, [pc, #20]	; (8000158 <__do_global_dtors_aux+0x18>)
 8000144:	7823      	ldrb	r3, [r4, #0]
 8000146:	b933      	cbnz	r3, 8000156 <__do_global_dtors_aux+0x16>
 8000148:	4b04      	ldr	r3, [pc, #16]	; (800015c <__do_global_dtors_aux+0x1c>)
 800014a:	b113      	cbz	r3, 8000152 <__do_global_dtors_aux+0x12>
 800014c:	4804      	ldr	r0, [pc, #16]	; (8000160 <__do_global_dtors_aux+0x20>)
 800014e:	f3af 8000 	nop.w
 8000152:	2301      	movs	r3, #1
 8000154:	7023      	strb	r3, [r4, #0]
 8000156:	bd10      	pop	{r4, pc}
 8000158:	20000184 	.word	0x20000184
 800015c:	00000000 	.word	0x00000000
 8000160:	0801936c 	.word	0x0801936c

08000164 <frame_dummy>:
 8000164:	b508      	push	{r3, lr}
 8000166:	4b03      	ldr	r3, [pc, #12]	; (8000174 <frame_dummy+0x10>)
 8000168:	b11b      	cbz	r3, 8000172 <frame_dummy+0xe>
 800016a:	4903      	ldr	r1, [pc, #12]	; (8000178 <frame_dummy+0x14>)
 800016c:	4803      	ldr	r0, [pc, #12]	; (800017c <frame_dummy+0x18>)
 800016e:	f3af 8000 	nop.w
 8000172:	bd08      	pop	{r3, pc}
 8000174:	00000000 	.word	0x00000000
 8000178:	20000188 	.word	0x20000188
 800017c:	0801936c 	.word	0x0801936c

08000180 <is_little_endian>:
 8000180:	b081      	sub	sp, #4
 8000182:	2001      	movs	r0, #1
 8000184:	f8ad 0000 	strh.w	r0, [sp]
 8000188:	4668      	mov	r0, sp
 800018a:	7800      	ldrb	r0, [r0, #0]
 800018c:	2801      	cmp	r0, #1
 800018e:	d101      	bne.n	8000194 <??is_little_endian_0>
 8000190:	2001      	movs	r0, #1
 8000192:	e000      	b.n	8000196 <??is_little_endian_1>

08000194 <??is_little_endian_0>:
 8000194:	2000      	movs	r0, #0

08000196 <??is_little_endian_1>:
 8000196:	b2c0      	uxtb	r0, r0
 8000198:	b001      	add	sp, #4
 800019a:	4770      	bx	lr

0800019c <pletoh16>:
 800019c:	0001      	movs	r1, r0
 800019e:	7808      	ldrb	r0, [r1, #0]
 80001a0:	7849      	ldrb	r1, [r1, #1]
 80001a2:	ea50 2001 	orrs.w	r0, r0, r1, lsl #8
 80001a6:	b280      	uxth	r0, r0
 80001a8:	4770      	bx	lr

080001aa <pletoh24>:
 80001aa:	b510      	push	{r4, lr}
 80001ac:	0004      	movs	r4, r0
 80001ae:	0020      	movs	r0, r4
 80001b0:	f7ff fff4 	bl	800019c <pletoh16>
 80001b4:	b280      	uxth	r0, r0
 80001b6:	78a1      	ldrb	r1, [r4, #2]
 80001b8:	ea50 4001 	orrs.w	r0, r0, r1, lsl #16
 80001bc:	bd10      	pop	{r4, pc}

080001be <pletoh32>:
 80001be:	b538      	push	{r3, r4, r5, lr}
 80001c0:	0004      	movs	r4, r0
 80001c2:	0020      	movs	r0, r4
 80001c4:	f7ff ffea 	bl	800019c <pletoh16>
 80001c8:	0005      	movs	r5, r0
 80001ca:	b2ad      	uxth	r5, r5
 80001cc:	1ca0      	adds	r0, r4, #2
 80001ce:	f7ff ffe5 	bl	800019c <pletoh16>
 80001d2:	ea55 4500 	orrs.w	r5, r5, r0, lsl #16
 80001d6:	0028      	movs	r0, r5
 80001d8:	bd32      	pop	{r1, r4, r5, pc}

080001da <pletoh40>:
 80001da:	b510      	push	{r4, lr}
 80001dc:	0004      	movs	r4, r0
 80001de:	0020      	movs	r0, r4
 80001e0:	f7ff ffed 	bl	80001be <pletoh32>
 80001e4:	7921      	ldrb	r1, [r4, #4]
 80001e6:	bd10      	pop	{r4, pc}

080001e8 <pletoh48>:
 80001e8:	b510      	push	{r4, lr}
 80001ea:	0004      	movs	r4, r0
 80001ec:	0020      	movs	r0, r4
 80001ee:	f7ff fff4 	bl	80001da <pletoh40>
 80001f2:	7962      	ldrb	r2, [r4, #5]
 80001f4:	2300      	movs	r3, #0
 80001f6:	0213      	lsls	r3, r2, #8
 80001f8:	2200      	movs	r2, #0
 80001fa:	4310      	orrs	r0, r2
 80001fc:	4319      	orrs	r1, r3
 80001fe:	bd10      	pop	{r4, pc}

08000200 <pletoh56>:
 8000200:	b510      	push	{r4, lr}
 8000202:	0004      	movs	r4, r0
 8000204:	0020      	movs	r0, r4
 8000206:	f7ff ffef 	bl	80001e8 <pletoh48>
 800020a:	79a2      	ldrb	r2, [r4, #6]
 800020c:	2300      	movs	r3, #0
 800020e:	0413      	lsls	r3, r2, #16
 8000210:	2200      	movs	r2, #0
 8000212:	4310      	orrs	r0, r2
 8000214:	4319      	orrs	r1, r3
 8000216:	bd10      	pop	{r4, pc}

08000218 <pletoh64>:
 8000218:	b538      	push	{r3, r4, r5, lr}
 800021a:	0005      	movs	r5, r0
 800021c:	0028      	movs	r0, r5
 800021e:	f7ff ffce 	bl	80001be <pletoh32>
 8000222:	0004      	movs	r4, r0
 8000224:	1d28      	adds	r0, r5, #4
 8000226:	f7ff ffca 	bl	80001be <pletoh32>
 800022a:	0003      	movs	r3, r0
 800022c:	0022      	movs	r2, r4
 800022e:	0010      	movs	r0, r2
 8000230:	0019      	movs	r1, r3
 8000232:	bd34      	pop	{r2, r4, r5, pc}

08000234 <putle16>:
 8000234:	7001      	strb	r1, [r0, #0]
 8000236:	000a      	movs	r2, r1
 8000238:	b292      	uxth	r2, r2
 800023a:	0a12      	lsrs	r2, r2, #8
 800023c:	7042      	strb	r2, [r0, #1]
 800023e:	4770      	bx	lr

08000240 <putle24>:
 8000240:	b538      	push	{r3, r4, r5, lr}
 8000242:	0004      	movs	r4, r0
 8000244:	000d      	movs	r5, r1
 8000246:	0029      	movs	r1, r5
 8000248:	b289      	uxth	r1, r1
 800024a:	0020      	movs	r0, r4
 800024c:	f7ff fff2 	bl	8000234 <putle16>
 8000250:	0028      	movs	r0, r5
 8000252:	0c00      	lsrs	r0, r0, #16
 8000254:	70a0      	strb	r0, [r4, #2]
 8000256:	bd31      	pop	{r0, r4, r5, pc}

08000258 <putle32>:
 8000258:	b538      	push	{r3, r4, r5, lr}
 800025a:	0004      	movs	r4, r0
 800025c:	000d      	movs	r5, r1
 800025e:	0029      	movs	r1, r5
 8000260:	0020      	movs	r0, r4
 8000262:	f7ff ffed 	bl	8000240 <putle24>
 8000266:	0028      	movs	r0, r5
 8000268:	0e00      	lsrs	r0, r0, #24
 800026a:	70e0      	strb	r0, [r4, #3]
 800026c:	bd31      	pop	{r0, r4, r5, pc}

0800026e <putle40>:
 800026e:	b570      	push	{r4, r5, r6, lr}
 8000270:	0006      	movs	r6, r0
 8000272:	0014      	movs	r4, r2
 8000274:	001d      	movs	r5, r3
 8000276:	0021      	movs	r1, r4
 8000278:	0030      	movs	r0, r6
 800027a:	f7ff ffed 	bl	8000258 <putle32>
 800027e:	7135      	strb	r5, [r6, #4]
 8000280:	bd70      	pop	{r4, r5, r6, pc}

08000282 <putle48>:
 8000282:	b570      	push	{r4, r5, r6, lr}
 8000284:	0006      	movs	r6, r0
 8000286:	0014      	movs	r4, r2
 8000288:	001d      	movs	r5, r3
 800028a:	0022      	movs	r2, r4
 800028c:	002b      	movs	r3, r5
 800028e:	0030      	movs	r0, r6
 8000290:	f7ff ffed 	bl	800026e <putle40>
 8000294:	0020      	movs	r0, r4
 8000296:	0029      	movs	r1, r5
 8000298:	0a08      	lsrs	r0, r1, #8
 800029a:	2100      	movs	r1, #0
 800029c:	7170      	strb	r0, [r6, #5]
 800029e:	bd70      	pop	{r4, r5, r6, pc}

080002a0 <putle56>:
 80002a0:	b570      	push	{r4, r5, r6, lr}
 80002a2:	0006      	movs	r6, r0
 80002a4:	0014      	movs	r4, r2
 80002a6:	001d      	movs	r5, r3
 80002a8:	0022      	movs	r2, r4
 80002aa:	002b      	movs	r3, r5
 80002ac:	0030      	movs	r0, r6
 80002ae:	f7ff ffe8 	bl	8000282 <putle48>
 80002b2:	0020      	movs	r0, r4
 80002b4:	0029      	movs	r1, r5
 80002b6:	0c08      	lsrs	r0, r1, #16
 80002b8:	2100      	movs	r1, #0
 80002ba:	71b0      	strb	r0, [r6, #6]
 80002bc:	bd70      	pop	{r4, r5, r6, pc}

080002be <putle64>:
 80002be:	b570      	push	{r4, r5, r6, lr}
 80002c0:	0006      	movs	r6, r0
 80002c2:	0014      	movs	r4, r2
 80002c4:	001d      	movs	r5, r3
 80002c6:	0022      	movs	r2, r4
 80002c8:	002b      	movs	r3, r5
 80002ca:	0030      	movs	r0, r6
 80002cc:	f7ff ffe8 	bl	80002a0 <putle56>
 80002d0:	0020      	movs	r0, r4
 80002d2:	0029      	movs	r1, r5
 80002d4:	0e08      	lsrs	r0, r1, #24
 80002d6:	2100      	movs	r1, #0
 80002d8:	71f0      	strb	r0, [r6, #7]
 80002da:	bd70      	pop	{r4, r5, r6, pc}

080002dc <ZbZclClusterGetEndpoint>:
 80002dc:	7b80      	ldrb	r0, [r0, #14]
 80002de:	4770      	bx	lr

080002e0 <ZbZclClusterSetCallbackArg>:
 80002e0:	6541      	str	r1, [r0, #84]	; 0x54
 80002e2:	4770      	bx	lr

080002e4 <ZbZclClusterSetMfrCode>:
 80002e4:	8201      	strh	r1, [r0, #16]
 80002e6:	4770      	bx	lr

080002e8 <ZbZclClusterGetClusterId>:
 80002e8:	8980      	ldrh	r0, [r0, #12]
 80002ea:	4770      	bx	lr

080002ec <ZbZclClusterSetProfileId>:
 80002ec:	b538      	push	{r3, r4, r5, lr}
 80002ee:	0004      	movs	r4, r0
 80002f0:	000d      	movs	r5, r1
 80002f2:	82a5      	strh	r5, [r4, #20]
 80002f4:	7ba0      	ldrb	r0, [r4, #14]
 80002f6:	28ff      	cmp	r0, #255	; 0xff
 80002f8:	d008      	beq.n	800030c <??ZbZclClusterSetProfileId_0>
 80002fa:	0020      	movs	r0, r4
 80002fc:	f015 ff1e 	bl	801613c <ZbZclClusterUnbind>
 8000300:	7f23      	ldrb	r3, [r4, #28]
 8000302:	8aa2      	ldrh	r2, [r4, #20]
 8000304:	7ba1      	ldrb	r1, [r4, #14]
 8000306:	0020      	movs	r0, r4
 8000308:	f015 fed5 	bl	80160b6 <ZbZclClusterBind>

0800030c <??ZbZclClusterSetProfileId_0>:
 800030c:	bd31      	pop	{r0, r4, r5, pc}

0800030e <ZbZclClusterGetProfileId>:
 800030e:	b510      	push	{r4, lr}
 8000310:	0004      	movs	r4, r0
 8000312:	7ba1      	ldrb	r1, [r4, #14]
 8000314:	68a0      	ldr	r0, [r4, #8]
 8000316:	f015 f9b6 	bl	8015686 <ZbApsEndpointProfile>
 800031a:	0001      	movs	r1, r0
 800031c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000320:	b289      	uxth	r1, r1
 8000322:	4291      	cmp	r1, r2
 8000324:	d101      	bne.n	800032a <??ZbZclClusterGetProfileId_0>
 8000326:	8aa1      	ldrh	r1, [r4, #20]
 8000328:	0008      	movs	r0, r1

0800032a <??ZbZclClusterGetProfileId_0>:
 800032a:	b280      	uxth	r0, r0
 800032c:	bd10      	pop	{r4, pc}

0800032e <ZbZclClusterSetMinSecurity>:
 800032e:	b430      	push	{r4, r5}
 8000330:	0003      	movs	r3, r0
 8000332:	2001      	movs	r0, #1
 8000334:	7d9a      	ldrb	r2, [r3, #22]
 8000336:	f012 0203 	ands.w	r2, r2, #3
 800033a:	2a01      	cmp	r2, #1
 800033c:	d101      	bne.n	8000342 <??ZbZclClusterSetMinSecurity_0>
 800033e:	2401      	movs	r4, #1
 8000340:	e000      	b.n	8000344 <??ZbZclClusterSetMinSecurity_1>

08000342 <??ZbZclClusterSetMinSecurity_0>:
 8000342:	2400      	movs	r4, #0

08000344 <??ZbZclClusterSetMinSecurity_1>:
 8000344:	000a      	movs	r2, r1
 8000346:	b2d2      	uxtb	r2, r2
 8000348:	2aab      	cmp	r2, #171	; 0xab
 800034a:	d01d      	beq.n	8000388 <??ZbZclClusterSetMinSecurity_2>
 800034c:	2aac      	cmp	r2, #172	; 0xac
 800034e:	d00f      	beq.n	8000370 <??ZbZclClusterSetMinSecurity_3>
 8000350:	2aaf      	cmp	r2, #175	; 0xaf
 8000352:	d123      	bne.n	800039c <??ZbZclClusterSetMinSecurity_4>

08000354 <??ZbZclClusterSetMinSecurity_5>:
 8000354:	8add      	ldrh	r5, [r3, #22]
 8000356:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 800035a:	4015      	ands	r5, r2
 800035c:	82dd      	strh	r5, [r3, #22]
 800035e:	8add      	ldrh	r5, [r3, #22]
 8000360:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8000364:	4015      	ands	r5, r2
 8000366:	82dd      	strh	r5, [r3, #22]
 8000368:	0022      	movs	r2, r4
 800036a:	b2d2      	uxtb	r2, r2
 800036c:	2a00      	cmp	r2, #0

0800036e <??ZbZclClusterSetMinSecurity_6>:
 800036e:	e017      	b.n	80003a0 <??ZbZclClusterSetMinSecurity_7>

08000370 <??ZbZclClusterSetMinSecurity_3>:
 8000370:	8ada      	ldrh	r2, [r3, #22]
 8000372:	f052 0202 	orrs.w	r2, r2, #2
 8000376:	82da      	strh	r2, [r3, #22]
 8000378:	8ada      	ldrh	r2, [r3, #22]
 800037a:	f052 0201 	orrs.w	r2, r2, #1
 800037e:	82da      	strh	r2, [r3, #22]
 8000380:	0022      	movs	r2, r4
 8000382:	b2d2      	uxtb	r2, r2
 8000384:	2a00      	cmp	r2, #0

08000386 <??ZbZclClusterSetMinSecurity_8>:
 8000386:	e00b      	b.n	80003a0 <??ZbZclClusterSetMinSecurity_7>

08000388 <??ZbZclClusterSetMinSecurity_2>:
 8000388:	8add      	ldrh	r5, [r3, #22]
 800038a:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 800038e:	4015      	ands	r5, r2
 8000390:	82dd      	strh	r5, [r3, #22]
 8000392:	8ada      	ldrh	r2, [r3, #22]
 8000394:	f052 0201 	orrs.w	r2, r2, #1
 8000398:	82da      	strh	r2, [r3, #22]
 800039a:	e001      	b.n	80003a0 <??ZbZclClusterSetMinSecurity_7>

0800039c <??ZbZclClusterSetMinSecurity_4>:
 800039c:	2200      	movs	r2, #0
 800039e:	0010      	movs	r0, r2

080003a0 <??ZbZclClusterSetMinSecurity_7>:
 80003a0:	0002      	movs	r2, r0
 80003a2:	b2d2      	uxtb	r2, r2
 80003a4:	2a00      	cmp	r2, #0
 80003a6:	d000      	beq.n	80003aa <??ZbZclClusterSetMinSecurity_9>
 80003a8:	7499      	strb	r1, [r3, #18]

080003aa <??ZbZclClusterSetMinSecurity_9>:
 80003aa:	b2c0      	uxtb	r0, r0
 80003ac:	bc30      	pop	{r4, r5}
 80003ae:	4770      	bx	lr

080003b0 <ZbZclClusterCheckMinSecurity>:
 80003b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80003b4:	0004      	movs	r4, r0
 80003b6:	000d      	movs	r5, r1
 80003b8:	0016      	movs	r6, r2
 80003ba:	2700      	movs	r7, #0
 80003bc:	7ca0      	ldrb	r0, [r4, #18]
 80003be:	28af      	cmp	r0, #175	; 0xaf
 80003c0:	d102      	bne.n	80003c8 <??ZbZclClusterCheckMinSecurity_0>
 80003c2:	2001      	movs	r0, #1
 80003c4:	0007      	movs	r7, r0
 80003c6:	e073      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

080003c8 <??ZbZclClusterCheckMinSecurity_0>:
 80003c8:	7ca0      	ldrb	r0, [r4, #18]
 80003ca:	28ac      	cmp	r0, #172	; 0xac
 80003cc:	d10a      	bne.n	80003e4 <??ZbZclClusterCheckMinSecurity_2>
 80003ce:	f895 002a 	ldrb.w	r0, [r5, #42]	; 0x2a
 80003d2:	28ac      	cmp	r0, #172	; 0xac
 80003d4:	d003      	beq.n	80003de <??ZbZclClusterCheckMinSecurity_3>
 80003d6:	f895 002a 	ldrb.w	r0, [r5, #42]	; 0x2a
 80003da:	28ab      	cmp	r0, #171	; 0xab
 80003dc:	d101      	bne.n	80003e2 <??ZbZclClusterCheckMinSecurity_4>

080003de <??ZbZclClusterCheckMinSecurity_3>:
 80003de:	2001      	movs	r0, #1
 80003e0:	0007      	movs	r7, r0

080003e2 <??ZbZclClusterCheckMinSecurity_4>:
 80003e2:	e065      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

080003e4 <??ZbZclClusterCheckMinSecurity_2>:
 80003e4:	7ca0      	ldrb	r0, [r4, #18]
 80003e6:	28ab      	cmp	r0, #171	; 0xab
 80003e8:	d162      	bne.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>
 80003ea:	f895 002a 	ldrb.w	r0, [r5, #42]	; 0x2a
 80003ee:	28ab      	cmp	r0, #171	; 0xab
 80003f0:	d102      	bne.n	80003f8 <??ZbZclClusterCheckMinSecurity_6>
 80003f2:	2001      	movs	r0, #1
 80003f4:	0007      	movs	r7, r0
 80003f6:	e05b      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

080003f8 <??ZbZclClusterCheckMinSecurity_6>:
 80003f8:	f895 002a 	ldrb.w	r0, [r5, #42]	; 0x2a
 80003fc:	28ac      	cmp	r0, #172	; 0xac
 80003fe:	d157      	bne.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

08000400 <??ZbZclClusterCheckMinSecurity_7>:
 8000400:	89a0      	ldrh	r0, [r4, #12]
 8000402:	2819      	cmp	r0, #25
 8000404:	d114      	bne.n	8000430 <??ZbZclClusterCheckMinSecurity_8>
 8000406:	7f20      	ldrb	r0, [r4, #28]
 8000408:	2801      	cmp	r0, #1
 800040a:	d111      	bne.n	8000430 <??ZbZclClusterCheckMinSecurity_8>
 800040c:	0028      	movs	r0, r5
 800040e:	f015 f96d 	bl	80156ec <ZbApsAddrIsBcast>
 8000412:	2800      	cmp	r0, #0
 8000414:	d00b      	beq.n	800042e <??ZbZclClusterCheckMinSecurity_9>
 8000416:	7830      	ldrb	r0, [r6, #0]
 8000418:	2801      	cmp	r0, #1
 800041a:	d108      	bne.n	800042e <??ZbZclClusterCheckMinSecurity_9>
 800041c:	78b0      	ldrb	r0, [r6, #2]
 800041e:	2801      	cmp	r0, #1
 8000420:	d105      	bne.n	800042e <??ZbZclClusterCheckMinSecurity_9>
 8000422:	79f0      	ldrb	r0, [r6, #7]
 8000424:	2800      	cmp	r0, #0
 8000426:	d102      	bne.n	800042e <??ZbZclClusterCheckMinSecurity_9>
 8000428:	2001      	movs	r0, #1
 800042a:	0007      	movs	r7, r0
 800042c:	e040      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

0800042e <??ZbZclClusterCheckMinSecurity_9>:
 800042e:	e03f      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

08000430 <??ZbZclClusterCheckMinSecurity_8>:
 8000430:	f240 7802 	movw	r8, #1794	; 0x702
 8000434:	89a0      	ldrh	r0, [r4, #12]
 8000436:	4540      	cmp	r0, r8
 8000438:	d11a      	bne.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 800043a:	7f20      	ldrb	r0, [r4, #28]
 800043c:	2800      	cmp	r0, #0
 800043e:	d117      	bne.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 8000440:	7830      	ldrb	r0, [r6, #0]
 8000442:	2800      	cmp	r0, #0
 8000444:	d114      	bne.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 8000446:	79f0      	ldrb	r0, [r6, #7]
 8000448:	2800      	cmp	r0, #0
 800044a:	d111      	bne.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 800044c:	78b0      	ldrb	r0, [r6, #2]
 800044e:	2800      	cmp	r0, #0
 8000450:	d10e      	bne.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 8000452:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8000454:	2802      	cmp	r0, #2
 8000456:	d30b      	bcc.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 8000458:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800045a:	f7ff fe9f 	bl	800019c <pletoh16>
 800045e:	0001      	movs	r1, r0
 8000460:	f240 3206 	movw	r2, #774	; 0x306
 8000464:	b289      	uxth	r1, r1
 8000466:	4291      	cmp	r1, r2
 8000468:	d102      	bne.n	8000470 <??ZbZclClusterCheckMinSecurity_10>
 800046a:	2101      	movs	r1, #1
 800046c:	000f      	movs	r7, r1
 800046e:	e01f      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

08000470 <??ZbZclClusterCheckMinSecurity_10>:
 8000470:	89a0      	ldrh	r0, [r4, #12]
 8000472:	4540      	cmp	r0, r8
 8000474:	d11b      	bne.n	80004ae <??ZbZclClusterCheckMinSecurity_11>
 8000476:	7f20      	ldrb	r0, [r4, #28]
 8000478:	2801      	cmp	r0, #1
 800047a:	d118      	bne.n	80004ae <??ZbZclClusterCheckMinSecurity_11>
 800047c:	7830      	ldrb	r0, [r6, #0]
 800047e:	2800      	cmp	r0, #0
 8000480:	d114      	bne.n	80004ac <??ZbZclClusterCheckMinSecurity_12>
 8000482:	79f0      	ldrb	r0, [r6, #7]
 8000484:	2801      	cmp	r0, #1
 8000486:	d111      	bne.n	80004ac <??ZbZclClusterCheckMinSecurity_12>
 8000488:	78b0      	ldrb	r0, [r6, #2]
 800048a:	2801      	cmp	r0, #1
 800048c:	d10e      	bne.n	80004ac <??ZbZclClusterCheckMinSecurity_12>
 800048e:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8000490:	2802      	cmp	r0, #2
 8000492:	d30b      	bcc.n	80004ac <??ZbZclClusterCheckMinSecurity_12>
 8000494:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8000496:	f7ff fe81 	bl	800019c <pletoh16>
 800049a:	0001      	movs	r1, r0
 800049c:	f240 3206 	movw	r2, #774	; 0x306
 80004a0:	b289      	uxth	r1, r1
 80004a2:	4291      	cmp	r1, r2
 80004a4:	d102      	bne.n	80004ac <??ZbZclClusterCheckMinSecurity_12>
 80004a6:	2101      	movs	r1, #1
 80004a8:	000f      	movs	r7, r1
 80004aa:	e001      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

080004ac <??ZbZclClusterCheckMinSecurity_12>:
 80004ac:	e000      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

080004ae <??ZbZclClusterCheckMinSecurity_11>:
 80004ae:	e7ff      	b.n	80004b0 <??ZbZclClusterCheckMinSecurity_1>

080004b0 <??ZbZclClusterCheckMinSecurity_1>:
 80004b0:	0038      	movs	r0, r7
 80004b2:	b2c0      	uxtb	r0, r0
 80004b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080004b8 <ZbZclClusterSetTxOptions>:
 80004b8:	05ca      	lsls	r2, r1, #23
 80004ba:	d400      	bmi.n	80004be <??ZbZclClusterSetTxOptions_0>

080004bc <??ZbZclClusterSetTxOptions_1>:
 80004bc:	82c1      	strh	r1, [r0, #22]

080004be <??ZbZclClusterSetTxOptions_0>:
 80004be:	4770      	bx	lr

080004c0 <ZbZclClusterGetTxOptions>:
 80004c0:	8ac0      	ldrh	r0, [r0, #22]
 80004c2:	f64f 61ff 	movw	r1, #65279	; 0xfeff
 80004c6:	4008      	ands	r0, r1
 80004c8:	4770      	bx	lr

080004ca <ZbZclTxOptsFromSecurityStatus>:
 80004ca:	0001      	movs	r1, r0
 80004cc:	2000      	movs	r0, #0
 80004ce:	f050 0004 	orrs.w	r0, r0, #4
 80004d2:	f050 0008 	orrs.w	r0, r0, #8
 80004d6:	000a      	movs	r2, r1
 80004d8:	b2d2      	uxtb	r2, r2
 80004da:	2aab      	cmp	r2, #171	; 0xab
 80004dc:	d102      	bne.n	80004e4 <??ZbZclTxOptsFromSecurityStatus_0>
 80004de:	f050 0001 	orrs.w	r0, r0, #1
 80004e2:	e007      	b.n	80004f4 <??ZbZclTxOptsFromSecurityStatus_1>

080004e4 <??ZbZclTxOptsFromSecurityStatus_0>:
 80004e4:	000a      	movs	r2, r1
 80004e6:	b2d2      	uxtb	r2, r2
 80004e8:	2aac      	cmp	r2, #172	; 0xac
 80004ea:	d103      	bne.n	80004f4 <??ZbZclTxOptsFromSecurityStatus_1>
 80004ec:	f050 0001 	orrs.w	r0, r0, #1
 80004f0:	f050 0002 	orrs.w	r0, r0, #2

080004f4 <??ZbZclTxOptsFromSecurityStatus_1>:
 80004f4:	b280      	uxth	r0, r0
 80004f6:	4770      	bx	lr

080004f8 <ZbZclClusterGetDirection>:
 80004f8:	7f00      	ldrb	r0, [r0, #28]
 80004fa:	4770      	bx	lr

080004fc <ZbZclClusterGetDirectionStr>:
 80004fc:	0001      	movs	r1, r0
 80004fe:	7f08      	ldrb	r0, [r1, #28]
 8000500:	2800      	cmp	r0, #0
 8000502:	d003      	beq.n	800050c <??ZbZclClusterGetDirectionStr_0>
 8000504:	2802      	cmp	r0, #2
 8000506:	d005      	beq.n	8000514 <??ZbZclClusterGetDirectionStr_1>
 8000508:	d302      	bcc.n	8000510 <??ZbZclClusterGetDirectionStr_2>
 800050a:	e005      	b.n	8000518 <??ZbZclClusterGetDirectionStr_3>

0800050c <??ZbZclClusterGetDirectionStr_0>:
 800050c:	4803      	ldr	r0, [pc, #12]	; (800051c <??DataTable1>)
 800050e:	e004      	b.n	800051a <??ZbZclClusterGetDirectionStr_4>

08000510 <??ZbZclClusterGetDirectionStr_2>:
 8000510:	4803      	ldr	r0, [pc, #12]	; (8000520 <??DataTable1_1>)
 8000512:	e002      	b.n	800051a <??ZbZclClusterGetDirectionStr_4>

08000514 <??ZbZclClusterGetDirectionStr_1>:
 8000514:	4803      	ldr	r0, [pc, #12]	; (8000524 <??DataTable1_2>)
 8000516:	e000      	b.n	800051a <??ZbZclClusterGetDirectionStr_4>

08000518 <??ZbZclClusterGetDirectionStr_3>:
 8000518:	4803      	ldr	r0, [pc, #12]	; (8000528 <??DataTable1_3>)

0800051a <??ZbZclClusterGetDirectionStr_4>:
 800051a:	4770      	bx	lr

0800051c <??DataTable1>:
 800051c:	9980 0801                                   ....

08000520 <??DataTable1_1>:
 8000520:	9988 0801                                   ....

08000524 <??DataTable1_2>:
 8000524:	9990 0801                                   ....

08000528 <??DataTable1_3>:
 8000528:	9998 0801                                   ....

0800052c <ZbZclClusterSetDiscoverRoute>:
 800052c:	7601      	strb	r1, [r0, #24]
 800052e:	4770      	bx	lr

08000530 <ZbZclClusterSetRadius>:
 8000530:	7641      	strb	r1, [r0, #25]
 8000532:	4770      	bx	lr

08000534 <ZbZclClusterGetRadius>:
 8000534:	7e40      	ldrb	r0, [r0, #25]
 8000536:	4770      	bx	lr

08000538 <ZbZclClusterSetMaxAsduLength>:
 8000538:	b410      	push	{r4}
 800053a:	0002      	movs	r2, r0
 800053c:	000b      	movs	r3, r1
 800053e:	0018      	movs	r0, r3
 8000540:	b280      	uxth	r0, r0
 8000542:	f240 74d1 	movw	r4, #2001	; 0x7d1
 8000546:	42a0      	cmp	r0, r4
 8000548:	d301      	bcc.n	800054e <??ZbZclClusterSetMaxAsduLength_0>
 800054a:	2000      	movs	r0, #0
 800054c:	e007      	b.n	800055e <??ZbZclClusterSetMaxAsduLength_1>

0800054e <??ZbZclClusterSetMaxAsduLength_0>:
 800054e:	0018      	movs	r0, r3
 8000550:	b280      	uxth	r0, r0
 8000552:	2839      	cmp	r0, #57	; 0x39
 8000554:	d201      	bcs.n	800055a <??ZbZclClusterSetMaxAsduLength_2>
 8000556:	2039      	movs	r0, #57	; 0x39
 8000558:	0003      	movs	r3, r0

0800055a <??ZbZclClusterSetMaxAsduLength_2>:
 800055a:	8353      	strh	r3, [r2, #26]
 800055c:	2001      	movs	r0, #1

0800055e <??ZbZclClusterSetMaxAsduLength_1>:
 800055e:	bc10      	pop	{r4}
 8000560:	4770      	bx	lr

08000562 <ZbZclClusterGetMaxAsduLength>:
 8000562:	8b40      	ldrh	r0, [r0, #26]
 8000564:	4770      	bx	lr

08000566 <ZbZclClusterInitCommandReq>:
 8000566:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800056a:	0004      	movs	r4, r0
 800056c:	000d      	movs	r5, r1
 800056e:	2630      	movs	r6, #48	; 0x30
 8000570:	2700      	movs	r7, #0
 8000572:	46a8      	mov	r8, r5
 8000574:	003a      	movs	r2, r7
 8000576:	0031      	movs	r1, r6
 8000578:	4640      	mov	r0, r8
 800057a:	f005 fa74 	bl	8005a66 <__aeabi_memset>
 800057e:	8aa0      	ldrh	r0, [r4, #20]
 8000580:	8228      	strh	r0, [r5, #16]
 8000582:	89a0      	ldrh	r0, [r4, #12]
 8000584:	8268      	strh	r0, [r5, #18]
 8000586:	7ba0      	ldrb	r0, [r4, #14]
 8000588:	82a8      	strh	r0, [r5, #20]
 800058a:	8ae0      	ldrh	r0, [r4, #22]
 800058c:	82e8      	strh	r0, [r5, #22]
 800058e:	7e20      	ldrb	r0, [r4, #24]
 8000590:	7628      	strb	r0, [r5, #24]
 8000592:	7e60      	ldrb	r0, [r4, #25]
 8000594:	7668      	strb	r0, [r5, #25]
 8000596:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800059a <ZbZclClusterInitApsdeReq>:
 800059a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800059e:	0005      	movs	r5, r0
 80005a0:	000e      	movs	r6, r1
 80005a2:	0014      	movs	r4, r2
 80005a4:	2730      	movs	r7, #48	; 0x30
 80005a6:	f05f 0800 	movs.w	r8, #0
 80005aa:	46b1      	mov	r9, r6
 80005ac:	4642      	mov	r2, r8
 80005ae:	0039      	movs	r1, r7
 80005b0:	4648      	mov	r0, r9
 80005b2:	f005 fa58 	bl	8005a66 <__aeabi_memset>
 80005b6:	8aa8      	ldrh	r0, [r5, #20]
 80005b8:	8230      	strh	r0, [r6, #16]
 80005ba:	89a8      	ldrh	r0, [r5, #12]
 80005bc:	8270      	strh	r0, [r6, #18]
 80005be:	7ba8      	ldrb	r0, [r5, #14]
 80005c0:	82b0      	strh	r0, [r6, #20]
 80005c2:	8ae8      	ldrh	r0, [r5, #22]
 80005c4:	84b0      	strh	r0, [r6, #36]	; 0x24
 80005c6:	7e28      	ldrb	r0, [r5, #24]
 80005c8:	f886 0026 	strb.w	r0, [r6, #38]	; 0x26
 80005cc:	7e68      	ldrb	r0, [r5, #25]
 80005ce:	f886 0027 	strb.w	r0, [r6, #39]	; 0x27
 80005d2:	2c00      	cmp	r4, #0
 80005d4:	d00b      	beq.n	80005ee <??ZbZclClusterInitApsdeReq_0>
 80005d6:	8ab0      	ldrh	r0, [r6, #20]
 80005d8:	28ff      	cmp	r0, #255	; 0xff
 80005da:	d101      	bne.n	80005e0 <??ZbZclClusterInitApsdeReq_1>
 80005dc:	8860      	ldrh	r0, [r4, #2]
 80005de:	82b0      	strh	r0, [r6, #20]

080005e0 <??ZbZclClusterInitApsdeReq_1>:
 80005e0:	8c20      	ldrh	r0, [r4, #32]
 80005e2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80005e6:	4288      	cmp	r0, r1
 80005e8:	d001      	beq.n	80005ee <??ZbZclClusterInitApsdeReq_0>
 80005ea:	8c20      	ldrh	r0, [r4, #32]
 80005ec:	8230      	strh	r0, [r6, #16]

080005ee <??ZbZclClusterInitApsdeReq_0>:
 80005ee:	e8bd 83f1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, r8, r9, pc}
	...

080005f4 <zcl_persist_handle_set>:
 80005f4:	e92d 4ffe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80005f8:	0004      	movs	r4, r0
 80005fa:	000d      	movs	r5, r1
 80005fc:	0016      	movs	r6, r2
 80005fe:	f05f 0b00 	movs.w	fp, #0

08000602 <??zcl_persist_handle_set_0>:
 8000602:	4658      	mov	r0, fp
 8000604:	0031      	movs	r1, r6
 8000606:	b280      	uxth	r0, r0
 8000608:	b289      	uxth	r1, r1
 800060a:	4288      	cmp	r0, r1
 800060c:	d23c      	bcs.n	8000688 <??zcl_persist_handle_set_1>
 800060e:	0030      	movs	r0, r6
 8000610:	b280      	uxth	r0, r0
 8000612:	4659      	mov	r1, fp
 8000614:	b289      	uxth	r1, r1
 8000616:	1d09      	adds	r1, r1, #4
 8000618:	4288      	cmp	r0, r1
 800061a:	d201      	bcs.n	8000620 <??zcl_persist_handle_set_2>
 800061c:	2087      	movs	r0, #135	; 0x87
 800061e:	e034      	b.n	800068a <??zcl_persist_handle_set_3>

08000620 <??zcl_persist_handle_set_2>:
 8000620:	4658      	mov	r0, fp
 8000622:	b280      	uxth	r0, r0
 8000624:	4428      	add	r0, r5
 8000626:	f7ff fdb9 	bl	800019c <pletoh16>
 800062a:	0007      	movs	r7, r0
 800062c:	f11b 0b02 	adds.w	fp, fp, #2
 8000630:	4658      	mov	r0, fp
 8000632:	b280      	uxth	r0, r0
 8000634:	4428      	add	r0, r5
 8000636:	f7ff fdb1 	bl	800019c <pletoh16>
 800063a:	4680      	mov	r8, r0
 800063c:	f11b 0b02 	adds.w	fp, fp, #2
 8000640:	0030      	movs	r0, r6
 8000642:	b280      	uxth	r0, r0
 8000644:	4641      	mov	r1, r8
 8000646:	b289      	uxth	r1, r1
 8000648:	fa11 f18b 	uxtah	r1, r1, fp
 800064c:	4288      	cmp	r0, r1
 800064e:	da01      	bge.n	8000654 <??zcl_persist_handle_set_4>
 8000650:	2087      	movs	r0, #135	; 0x87
 8000652:	e01a      	b.n	800068a <??zcl_persist_handle_set_3>

08000654 <??zcl_persist_handle_set_4>:
 8000654:	4658      	mov	r0, fp
 8000656:	b280      	uxth	r0, r0
 8000658:	4428      	add	r0, r5
 800065a:	4681      	mov	r9, r0
 800065c:	eb18 0b0b 	adds.w	fp, r8, fp
 8000660:	2006      	movs	r0, #6
 8000662:	9001      	str	r0, [sp, #4]
 8000664:	4640      	mov	r0, r8
 8000666:	b280      	uxth	r0, r0
 8000668:	9000      	str	r0, [sp, #0]
 800066a:	464b      	mov	r3, r9
 800066c:	003a      	movs	r2, r7
 800066e:	b292      	uxth	r2, r2
 8000670:	2100      	movs	r1, #0
 8000672:	0020      	movs	r0, r4
 8000674:	f000 ffc9 	bl	800160a <ZbZclAttrWrite>
 8000678:	4682      	mov	sl, r0
 800067a:	4650      	mov	r0, sl
 800067c:	b2c0      	uxtb	r0, r0
 800067e:	2800      	cmp	r0, #0
 8000680:	d0bf      	beq.n	8000602 <??zcl_persist_handle_set_0>
 8000682:	4650      	mov	r0, sl
 8000684:	b2c0      	uxtb	r0, r0
 8000686:	e000      	b.n	800068a <??zcl_persist_handle_set_3>

08000688 <??zcl_persist_handle_set_1>:
 8000688:	2000      	movs	r0, #0

0800068a <??zcl_persist_handle_set_3>:
 800068a:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800068e <ZbZclHandleReadAttr>:
 800068e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000692:	b092      	sub	sp, #72	; 0x48
 8000694:	0005      	movs	r5, r0
 8000696:	000e      	movs	r6, r1
 8000698:	0017      	movs	r7, r2
 800069a:	f20f 19a4 	addw	r9, pc, #420	; 0x1a4
 800069e:	2300      	movs	r3, #0
 80006a0:	464a      	mov	r2, r9
 80006a2:	8b69      	ldrh	r1, [r5, #26]
 80006a4:	68a8      	ldr	r0, [r5, #8]
 80006a6:	f015 fda1 	bl	80161ec <zb_heap_alloc>
 80006aa:	0004      	movs	r4, r0
 80006ac:	2c00      	cmp	r4, #0
 80006ae:	d106      	bne.n	80006be <??ZbZclHandleReadAttr_0>
 80006b0:	2389      	movs	r3, #137	; 0x89
 80006b2:	0032      	movs	r2, r6
 80006b4:	0039      	movs	r1, r7
 80006b6:	0028      	movs	r0, r5
 80006b8:	f015 fc5b 	bl	8015f72 <ZbZclSendDefaultResponse>
 80006bc:	e0bd      	b.n	800083a <??ZbZclHandleReadAttr_1>

080006be <??ZbZclHandleReadAttr_0>:
 80006be:	f05f 0808 	movs.w	r8, #8
 80006c2:	f05f 0a00 	movs.w	sl, #0
 80006c6:	f10d 0b0c 	add.w	fp, sp, #12
 80006ca:	4652      	mov	r2, sl
 80006cc:	4641      	mov	r1, r8
 80006ce:	4658      	mov	r0, fp
 80006d0:	f005 f9c9 	bl	8005a66 <__aeabi_memset>
 80006d4:	2000      	movs	r0, #0
 80006d6:	f88d 000c 	strb.w	r0, [sp, #12]
 80006da:	7870      	ldrb	r0, [r6, #1]
 80006dc:	f88d 000d 	strb.w	r0, [sp, #13]
 80006e0:	78b0      	ldrb	r0, [r6, #2]
 80006e2:	2800      	cmp	r0, #0
 80006e4:	d101      	bne.n	80006ea <??ZbZclHandleReadAttr_2>
 80006e6:	2001      	movs	r0, #1
 80006e8:	e000      	b.n	80006ec <??ZbZclHandleReadAttr_3>

080006ea <??ZbZclHandleReadAttr_2>:
 80006ea:	2000      	movs	r0, #0

080006ec <??ZbZclHandleReadAttr_3>:
 80006ec:	f88d 000e 	strb.w	r0, [sp, #14]
 80006f0:	2001      	movs	r0, #1
 80006f2:	f88d 000f 	strb.w	r0, [sp, #15]
 80006f6:	88b0      	ldrh	r0, [r6, #4]
 80006f8:	f8ad 0010 	strh.w	r0, [sp, #16]
 80006fc:	79b0      	ldrb	r0, [r6, #6]
 80006fe:	f88d 0012 	strb.w	r0, [sp, #18]
 8000702:	2001      	movs	r0, #1
 8000704:	f88d 0013 	strb.w	r0, [sp, #19]
 8000708:	8b6a      	ldrh	r2, [r5, #26]
 800070a:	0021      	movs	r1, r4
 800070c:	a803      	add	r0, sp, #12
 800070e:	f000 fca5 	bl	800105c <ZbZclAppendHeader>
 8000712:	4680      	mov	r8, r0
 8000714:	f1b8 0f00 	cmp.w	r8, #0
 8000718:	d50c      	bpl.n	8000734 <??ZbZclHandleReadAttr_4>
 800071a:	2300      	movs	r3, #0
 800071c:	464a      	mov	r2, r9
 800071e:	0021      	movs	r1, r4
 8000720:	68a8      	ldr	r0, [r5, #8]
 8000722:	f015 fd72 	bl	801620a <zb_heap_free>
 8000726:	2380      	movs	r3, #128	; 0x80
 8000728:	0032      	movs	r2, r6
 800072a:	0039      	movs	r1, r7
 800072c:	0028      	movs	r0, r5
 800072e:	f015 fc20 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000732:	e082      	b.n	800083a <??ZbZclHandleReadAttr_1>

08000734 <??ZbZclHandleReadAttr_4>:
 8000734:	46c3      	mov	fp, r8

08000736 <??ZbZclHandleReadAttr_5>:
 8000736:	8d38      	ldrh	r0, [r7, #40]	; 0x28
 8000738:	2802      	cmp	r0, #2
 800073a:	d353      	bcc.n	80007e4 <??ZbZclHandleReadAttr_6>

0800073c <??ZbZclHandleReadAttr_7>:
 800073c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800073e:	f7ff fd2d 	bl	800019c <pletoh16>
 8000742:	f8ad 000a 	strh.w	r0, [sp, #10]
 8000746:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8000748:	1c80      	adds	r0, r0, #2
 800074a:	6278      	str	r0, [r7, #36]	; 0x24
 800074c:	8d38      	ldrh	r0, [r7, #40]	; 0x28
 800074e:	1e80      	subs	r0, r0, #2
 8000750:	8538      	strh	r0, [r7, #40]	; 0x28
 8000752:	f11b 0004 	adds.w	r0, fp, #4
 8000756:	8b69      	ldrh	r1, [r5, #26]
 8000758:	4288      	cmp	r0, r1
 800075a:	d243      	bcs.n	80007e4 <??ZbZclHandleReadAttr_6>

0800075c <??ZbZclHandleReadAttr_8>:
 800075c:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 8000760:	eb04 000b 	add.w	r0, r4, fp
 8000764:	f7ff fd66 	bl	8000234 <putle16>
 8000768:	f11b 0b02 	adds.w	fp, fp, #2
 800076c:	2000      	movs	r0, #0
 800076e:	9001      	str	r0, [sp, #4]
 8000770:	8b68      	ldrh	r0, [r5, #26]
 8000772:	ebb0 000b 	subs.w	r0, r0, fp
 8000776:	1e80      	subs	r0, r0, #2
 8000778:	9000      	str	r0, [sp, #0]
 800077a:	eb04 000b 	add.w	r0, r4, fp
 800077e:	1c83      	adds	r3, r0, #2
 8000780:	aa02      	add	r2, sp, #8
 8000782:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 8000786:	0028      	movs	r0, r5
 8000788:	f000 fded 	bl	8001366 <ZbZclAttrRead>
 800078c:	4682      	mov	sl, r0
 800078e:	f804 a00b 	strb.w	sl, [r4, fp]
 8000792:	f11b 0b01 	adds.w	fp, fp, #1
 8000796:	4650      	mov	r0, sl
 8000798:	b2c0      	uxtb	r0, r0
 800079a:	2889      	cmp	r0, #137	; 0x89
 800079c:	d022      	beq.n	80007e4 <??ZbZclHandleReadAttr_6>

0800079e <??ZbZclHandleReadAttr_9>:
 800079e:	4650      	mov	r0, sl
 80007a0:	b2c0      	uxtb	r0, r0
 80007a2:	2800      	cmp	r0, #0
 80007a4:	d1c7      	bne.n	8000736 <??ZbZclHandleReadAttr_5>

080007a6 <??ZbZclHandleReadAttr_10>:
 80007a6:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80007aa:	f804 000b 	strb.w	r0, [r4, fp]
 80007ae:	f11b 0b01 	adds.w	fp, fp, #1
 80007b2:	2300      	movs	r3, #0
 80007b4:	8b6a      	ldrh	r2, [r5, #26]
 80007b6:	ebb2 020b 	subs.w	r2, r2, fp
 80007ba:	eb04 010b 	add.w	r1, r4, fp
 80007be:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80007c2:	f001 fbf8 	bl	8001fb6 <ZbZclAttrParseLength>
 80007c6:	4680      	mov	r8, r0
 80007c8:	f1b8 0f00 	cmp.w	r8, #0
 80007cc:	d507      	bpl.n	80007de <??ZbZclHandleReadAttr_11>
 80007ce:	f1bb 0b01 	subs.w	fp, fp, #1
 80007d2:	2087      	movs	r0, #135	; 0x87
 80007d4:	eb04 010b 	add.w	r1, r4, fp
 80007d8:	f801 0c01 	strb.w	r0, [r1, #-1]
 80007dc:	e7ab      	b.n	8000736 <??ZbZclHandleReadAttr_5>

080007de <??ZbZclHandleReadAttr_11>:
 80007de:	eb18 0b0b 	adds.w	fp, r8, fp
 80007e2:	e7a8      	b.n	8000736 <??ZbZclHandleReadAttr_5>

080007e4 <??ZbZclHandleReadAttr_6>:
 80007e4:	003a      	movs	r2, r7
 80007e6:	a906      	add	r1, sp, #24
 80007e8:	0028      	movs	r0, r5
 80007ea:	f7ff fed6 	bl	800059a <ZbZclClusterInitApsdeReq>
 80007ee:	a806      	add	r0, sp, #24
 80007f0:	f117 0110 	adds.w	r1, r7, #16
 80007f4:	2210      	movs	r2, #16
 80007f6:	f017 fecc 	bl	8018592 <__aeabi_memcpy>
 80007fa:	f897 002a 	ldrb.w	r0, [r7, #42]	; 0x2a
 80007fe:	f7ff fe64 	bl	80004ca <ZbZclTxOptsFromSecurityStatus>
 8000802:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8000806:	7da8      	ldrb	r0, [r5, #22]
 8000808:	0700      	lsls	r0, r0, #28
 800080a:	d406      	bmi.n	800081a <??ZbZclHandleReadAttr_12>
 800080c:	f8bd 103c 	ldrh.w	r1, [sp, #60]	; 0x3c
 8000810:	f64f 70f7 	movw	r0, #65527	; 0xfff7
 8000814:	4001      	ands	r1, r0
 8000816:	f8ad 103c 	strh.w	r1, [sp, #60]	; 0x3c

0800081a <??ZbZclHandleReadAttr_12>:
 800081a:	940c      	str	r4, [sp, #48]	; 0x30
 800081c:	4658      	mov	r0, fp
 800081e:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
 8000822:	2300      	movs	r3, #0
 8000824:	2200      	movs	r2, #0
 8000826:	a906      	add	r1, sp, #24
 8000828:	68a8      	ldr	r0, [r5, #8]
 800082a:	f014 fee5 	bl	80155f8 <ZbApsdeDataReqCallback>
 800082e:	2300      	movs	r3, #0
 8000830:	464a      	mov	r2, r9
 8000832:	0021      	movs	r1, r4
 8000834:	68a8      	ldr	r0, [r5, #8]
 8000836:	f015 fce8 	bl	801620a <zb_heap_free>

0800083a <??ZbZclHandleReadAttr_1>:
 800083a:	b013      	add	sp, #76	; 0x4c
 800083c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000840 <??DataTable1>:
 8000840:	0000 0000                                   ....

08000844 <ZbZclHandleWriteAttr>:
 8000844:	e92d 4ff3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000848:	b0a3      	sub	sp, #140	; 0x8c
 800084a:	0016      	movs	r6, r2
 800084c:	2701      	movs	r7, #1
 800084e:	2500      	movs	r5, #0
 8000850:	2400      	movs	r4, #0
 8000852:	f05f 0800 	movs.w	r8, #0
 8000856:	9824      	ldr	r0, [sp, #144]	; 0x90
 8000858:	79c0      	ldrb	r0, [r0, #7]
 800085a:	f88d 000a 	strb.w	r0, [sp, #10]
 800085e:	f05f 0900 	movs.w	r9, #0
 8000862:	f89d 000a 	ldrb.w	r0, [sp, #10]
 8000866:	2802      	cmp	r0, #2
 8000868:	d007      	beq.n	800087a <??ZbZclHandleWriteAttr_0>
 800086a:	2803      	cmp	r0, #3
 800086c:	d003      	beq.n	8000876 <??ZbZclHandleWriteAttr_1>
 800086e:	2805      	cmp	r0, #5
 8000870:	f000 80c3 	beq.w	80009fa <??ZbZclHandleWriteAttr_2>
 8000874:	e116      	b.n	8000aa4 <??ZbZclHandleWriteAttr_3>

08000876 <??ZbZclHandleWriteAttr_1>:
 8000876:	f059 0901 	orrs.w	r9, r9, #1

0800087a <??ZbZclHandleWriteAttr_0>:
 800087a:	2008      	movs	r0, #8
 800087c:	9001      	str	r0, [sp, #4]
 800087e:	2000      	movs	r0, #0
 8000880:	9000      	str	r0, [sp, #0]
 8000882:	f10d 0b14 	add.w	fp, sp, #20
 8000886:	9a00      	ldr	r2, [sp, #0]
 8000888:	9901      	ldr	r1, [sp, #4]
 800088a:	4658      	mov	r0, fp
 800088c:	f005 f8eb 	bl	8005a66 <__aeabi_memset>
 8000890:	2000      	movs	r0, #0
 8000892:	f88d 0014 	strb.w	r0, [sp, #20]
 8000896:	9824      	ldr	r0, [sp, #144]	; 0x90
 8000898:	7840      	ldrb	r0, [r0, #1]
 800089a:	f88d 0015 	strb.w	r0, [sp, #21]
 800089e:	9824      	ldr	r0, [sp, #144]	; 0x90
 80008a0:	7880      	ldrb	r0, [r0, #2]
 80008a2:	2800      	cmp	r0, #0
 80008a4:	d101      	bne.n	80008aa <??ZbZclHandleWriteAttr_4>
 80008a6:	2001      	movs	r0, #1
 80008a8:	e000      	b.n	80008ac <??ZbZclHandleWriteAttr_5>

080008aa <??ZbZclHandleWriteAttr_4>:
 80008aa:	2000      	movs	r0, #0

080008ac <??ZbZclHandleWriteAttr_5>:
 80008ac:	f88d 0016 	strb.w	r0, [sp, #22]
 80008b0:	2001      	movs	r0, #1
 80008b2:	f88d 0017 	strb.w	r0, [sp, #23]
 80008b6:	9824      	ldr	r0, [sp, #144]	; 0x90
 80008b8:	8880      	ldrh	r0, [r0, #4]
 80008ba:	f8ad 0018 	strh.w	r0, [sp, #24]
 80008be:	9824      	ldr	r0, [sp, #144]	; 0x90
 80008c0:	7980      	ldrb	r0, [r0, #6]
 80008c2:	f88d 001a 	strb.w	r0, [sp, #26]
 80008c6:	2004      	movs	r0, #4
 80008c8:	f88d 001b 	strb.w	r0, [sp, #27]
 80008cc:	2239      	movs	r2, #57	; 0x39
 80008ce:	a907      	add	r1, sp, #28
 80008d0:	a805      	add	r0, sp, #20
 80008d2:	f000 fbc3 	bl	800105c <ZbZclAppendHeader>
 80008d6:	0005      	movs	r5, r0
 80008d8:	2d00      	cmp	r5, #0
 80008da:	d502      	bpl.n	80008e2 <??ZbZclHandleWriteAttr_6>
 80008dc:	2080      	movs	r0, #128	; 0x80
 80008de:	4680      	mov	r8, r0
 80008e0:	e0e2      	b.n	8000aa8 <??ZbZclHandleWriteAttr_7>

080008e2 <??ZbZclHandleWriteAttr_6>:
 80008e2:	0032      	movs	r2, r6
 80008e4:	a916      	add	r1, sp, #88	; 0x58
 80008e6:	9823      	ldr	r0, [sp, #140]	; 0x8c
 80008e8:	f7ff fe57 	bl	800059a <ZbZclClusterInitApsdeReq>
 80008ec:	a816      	add	r0, sp, #88	; 0x58
 80008ee:	f116 0110 	adds.w	r1, r6, #16
 80008f2:	2210      	movs	r2, #16
 80008f4:	f017 fe4d 	bl	8018592 <__aeabi_memcpy>
 80008f8:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
 80008fc:	f7ff fde5 	bl	80004ca <ZbZclTxOptsFromSecurityStatus>
 8000900:	f8ad 007c 	strh.w	r0, [sp, #124]	; 0x7c
 8000904:	2000      	movs	r0, #0
 8000906:	4682      	mov	sl, r0
 8000908:	2080      	movs	r0, #128	; 0x80
 800090a:	0007      	movs	r7, r0
 800090c:	2001      	movs	r0, #1
 800090e:	f88d 0008 	strb.w	r0, [sp, #8]
 8000912:	2000      	movs	r0, #0
 8000914:	0004      	movs	r4, r0

08000916 <??ZbZclHandleWriteAttr_8>:
 8000916:	f11a 0003 	adds.w	r0, sl, #3
 800091a:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 800091c:	4288      	cmp	r0, r1
 800091e:	d302      	bcc.n	8000926 <??ZbZclHandleWriteAttr_9>
 8000920:	2080      	movs	r0, #128	; 0x80
 8000922:	0007      	movs	r7, r0
 8000924:	e05c      	b.n	80009e0 <??ZbZclHandleWriteAttr_10>

08000926 <??ZbZclHandleWriteAttr_9>:
 8000926:	1ce8      	adds	r0, r5, #3
 8000928:	283a      	cmp	r0, #58	; 0x3a
 800092a:	d305      	bcc.n	8000938 <??ZbZclHandleWriteAttr_11>
 800092c:	2001      	movs	r0, #1
 800092e:	f88d 0008 	strb.w	r0, [sp, #8]
 8000932:	2089      	movs	r0, #137	; 0x89
 8000934:	0007      	movs	r7, r0
 8000936:	e053      	b.n	80009e0 <??ZbZclHandleWriteAttr_10>

08000938 <??ZbZclHandleWriteAttr_11>:
 8000938:	2000      	movs	r0, #0
 800093a:	f88d 0008 	strb.w	r0, [sp, #8]
 800093e:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000940:	4450      	add	r0, sl
 8000942:	f7ff fc2b 	bl	800019c <pletoh16>
 8000946:	f8ad 000c 	strh.w	r0, [sp, #12]
 800094a:	f11a 0a02 	adds.w	sl, sl, #2
 800094e:	4650      	mov	r0, sl
 8000950:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8000952:	5c09      	ldrb	r1, [r1, r0]
 8000954:	f88d 1009 	strb.w	r1, [sp, #9]
 8000958:	4682      	mov	sl, r0
 800095a:	f11a 0a01 	adds.w	sl, sl, #1
 800095e:	2300      	movs	r3, #0
 8000960:	8d32      	ldrh	r2, [r6, #40]	; 0x28
 8000962:	ebb2 020a 	subs.w	r2, r2, sl
 8000966:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000968:	eb00 010a 	add.w	r1, r0, sl
 800096c:	f89d 0009 	ldrb.w	r0, [sp, #9]
 8000970:	f001 fb21 	bl	8001fb6 <ZbZclAttrParseLength>
 8000974:	9004      	str	r0, [sp, #16]
 8000976:	9804      	ldr	r0, [sp, #16]
 8000978:	2800      	cmp	r0, #0
 800097a:	d50c      	bpl.n	8000996 <??ZbZclHandleWriteAttr_12>
 800097c:	1c64      	adds	r4, r4, #1
 800097e:	2087      	movs	r0, #135	; 0x87
 8000980:	a907      	add	r1, sp, #28
 8000982:	5548      	strb	r0, [r1, r5]
 8000984:	1c6d      	adds	r5, r5, #1
 8000986:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 800098a:	a807      	add	r0, sp, #28
 800098c:	4428      	add	r0, r5
 800098e:	f7ff fc51 	bl	8000234 <putle16>
 8000992:	1cad      	adds	r5, r5, #2
 8000994:	e024      	b.n	80009e0 <??ZbZclHandleWriteAttr_10>

08000996 <??ZbZclHandleWriteAttr_12>:
 8000996:	4648      	mov	r0, r9
 8000998:	b280      	uxth	r0, r0
 800099a:	9001      	str	r0, [sp, #4]
 800099c:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 800099e:	ebb0 000a 	subs.w	r0, r0, sl
 80009a2:	9000      	str	r0, [sp, #0]
 80009a4:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80009a6:	eb00 030a 	add.w	r3, r0, sl
 80009aa:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 80009ae:	f116 0110 	adds.w	r1, r6, #16
 80009b2:	9823      	ldr	r0, [sp, #140]	; 0x8c
 80009b4:	f000 fe29 	bl	800160a <ZbZclAttrWrite>
 80009b8:	0007      	movs	r7, r0
 80009ba:	9804      	ldr	r0, [sp, #16]
 80009bc:	eb10 0a0a 	adds.w	sl, r0, sl
 80009c0:	0038      	movs	r0, r7
 80009c2:	b2c0      	uxtb	r0, r0
 80009c4:	2800      	cmp	r0, #0
 80009c6:	d0a6      	beq.n	8000916 <??ZbZclHandleWriteAttr_8>
 80009c8:	1c64      	adds	r4, r4, #1
 80009ca:	a807      	add	r0, sp, #28
 80009cc:	5547      	strb	r7, [r0, r5]
 80009ce:	1c6d      	adds	r5, r5, #1
 80009d0:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 80009d4:	a807      	add	r0, sp, #28
 80009d6:	4428      	add	r0, r5
 80009d8:	f7ff fc2c 	bl	8000234 <putle16>
 80009dc:	1cad      	adds	r5, r5, #2
 80009de:	e79a      	b.n	8000916 <??ZbZclHandleWriteAttr_8>

080009e0 <??ZbZclHandleWriteAttr_10>:
 80009e0:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80009e4:	2800      	cmp	r0, #0
 80009e6:	d001      	beq.n	80009ec <??ZbZclHandleWriteAttr_13>
 80009e8:	46b8      	mov	r8, r7
 80009ea:	e05d      	b.n	8000aa8 <??ZbZclHandleWriteAttr_7>

080009ec <??ZbZclHandleWriteAttr_13>:
 80009ec:	f89d 000a 	ldrb.w	r0, [sp, #10]
 80009f0:	2802      	cmp	r0, #2
 80009f2:	d001      	beq.n	80009f8 <??ZbZclHandleWriteAttr_14>
 80009f4:	2c00      	cmp	r4, #0
 80009f6:	d000      	beq.n	80009fa <??ZbZclHandleWriteAttr_2>

080009f8 <??ZbZclHandleWriteAttr_14>:
 80009f8:	e056      	b.n	8000aa8 <??ZbZclHandleWriteAttr_7>

080009fa <??ZbZclHandleWriteAttr_2>:
 80009fa:	2000      	movs	r0, #0
 80009fc:	4682      	mov	sl, r0
 80009fe:	f05f 0b00 	movs.w	fp, #0

08000a02 <??ZbZclHandleWriteAttr_15>:
 8000a02:	f11a 0003 	adds.w	r0, sl, #3
 8000a06:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8000a08:	4288      	cmp	r0, r1
 8000a0a:	d302      	bcc.n	8000a12 <??ZbZclHandleWriteAttr_16>
 8000a0c:	465c      	mov	r4, fp
 8000a0e:	1c64      	adds	r4, r4, #1
 8000a10:	e03b      	b.n	8000a8a <??ZbZclHandleWriteAttr_17>

08000a12 <??ZbZclHandleWriteAttr_16>:
 8000a12:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000a14:	4450      	add	r0, sl
 8000a16:	f7ff fbc1 	bl	800019c <pletoh16>
 8000a1a:	f8ad 000c 	strh.w	r0, [sp, #12]
 8000a1e:	f11a 0a02 	adds.w	sl, sl, #2
 8000a22:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000a24:	f810 000a 	ldrb.w	r0, [r0, sl]
 8000a28:	f88d 0009 	strb.w	r0, [sp, #9]
 8000a2c:	f11a 0a01 	adds.w	sl, sl, #1
 8000a30:	2300      	movs	r3, #0
 8000a32:	8d32      	ldrh	r2, [r6, #40]	; 0x28
 8000a34:	ebb2 020a 	subs.w	r2, r2, sl
 8000a38:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000a3a:	eb00 010a 	add.w	r1, r0, sl
 8000a3e:	f89d 0009 	ldrb.w	r0, [sp, #9]
 8000a42:	f001 fab8 	bl	8001fb6 <ZbZclAttrParseLength>
 8000a46:	9004      	str	r0, [sp, #16]
 8000a48:	9804      	ldr	r0, [sp, #16]
 8000a4a:	2800      	cmp	r0, #0
 8000a4c:	d502      	bpl.n	8000a54 <??ZbZclHandleWriteAttr_18>
 8000a4e:	465c      	mov	r4, fp
 8000a50:	1c64      	adds	r4, r4, #1
 8000a52:	e01a      	b.n	8000a8a <??ZbZclHandleWriteAttr_17>

08000a54 <??ZbZclHandleWriteAttr_18>:
 8000a54:	2000      	movs	r0, #0
 8000a56:	9001      	str	r0, [sp, #4]
 8000a58:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 8000a5a:	ebb0 000a 	subs.w	r0, r0, sl
 8000a5e:	9000      	str	r0, [sp, #0]
 8000a60:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8000a62:	eb00 030a 	add.w	r3, r0, sl
 8000a66:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 8000a6a:	f116 0110 	adds.w	r1, r6, #16
 8000a6e:	9823      	ldr	r0, [sp, #140]	; 0x8c
 8000a70:	f000 fdcb 	bl	800160a <ZbZclAttrWrite>
 8000a74:	0007      	movs	r7, r0
 8000a76:	0038      	movs	r0, r7
 8000a78:	b2c0      	uxtb	r0, r0
 8000a7a:	2800      	cmp	r0, #0
 8000a7c:	d001      	beq.n	8000a82 <??ZbZclHandleWriteAttr_19>
 8000a7e:	f11b 0b01 	adds.w	fp, fp, #1

08000a82 <??ZbZclHandleWriteAttr_19>:
 8000a82:	9804      	ldr	r0, [sp, #16]
 8000a84:	eb10 0a0a 	adds.w	sl, r0, sl
 8000a88:	e7bb      	b.n	8000a02 <??ZbZclHandleWriteAttr_15>

08000a8a <??ZbZclHandleWriteAttr_17>:
 8000a8a:	f89d 000a 	ldrb.w	r0, [sp, #10]
 8000a8e:	2803      	cmp	r0, #3
 8000a90:	d105      	bne.n	8000a9e <??ZbZclHandleWriteAttr_20>
 8000a92:	2c00      	cmp	r4, #0
 8000a94:	d002      	beq.n	8000a9c <??ZbZclHandleWriteAttr_21>
 8000a96:	2001      	movs	r0, #1
 8000a98:	4680      	mov	r8, r0
 8000a9a:	e005      	b.n	8000aa8 <??ZbZclHandleWriteAttr_7>

08000a9c <??ZbZclHandleWriteAttr_21>:
 8000a9c:	e004      	b.n	8000aa8 <??ZbZclHandleWriteAttr_7>

08000a9e <??ZbZclHandleWriteAttr_20>:
 8000a9e:	20ff      	movs	r0, #255	; 0xff
 8000aa0:	4680      	mov	r8, r0
 8000aa2:	e001      	b.n	8000aa8 <??ZbZclHandleWriteAttr_7>

08000aa4 <??ZbZclHandleWriteAttr_3>:
 8000aa4:	2081      	movs	r0, #129	; 0x81
 8000aa6:	4680      	mov	r8, r0

08000aa8 <??ZbZclHandleWriteAttr_7>:
 8000aa8:	4640      	mov	r0, r8
 8000aaa:	b2c0      	uxtb	r0, r0
 8000aac:	2800      	cmp	r0, #0
 8000aae:	d00b      	beq.n	8000ac8 <??ZbZclHandleWriteAttr_22>
 8000ab0:	4640      	mov	r0, r8
 8000ab2:	b2c0      	uxtb	r0, r0
 8000ab4:	28ff      	cmp	r0, #255	; 0xff
 8000ab6:	d006      	beq.n	8000ac6 <??ZbZclHandleWriteAttr_23>
 8000ab8:	4643      	mov	r3, r8
 8000aba:	b2db      	uxtb	r3, r3
 8000abc:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8000abe:	0031      	movs	r1, r6
 8000ac0:	9823      	ldr	r0, [sp, #140]	; 0x8c
 8000ac2:	f015 fa56 	bl	8015f72 <ZbZclSendDefaultResponse>

08000ac6 <??ZbZclHandleWriteAttr_23>:
 8000ac6:	e01a      	b.n	8000afe <??ZbZclHandleWriteAttr_24>

08000ac8 <??ZbZclHandleWriteAttr_22>:
 8000ac8:	2c00      	cmp	r4, #0
 8000aca:	d10c      	bne.n	8000ae6 <??ZbZclHandleWriteAttr_25>
 8000acc:	2d00      	cmp	r5, #0
 8000ace:	d106      	bne.n	8000ade <??ZbZclHandleWriteAttr_26>
 8000ad0:	2301      	movs	r3, #1
 8000ad2:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8000ad4:	0031      	movs	r1, r6
 8000ad6:	9823      	ldr	r0, [sp, #140]	; 0x8c
 8000ad8:	f015 fa4b 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000adc:	e00f      	b.n	8000afe <??ZbZclHandleWriteAttr_24>

08000ade <??ZbZclHandleWriteAttr_26>:
 8000ade:	2000      	movs	r0, #0
 8000ae0:	a907      	add	r1, sp, #28
 8000ae2:	5548      	strb	r0, [r1, r5]
 8000ae4:	1c6d      	adds	r5, r5, #1

08000ae6 <??ZbZclHandleWriteAttr_25>:
 8000ae6:	a807      	add	r0, sp, #28
 8000ae8:	901c      	str	r0, [sp, #112]	; 0x70
 8000aea:	0028      	movs	r0, r5
 8000aec:	f8ad 0074 	strh.w	r0, [sp, #116]	; 0x74
 8000af0:	2300      	movs	r3, #0
 8000af2:	2200      	movs	r2, #0
 8000af4:	a916      	add	r1, sp, #88	; 0x58
 8000af6:	9823      	ldr	r0, [sp, #140]	; 0x8c
 8000af8:	6880      	ldr	r0, [r0, #8]
 8000afa:	f014 fd7d 	bl	80155f8 <ZbApsdeDataReqCallback>

08000afe <??ZbZclHandleWriteAttr_24>:
 8000afe:	b025      	add	sp, #148	; 0x94
 8000b00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000b04 <zcl_handle_command>:
 8000b04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000b08:	0004      	movs	r4, r0
 8000b0a:	000d      	movs	r5, r1
 8000b0c:	0016      	movs	r6, r2
 8000b0e:	79f7      	ldrb	r7, [r6, #7]
 8000b10:	8868      	ldrh	r0, [r5, #2]
 8000b12:	28ff      	cmp	r0, #255	; 0xff
 8000b14:	d102      	bne.n	8000b1c <??zcl_handle_command_0>
 8000b16:	f05f 0800 	movs.w	r8, #0
 8000b1a:	e001      	b.n	8000b20 <??zcl_handle_command_1>

08000b1c <??zcl_handle_command_0>:
 8000b1c:	f05f 0801 	movs.w	r8, #1

08000b20 <??zcl_handle_command_1>:
 8000b20:	f115 0110 	adds.w	r1, r5, #16
 8000b24:	68a0      	ldr	r0, [r4, #8]
 8000b26:	f014 fe04 	bl	8015732 <ZbApsAddrIsLocal>
 8000b2a:	2800      	cmp	r0, #0
 8000b2c:	d121      	bne.n	8000b72 <??zcl_handle_command_2>

08000b2e <??zcl_handle_command_3>:
 8000b2e:	89a0      	ldrh	r0, [r4, #12]
 8000b30:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8000b34:	d01d      	beq.n	8000b72 <??zcl_handle_command_2>

08000b36 <??zcl_handle_command_4>:
 8000b36:	0032      	movs	r2, r6
 8000b38:	0029      	movs	r1, r5
 8000b3a:	0020      	movs	r0, r4
 8000b3c:	f7ff fc38 	bl	80003b0 <ZbZclClusterCheckMinSecurity>
 8000b40:	2800      	cmp	r0, #0
 8000b42:	d107      	bne.n	8000b54 <??zcl_handle_command_5>
 8000b44:	2301      	movs	r3, #1
 8000b46:	0032      	movs	r2, r6
 8000b48:	0029      	movs	r1, r5
 8000b4a:	0020      	movs	r0, r4
 8000b4c:	f015 fa11 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000b50:	4640      	mov	r0, r8
 8000b52:	e0f7      	b.n	8000d44 <??zcl_handle_command_6>

08000b54 <??zcl_handle_command_5>:
 8000b54:	0032      	movs	r2, r6
 8000b56:	0029      	movs	r1, r5
 8000b58:	68a0      	ldr	r0, [r4, #8]
 8000b5a:	f015 f8d3 	bl	8015d04 <ZbZclDeviceLogCheckAllow>
 8000b5e:	2800      	cmp	r0, #0
 8000b60:	d107      	bne.n	8000b72 <??zcl_handle_command_2>
 8000b62:	2301      	movs	r3, #1
 8000b64:	0032      	movs	r2, r6
 8000b66:	0029      	movs	r1, r5
 8000b68:	0020      	movs	r0, r4
 8000b6a:	f015 fa02 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000b6e:	4640      	mov	r0, r8
 8000b70:	e0e8      	b.n	8000d44 <??zcl_handle_command_6>

08000b72 <??zcl_handle_command_2>:
 8000b72:	7830      	ldrb	r0, [r6, #0]
 8000b74:	2801      	cmp	r0, #1
 8000b76:	d13a      	bne.n	8000bee <??zcl_handle_command_8>
 8000b78:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8000b7a:	2800      	cmp	r0, #0
 8000b7c:	d107      	bne.n	8000b8e <??zcl_handle_command_9>
 8000b7e:	2381      	movs	r3, #129	; 0x81
 8000b80:	0032      	movs	r2, r6
 8000b82:	0029      	movs	r1, r5
 8000b84:	0020      	movs	r0, r4
 8000b86:	f015 f9f4 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000b8a:	4640      	mov	r0, r8
 8000b8c:	e0da      	b.n	8000d44 <??zcl_handle_command_6>

08000b8e <??zcl_handle_command_9>:
 8000b8e:	7870      	ldrb	r0, [r6, #1]
 8000b90:	2800      	cmp	r0, #0
 8000b92:	d00e      	beq.n	8000bb2 <??zcl_handle_command_10>
 8000b94:	8a20      	ldrh	r0, [r4, #16]
 8000b96:	2800      	cmp	r0, #0
 8000b98:	d003      	beq.n	8000ba2 <??zcl_handle_command_11>
 8000b9a:	8a20      	ldrh	r0, [r4, #16]
 8000b9c:	88b1      	ldrh	r1, [r6, #4]
 8000b9e:	4288      	cmp	r0, r1
 8000ba0:	d012      	beq.n	8000bc8 <??zcl_handle_command_12>

08000ba2 <??zcl_handle_command_11>:
 8000ba2:	2381      	movs	r3, #129	; 0x81
 8000ba4:	0032      	movs	r2, r6
 8000ba6:	0029      	movs	r1, r5
 8000ba8:	0020      	movs	r0, r4
 8000baa:	f015 f9e2 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000bae:	4640      	mov	r0, r8
 8000bb0:	e0c8      	b.n	8000d44 <??zcl_handle_command_6>

08000bb2 <??zcl_handle_command_10>:
 8000bb2:	8a20      	ldrh	r0, [r4, #16]
 8000bb4:	2800      	cmp	r0, #0
 8000bb6:	d007      	beq.n	8000bc8 <??zcl_handle_command_12>
 8000bb8:	2381      	movs	r3, #129	; 0x81
 8000bba:	0032      	movs	r2, r6
 8000bbc:	0029      	movs	r1, r5
 8000bbe:	0020      	movs	r0, r4
 8000bc0:	f015 f9d7 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000bc4:	4640      	mov	r0, r8
 8000bc6:	e0bd      	b.n	8000d44 <??zcl_handle_command_6>

08000bc8 <??zcl_handle_command_12>:
 8000bc8:	002a      	movs	r2, r5
 8000bca:	0031      	movs	r1, r6
 8000bcc:	0020      	movs	r0, r4
 8000bce:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000bd0:	4798      	blx	r3
 8000bd2:	4681      	mov	r9, r0
 8000bd4:	4648      	mov	r0, r9
 8000bd6:	b2c0      	uxtb	r0, r0
 8000bd8:	28ff      	cmp	r0, #255	; 0xff
 8000bda:	d006      	beq.n	8000bea <??zcl_handle_command_13>
 8000bdc:	464b      	mov	r3, r9
 8000bde:	b2db      	uxtb	r3, r3
 8000be0:	0032      	movs	r2, r6
 8000be2:	0029      	movs	r1, r5
 8000be4:	0020      	movs	r0, r4
 8000be6:	f015 f9c4 	bl	8015f72 <ZbZclSendDefaultResponse>

08000bea <??zcl_handle_command_13>:
 8000bea:	4640      	mov	r0, r8
 8000bec:	e0aa      	b.n	8000d44 <??zcl_handle_command_6>

08000bee <??zcl_handle_command_8>:
 8000bee:	7830      	ldrb	r0, [r6, #0]
 8000bf0:	2800      	cmp	r0, #0
 8000bf2:	d007      	beq.n	8000c04 <??zcl_handle_command_14>
 8000bf4:	2385      	movs	r3, #133	; 0x85
 8000bf6:	0032      	movs	r2, r6
 8000bf8:	0029      	movs	r1, r5
 8000bfa:	0020      	movs	r0, r4
 8000bfc:	f015 f9b9 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000c00:	4640      	mov	r0, r8
 8000c02:	e09f      	b.n	8000d44 <??zcl_handle_command_6>

08000c04 <??zcl_handle_command_14>:
 8000c04:	0038      	movs	r0, r7
 8000c06:	b2c0      	uxtb	r0, r0
 8000c08:	2800      	cmp	r0, #0
 8000c0a:	d01c      	beq.n	8000c46 <??zcl_handle_command_15>
 8000c0c:	2801      	cmp	r0, #1
 8000c0e:	d03f      	beq.n	8000c90 <??zcl_handle_command_16>
 8000c10:	2802      	cmp	r0, #2
 8000c12:	d01e      	beq.n	8000c52 <??zcl_handle_command_17>
 8000c14:	2803      	cmp	r0, #3
 8000c16:	d01c      	beq.n	8000c52 <??zcl_handle_command_17>
 8000c18:	2804      	cmp	r0, #4
 8000c1a:	d039      	beq.n	8000c90 <??zcl_handle_command_16>
 8000c1c:	2805      	cmp	r0, #5
 8000c1e:	d018      	beq.n	8000c52 <??zcl_handle_command_17>
 8000c20:	2806      	cmp	r0, #6
 8000c22:	d01c      	beq.n	8000c5e <??zcl_handle_command_18>
 8000c24:	2807      	cmp	r0, #7
 8000c26:	d033      	beq.n	8000c90 <??zcl_handle_command_16>
 8000c28:	2808      	cmp	r0, #8
 8000c2a:	d01e      	beq.n	8000c6a <??zcl_handle_command_19>
 8000c2c:	2809      	cmp	r0, #9
 8000c2e:	d02f      	beq.n	8000c90 <??zcl_handle_command_16>
 8000c30:	280a      	cmp	r0, #10
 8000c32:	d020      	beq.n	8000c76 <??zcl_handle_command_20>
 8000c34:	280b      	cmp	r0, #11
 8000c36:	d02a      	beq.n	8000c8e <??zcl_handle_command_21>
 8000c38:	280c      	cmp	r0, #12
 8000c3a:	d022      	beq.n	8000c82 <??zcl_handle_command_22>
 8000c3c:	280d      	cmp	r0, #13
 8000c3e:	d027      	beq.n	8000c90 <??zcl_handle_command_16>
 8000c40:	2810      	cmp	r0, #16
 8000c42:	d025      	beq.n	8000c90 <??zcl_handle_command_16>
 8000c44:	e025      	b.n	8000c92 <??zcl_handle_command_23>

08000c46 <??zcl_handle_command_15>:
 8000c46:	002a      	movs	r2, r5
 8000c48:	0031      	movs	r1, r6
 8000c4a:	0020      	movs	r0, r4
 8000c4c:	f7ff fd1f 	bl	800068e <ZbZclHandleReadAttr>
 8000c50:	e077      	b.n	8000d42 <??zcl_handle_command_24>

08000c52 <??zcl_handle_command_17>:
 8000c52:	002a      	movs	r2, r5
 8000c54:	0031      	movs	r1, r6
 8000c56:	0020      	movs	r0, r4
 8000c58:	f7ff fdf4 	bl	8000844 <ZbZclHandleWriteAttr>
 8000c5c:	e071      	b.n	8000d42 <??zcl_handle_command_24>

08000c5e <??zcl_handle_command_18>:
 8000c5e:	002a      	movs	r2, r5
 8000c60:	0031      	movs	r1, r6
 8000c62:	0020      	movs	r0, r4
 8000c64:	f003 f849 	bl	8003cfa <ZbZclHandleConfigReport>
 8000c68:	e06b      	b.n	8000d42 <??zcl_handle_command_24>

08000c6a <??zcl_handle_command_19>:
 8000c6a:	002a      	movs	r2, r5
 8000c6c:	0031      	movs	r1, r6
 8000c6e:	0020      	movs	r0, r4
 8000c70:	f003 fac7 	bl	8004202 <ZbZclHandleReadReport>
 8000c74:	e065      	b.n	8000d42 <??zcl_handle_command_24>

08000c76 <??zcl_handle_command_20>:
 8000c76:	002a      	movs	r2, r5
 8000c78:	0031      	movs	r1, r6
 8000c7a:	0020      	movs	r0, r4
 8000c7c:	f003 fbe6 	bl	800444c <ZbZclHandleReportAttr>
 8000c80:	e05f      	b.n	8000d42 <??zcl_handle_command_24>

08000c82 <??zcl_handle_command_22>:
 8000c82:	002a      	movs	r2, r5
 8000c84:	0031      	movs	r1, r6
 8000c86:	0020      	movs	r0, r4
 8000c88:	f000 fa8b 	bl	80011a2 <ZbZclAttrHandleDiscover>
 8000c8c:	e059      	b.n	8000d42 <??zcl_handle_command_24>

08000c8e <??zcl_handle_command_21>:
 8000c8e:	e058      	b.n	8000d42 <??zcl_handle_command_24>

08000c90 <??zcl_handle_command_16>:
 8000c90:	e057      	b.n	8000d42 <??zcl_handle_command_24>

08000c92 <??zcl_handle_command_23>:
 8000c92:	7870      	ldrb	r0, [r6, #1]
 8000c94:	2800      	cmp	r0, #0
 8000c96:	d04e      	beq.n	8000d36 <??zcl_handle_command_25>
 8000c98:	88b0      	ldrh	r0, [r6, #4]
 8000c9a:	f64f 71fe 	movw	r1, #65534	; 0xfffe
 8000c9e:	4288      	cmp	r0, r1
 8000ca0:	d141      	bne.n	8000d26 <??zcl_handle_command_26>
 8000ca2:	f115 0110 	adds.w	r1, r5, #16
 8000ca6:	68a0      	ldr	r0, [r4, #8]
 8000ca8:	f014 fd43 	bl	8015732 <ZbApsAddrIsLocal>
 8000cac:	2800      	cmp	r0, #0
 8000cae:	d107      	bne.n	8000cc0 <??zcl_handle_command_27>
 8000cb0:	2381      	movs	r3, #129	; 0x81
 8000cb2:	0032      	movs	r2, r6
 8000cb4:	0029      	movs	r1, r5
 8000cb6:	0020      	movs	r0, r4
 8000cb8:	f015 f95b 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000cbc:	4640      	mov	r0, r8
 8000cbe:	e041      	b.n	8000d44 <??zcl_handle_command_6>

08000cc0 <??zcl_handle_command_27>:
 8000cc0:	0038      	movs	r0, r7
 8000cc2:	b2c0      	uxtb	r0, r0
 8000cc4:	28f0      	cmp	r0, #240	; 0xf0
 8000cc6:	d108      	bne.n	8000cda <??zcl_handle_command_28>
 8000cc8:	78b0      	ldrb	r0, [r6, #2]
 8000cca:	2800      	cmp	r0, #0
 8000ccc:	d131      	bne.n	8000d32 <??zcl_handle_command_29>
 8000cce:	002a      	movs	r2, r5
 8000cd0:	0031      	movs	r1, r6
 8000cd2:	0020      	movs	r0, r4
 8000cd4:	f004 f933 	bl	8004f3e <ZbZclHandleGetSceneData>
 8000cd8:	e02b      	b.n	8000d32 <??zcl_handle_command_29>

08000cda <??zcl_handle_command_28>:
 8000cda:	0038      	movs	r0, r7
 8000cdc:	b2c0      	uxtb	r0, r0
 8000cde:	28f1      	cmp	r0, #241	; 0xf1
 8000ce0:	d108      	bne.n	8000cf4 <??zcl_handle_command_30>
 8000ce2:	78b0      	ldrb	r0, [r6, #2]
 8000ce4:	2800      	cmp	r0, #0
 8000ce6:	d124      	bne.n	8000d32 <??zcl_handle_command_29>
 8000ce8:	002a      	movs	r2, r5
 8000cea:	0031      	movs	r1, r6
 8000cec:	0020      	movs	r0, r4
 8000cee:	f004 f9a5 	bl	800503c <ZbZclHandleSetSceneData>
 8000cf2:	e01e      	b.n	8000d32 <??zcl_handle_command_29>

08000cf4 <??zcl_handle_command_30>:
 8000cf4:	0038      	movs	r0, r7
 8000cf6:	b2c0      	uxtb	r0, r0
 8000cf8:	28f2      	cmp	r0, #242	; 0xf2
 8000cfa:	d10d      	bne.n	8000d18 <??zcl_handle_command_31>
 8000cfc:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
 8000cfe:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8000d00:	0020      	movs	r0, r4
 8000d02:	f7ff fc77 	bl	80005f4 <zcl_persist_handle_set>
 8000d06:	4681      	mov	r9, r0
 8000d08:	464b      	mov	r3, r9
 8000d0a:	b2db      	uxtb	r3, r3
 8000d0c:	0032      	movs	r2, r6
 8000d0e:	0029      	movs	r1, r5
 8000d10:	0020      	movs	r0, r4
 8000d12:	f015 f92e 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000d16:	e00c      	b.n	8000d32 <??zcl_handle_command_29>

08000d18 <??zcl_handle_command_31>:
 8000d18:	2381      	movs	r3, #129	; 0x81
 8000d1a:	0032      	movs	r2, r6
 8000d1c:	0029      	movs	r1, r5
 8000d1e:	0020      	movs	r0, r4
 8000d20:	f015 f927 	bl	8015f72 <ZbZclSendDefaultResponse>
 8000d24:	e005      	b.n	8000d32 <??zcl_handle_command_29>

08000d26 <??zcl_handle_command_26>:
 8000d26:	2381      	movs	r3, #129	; 0x81
 8000d28:	0032      	movs	r2, r6
 8000d2a:	0029      	movs	r1, r5
 8000d2c:	0020      	movs	r0, r4
 8000d2e:	f015 f920 	bl	8015f72 <ZbZclSendDefaultResponse>

08000d32 <??zcl_handle_command_29>:
 8000d32:	4640      	mov	r0, r8
 8000d34:	e006      	b.n	8000d44 <??zcl_handle_command_6>

08000d36 <??zcl_handle_command_25>:
 8000d36:	2381      	movs	r3, #129	; 0x81
 8000d38:	0032      	movs	r2, r6
 8000d3a:	0029      	movs	r1, r5
 8000d3c:	0020      	movs	r0, r4
 8000d3e:	f015 f918 	bl	8015f72 <ZbZclSendDefaultResponse>

08000d42 <??zcl_handle_command_24>:
 8000d42:	4640      	mov	r0, r8

08000d44 <??zcl_handle_command_6>:
 8000d44:	e8bd 83f2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, pc}

08000d48 <zcl_cluster_data_ind>:
 8000d48:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8000d4a:	0004      	movs	r4, r0
 8000d4c:	000d      	movs	r5, r1
 8000d4e:	002e      	movs	r6, r5
 8000d50:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8000d52:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000d54:	4668      	mov	r0, sp
 8000d56:	f000 f8fe 	bl	8000f56 <ZbZclParseHeader>
 8000d5a:	0007      	movs	r7, r0
 8000d5c:	2f00      	cmp	r7, #0
 8000d5e:	d501      	bpl.n	8000d64 <??zcl_cluster_data_ind_0>
 8000d60:	2000      	movs	r0, #0
 8000d62:	e00a      	b.n	8000d7a <??zcl_cluster_data_ind_1>

08000d64 <??zcl_cluster_data_ind_0>:
 8000d64:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000d66:	4438      	add	r0, r7
 8000d68:	6260      	str	r0, [r4, #36]	; 0x24
 8000d6a:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 8000d6c:	1bc0      	subs	r0, r0, r7
 8000d6e:	8520      	strh	r0, [r4, #40]	; 0x28
 8000d70:	466a      	mov	r2, sp
 8000d72:	0021      	movs	r1, r4
 8000d74:	0030      	movs	r0, r6
 8000d76:	f7ff fec5 	bl	8000b04 <zcl_handle_command>

08000d7a <??zcl_cluster_data_ind_1>:
 8000d7a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08000d7c <zcl_cluster_alarm_data_ind>:
 8000d7c:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000d80:	b098      	sub	sp, #96	; 0x60
 8000d82:	0004      	movs	r4, r0
 8000d84:	9d18      	ldr	r5, [sp, #96]	; 0x60
 8000d86:	26ff      	movs	r6, #255	; 0xff
 8000d88:	2700      	movs	r7, #0
 8000d8a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8000d8c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000d8e:	a802      	add	r0, sp, #8
 8000d90:	f000 f8e1 	bl	8000f56 <ZbZclParseHeader>
 8000d94:	4680      	mov	r8, r0
 8000d96:	f1b8 0f00 	cmp.w	r8, #0
 8000d9a:	d501      	bpl.n	8000da0 <??zcl_cluster_alarm_data_ind_0>
 8000d9c:	2000      	movs	r0, #0
 8000d9e:	e0d7      	b.n	8000f50 <??zcl_cluster_alarm_data_ind_1>

08000da0 <??zcl_cluster_alarm_data_ind_0>:
 8000da0:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 8000da2:	ebb0 0008 	subs.w	r0, r0, r8
 8000da6:	8520      	strh	r0, [r4, #40]	; 0x28
 8000da8:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 8000daa:	2809      	cmp	r0, #9
 8000dac:	d001      	beq.n	8000db2 <??zcl_cluster_alarm_data_ind_2>
 8000dae:	2000      	movs	r0, #0
 8000db0:	e0ce      	b.n	8000f50 <??zcl_cluster_alarm_data_ind_1>

08000db2 <??zcl_cluster_alarm_data_ind_2>:
 8000db2:	f89d 000a 	ldrb.w	r0, [sp, #10]
 8000db6:	2800      	cmp	r0, #0
 8000db8:	d001      	beq.n	8000dbe <??zcl_cluster_alarm_data_ind_3>
 8000dba:	2000      	movs	r0, #0
 8000dbc:	e0c8      	b.n	8000f50 <??zcl_cluster_alarm_data_ind_1>

08000dbe <??zcl_cluster_alarm_data_ind_3>:
 8000dbe:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8000dc2:	2801      	cmp	r0, #1
 8000dc4:	d001      	beq.n	8000dca <??zcl_cluster_alarm_data_ind_4>
 8000dc6:	2000      	movs	r0, #0
 8000dc8:	e0c2      	b.n	8000f50 <??zcl_cluster_alarm_data_ind_1>

08000dca <??zcl_cluster_alarm_data_ind_4>:
 8000dca:	f89d 000f 	ldrb.w	r0, [sp, #15]
 8000dce:	2800      	cmp	r0, #0
 8000dd0:	d002      	beq.n	8000dd8 <??zcl_cluster_alarm_data_ind_5>
 8000dd2:	2801      	cmp	r0, #1
 8000dd4:	d02a      	beq.n	8000e2c <??zcl_cluster_alarm_data_ind_6>
 8000dd6:	e03f      	b.n	8000e58 <??zcl_cluster_alarm_data_ind_7>

08000dd8 <??zcl_cluster_alarm_data_ind_5>:
 8000dd8:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000dda:	f810 0008 	ldrb.w	r0, [r0, r8]
 8000dde:	f88d 0004 	strb.w	r0, [sp, #4]
 8000de2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000de4:	4440      	add	r0, r8
 8000de6:	1c40      	adds	r0, r0, #1
 8000de8:	f7ff f9d8 	bl	800019c <pletoh16>
 8000dec:	f8ad 0006 	strh.w	r0, [sp, #6]
 8000df0:	f8bd 9006 	ldrh.w	r9, [sp, #6]
 8000df4:	0028      	movs	r0, r5
 8000df6:	f7ff fa77 	bl	80002e8 <ZbZclClusterGetClusterId>
 8000dfa:	4581      	cmp	r9, r0
 8000dfc:	d12c      	bne.n	8000e58 <??zcl_cluster_alarm_data_ind_7>

08000dfe <??zcl_cluster_alarm_data_ind_9>:
 8000dfe:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
 8000e00:	2800      	cmp	r0, #0
 8000e02:	d104      	bne.n	8000e0e <??zcl_cluster_alarm_data_ind_10>
 8000e04:	2081      	movs	r0, #129	; 0x81
 8000e06:	0006      	movs	r6, r0
 8000e08:	2001      	movs	r0, #1
 8000e0a:	0007      	movs	r7, r0
 8000e0c:	e024      	b.n	8000e58 <??zcl_cluster_alarm_data_ind_7>

08000e0e <??zcl_cluster_alarm_data_ind_10>:
 8000e0e:	a802      	add	r0, sp, #8
 8000e10:	9000      	str	r0, [sp, #0]
 8000e12:	0023      	movs	r3, r4
 8000e14:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8000e18:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8000e1c:	0028      	movs	r0, r5
 8000e1e:	f8d5 c04c 	ldr.w	ip, [r5, #76]	; 0x4c
 8000e22:	47e0      	blx	ip
 8000e24:	0006      	movs	r6, r0
 8000e26:	2001      	movs	r0, #1
 8000e28:	0007      	movs	r7, r0
 8000e2a:	e015      	b.n	8000e58 <??zcl_cluster_alarm_data_ind_7>

08000e2c <??zcl_cluster_alarm_data_ind_6>:
 8000e2c:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
 8000e2e:	2800      	cmp	r0, #0
 8000e30:	d104      	bne.n	8000e3c <??zcl_cluster_alarm_data_ind_11>
 8000e32:	2081      	movs	r0, #129	; 0x81
 8000e34:	0006      	movs	r6, r0
 8000e36:	2001      	movs	r0, #1
 8000e38:	0007      	movs	r7, r0
 8000e3a:	e00d      	b.n	8000e58 <??zcl_cluster_alarm_data_ind_7>

08000e3c <??zcl_cluster_alarm_data_ind_11>:
 8000e3c:	a802      	add	r0, sp, #8
 8000e3e:	9000      	str	r0, [sp, #0]
 8000e40:	0023      	movs	r3, r4
 8000e42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000e46:	21ff      	movs	r1, #255	; 0xff
 8000e48:	0028      	movs	r0, r5
 8000e4a:	f8d5 c04c 	ldr.w	ip, [r5, #76]	; 0x4c
 8000e4e:	47e0      	blx	ip
 8000e50:	0006      	movs	r6, r0
 8000e52:	2001      	movs	r0, #1
 8000e54:	0007      	movs	r7, r0
 8000e56:	e7ff      	b.n	8000e58 <??zcl_cluster_alarm_data_ind_7>

08000e58 <??zcl_cluster_alarm_data_ind_7>:
 8000e58:	0030      	movs	r0, r6
 8000e5a:	b2c0      	uxtb	r0, r0
 8000e5c:	28ff      	cmp	r0, #255	; 0xff
 8000e5e:	d076      	beq.n	8000f4e <??zcl_cluster_alarm_data_ind_12>
 8000e60:	f89d 000e 	ldrb.w	r0, [sp, #14]
 8000e64:	f88d 0000 	strb.w	r0, [sp]
 8000e68:	f89d 000f 	ldrb.w	r0, [sp, #15]
 8000e6c:	f88d 0002 	strb.w	r0, [sp, #2]
 8000e70:	f88d 6003 	strb.w	r6, [sp, #3]
 8000e74:	f05f 0a08 	movs.w	sl, #8
 8000e78:	f05f 0b00 	movs.w	fp, #0
 8000e7c:	f10d 0908 	add.w	r9, sp, #8
 8000e80:	465a      	mov	r2, fp
 8000e82:	4651      	mov	r1, sl
 8000e84:	4648      	mov	r0, r9
 8000e86:	f004 fdee 	bl	8005a66 <__aeabi_memset>
 8000e8a:	2000      	movs	r0, #0
 8000e8c:	f88d 0008 	strb.w	r0, [sp, #8]
 8000e90:	2000      	movs	r0, #0
 8000e92:	f88d 0009 	strb.w	r0, [sp, #9]
 8000e96:	2001      	movs	r0, #1
 8000e98:	f88d 000a 	strb.w	r0, [sp, #10]
 8000e9c:	2001      	movs	r0, #1
 8000e9e:	f88d 000b 	strb.w	r0, [sp, #11]
 8000ea2:	2000      	movs	r0, #0
 8000ea4:	f8ad 000c 	strh.w	r0, [sp, #12]
 8000ea8:	f89d 0000 	ldrb.w	r0, [sp]
 8000eac:	f88d 000e 	strb.w	r0, [sp, #14]
 8000eb0:	200b      	movs	r0, #11
 8000eb2:	f88d 000f 	strb.w	r0, [sp, #15]
 8000eb6:	2205      	movs	r2, #5
 8000eb8:	a905      	add	r1, sp, #20
 8000eba:	a802      	add	r0, sp, #8
 8000ebc:	f000 f8ce 	bl	800105c <ZbZclAppendHeader>
 8000ec0:	4681      	mov	r9, r0
 8000ec2:	f1b9 0f00 	cmp.w	r9, #0
 8000ec6:	d501      	bpl.n	8000ecc <??zcl_cluster_alarm_data_ind_13>
 8000ec8:	2089      	movs	r0, #137	; 0x89
 8000eca:	e041      	b.n	8000f50 <??zcl_cluster_alarm_data_ind_1>

08000ecc <??zcl_cluster_alarm_data_ind_13>:
 8000ecc:	a805      	add	r0, sp, #20
 8000ece:	9014      	str	r0, [sp, #80]	; 0x50
 8000ed0:	a814      	add	r0, sp, #80	; 0x50
 8000ed2:	f8c0 9004 	str.w	r9, [r0, #4]
 8000ed6:	f10d 0102 	add.w	r1, sp, #2
 8000eda:	6081      	str	r1, [r0, #8]
 8000edc:	2002      	movs	r0, #2
 8000ede:	9017      	str	r0, [sp, #92]	; 0x5c
 8000ee0:	2030      	movs	r0, #48	; 0x30
 8000ee2:	9004      	str	r0, [sp, #16]
 8000ee4:	f05f 0a00 	movs.w	sl, #0
 8000ee8:	f10d 0b20 	add.w	fp, sp, #32
 8000eec:	4652      	mov	r2, sl
 8000eee:	9904      	ldr	r1, [sp, #16]
 8000ef0:	4658      	mov	r0, fp
 8000ef2:	f004 fdb8 	bl	8005a66 <__aeabi_memset>
 8000ef6:	a808      	add	r0, sp, #32
 8000ef8:	f114 0110 	adds.w	r1, r4, #16
 8000efc:	2210      	movs	r2, #16
 8000efe:	f017 fb48 	bl	8018592 <__aeabi_memcpy>
 8000f02:	8aa8      	ldrh	r0, [r5, #20]
 8000f04:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
 8000f08:	2009      	movs	r0, #9
 8000f0a:	f8ad 0032 	strh.w	r0, [sp, #50]	; 0x32
 8000f0e:	7ba8      	ldrb	r0, [r5, #14]
 8000f10:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
 8000f14:	a814      	add	r0, sp, #80	; 0x50
 8000f16:	900e      	str	r0, [sp, #56]	; 0x38
 8000f18:	2002      	movs	r0, #2
 8000f1a:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8000f1e:	f894 002a 	ldrb.w	r0, [r4, #42]	; 0x2a
 8000f22:	f7ff fad2 	bl	80004ca <ZbZclTxOptsFromSecurityStatus>
 8000f26:	f8ad 0044 	strh.w	r0, [sp, #68]	; 0x44
 8000f2a:	f8bd 0044 	ldrh.w	r0, [sp, #68]	; 0x44
 8000f2e:	f450 7080 	orrs.w	r0, r0, #256	; 0x100
 8000f32:	f8ad 0044 	strh.w	r0, [sp, #68]	; 0x44
 8000f36:	2000      	movs	r0, #0
 8000f38:	f88d 0046 	strb.w	r0, [sp, #70]	; 0x46
 8000f3c:	2000      	movs	r0, #0
 8000f3e:	f88d 0047 	strb.w	r0, [sp, #71]	; 0x47
 8000f42:	2300      	movs	r3, #0
 8000f44:	2200      	movs	r2, #0
 8000f46:	a908      	add	r1, sp, #32
 8000f48:	68a8      	ldr	r0, [r5, #8]
 8000f4a:	f014 fb55 	bl	80155f8 <ZbApsdeDataReqCallback>

08000f4e <??zcl_cluster_alarm_data_ind_12>:
 8000f4e:	0038      	movs	r0, r7

08000f50 <??zcl_cluster_alarm_data_ind_1>:
 8000f50:	b019      	add	sp, #100	; 0x64
 8000f52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000f56 <ZbZclParseHeader>:
 8000f56:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000f5a:	0004      	movs	r4, r0
 8000f5c:	000d      	movs	r5, r1
 8000f5e:	0016      	movs	r6, r2
 8000f60:	2700      	movs	r7, #0
 8000f62:	2e03      	cmp	r6, #3
 8000f64:	d202      	bcs.n	8000f6c <??ZbZclParseHeader_0>
 8000f66:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8000f6a:	e035      	b.n	8000fd8 <??ZbZclParseHeader_1>

08000f6c <??ZbZclParseHeader_0>:
 8000f6c:	f05f 0808 	movs.w	r8, #8
 8000f70:	f05f 0900 	movs.w	r9, #0
 8000f74:	46a2      	mov	sl, r4
 8000f76:	464a      	mov	r2, r9
 8000f78:	4641      	mov	r1, r8
 8000f7a:	4650      	mov	r0, sl
 8000f7c:	f004 fd73 	bl	8005a66 <__aeabi_memset>
 8000f80:	5de8      	ldrb	r0, [r5, r7]
 8000f82:	f010 0003 	ands.w	r0, r0, #3
 8000f86:	7020      	strb	r0, [r4, #0]
 8000f88:	5de8      	ldrb	r0, [r5, r7]
 8000f8a:	b2c0      	uxtb	r0, r0
 8000f8c:	0880      	lsrs	r0, r0, #2
 8000f8e:	f010 0001 	ands.w	r0, r0, #1
 8000f92:	7060      	strb	r0, [r4, #1]
 8000f94:	5de8      	ldrb	r0, [r5, r7]
 8000f96:	b2c0      	uxtb	r0, r0
 8000f98:	08c0      	lsrs	r0, r0, #3
 8000f9a:	f010 0001 	ands.w	r0, r0, #1
 8000f9e:	70a0      	strb	r0, [r4, #2]
 8000fa0:	5de8      	ldrb	r0, [r5, r7]
 8000fa2:	b2c0      	uxtb	r0, r0
 8000fa4:	0900      	lsrs	r0, r0, #4
 8000fa6:	f010 0001 	ands.w	r0, r0, #1
 8000faa:	70e0      	strb	r0, [r4, #3]
 8000fac:	1c7f      	adds	r7, r7, #1
 8000fae:	7860      	ldrb	r0, [r4, #1]
 8000fb0:	2800      	cmp	r0, #0
 8000fb2:	d00a      	beq.n	8000fca <??ZbZclParseHeader_2>
 8000fb4:	2e05      	cmp	r6, #5
 8000fb6:	d202      	bcs.n	8000fbe <??ZbZclParseHeader_3>
 8000fb8:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8000fbc:	e00c      	b.n	8000fd8 <??ZbZclParseHeader_1>

08000fbe <??ZbZclParseHeader_3>:
 8000fbe:	eb05 0007 	add.w	r0, r5, r7
 8000fc2:	f7ff f8eb 	bl	800019c <pletoh16>
 8000fc6:	80a0      	strh	r0, [r4, #4]
 8000fc8:	1cbf      	adds	r7, r7, #2

08000fca <??ZbZclParseHeader_2>:
 8000fca:	5de8      	ldrb	r0, [r5, r7]
 8000fcc:	71a0      	strb	r0, [r4, #6]
 8000fce:	1c7f      	adds	r7, r7, #1
 8000fd0:	5de8      	ldrb	r0, [r5, r7]
 8000fd2:	71e0      	strb	r0, [r4, #7]
 8000fd4:	1c7f      	adds	r7, r7, #1
 8000fd6:	0038      	movs	r0, r7

08000fd8 <??ZbZclParseHeader_1>:
 8000fd8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08000fdc <ZbZclPrependHeader>:
 8000fdc:	b470      	push	{r4, r5, r6}
 8000fde:	0003      	movs	r3, r0
 8000fe0:	2400      	movs	r4, #0
 8000fe2:	0015      	movs	r5, r2
 8000fe4:	2600      	movs	r6, #0
 8000fe6:	7858      	ldrb	r0, [r3, #1]
 8000fe8:	2800      	cmp	r0, #0
 8000fea:	d004      	beq.n	8000ff6 <??ZbZclPrependHeader_0>
 8000fec:	2a05      	cmp	r2, #5
 8000fee:	d202      	bcs.n	8000ff6 <??ZbZclPrependHeader_0>
 8000ff0:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8000ff4:	e030      	b.n	8001058 <??ZbZclPrependHeader_1>

08000ff6 <??ZbZclPrependHeader_0>:
 8000ff6:	2a03      	cmp	r2, #3
 8000ff8:	d202      	bcs.n	8001000 <??ZbZclPrependHeader_2>
 8000ffa:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8000ffe:	e02b      	b.n	8001058 <??ZbZclPrependHeader_1>

08001000 <??ZbZclPrependHeader_2>:
 8001000:	1e6d      	subs	r5, r5, #1
 8001002:	79d8      	ldrb	r0, [r3, #7]
 8001004:	5548      	strb	r0, [r1, r5]
 8001006:	1c76      	adds	r6, r6, #1
 8001008:	1e6d      	subs	r5, r5, #1
 800100a:	7998      	ldrb	r0, [r3, #6]
 800100c:	5548      	strb	r0, [r1, r5]
 800100e:	1c76      	adds	r6, r6, #1
 8001010:	7858      	ldrb	r0, [r3, #1]
 8001012:	2800      	cmp	r0, #0
 8001014:	d009      	beq.n	800102a <??ZbZclPrependHeader_3>
 8001016:	1e6d      	subs	r5, r5, #1
 8001018:	8898      	ldrh	r0, [r3, #4]
 800101a:	b280      	uxth	r0, r0
 800101c:	0a00      	lsrs	r0, r0, #8
 800101e:	5548      	strb	r0, [r1, r5]
 8001020:	1c76      	adds	r6, r6, #1
 8001022:	1e6d      	subs	r5, r5, #1
 8001024:	8898      	ldrh	r0, [r3, #4]
 8001026:	5548      	strb	r0, [r1, r5]
 8001028:	1c76      	adds	r6, r6, #1

0800102a <??ZbZclPrependHeader_3>:
 800102a:	7818      	ldrb	r0, [r3, #0]
 800102c:	f010 0003 	ands.w	r0, r0, #3
 8001030:	4304      	orrs	r4, r0
 8001032:	7858      	ldrb	r0, [r3, #1]
 8001034:	2800      	cmp	r0, #0
 8001036:	d001      	beq.n	800103c <??ZbZclPrependHeader_4>
 8001038:	f054 0404 	orrs.w	r4, r4, #4

0800103c <??ZbZclPrependHeader_4>:
 800103c:	7898      	ldrb	r0, [r3, #2]
 800103e:	2801      	cmp	r0, #1
 8001040:	d101      	bne.n	8001046 <??ZbZclPrependHeader_5>
 8001042:	f054 0408 	orrs.w	r4, r4, #8

08001046 <??ZbZclPrependHeader_5>:
 8001046:	78d8      	ldrb	r0, [r3, #3]
 8001048:	2801      	cmp	r0, #1
 800104a:	d101      	bne.n	8001050 <??ZbZclPrependHeader_6>
 800104c:	f054 0410 	orrs.w	r4, r4, #16

08001050 <??ZbZclPrependHeader_6>:
 8001050:	1e6d      	subs	r5, r5, #1
 8001052:	554c      	strb	r4, [r1, r5]
 8001054:	1c76      	adds	r6, r6, #1
 8001056:	0030      	movs	r0, r6

08001058 <??ZbZclPrependHeader_1>:
 8001058:	bc70      	pop	{r4, r5, r6}
 800105a:	4770      	bx	lr

0800105c <ZbZclAppendHeader>:
 800105c:	b430      	push	{r4, r5}
 800105e:	0003      	movs	r3, r0
 8001060:	2400      	movs	r4, #0
 8001062:	2500      	movs	r5, #0
 8001064:	7858      	ldrb	r0, [r3, #1]
 8001066:	2800      	cmp	r0, #0
 8001068:	d004      	beq.n	8001074 <??ZbZclAppendHeader_0>
 800106a:	2a05      	cmp	r2, #5
 800106c:	d202      	bcs.n	8001074 <??ZbZclAppendHeader_0>
 800106e:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8001072:	e02b      	b.n	80010cc <??ZbZclAppendHeader_1>

08001074 <??ZbZclAppendHeader_0>:
 8001074:	2a03      	cmp	r2, #3
 8001076:	d202      	bcs.n	800107e <??ZbZclAppendHeader_2>
 8001078:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 800107c:	e026      	b.n	80010cc <??ZbZclAppendHeader_1>

0800107e <??ZbZclAppendHeader_2>:
 800107e:	7818      	ldrb	r0, [r3, #0]
 8001080:	f010 0003 	ands.w	r0, r0, #3
 8001084:	4304      	orrs	r4, r0
 8001086:	7858      	ldrb	r0, [r3, #1]
 8001088:	2800      	cmp	r0, #0
 800108a:	d001      	beq.n	8001090 <??ZbZclAppendHeader_3>
 800108c:	f054 0404 	orrs.w	r4, r4, #4

08001090 <??ZbZclAppendHeader_3>:
 8001090:	7898      	ldrb	r0, [r3, #2]
 8001092:	2801      	cmp	r0, #1
 8001094:	d101      	bne.n	800109a <??ZbZclAppendHeader_4>
 8001096:	f054 0408 	orrs.w	r4, r4, #8

0800109a <??ZbZclAppendHeader_4>:
 800109a:	78d8      	ldrb	r0, [r3, #3]
 800109c:	2801      	cmp	r0, #1
 800109e:	d101      	bne.n	80010a4 <??ZbZclAppendHeader_5>
 80010a0:	f054 0410 	orrs.w	r4, r4, #16

080010a4 <??ZbZclAppendHeader_5>:
 80010a4:	554c      	strb	r4, [r1, r5]
 80010a6:	1c6d      	adds	r5, r5, #1
 80010a8:	7858      	ldrb	r0, [r3, #1]
 80010aa:	2800      	cmp	r0, #0
 80010ac:	d007      	beq.n	80010be <??ZbZclAppendHeader_6>
 80010ae:	8898      	ldrh	r0, [r3, #4]
 80010b0:	5548      	strb	r0, [r1, r5]
 80010b2:	1c6d      	adds	r5, r5, #1
 80010b4:	8898      	ldrh	r0, [r3, #4]
 80010b6:	b280      	uxth	r0, r0
 80010b8:	0a00      	lsrs	r0, r0, #8
 80010ba:	5548      	strb	r0, [r1, r5]
 80010bc:	1c6d      	adds	r5, r5, #1

080010be <??ZbZclAppendHeader_6>:
 80010be:	7998      	ldrb	r0, [r3, #6]
 80010c0:	5548      	strb	r0, [r1, r5]
 80010c2:	1c6d      	adds	r5, r5, #1
 80010c4:	79d8      	ldrb	r0, [r3, #7]
 80010c6:	5548      	strb	r0, [r1, r5]
 80010c8:	1c6d      	adds	r5, r5, #1
 80010ca:	0028      	movs	r0, r5

080010cc <??ZbZclAppendHeader_1>:
 80010cc:	bc30      	pop	{r4, r5}
 80010ce:	4770      	bx	lr

080010d0 <ZbZclTempMeasClientAlloc>:
 80010d0:	b57c      	push	{r2, r3, r4, r5, r6, lr}
 80010d2:	0005      	movs	r5, r0
 80010d4:	000e      	movs	r6, r1
 80010d6:	2001      	movs	r0, #1
 80010d8:	9000      	str	r0, [sp, #0]
 80010da:	0033      	movs	r3, r6
 80010dc:	b2db      	uxtb	r3, r3
 80010de:	f240 4202 	movw	r2, #1026	; 0x402
 80010e2:	216c      	movs	r1, #108	; 0x6c
 80010e4:	0028      	movs	r0, r5
 80010e6:	f003 fc40 	bl	800496a <ZbZclClusterAlloc>
 80010ea:	0004      	movs	r4, r0
 80010ec:	2c00      	cmp	r4, #0
 80010ee:	d101      	bne.n	80010f4 <??ZbZclTempMeasClientAlloc_0>
 80010f0:	2000      	movs	r0, #0
 80010f2:	e003      	b.n	80010fc <??ZbZclTempMeasClientAlloc_1>

080010f4 <??ZbZclTempMeasClientAlloc_0>:
 80010f4:	0020      	movs	r0, r4
 80010f6:	f003 fcc8 	bl	8004a8a <ZbZclClusterAttach>
 80010fa:	0020      	movs	r0, r4

080010fc <??ZbZclTempMeasClientAlloc_1>:
 80010fc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	...

08001100 <ZbZclAttrAddSorted>:
 8001100:	b430      	push	{r4, r5}
 8001102:	0002      	movs	r2, r0
 8001104:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001106:	f112 0424 	adds.w	r4, r2, #36	; 0x24
 800110a:	42a0      	cmp	r0, r4
 800110c:	d001      	beq.n	8001112 <??ZbZclAttrAddSorted_0>
 800110e:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001110:	e000      	b.n	8001114 <??ZbZclAttrAddSorted_1>

08001112 <??ZbZclAttrAddSorted_0>:
 8001112:	2000      	movs	r0, #0

08001114 <??ZbZclAttrAddSorted_1>:
 8001114:	2800      	cmp	r0, #0
 8001116:	d017      	beq.n	8001148 <??ZbZclAttrAddSorted_2>
 8001118:	0003      	movs	r3, r0
 800111a:	688c      	ldr	r4, [r1, #8]
 800111c:	8824      	ldrh	r4, [r4, #0]
 800111e:	689d      	ldr	r5, [r3, #8]
 8001120:	882d      	ldrh	r5, [r5, #0]
 8001122:	42ac      	cmp	r4, r5
 8001124:	d207      	bcs.n	8001136 <??ZbZclAttrAddSorted_3>
 8001126:	600b      	str	r3, [r1, #0]
 8001128:	685c      	ldr	r4, [r3, #4]
 800112a:	604c      	str	r4, [r1, #4]
 800112c:	680c      	ldr	r4, [r1, #0]
 800112e:	6061      	str	r1, [r4, #4]
 8001130:	684c      	ldr	r4, [r1, #4]
 8001132:	6021      	str	r1, [r4, #0]
 8001134:	e011      	b.n	800115a <??ZbZclAttrAddSorted_4>

08001136 <??ZbZclAttrAddSorted_3>:
 8001136:	6804      	ldr	r4, [r0, #0]
 8001138:	f112 0524 	adds.w	r5, r2, #36	; 0x24
 800113c:	42ac      	cmp	r4, r5
 800113e:	d001      	beq.n	8001144 <??ZbZclAttrAddSorted_5>
 8001140:	6800      	ldr	r0, [r0, #0]
 8001142:	e7e7      	b.n	8001114 <??ZbZclAttrAddSorted_1>

08001144 <??ZbZclAttrAddSorted_5>:
 8001144:	2000      	movs	r0, #0
 8001146:	e7e5      	b.n	8001114 <??ZbZclAttrAddSorted_1>

08001148 <??ZbZclAttrAddSorted_2>:
 8001148:	f112 0424 	adds.w	r4, r2, #36	; 0x24
 800114c:	600c      	str	r4, [r1, #0]
 800114e:	6a94      	ldr	r4, [r2, #40]	; 0x28
 8001150:	604c      	str	r4, [r1, #4]
 8001152:	680c      	ldr	r4, [r1, #0]
 8001154:	6061      	str	r1, [r4, #4]
 8001156:	684c      	ldr	r4, [r1, #4]
 8001158:	6021      	str	r1, [r4, #0]

0800115a <??ZbZclAttrAddSorted_4>:
 800115a:	bc30      	pop	{r4, r5}
 800115c:	4770      	bx	lr

0800115e <ZbZclAttrFind>:
 800115e:	b430      	push	{r4, r5}
 8001160:	0003      	movs	r3, r0
 8001162:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001164:	f113 0224 	adds.w	r2, r3, #36	; 0x24
 8001168:	4290      	cmp	r0, r2
 800116a:	d001      	beq.n	8001170 <??ZbZclAttrFind_0>
 800116c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800116e:	e000      	b.n	8001172 <??ZbZclAttrFind_1>

08001170 <??ZbZclAttrFind_0>:
 8001170:	2200      	movs	r2, #0

08001172 <??ZbZclAttrFind_1>:
 8001172:	2a00      	cmp	r2, #0
 8001174:	d012      	beq.n	800119c <??ZbZclAttrFind_2>
 8001176:	0014      	movs	r4, r2
 8001178:	68a0      	ldr	r0, [r4, #8]
 800117a:	8800      	ldrh	r0, [r0, #0]
 800117c:	000d      	movs	r5, r1
 800117e:	b2ad      	uxth	r5, r5
 8001180:	42a8      	cmp	r0, r5
 8001182:	d005      	beq.n	8001190 <??ZbZclAttrFind_3>
 8001184:	6810      	ldr	r0, [r2, #0]
 8001186:	f113 0524 	adds.w	r5, r3, #36	; 0x24
 800118a:	42a8      	cmp	r0, r5
 800118c:	d004      	beq.n	8001198 <??ZbZclAttrFind_4>
 800118e:	e001      	b.n	8001194 <??ZbZclAttrFind_5>

08001190 <??ZbZclAttrFind_3>:
 8001190:	0020      	movs	r0, r4
 8001192:	e004      	b.n	800119e <??ZbZclAttrFind_6>

08001194 <??ZbZclAttrFind_5>:
 8001194:	6812      	ldr	r2, [r2, #0]
 8001196:	e7ec      	b.n	8001172 <??ZbZclAttrFind_1>

08001198 <??ZbZclAttrFind_4>:
 8001198:	2200      	movs	r2, #0
 800119a:	e7ea      	b.n	8001172 <??ZbZclAttrFind_1>

0800119c <??ZbZclAttrFind_2>:
 800119c:	2000      	movs	r0, #0

0800119e <??ZbZclAttrFind_6>:
 800119e:	bc30      	pop	{r4, r5}
 80011a0:	4770      	bx	lr

080011a2 <ZbZclAttrHandleDiscover>:
 80011a2:	e92d 47f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80011a6:	b09f      	sub	sp, #124	; 0x7c
 80011a8:	0004      	movs	r4, r0
 80011aa:	000d      	movs	r5, r1
 80011ac:	0016      	movs	r6, r2
 80011ae:	2708      	movs	r7, #8
 80011b0:	f05f 0800 	movs.w	r8, #0
 80011b4:	f10d 0908 	add.w	r9, sp, #8
 80011b8:	4642      	mov	r2, r8
 80011ba:	0039      	movs	r1, r7
 80011bc:	4648      	mov	r0, r9
 80011be:	f004 fc52 	bl	8005a66 <__aeabi_memset>
 80011c2:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 80011c4:	2803      	cmp	r0, #3
 80011c6:	d206      	bcs.n	80011d6 <??ZbZclAttrHandleDiscover_0>
 80011c8:	2380      	movs	r3, #128	; 0x80
 80011ca:	002a      	movs	r2, r5
 80011cc:	0031      	movs	r1, r6
 80011ce:	0020      	movs	r0, r4
 80011d0:	f014 fecf 	bl	8015f72 <ZbZclSendDefaultResponse>
 80011d4:	e070      	b.n	80012b8 <??ZbZclAttrHandleDiscover_1>

080011d6 <??ZbZclAttrHandleDiscover_0>:
 80011d6:	f05f 0800 	movs.w	r8, #0
 80011da:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80011dc:	4641      	mov	r1, r8
 80011de:	b2c9      	uxtb	r1, r1
 80011e0:	4408      	add	r0, r1
 80011e2:	f7fe ffdb 	bl	800019c <pletoh16>
 80011e6:	0007      	movs	r7, r0
 80011e8:	f118 0802 	adds.w	r8, r8, #2
 80011ec:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80011ee:	4641      	mov	r1, r8
 80011f0:	b2c9      	uxtb	r1, r1
 80011f2:	5c40      	ldrb	r0, [r0, r1]
 80011f4:	f88d 0004 	strb.w	r0, [sp, #4]
 80011f8:	f118 0801 	adds.w	r8, r8, #1
 80011fc:	2000      	movs	r0, #0
 80011fe:	f88d 0008 	strb.w	r0, [sp, #8]
 8001202:	7868      	ldrb	r0, [r5, #1]
 8001204:	f88d 0009 	strb.w	r0, [sp, #9]
 8001208:	78a8      	ldrb	r0, [r5, #2]
 800120a:	2800      	cmp	r0, #0
 800120c:	d101      	bne.n	8001212 <??ZbZclAttrHandleDiscover_2>
 800120e:	2001      	movs	r0, #1
 8001210:	e000      	b.n	8001214 <??ZbZclAttrHandleDiscover_3>

08001212 <??ZbZclAttrHandleDiscover_2>:
 8001212:	2000      	movs	r0, #0

08001214 <??ZbZclAttrHandleDiscover_3>:
 8001214:	f88d 000a 	strb.w	r0, [sp, #10]
 8001218:	2001      	movs	r0, #1
 800121a:	f88d 000b 	strb.w	r0, [sp, #11]
 800121e:	88a8      	ldrh	r0, [r5, #4]
 8001220:	f8ad 000c 	strh.w	r0, [sp, #12]
 8001224:	79a8      	ldrb	r0, [r5, #6]
 8001226:	f88d 000e 	strb.w	r0, [sp, #14]
 800122a:	200d      	movs	r0, #13
 800122c:	f88d 000f 	strb.w	r0, [sp, #15]
 8001230:	2239      	movs	r2, #57	; 0x39
 8001232:	a910      	add	r1, sp, #64	; 0x40
 8001234:	a802      	add	r0, sp, #8
 8001236:	f7ff ff11 	bl	800105c <ZbZclAppendHeader>
 800123a:	4682      	mov	sl, r0
 800123c:	f1ba 0f00 	cmp.w	sl, #0
 8001240:	d506      	bpl.n	8001250 <??ZbZclAttrHandleDiscover_4>
 8001242:	2380      	movs	r3, #128	; 0x80
 8001244:	002a      	movs	r2, r5
 8001246:	0031      	movs	r1, r6
 8001248:	0020      	movs	r0, r4
 800124a:	f014 fe92 	bl	8015f72 <ZbZclSendDefaultResponse>
 800124e:	e033      	b.n	80012b8 <??ZbZclAttrHandleDiscover_1>

08001250 <??ZbZclAttrHandleDiscover_4>:
 8001250:	f1da 0039 	rsbs	r0, sl, #57	; 0x39
 8001254:	9000      	str	r0, [sp, #0]
 8001256:	a810      	add	r0, sp, #64	; 0x40
 8001258:	eb00 030a 	add.w	r3, r0, sl
 800125c:	aa01      	add	r2, sp, #4
 800125e:	0039      	movs	r1, r7
 8001260:	b289      	uxth	r1, r1
 8001262:	0020      	movs	r0, r4
 8001264:	f000 f82b 	bl	80012be <ZbZclAttrDiscoverGetList>
 8001268:	4681      	mov	r9, r0
 800126a:	eb19 090a 	adds.w	r9, r9, sl
 800126e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8001272:	2800      	cmp	r0, #0
 8001274:	d104      	bne.n	8001280 <??ZbZclAttrHandleDiscover_5>
 8001276:	0030      	movs	r0, r6
 8001278:	f014 fa38 	bl	80156ec <ZbApsAddrIsBcast>
 800127c:	2800      	cmp	r0, #0
 800127e:	d11b      	bne.n	80012b8 <??ZbZclAttrHandleDiscover_1>

08001280 <??ZbZclAttrHandleDiscover_5>:
 8001280:	0032      	movs	r2, r6
 8001282:	a904      	add	r1, sp, #16
 8001284:	0020      	movs	r0, r4
 8001286:	f7ff f988 	bl	800059a <ZbZclClusterInitApsdeReq>
 800128a:	a804      	add	r0, sp, #16
 800128c:	f116 0110 	adds.w	r1, r6, #16
 8001290:	2210      	movs	r2, #16
 8001292:	f017 f97e 	bl	8018592 <__aeabi_memcpy>
 8001296:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
 800129a:	f7ff f916 	bl	80004ca <ZbZclTxOptsFromSecurityStatus>
 800129e:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
 80012a2:	a810      	add	r0, sp, #64	; 0x40
 80012a4:	900a      	str	r0, [sp, #40]	; 0x28
 80012a6:	4648      	mov	r0, r9
 80012a8:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
 80012ac:	2300      	movs	r3, #0
 80012ae:	2200      	movs	r2, #0
 80012b0:	a904      	add	r1, sp, #16
 80012b2:	68a0      	ldr	r0, [r4, #8]
 80012b4:	f014 f9a0 	bl	80155f8 <ZbApsdeDataReqCallback>

080012b8 <??ZbZclAttrHandleDiscover_1>:
 80012b8:	b020      	add	sp, #128	; 0x80
 80012ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080012be <ZbZclAttrDiscoverGetList>:
 80012be:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80012c2:	0005      	movs	r5, r0
 80012c4:	0016      	movs	r6, r2
 80012c6:	001f      	movs	r7, r3
 80012c8:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 80012cc:	f05f 0a00 	movs.w	sl, #0
 80012d0:	f05f 0b00 	movs.w	fp, #0
 80012d4:	2000      	movs	r0, #0
 80012d6:	f807 000b 	strb.w	r0, [r7, fp]
 80012da:	f11b 0b01 	adds.w	fp, fp, #1
 80012de:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80012e0:	f115 0124 	adds.w	r1, r5, #36	; 0x24
 80012e4:	4288      	cmp	r0, r1
 80012e6:	d001      	beq.n	80012ec <??ZbZclAttrDiscoverGetList_0>
 80012e8:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80012ea:	e000      	b.n	80012ee <??ZbZclAttrDiscoverGetList_1>

080012ec <??ZbZclAttrDiscoverGetList_0>:
 80012ec:	2400      	movs	r4, #0

080012ee <??ZbZclAttrDiscoverGetList_1>:
 80012ee:	2c00      	cmp	r4, #0
 80012f0:	d030      	beq.n	8001354 <??ZbZclAttrDiscoverGetList_2>
 80012f2:	46a1      	mov	r9, r4
 80012f4:	f8d9 0008 	ldr.w	r0, [r9, #8]
 80012f8:	8800      	ldrh	r0, [r0, #0]
 80012fa:	f8bd 1000 	ldrh.w	r1, [sp]
 80012fe:	4288      	cmp	r0, r1
 8001300:	d31f      	bcc.n	8001342 <??ZbZclAttrDiscoverGetList_3>

08001302 <??ZbZclAttrDiscoverGetList_4>:
 8001302:	f8d9 0008 	ldr.w	r0, [r9, #8]
 8001306:	8880      	ldrh	r0, [r0, #4]
 8001308:	0400      	lsls	r0, r0, #16
 800130a:	d41a      	bmi.n	8001342 <??ZbZclAttrDiscoverGetList_3>

0800130c <??ZbZclAttrDiscoverGetList_5>:
 800130c:	4650      	mov	r0, sl
 800130e:	7831      	ldrb	r1, [r6, #0]
 8001310:	b2c0      	uxtb	r0, r0
 8001312:	4288      	cmp	r0, r1
 8001314:	d21e      	bcs.n	8001354 <??ZbZclAttrDiscoverGetList_2>

08001316 <??ZbZclAttrDiscoverGetList_6>:
 8001316:	f11b 0003 	adds.w	r0, fp, #3
 800131a:	4580      	cmp	r8, r0
 800131c:	d31a      	bcc.n	8001354 <??ZbZclAttrDiscoverGetList_2>

0800131e <??ZbZclAttrDiscoverGetList_7>:
 800131e:	f8d9 0008 	ldr.w	r0, [r9, #8]
 8001322:	8801      	ldrh	r1, [r0, #0]
 8001324:	eb07 000b 	add.w	r0, r7, fp
 8001328:	f7fe ff84 	bl	8000234 <putle16>
 800132c:	f11b 0b02 	adds.w	fp, fp, #2
 8001330:	f8d9 0008 	ldr.w	r0, [r9, #8]
 8001334:	7880      	ldrb	r0, [r0, #2]
 8001336:	f807 000b 	strb.w	r0, [r7, fp]
 800133a:	f11b 0b01 	adds.w	fp, fp, #1
 800133e:	f11a 0a01 	adds.w	sl, sl, #1

08001342 <??ZbZclAttrDiscoverGetList_3>:
 8001342:	6820      	ldr	r0, [r4, #0]
 8001344:	f115 0124 	adds.w	r1, r5, #36	; 0x24
 8001348:	4288      	cmp	r0, r1
 800134a:	d001      	beq.n	8001350 <??ZbZclAttrDiscoverGetList_8>
 800134c:	6824      	ldr	r4, [r4, #0]
 800134e:	e7ce      	b.n	80012ee <??ZbZclAttrDiscoverGetList_1>

08001350 <??ZbZclAttrDiscoverGetList_8>:
 8001350:	2400      	movs	r4, #0
 8001352:	e7cc      	b.n	80012ee <??ZbZclAttrDiscoverGetList_1>

08001354 <??ZbZclAttrDiscoverGetList_2>:
 8001354:	2c00      	cmp	r4, #0
 8001356:	d101      	bne.n	800135c <??ZbZclAttrDiscoverGetList_9>
 8001358:	2001      	movs	r0, #1
 800135a:	7038      	strb	r0, [r7, #0]

0800135c <??ZbZclAttrDiscoverGetList_9>:
 800135c:	f886 a000 	strb.w	sl, [r6]
 8001360:	4658      	mov	r0, fp
 8001362:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001366 <ZbZclAttrRead>:
 8001366:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800136a:	b088      	sub	sp, #32
 800136c:	4680      	mov	r8, r0
 800136e:	0014      	movs	r4, r2
 8001370:	001d      	movs	r5, r3
 8001372:	9e12      	ldr	r6, [sp, #72]	; 0x48
 8001374:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 8001378:	4640      	mov	r0, r8
 800137a:	f7ff fef0 	bl	800115e <ZbZclAttrFind>
 800137e:	0007      	movs	r7, r0
 8001380:	2f00      	cmp	r7, #0
 8001382:	d101      	bne.n	8001388 <??ZbZclAttrRead_0>
 8001384:	2086      	movs	r0, #134	; 0x86
 8001386:	e03c      	b.n	8001402 <??ZbZclAttrRead_1>

08001388 <??ZbZclAttrRead_0>:
 8001388:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
 800138c:	2800      	cmp	r0, #0
 800138e:	d005      	beq.n	800139c <??ZbZclAttrRead_2>
 8001390:	68b8      	ldr	r0, [r7, #8]
 8001392:	7900      	ldrb	r0, [r0, #4]
 8001394:	0780      	lsls	r0, r0, #30
 8001396:	d401      	bmi.n	800139c <??ZbZclAttrRead_2>
 8001398:	208c      	movs	r0, #140	; 0x8c
 800139a:	e032      	b.n	8001402 <??ZbZclAttrRead_1>

0800139c <??ZbZclAttrRead_2>:
 800139c:	2c00      	cmp	r4, #0
 800139e:	d002      	beq.n	80013a6 <??ZbZclAttrRead_3>
 80013a0:	68b8      	ldr	r0, [r7, #8]
 80013a2:	7880      	ldrb	r0, [r0, #2]
 80013a4:	7020      	strb	r0, [r4, #0]

080013a6 <??ZbZclAttrRead_3>:
 80013a6:	2d00      	cmp	r5, #0
 80013a8:	d001      	beq.n	80013ae <??ZbZclAttrRead_4>
 80013aa:	2e00      	cmp	r6, #0
 80013ac:	d105      	bne.n	80013ba <??ZbZclAttrRead_5>

080013ae <??ZbZclAttrRead_4>:
 80013ae:	2c00      	cmp	r4, #0
 80013b0:	d001      	beq.n	80013b6 <??ZbZclAttrRead_6>
 80013b2:	2000      	movs	r0, #0
 80013b4:	e025      	b.n	8001402 <??ZbZclAttrRead_1>

080013b6 <??ZbZclAttrRead_6>:
 80013b6:	2089      	movs	r0, #137	; 0x89
 80013b8:	e023      	b.n	8001402 <??ZbZclAttrRead_1>

080013ba <??ZbZclAttrRead_5>:
 80013ba:	68b8      	ldr	r0, [r7, #8]
 80013bc:	7900      	ldrb	r0, [r0, #4]
 80013be:	06c0      	lsls	r0, r0, #27
 80013c0:	d519      	bpl.n	80013f6 <??ZbZclAttrRead_7>
 80013c2:	f05f 0920 	movs.w	r9, #32
 80013c6:	f05f 0a00 	movs.w	sl, #0
 80013ca:	46eb      	mov	fp, sp
 80013cc:	4652      	mov	r2, sl
 80013ce:	4649      	mov	r1, r9
 80013d0:	4658      	mov	r0, fp
 80013d2:	f004 fb48 	bl	8005a66 <__aeabi_memset>
 80013d6:	68b8      	ldr	r0, [r7, #8]
 80013d8:	9000      	str	r0, [sp, #0]
 80013da:	2000      	movs	r0, #0
 80013dc:	f88d 0004 	strb.w	r0, [sp, #4]
 80013e0:	9502      	str	r5, [sp, #8]
 80013e2:	9603      	str	r6, [sp, #12]
 80013e4:	f8d8 0054 	ldr.w	r0, [r8, #84]	; 0x54
 80013e8:	9007      	str	r0, [sp, #28]
 80013ea:	466a      	mov	r2, sp
 80013ec:	0039      	movs	r1, r7
 80013ee:	4640      	mov	r0, r8
 80013f0:	f001 fce6 	bl	8002dc0 <ZbZclAttrCallbackExec>
 80013f4:	e005      	b.n	8001402 <??ZbZclAttrRead_1>

080013f6 <??ZbZclAttrRead_7>:
 80013f6:	0033      	movs	r3, r6
 80013f8:	002a      	movs	r2, r5
 80013fa:	0039      	movs	r1, r7
 80013fc:	4640      	mov	r0, r8
 80013fe:	f000 f803 	bl	8001408 <ZbZclAttrDefaultRead>

08001402 <??ZbZclAttrRead_1>:
 8001402:	b009      	add	sp, #36	; 0x24
 8001404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001408 <ZbZclAttrDefaultRead>:
 8001408:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800140c:	0005      	movs	r5, r0
 800140e:	000e      	movs	r6, r1
 8001410:	0017      	movs	r7, r2
 8001412:	001c      	movs	r4, r3
 8001414:	f05f 0800 	movs.w	r8, #0
 8001418:	f05f 0900 	movs.w	r9, #0
 800141c:	68b0      	ldr	r0, [r6, #8]
 800141e:	7880      	ldrb	r0, [r0, #2]
 8001420:	2808      	cmp	r0, #8
 8001422:	d065      	beq.n	80014f0 <??ZbZclAttrDefaultRead_0>
 8001424:	2809      	cmp	r0, #9
 8001426:	d06b      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 8001428:	280a      	cmp	r0, #10
 800142a:	d071      	beq.n	8001510 <??ZbZclAttrDefaultRead_2>
 800142c:	280b      	cmp	r0, #11
 800142e:	d077      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 8001430:	280c      	cmp	r0, #12
 8001432:	d07d      	beq.n	8001530 <??ZbZclAttrDefaultRead_4>
 8001434:	280d      	cmp	r0, #13
 8001436:	f000 8083 	beq.w	8001540 <??ZbZclAttrDefaultRead_5>
 800143a:	280e      	cmp	r0, #14
 800143c:	f000 8088 	beq.w	8001550 <??ZbZclAttrDefaultRead_6>
 8001440:	280f      	cmp	r0, #15
 8001442:	f000 808d 	beq.w	8001560 <??ZbZclAttrDefaultRead_7>
 8001446:	2810      	cmp	r0, #16
 8001448:	d052      	beq.n	80014f0 <??ZbZclAttrDefaultRead_0>
 800144a:	2818      	cmp	r0, #24
 800144c:	d050      	beq.n	80014f0 <??ZbZclAttrDefaultRead_0>
 800144e:	2819      	cmp	r0, #25
 8001450:	d056      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 8001452:	281a      	cmp	r0, #26
 8001454:	d05c      	beq.n	8001510 <??ZbZclAttrDefaultRead_2>
 8001456:	281b      	cmp	r0, #27
 8001458:	d062      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 800145a:	281c      	cmp	r0, #28
 800145c:	d068      	beq.n	8001530 <??ZbZclAttrDefaultRead_4>
 800145e:	281d      	cmp	r0, #29
 8001460:	d06e      	beq.n	8001540 <??ZbZclAttrDefaultRead_5>
 8001462:	281e      	cmp	r0, #30
 8001464:	d074      	beq.n	8001550 <??ZbZclAttrDefaultRead_6>
 8001466:	281f      	cmp	r0, #31
 8001468:	d07a      	beq.n	8001560 <??ZbZclAttrDefaultRead_7>
 800146a:	2820      	cmp	r0, #32
 800146c:	d040      	beq.n	80014f0 <??ZbZclAttrDefaultRead_0>
 800146e:	2821      	cmp	r0, #33	; 0x21
 8001470:	d046      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 8001472:	2822      	cmp	r0, #34	; 0x22
 8001474:	d04c      	beq.n	8001510 <??ZbZclAttrDefaultRead_2>
 8001476:	2823      	cmp	r0, #35	; 0x23
 8001478:	d052      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 800147a:	2824      	cmp	r0, #36	; 0x24
 800147c:	d058      	beq.n	8001530 <??ZbZclAttrDefaultRead_4>
 800147e:	2825      	cmp	r0, #37	; 0x25
 8001480:	d05e      	beq.n	8001540 <??ZbZclAttrDefaultRead_5>
 8001482:	2826      	cmp	r0, #38	; 0x26
 8001484:	d064      	beq.n	8001550 <??ZbZclAttrDefaultRead_6>
 8001486:	2827      	cmp	r0, #39	; 0x27
 8001488:	d06a      	beq.n	8001560 <??ZbZclAttrDefaultRead_7>
 800148a:	2828      	cmp	r0, #40	; 0x28
 800148c:	d030      	beq.n	80014f0 <??ZbZclAttrDefaultRead_0>
 800148e:	2829      	cmp	r0, #41	; 0x29
 8001490:	d036      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 8001492:	282a      	cmp	r0, #42	; 0x2a
 8001494:	d03c      	beq.n	8001510 <??ZbZclAttrDefaultRead_2>
 8001496:	282b      	cmp	r0, #43	; 0x2b
 8001498:	d042      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 800149a:	282c      	cmp	r0, #44	; 0x2c
 800149c:	d048      	beq.n	8001530 <??ZbZclAttrDefaultRead_4>
 800149e:	282d      	cmp	r0, #45	; 0x2d
 80014a0:	d04e      	beq.n	8001540 <??ZbZclAttrDefaultRead_5>
 80014a2:	282e      	cmp	r0, #46	; 0x2e
 80014a4:	d054      	beq.n	8001550 <??ZbZclAttrDefaultRead_6>
 80014a6:	282f      	cmp	r0, #47	; 0x2f
 80014a8:	d05a      	beq.n	8001560 <??ZbZclAttrDefaultRead_7>
 80014aa:	2830      	cmp	r0, #48	; 0x30
 80014ac:	d020      	beq.n	80014f0 <??ZbZclAttrDefaultRead_0>
 80014ae:	2831      	cmp	r0, #49	; 0x31
 80014b0:	d026      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 80014b2:	2838      	cmp	r0, #56	; 0x38
 80014b4:	d024      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 80014b6:	2839      	cmp	r0, #57	; 0x39
 80014b8:	d032      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 80014ba:	283a      	cmp	r0, #58	; 0x3a
 80014bc:	d050      	beq.n	8001560 <??ZbZclAttrDefaultRead_7>
 80014be:	2841      	cmp	r0, #65	; 0x41
 80014c0:	d05e      	beq.n	8001580 <??ZbZclAttrDefaultRead_8>
 80014c2:	2842      	cmp	r0, #66	; 0x42
 80014c4:	d05c      	beq.n	8001580 <??ZbZclAttrDefaultRead_8>
 80014c6:	2843      	cmp	r0, #67	; 0x43
 80014c8:	d071      	beq.n	80015ae <??ZbZclAttrDefaultRead_9>
 80014ca:	2844      	cmp	r0, #68	; 0x44
 80014cc:	d06f      	beq.n	80015ae <??ZbZclAttrDefaultRead_9>
 80014ce:	28e0      	cmp	r0, #224	; 0xe0
 80014d0:	d026      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 80014d2:	28e1      	cmp	r0, #225	; 0xe1
 80014d4:	d024      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 80014d6:	28e2      	cmp	r0, #226	; 0xe2
 80014d8:	d022      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 80014da:	28e8      	cmp	r0, #232	; 0xe8
 80014dc:	d010      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 80014de:	28e9      	cmp	r0, #233	; 0xe9
 80014e0:	d00e      	beq.n	8001500 <??ZbZclAttrDefaultRead_1>
 80014e2:	28ea      	cmp	r0, #234	; 0xea
 80014e4:	d01c      	beq.n	8001520 <??ZbZclAttrDefaultRead_3>
 80014e6:	28f0      	cmp	r0, #240	; 0xf0
 80014e8:	d03a      	beq.n	8001560 <??ZbZclAttrDefaultRead_7>
 80014ea:	28f1      	cmp	r0, #241	; 0xf1
 80014ec:	d040      	beq.n	8001570 <??ZbZclAttrDefaultRead_10>
 80014ee:	e078      	b.n	80015e2 <??ZbZclAttrDefaultRead_11>

080014f0 <??ZbZclAttrDefaultRead_0>:
 80014f0:	2c00      	cmp	r4, #0
 80014f2:	d102      	bne.n	80014fa <??ZbZclAttrDefaultRead_12>
 80014f4:	2089      	movs	r0, #137	; 0x89
 80014f6:	4681      	mov	r9, r0
 80014f8:	e075      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

080014fa <??ZbZclAttrDefaultRead_12>:
 80014fa:	2001      	movs	r0, #1
 80014fc:	4680      	mov	r8, r0
 80014fe:	e072      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001500 <??ZbZclAttrDefaultRead_1>:
 8001500:	2c02      	cmp	r4, #2
 8001502:	d202      	bcs.n	800150a <??ZbZclAttrDefaultRead_14>
 8001504:	2089      	movs	r0, #137	; 0x89
 8001506:	4681      	mov	r9, r0
 8001508:	e06d      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800150a <??ZbZclAttrDefaultRead_14>:
 800150a:	2002      	movs	r0, #2
 800150c:	4680      	mov	r8, r0
 800150e:	e06a      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001510 <??ZbZclAttrDefaultRead_2>:
 8001510:	2c03      	cmp	r4, #3
 8001512:	d202      	bcs.n	800151a <??ZbZclAttrDefaultRead_15>
 8001514:	2089      	movs	r0, #137	; 0x89
 8001516:	4681      	mov	r9, r0
 8001518:	e065      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800151a <??ZbZclAttrDefaultRead_15>:
 800151a:	2003      	movs	r0, #3
 800151c:	4680      	mov	r8, r0
 800151e:	e062      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001520 <??ZbZclAttrDefaultRead_3>:
 8001520:	2c04      	cmp	r4, #4
 8001522:	d202      	bcs.n	800152a <??ZbZclAttrDefaultRead_16>
 8001524:	2089      	movs	r0, #137	; 0x89
 8001526:	4681      	mov	r9, r0
 8001528:	e05d      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800152a <??ZbZclAttrDefaultRead_16>:
 800152a:	2004      	movs	r0, #4
 800152c:	4680      	mov	r8, r0
 800152e:	e05a      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001530 <??ZbZclAttrDefaultRead_4>:
 8001530:	2c05      	cmp	r4, #5
 8001532:	d202      	bcs.n	800153a <??ZbZclAttrDefaultRead_17>
 8001534:	2089      	movs	r0, #137	; 0x89
 8001536:	4681      	mov	r9, r0
 8001538:	e055      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800153a <??ZbZclAttrDefaultRead_17>:
 800153a:	2005      	movs	r0, #5
 800153c:	4680      	mov	r8, r0
 800153e:	e052      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001540 <??ZbZclAttrDefaultRead_5>:
 8001540:	2c06      	cmp	r4, #6
 8001542:	d202      	bcs.n	800154a <??ZbZclAttrDefaultRead_18>
 8001544:	2089      	movs	r0, #137	; 0x89
 8001546:	4681      	mov	r9, r0
 8001548:	e04d      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800154a <??ZbZclAttrDefaultRead_18>:
 800154a:	2006      	movs	r0, #6
 800154c:	4680      	mov	r8, r0
 800154e:	e04a      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001550 <??ZbZclAttrDefaultRead_6>:
 8001550:	2c07      	cmp	r4, #7
 8001552:	d202      	bcs.n	800155a <??ZbZclAttrDefaultRead_19>
 8001554:	2089      	movs	r0, #137	; 0x89
 8001556:	4681      	mov	r9, r0
 8001558:	e045      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800155a <??ZbZclAttrDefaultRead_19>:
 800155a:	2007      	movs	r0, #7
 800155c:	4680      	mov	r8, r0
 800155e:	e042      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001560 <??ZbZclAttrDefaultRead_7>:
 8001560:	2c08      	cmp	r4, #8
 8001562:	d202      	bcs.n	800156a <??ZbZclAttrDefaultRead_20>
 8001564:	2089      	movs	r0, #137	; 0x89
 8001566:	4681      	mov	r9, r0
 8001568:	e03d      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800156a <??ZbZclAttrDefaultRead_20>:
 800156a:	2008      	movs	r0, #8
 800156c:	4680      	mov	r8, r0
 800156e:	e03a      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001570 <??ZbZclAttrDefaultRead_10>:
 8001570:	2c10      	cmp	r4, #16
 8001572:	d202      	bcs.n	800157a <??ZbZclAttrDefaultRead_21>
 8001574:	2089      	movs	r0, #137	; 0x89
 8001576:	4681      	mov	r9, r0
 8001578:	e035      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800157a <??ZbZclAttrDefaultRead_21>:
 800157a:	2010      	movs	r0, #16
 800157c:	4680      	mov	r8, r0
 800157e:	e032      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

08001580 <??ZbZclAttrDefaultRead_8>:
 8001580:	2c00      	cmp	r4, #0
 8001582:	d102      	bne.n	800158a <??ZbZclAttrDefaultRead_22>
 8001584:	2089      	movs	r0, #137	; 0x89
 8001586:	4681      	mov	r9, r0
 8001588:	e02d      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

0800158a <??ZbZclAttrDefaultRead_22>:
 800158a:	68f0      	ldr	r0, [r6, #12]
 800158c:	7800      	ldrb	r0, [r0, #0]
 800158e:	0001      	movs	r1, r0
 8001590:	b2c9      	uxtb	r1, r1
 8001592:	29ff      	cmp	r1, #255	; 0xff
 8001594:	d101      	bne.n	800159a <??ZbZclAttrDefaultRead_23>
 8001596:	2100      	movs	r1, #0
 8001598:	0008      	movs	r0, r1

0800159a <??ZbZclAttrDefaultRead_23>:
 800159a:	0001      	movs	r1, r0
 800159c:	b2c9      	uxtb	r1, r1
 800159e:	1c49      	adds	r1, r1, #1
 80015a0:	4688      	mov	r8, r1
 80015a2:	4544      	cmp	r4, r8
 80015a4:	d202      	bcs.n	80015ac <??ZbZclAttrDefaultRead_24>
 80015a6:	2189      	movs	r1, #137	; 0x89
 80015a8:	4689      	mov	r9, r1
 80015aa:	e01c      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

080015ac <??ZbZclAttrDefaultRead_24>:
 80015ac:	e01b      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

080015ae <??ZbZclAttrDefaultRead_9>:
 80015ae:	2c00      	cmp	r4, #0
 80015b0:	d102      	bne.n	80015b8 <??ZbZclAttrDefaultRead_25>
 80015b2:	2089      	movs	r0, #137	; 0x89
 80015b4:	4681      	mov	r9, r0
 80015b6:	e016      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

080015b8 <??ZbZclAttrDefaultRead_25>:
 80015b8:	68f0      	ldr	r0, [r6, #12]
 80015ba:	f7fe fdef 	bl	800019c <pletoh16>
 80015be:	0001      	movs	r1, r0
 80015c0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80015c4:	b289      	uxth	r1, r1
 80015c6:	4291      	cmp	r1, r2
 80015c8:	d101      	bne.n	80015ce <??ZbZclAttrDefaultRead_26>
 80015ca:	2100      	movs	r1, #0
 80015cc:	0008      	movs	r0, r1

080015ce <??ZbZclAttrDefaultRead_26>:
 80015ce:	0001      	movs	r1, r0
 80015d0:	b289      	uxth	r1, r1
 80015d2:	1c89      	adds	r1, r1, #2
 80015d4:	4688      	mov	r8, r1
 80015d6:	4544      	cmp	r4, r8
 80015d8:	d202      	bcs.n	80015e0 <??ZbZclAttrDefaultRead_27>
 80015da:	2189      	movs	r1, #137	; 0x89
 80015dc:	4689      	mov	r9, r1
 80015de:	e002      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

080015e0 <??ZbZclAttrDefaultRead_27>:
 80015e0:	e001      	b.n	80015e6 <??ZbZclAttrDefaultRead_13>

080015e2 <??ZbZclAttrDefaultRead_11>:
 80015e2:	2086      	movs	r0, #134	; 0x86
 80015e4:	4681      	mov	r9, r0

080015e6 <??ZbZclAttrDefaultRead_13>:
 80015e6:	4648      	mov	r0, r9
 80015e8:	b2c0      	uxtb	r0, r0
 80015ea:	2800      	cmp	r0, #0
 80015ec:	d109      	bne.n	8001602 <??ZbZclAttrDefaultRead_28>
 80015ee:	f8cd 8000 	str.w	r8, [sp]
 80015f2:	f8d6 a00c 	ldr.w	sl, [r6, #12]
 80015f6:	46bb      	mov	fp, r7
 80015f8:	9a00      	ldr	r2, [sp, #0]
 80015fa:	4651      	mov	r1, sl
 80015fc:	4658      	mov	r0, fp
 80015fe:	f016 ffc8 	bl	8018592 <__aeabi_memcpy>

08001602 <??ZbZclAttrDefaultRead_28>:
 8001602:	4648      	mov	r0, r9
 8001604:	b2c0      	uxtb	r0, r0
 8001606:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800160a <ZbZclAttrWrite>:
 800160a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800160e:	b096      	sub	sp, #88	; 0x58
 8001610:	4680      	mov	r8, r0
 8001612:	4699      	mov	r9, r3
 8001614:	f8dd a088 	ldr.w	sl, [sp, #136]	; 0x88
 8001618:	9f23      	ldr	r7, [sp, #140]	; 0x8c
 800161a:	f8bd 1060 	ldrh.w	r1, [sp, #96]	; 0x60
 800161e:	4640      	mov	r0, r8
 8001620:	f7ff fd9d 	bl	800115e <ZbZclAttrFind>
 8001624:	0006      	movs	r6, r0
 8001626:	2e00      	cmp	r6, #0
 8001628:	d101      	bne.n	800162e <??ZbZclAttrWrite_0>
 800162a:	2086      	movs	r0, #134	; 0x86
 800162c:	e0a2      	b.n	8001774 <??ZbZclAttrWrite_1>

0800162e <??ZbZclAttrWrite_0>:
 800162e:	68b0      	ldr	r0, [r6, #8]
 8001630:	7900      	ldrb	r0, [r0, #4]
 8001632:	f010 0001 	ands.w	r0, r0, #1
 8001636:	b2c0      	uxtb	r0, r0
 8001638:	2800      	cmp	r0, #0
 800163a:	d105      	bne.n	8001648 <??ZbZclAttrWrite_2>
 800163c:	0038      	movs	r0, r7
 800163e:	b280      	uxth	r0, r0
 8001640:	0780      	lsls	r0, r0, #30
 8001642:	d401      	bmi.n	8001648 <??ZbZclAttrWrite_2>
 8001644:	2088      	movs	r0, #136	; 0x88
 8001646:	e095      	b.n	8001774 <??ZbZclAttrWrite_1>

08001648 <??ZbZclAttrWrite_2>:
 8001648:	2300      	movs	r3, #0
 800164a:	4652      	mov	r2, sl
 800164c:	4649      	mov	r1, r9
 800164e:	68b0      	ldr	r0, [r6, #8]
 8001650:	7880      	ldrb	r0, [r0, #2]
 8001652:	f000 fcb0 	bl	8001fb6 <ZbZclAttrParseLength>
 8001656:	9005      	str	r0, [sp, #20]
 8001658:	9805      	ldr	r0, [sp, #20]
 800165a:	2800      	cmp	r0, #0
 800165c:	d501      	bpl.n	8001662 <??ZbZclAttrWrite_3>
 800165e:	2087      	movs	r0, #135	; 0x87
 8001660:	e088      	b.n	8001774 <??ZbZclAttrWrite_1>

08001662 <??ZbZclAttrWrite_3>:
 8001662:	68b0      	ldr	r0, [r6, #8]
 8001664:	7880      	ldrb	r0, [r0, #2]
 8001666:	f000 ff83 	bl	8002570 <ZbZclAttrIsInteger>
 800166a:	2800      	cmp	r0, #0
 800166c:	d026      	beq.n	80016bc <??ZbZclAttrWrite_4>
 800166e:	aa04      	add	r2, sp, #16
 8001670:	4649      	mov	r1, r9
 8001672:	68b0      	ldr	r0, [r6, #8]
 8001674:	7880      	ldrb	r0, [r0, #2]
 8001676:	f000 fe4d 	bl	8002314 <ZbZclParseInteger>
 800167a:	0004      	movs	r4, r0
 800167c:	000d      	movs	r5, r1
 800167e:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8001682:	2800      	cmp	r0, #0
 8001684:	d002      	beq.n	800168c <??ZbZclAttrWrite_5>
 8001686:	f89d 0010 	ldrb.w	r0, [sp, #16]
 800168a:	e073      	b.n	8001774 <??ZbZclAttrWrite_1>

0800168c <??ZbZclAttrWrite_5>:
 800168c:	68b0      	ldr	r0, [r6, #8]
 800168e:	e9d0 0106 	ldrd	r0, r1, [r0, #24]
 8001692:	f004 ff2f 	bl	80064f4 <__aeabi_d2lz>
 8001696:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800169a:	68b0      	ldr	r0, [r6, #8]
 800169c:	e9d0 0104 	ldrd	r0, r1, [r0, #16]
 80016a0:	f004 ff28 	bl	80064f4 <__aeabi_d2lz>
 80016a4:	e9cd 0100 	strd	r0, r1, [sp]
 80016a8:	68b0      	ldr	r0, [r6, #8]
 80016aa:	7882      	ldrb	r2, [r0, #2]
 80016ac:	0020      	movs	r0, r4
 80016ae:	0029      	movs	r1, r5
 80016b0:	f000 ff74 	bl	800259c <ZbZclAttrIntegerRangeCheck>
 80016b4:	2800      	cmp	r0, #0
 80016b6:	d101      	bne.n	80016bc <??ZbZclAttrWrite_4>
 80016b8:	2087      	movs	r0, #135	; 0x87
 80016ba:	e05b      	b.n	8001774 <??ZbZclAttrWrite_1>

080016bc <??ZbZclAttrWrite_4>:
 80016bc:	68b0      	ldr	r0, [r6, #8]
 80016be:	7900      	ldrb	r0, [r0, #4]
 80016c0:	0680      	lsls	r0, r0, #26
 80016c2:	d522      	bpl.n	800170a <??ZbZclAttrWrite_6>
 80016c4:	2420      	movs	r4, #32
 80016c6:	2500      	movs	r5, #0
 80016c8:	f10d 0b18 	add.w	fp, sp, #24
 80016cc:	002a      	movs	r2, r5
 80016ce:	0021      	movs	r1, r4
 80016d0:	4658      	mov	r0, fp
 80016d2:	f004 f9c8 	bl	8005a66 <__aeabi_memset>
 80016d6:	68b0      	ldr	r0, [r6, #8]
 80016d8:	9006      	str	r0, [sp, #24]
 80016da:	2001      	movs	r0, #1
 80016dc:	f88d 001c 	strb.w	r0, [sp, #28]
 80016e0:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80016e2:	900c      	str	r0, [sp, #48]	; 0x30
 80016e4:	f8cd 9020 	str.w	r9, [sp, #32]
 80016e8:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 80016ec:	f8ad 7028 	strh.w	r7, [sp, #40]	; 0x28
 80016f0:	68f0      	ldr	r0, [r6, #12]
 80016f2:	900b      	str	r0, [sp, #44]	; 0x2c
 80016f4:	f8d8 0054 	ldr.w	r0, [r8, #84]	; 0x54
 80016f8:	900d      	str	r0, [sp, #52]	; 0x34
 80016fa:	aa06      	add	r2, sp, #24
 80016fc:	0031      	movs	r1, r6
 80016fe:	4640      	mov	r0, r8
 8001700:	f001 fb5e 	bl	8002dc0 <ZbZclAttrCallbackExec>
 8001704:	f88d 0010 	strb.w	r0, [sp, #16]
 8001708:	e028      	b.n	800175c <??ZbZclAttrWrite_7>

0800170a <??ZbZclAttrWrite_6>:
 800170a:	003b      	movs	r3, r7
 800170c:	b29b      	uxth	r3, r3
 800170e:	464a      	mov	r2, r9
 8001710:	0031      	movs	r1, r6
 8001712:	4640      	mov	r0, r8
 8001714:	f000 f85e 	bl	80017d4 <ZbZclAttrDefaultWrite>
 8001718:	f88d 0010 	strb.w	r0, [sp, #16]
 800171c:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8001720:	2800      	cmp	r0, #0
 8001722:	d11b      	bne.n	800175c <??ZbZclAttrWrite_7>
 8001724:	68b0      	ldr	r0, [r6, #8]
 8001726:	7900      	ldrb	r0, [r0, #4]
 8001728:	0640      	lsls	r0, r0, #25
 800172a:	d517      	bpl.n	800175c <??ZbZclAttrWrite_7>
 800172c:	2420      	movs	r4, #32
 800172e:	2500      	movs	r5, #0
 8001730:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
 8001734:	002a      	movs	r2, r5
 8001736:	0021      	movs	r1, r4
 8001738:	4658      	mov	r0, fp
 800173a:	f004 f994 	bl	8005a66 <__aeabi_memset>
 800173e:	68b0      	ldr	r0, [r6, #8]
 8001740:	900e      	str	r0, [sp, #56]	; 0x38
 8001742:	2002      	movs	r0, #2
 8001744:	f88d 003c 	strb.w	r0, [sp, #60]	; 0x3c
 8001748:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800174a:	9014      	str	r0, [sp, #80]	; 0x50
 800174c:	f8d8 0054 	ldr.w	r0, [r8, #84]	; 0x54
 8001750:	9015      	str	r0, [sp, #84]	; 0x54
 8001752:	aa0e      	add	r2, sp, #56	; 0x38
 8001754:	0031      	movs	r1, r6
 8001756:	4640      	mov	r0, r8
 8001758:	f001 fb32 	bl	8002dc0 <ZbZclAttrCallbackExec>

0800175c <??ZbZclAttrWrite_7>:
 800175c:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8001760:	2800      	cmp	r0, #0
 8001762:	d002      	beq.n	800176a <??ZbZclAttrWrite_8>
 8001764:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8001768:	e004      	b.n	8001774 <??ZbZclAttrWrite_1>

0800176a <??ZbZclAttrWrite_8>:
 800176a:	0031      	movs	r1, r6
 800176c:	4640      	mov	r0, r8
 800176e:	f000 f804 	bl	800177a <ZbZclAttrPostWrite>
 8001772:	2000      	movs	r0, #0

08001774 <??ZbZclAttrWrite_1>:
 8001774:	b019      	add	sp, #100	; 0x64
 8001776:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800177a <ZbZclAttrPostWrite>:
 800177a:	b538      	push	{r3, r4, r5, lr}
 800177c:	0005      	movs	r5, r0
 800177e:	000c      	movs	r4, r1
 8001780:	6d28      	ldr	r0, [r5, #80]	; 0x50
 8001782:	2800      	cmp	r0, #0
 8001784:	d004      	beq.n	8001790 <??ZbZclAttrPostWrite_0>
 8001786:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800178a:	6d28      	ldr	r0, [r5, #80]	; 0x50
 800178c:	f014 f9f2 	bl	8015b74 <ZbTimerReset>

08001790 <??ZbZclAttrPostWrite_0>:
 8001790:	2c00      	cmp	r4, #0
 8001792:	d005      	beq.n	80017a0 <??ZbZclAttrPostWrite_1>
 8001794:	2200      	movs	r2, #0
 8001796:	68a0      	ldr	r0, [r4, #8]
 8001798:	8801      	ldrh	r1, [r0, #0]
 800179a:	0028      	movs	r0, r5
 800179c:	f001 ffcb 	bl	8003736 <zcl_attr_reporting_check>

080017a0 <??ZbZclAttrPostWrite_1>:
 80017a0:	bd31      	pop	{r0, r4, r5, pc}

080017a2 <ZbZclAttrPersist>:
 80017a2:	b570      	push	{r4, r5, r6, lr}
 80017a4:	0005      	movs	r5, r0
 80017a6:	000e      	movs	r6, r1
 80017a8:	0031      	movs	r1, r6
 80017aa:	b289      	uxth	r1, r1
 80017ac:	0028      	movs	r0, r5
 80017ae:	f7ff fcd6 	bl	800115e <ZbZclAttrFind>
 80017b2:	0004      	movs	r4, r0
 80017b4:	2c00      	cmp	r4, #0
 80017b6:	d101      	bne.n	80017bc <??ZbZclAttrPersist_0>
 80017b8:	2000      	movs	r0, #0
 80017ba:	e00a      	b.n	80017d2 <??ZbZclAttrPersist_1>

080017bc <??ZbZclAttrPersist_0>:
 80017bc:	68a0      	ldr	r0, [r4, #8]
 80017be:	7900      	ldrb	r0, [r0, #4]
 80017c0:	0740      	lsls	r0, r0, #29
 80017c2:	d401      	bmi.n	80017c8 <??ZbZclAttrPersist_2>
 80017c4:	2000      	movs	r0, #0
 80017c6:	e004      	b.n	80017d2 <??ZbZclAttrPersist_1>

080017c8 <??ZbZclAttrPersist_2>:
 80017c8:	0021      	movs	r1, r4
 80017ca:	0028      	movs	r0, r5
 80017cc:	f7ff ffd5 	bl	800177a <ZbZclAttrPostWrite>
 80017d0:	2001      	movs	r0, #1

080017d2 <??ZbZclAttrPersist_1>:
 80017d2:	bd70      	pop	{r4, r5, r6, pc}

080017d4 <ZbZclAttrDefaultWrite>:
 80017d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80017d8:	0006      	movs	r6, r0
 80017da:	000f      	movs	r7, r1
 80017dc:	0014      	movs	r4, r2
 80017de:	4698      	mov	r8, r3
 80017e0:	2500      	movs	r5, #0
 80017e2:	f05f 0900 	movs.w	r9, #0
 80017e6:	2c00      	cmp	r4, #0
 80017e8:	d101      	bne.n	80017ee <??ZbZclAttrDefaultWrite_0>
 80017ea:	2001      	movs	r0, #1
 80017ec:	e0d6      	b.n	800199c <??ZbZclAttrDefaultWrite_1>

080017ee <??ZbZclAttrDefaultWrite_0>:
 80017ee:	68b8      	ldr	r0, [r7, #8]
 80017f0:	7880      	ldrb	r0, [r0, #2]
 80017f2:	2808      	cmp	r0, #8
 80017f4:	d062      	beq.n	80018bc <??ZbZclAttrDefaultWrite_2>
 80017f6:	2809      	cmp	r0, #9
 80017f8:	d063      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 80017fa:	280a      	cmp	r0, #10
 80017fc:	d064      	beq.n	80018c8 <??ZbZclAttrDefaultWrite_4>
 80017fe:	280b      	cmp	r0, #11
 8001800:	d065      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 8001802:	280c      	cmp	r0, #12
 8001804:	d066      	beq.n	80018d4 <??ZbZclAttrDefaultWrite_6>
 8001806:	280d      	cmp	r0, #13
 8001808:	d067      	beq.n	80018da <??ZbZclAttrDefaultWrite_7>
 800180a:	280e      	cmp	r0, #14
 800180c:	d068      	beq.n	80018e0 <??ZbZclAttrDefaultWrite_8>
 800180e:	280f      	cmp	r0, #15
 8001810:	d069      	beq.n	80018e6 <??ZbZclAttrDefaultWrite_9>
 8001812:	2810      	cmp	r0, #16
 8001814:	d052      	beq.n	80018bc <??ZbZclAttrDefaultWrite_2>
 8001816:	2818      	cmp	r0, #24
 8001818:	d050      	beq.n	80018bc <??ZbZclAttrDefaultWrite_2>
 800181a:	2819      	cmp	r0, #25
 800181c:	d051      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 800181e:	281a      	cmp	r0, #26
 8001820:	d052      	beq.n	80018c8 <??ZbZclAttrDefaultWrite_4>
 8001822:	281b      	cmp	r0, #27
 8001824:	d053      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 8001826:	281c      	cmp	r0, #28
 8001828:	d054      	beq.n	80018d4 <??ZbZclAttrDefaultWrite_6>
 800182a:	281d      	cmp	r0, #29
 800182c:	d055      	beq.n	80018da <??ZbZclAttrDefaultWrite_7>
 800182e:	281e      	cmp	r0, #30
 8001830:	d056      	beq.n	80018e0 <??ZbZclAttrDefaultWrite_8>
 8001832:	281f      	cmp	r0, #31
 8001834:	d057      	beq.n	80018e6 <??ZbZclAttrDefaultWrite_9>
 8001836:	2820      	cmp	r0, #32
 8001838:	d040      	beq.n	80018bc <??ZbZclAttrDefaultWrite_2>
 800183a:	2821      	cmp	r0, #33	; 0x21
 800183c:	d041      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 800183e:	2822      	cmp	r0, #34	; 0x22
 8001840:	d042      	beq.n	80018c8 <??ZbZclAttrDefaultWrite_4>
 8001842:	2823      	cmp	r0, #35	; 0x23
 8001844:	d043      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 8001846:	2824      	cmp	r0, #36	; 0x24
 8001848:	d044      	beq.n	80018d4 <??ZbZclAttrDefaultWrite_6>
 800184a:	2825      	cmp	r0, #37	; 0x25
 800184c:	d045      	beq.n	80018da <??ZbZclAttrDefaultWrite_7>
 800184e:	2826      	cmp	r0, #38	; 0x26
 8001850:	d046      	beq.n	80018e0 <??ZbZclAttrDefaultWrite_8>
 8001852:	2827      	cmp	r0, #39	; 0x27
 8001854:	d047      	beq.n	80018e6 <??ZbZclAttrDefaultWrite_9>
 8001856:	2828      	cmp	r0, #40	; 0x28
 8001858:	d030      	beq.n	80018bc <??ZbZclAttrDefaultWrite_2>
 800185a:	2829      	cmp	r0, #41	; 0x29
 800185c:	d031      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 800185e:	282a      	cmp	r0, #42	; 0x2a
 8001860:	d032      	beq.n	80018c8 <??ZbZclAttrDefaultWrite_4>
 8001862:	282b      	cmp	r0, #43	; 0x2b
 8001864:	d033      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 8001866:	282c      	cmp	r0, #44	; 0x2c
 8001868:	d034      	beq.n	80018d4 <??ZbZclAttrDefaultWrite_6>
 800186a:	282d      	cmp	r0, #45	; 0x2d
 800186c:	d035      	beq.n	80018da <??ZbZclAttrDefaultWrite_7>
 800186e:	282e      	cmp	r0, #46	; 0x2e
 8001870:	d036      	beq.n	80018e0 <??ZbZclAttrDefaultWrite_8>
 8001872:	282f      	cmp	r0, #47	; 0x2f
 8001874:	d037      	beq.n	80018e6 <??ZbZclAttrDefaultWrite_9>
 8001876:	2830      	cmp	r0, #48	; 0x30
 8001878:	d020      	beq.n	80018bc <??ZbZclAttrDefaultWrite_2>
 800187a:	2831      	cmp	r0, #49	; 0x31
 800187c:	d021      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 800187e:	2838      	cmp	r0, #56	; 0x38
 8001880:	d01f      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 8001882:	2839      	cmp	r0, #57	; 0x39
 8001884:	d023      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 8001886:	283a      	cmp	r0, #58	; 0x3a
 8001888:	d02d      	beq.n	80018e6 <??ZbZclAttrDefaultWrite_9>
 800188a:	2841      	cmp	r0, #65	; 0x41
 800188c:	d031      	beq.n	80018f2 <??ZbZclAttrDefaultWrite_10>
 800188e:	2842      	cmp	r0, #66	; 0x42
 8001890:	d02f      	beq.n	80018f2 <??ZbZclAttrDefaultWrite_10>
 8001892:	2843      	cmp	r0, #67	; 0x43
 8001894:	d049      	beq.n	800192a <??ZbZclAttrDefaultWrite_11>
 8001896:	2844      	cmp	r0, #68	; 0x44
 8001898:	d047      	beq.n	800192a <??ZbZclAttrDefaultWrite_11>
 800189a:	28e0      	cmp	r0, #224	; 0xe0
 800189c:	d017      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 800189e:	28e1      	cmp	r0, #225	; 0xe1
 80018a0:	d015      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 80018a2:	28e2      	cmp	r0, #226	; 0xe2
 80018a4:	d013      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 80018a6:	28e8      	cmp	r0, #232	; 0xe8
 80018a8:	d00b      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 80018aa:	28e9      	cmp	r0, #233	; 0xe9
 80018ac:	d009      	beq.n	80018c2 <??ZbZclAttrDefaultWrite_3>
 80018ae:	28ea      	cmp	r0, #234	; 0xea
 80018b0:	d00d      	beq.n	80018ce <??ZbZclAttrDefaultWrite_5>
 80018b2:	28f0      	cmp	r0, #240	; 0xf0
 80018b4:	d017      	beq.n	80018e6 <??ZbZclAttrDefaultWrite_9>
 80018b6:	28f1      	cmp	r0, #241	; 0xf1
 80018b8:	d018      	beq.n	80018ec <??ZbZclAttrDefaultWrite_12>
 80018ba:	e058      	b.n	800196e <??ZbZclAttrDefaultWrite_13>

080018bc <??ZbZclAttrDefaultWrite_2>:
 80018bc:	2001      	movs	r0, #1
 80018be:	0005      	movs	r5, r0
 80018c0:	e057      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018c2 <??ZbZclAttrDefaultWrite_3>:
 80018c2:	2002      	movs	r0, #2
 80018c4:	0005      	movs	r5, r0
 80018c6:	e054      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018c8 <??ZbZclAttrDefaultWrite_4>:
 80018c8:	2003      	movs	r0, #3
 80018ca:	0005      	movs	r5, r0
 80018cc:	e051      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018ce <??ZbZclAttrDefaultWrite_5>:
 80018ce:	2004      	movs	r0, #4
 80018d0:	0005      	movs	r5, r0
 80018d2:	e04e      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018d4 <??ZbZclAttrDefaultWrite_6>:
 80018d4:	2005      	movs	r0, #5
 80018d6:	0005      	movs	r5, r0
 80018d8:	e04b      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018da <??ZbZclAttrDefaultWrite_7>:
 80018da:	2006      	movs	r0, #6
 80018dc:	0005      	movs	r5, r0
 80018de:	e048      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018e0 <??ZbZclAttrDefaultWrite_8>:
 80018e0:	2007      	movs	r0, #7
 80018e2:	0005      	movs	r5, r0
 80018e4:	e045      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018e6 <??ZbZclAttrDefaultWrite_9>:
 80018e6:	2008      	movs	r0, #8
 80018e8:	0005      	movs	r5, r0
 80018ea:	e042      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018ec <??ZbZclAttrDefaultWrite_12>:
 80018ec:	2010      	movs	r0, #16
 80018ee:	0005      	movs	r5, r0
 80018f0:	e03f      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018f2 <??ZbZclAttrDefaultWrite_10>:
 80018f2:	6938      	ldr	r0, [r7, #16]
 80018f4:	2800      	cmp	r0, #0
 80018f6:	d102      	bne.n	80018fe <??ZbZclAttrDefaultWrite_15>
 80018f8:	2089      	movs	r0, #137	; 0x89
 80018fa:	4681      	mov	r9, r0
 80018fc:	e039      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

080018fe <??ZbZclAttrDefaultWrite_15>:
 80018fe:	7820      	ldrb	r0, [r4, #0]
 8001900:	0001      	movs	r1, r0
 8001902:	b2c9      	uxtb	r1, r1
 8001904:	29ff      	cmp	r1, #255	; 0xff
 8001906:	d105      	bne.n	8001914 <??ZbZclAttrDefaultWrite_16>
 8001908:	21ff      	movs	r1, #255	; 0xff
 800190a:	68fa      	ldr	r2, [r7, #12]
 800190c:	7011      	strb	r1, [r2, #0]
 800190e:	2100      	movs	r1, #0
 8001910:	000d      	movs	r5, r1
 8001912:	e02e      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

08001914 <??ZbZclAttrDefaultWrite_16>:
 8001914:	0001      	movs	r1, r0
 8001916:	b2c9      	uxtb	r1, r1
 8001918:	1c49      	adds	r1, r1, #1
 800191a:	000d      	movs	r5, r1
 800191c:	6939      	ldr	r1, [r7, #16]
 800191e:	42a9      	cmp	r1, r5
 8001920:	d202      	bcs.n	8001928 <??ZbZclAttrDefaultWrite_17>
 8001922:	2189      	movs	r1, #137	; 0x89
 8001924:	4689      	mov	r9, r1
 8001926:	e024      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

08001928 <??ZbZclAttrDefaultWrite_17>:
 8001928:	e023      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

0800192a <??ZbZclAttrDefaultWrite_11>:
 800192a:	6938      	ldr	r0, [r7, #16]
 800192c:	2802      	cmp	r0, #2
 800192e:	d202      	bcs.n	8001936 <??ZbZclAttrDefaultWrite_18>
 8001930:	2089      	movs	r0, #137	; 0x89
 8001932:	4681      	mov	r9, r0
 8001934:	e01d      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

08001936 <??ZbZclAttrDefaultWrite_18>:
 8001936:	0020      	movs	r0, r4
 8001938:	f7fe fc30 	bl	800019c <pletoh16>
 800193c:	4682      	mov	sl, r0
 800193e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001942:	4650      	mov	r0, sl
 8001944:	000a      	movs	r2, r1
 8001946:	b280      	uxth	r0, r0
 8001948:	4290      	cmp	r0, r2
 800194a:	d105      	bne.n	8001958 <??ZbZclAttrDefaultWrite_19>
 800194c:	68f8      	ldr	r0, [r7, #12]
 800194e:	f7fe fc71 	bl	8000234 <putle16>
 8001952:	2000      	movs	r0, #0
 8001954:	0005      	movs	r5, r0
 8001956:	e00c      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

08001958 <??ZbZclAttrDefaultWrite_19>:
 8001958:	4650      	mov	r0, sl
 800195a:	b280      	uxth	r0, r0
 800195c:	1c80      	adds	r0, r0, #2
 800195e:	0005      	movs	r5, r0
 8001960:	6938      	ldr	r0, [r7, #16]
 8001962:	42a8      	cmp	r0, r5
 8001964:	d202      	bcs.n	800196c <??ZbZclAttrDefaultWrite_20>
 8001966:	2089      	movs	r0, #137	; 0x89
 8001968:	4681      	mov	r9, r0
 800196a:	e002      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

0800196c <??ZbZclAttrDefaultWrite_20>:
 800196c:	e001      	b.n	8001972 <??ZbZclAttrDefaultWrite_14>

0800196e <??ZbZclAttrDefaultWrite_13>:
 800196e:	2086      	movs	r0, #134	; 0x86
 8001970:	4681      	mov	r9, r0

08001972 <??ZbZclAttrDefaultWrite_14>:
 8001972:	4648      	mov	r0, r9
 8001974:	b2c0      	uxtb	r0, r0
 8001976:	2800      	cmp	r0, #0
 8001978:	d10e      	bne.n	8001998 <??ZbZclAttrDefaultWrite_21>
 800197a:	4640      	mov	r0, r8
 800197c:	b280      	uxth	r0, r0
 800197e:	07c0      	lsls	r0, r0, #31
 8001980:	d40a      	bmi.n	8001998 <??ZbZclAttrDefaultWrite_21>
 8001982:	2d00      	cmp	r5, #0
 8001984:	d008      	beq.n	8001998 <??ZbZclAttrDefaultWrite_21>
 8001986:	9500      	str	r5, [sp, #0]
 8001988:	46a2      	mov	sl, r4
 800198a:	f8d7 b00c 	ldr.w	fp, [r7, #12]
 800198e:	9a00      	ldr	r2, [sp, #0]
 8001990:	4651      	mov	r1, sl
 8001992:	4658      	mov	r0, fp
 8001994:	f016 fdfd 	bl	8018592 <__aeabi_memcpy>

08001998 <??ZbZclAttrDefaultWrite_21>:
 8001998:	4648      	mov	r0, r9
 800199a:	b2c0      	uxtb	r0, r0

0800199c <??ZbZclAttrDefaultWrite_1>:
 800199c:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080019a0 <ZbZclAttrDefaultValue>:
 80019a0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019a4:	0004      	movs	r4, r0
 80019a6:	4688      	mov	r8, r1
 80019a8:	0015      	movs	r5, r2
 80019aa:	2600      	movs	r6, #0
 80019ac:	f05f 37ff 	movs.w	r7, #4294967295	; 0xffffffff
 80019b0:	0020      	movs	r0, r4
 80019b2:	b2c0      	uxtb	r0, r0
 80019b4:	2800      	cmp	r0, #0
 80019b6:	f000 80a1 	beq.w	8001afc <??ZbZclAttrDefaultValue_0>
 80019ba:	2808      	cmp	r0, #8
 80019bc:	f000 80e7 	beq.w	8001b8e <??ZbZclAttrDefaultValue_1>
 80019c0:	2809      	cmp	r0, #9
 80019c2:	f000 80da 	beq.w	8001b7a <??ZbZclAttrDefaultValue_2>
 80019c6:	280a      	cmp	r0, #10
 80019c8:	f000 80cd 	beq.w	8001b66 <??ZbZclAttrDefaultValue_3>
 80019cc:	280b      	cmp	r0, #11
 80019ce:	f000 80c0 	beq.w	8001b52 <??ZbZclAttrDefaultValue_4>
 80019d2:	280c      	cmp	r0, #12
 80019d4:	f000 80b3 	beq.w	8001b3e <??ZbZclAttrDefaultValue_5>
 80019d8:	280d      	cmp	r0, #13
 80019da:	f000 80a6 	beq.w	8001b2a <??ZbZclAttrDefaultValue_6>
 80019de:	280e      	cmp	r0, #14
 80019e0:	f000 8099 	beq.w	8001b16 <??ZbZclAttrDefaultValue_7>
 80019e4:	280f      	cmp	r0, #15
 80019e6:	f000 808c 	beq.w	8001b02 <??ZbZclAttrDefaultValue_8>
 80019ea:	2810      	cmp	r0, #16
 80019ec:	f000 80db 	beq.w	8001ba6 <??ZbZclAttrDefaultValue_9>
 80019f0:	2818      	cmp	r0, #24
 80019f2:	f000 8126 	beq.w	8001c42 <??ZbZclAttrDefaultValue_10>
 80019f6:	2819      	cmp	r0, #25
 80019f8:	f000 8119 	beq.w	8001c2e <??ZbZclAttrDefaultValue_11>
 80019fc:	281a      	cmp	r0, #26
 80019fe:	f000 810c 	beq.w	8001c1a <??ZbZclAttrDefaultValue_12>
 8001a02:	281b      	cmp	r0, #27
 8001a04:	f000 80ff 	beq.w	8001c06 <??ZbZclAttrDefaultValue_13>
 8001a08:	281c      	cmp	r0, #28
 8001a0a:	f000 80f2 	beq.w	8001bf2 <??ZbZclAttrDefaultValue_14>
 8001a0e:	281d      	cmp	r0, #29
 8001a10:	f000 80e5 	beq.w	8001bde <??ZbZclAttrDefaultValue_15>
 8001a14:	281e      	cmp	r0, #30
 8001a16:	f000 80d8 	beq.w	8001bca <??ZbZclAttrDefaultValue_16>
 8001a1a:	281f      	cmp	r0, #31
 8001a1c:	f000 80cb 	beq.w	8001bb6 <??ZbZclAttrDefaultValue_17>
 8001a20:	2820      	cmp	r0, #32
 8001a22:	f000 80b4 	beq.w	8001b8e <??ZbZclAttrDefaultValue_1>
 8001a26:	2821      	cmp	r0, #33	; 0x21
 8001a28:	f000 80a7 	beq.w	8001b7a <??ZbZclAttrDefaultValue_2>
 8001a2c:	2822      	cmp	r0, #34	; 0x22
 8001a2e:	f000 809a 	beq.w	8001b66 <??ZbZclAttrDefaultValue_3>
 8001a32:	2823      	cmp	r0, #35	; 0x23
 8001a34:	f000 808d 	beq.w	8001b52 <??ZbZclAttrDefaultValue_4>
 8001a38:	2824      	cmp	r0, #36	; 0x24
 8001a3a:	f000 8080 	beq.w	8001b3e <??ZbZclAttrDefaultValue_5>
 8001a3e:	2825      	cmp	r0, #37	; 0x25
 8001a40:	d073      	beq.n	8001b2a <??ZbZclAttrDefaultValue_6>
 8001a42:	2826      	cmp	r0, #38	; 0x26
 8001a44:	d067      	beq.n	8001b16 <??ZbZclAttrDefaultValue_7>
 8001a46:	2827      	cmp	r0, #39	; 0x27
 8001a48:	d05b      	beq.n	8001b02 <??ZbZclAttrDefaultValue_8>
 8001a4a:	2828      	cmp	r0, #40	; 0x28
 8001a4c:	f000 814b 	beq.w	8001ce6 <??ZbZclAttrDefaultValue_18>
 8001a50:	2829      	cmp	r0, #41	; 0x29
 8001a52:	f000 813e 	beq.w	8001cd2 <??ZbZclAttrDefaultValue_19>
 8001a56:	282a      	cmp	r0, #42	; 0x2a
 8001a58:	f000 8131 	beq.w	8001cbe <??ZbZclAttrDefaultValue_20>
 8001a5c:	282b      	cmp	r0, #43	; 0x2b
 8001a5e:	f000 8124 	beq.w	8001caa <??ZbZclAttrDefaultValue_21>
 8001a62:	282c      	cmp	r0, #44	; 0x2c
 8001a64:	f000 8117 	beq.w	8001c96 <??ZbZclAttrDefaultValue_22>
 8001a68:	282d      	cmp	r0, #45	; 0x2d
 8001a6a:	f000 810a 	beq.w	8001c82 <??ZbZclAttrDefaultValue_23>
 8001a6e:	282e      	cmp	r0, #46	; 0x2e
 8001a70:	f000 80fd 	beq.w	8001c6e <??ZbZclAttrDefaultValue_24>
 8001a74:	282f      	cmp	r0, #47	; 0x2f
 8001a76:	f000 80f0 	beq.w	8001c5a <??ZbZclAttrDefaultValue_25>
 8001a7a:	2830      	cmp	r0, #48	; 0x30
 8001a7c:	f000 8087 	beq.w	8001b8e <??ZbZclAttrDefaultValue_1>
 8001a80:	2831      	cmp	r0, #49	; 0x31
 8001a82:	d07a      	beq.n	8001b7a <??ZbZclAttrDefaultValue_2>
 8001a84:	2838      	cmp	r0, #56	; 0x38
 8001a86:	f000 813a 	beq.w	8001cfe <??ZbZclAttrDefaultValue_26>
 8001a8a:	2839      	cmp	r0, #57	; 0x39
 8001a8c:	f000 8142 	beq.w	8001d14 <??ZbZclAttrDefaultValue_27>
 8001a90:	283a      	cmp	r0, #58	; 0x3a
 8001a92:	f000 8149 	beq.w	8001d28 <??ZbZclAttrDefaultValue_28>
 8001a96:	2841      	cmp	r0, #65	; 0x41
 8001a98:	f000 8152 	beq.w	8001d40 <??ZbZclAttrDefaultValue_29>
 8001a9c:	2842      	cmp	r0, #66	; 0x42
 8001a9e:	f000 8159 	beq.w	8001d54 <??ZbZclAttrDefaultValue_30>
 8001aa2:	2843      	cmp	r0, #67	; 0x43
 8001aa4:	f000 8160 	beq.w	8001d68 <??ZbZclAttrDefaultValue_31>
 8001aa8:	2844      	cmp	r0, #68	; 0x44
 8001aaa:	f000 8168 	beq.w	8001d7e <??ZbZclAttrDefaultValue_32>
 8001aae:	2848      	cmp	r0, #72	; 0x48
 8001ab0:	f000 818b 	beq.w	8001dca <??ZbZclAttrDefaultValue_33>
 8001ab4:	284c      	cmp	r0, #76	; 0x4c
 8001ab6:	f000 8192 	beq.w	8001dde <??ZbZclAttrDefaultValue_34>
 8001aba:	2850      	cmp	r0, #80	; 0x50
 8001abc:	f000 8199 	beq.w	8001df2 <??ZbZclAttrDefaultValue_35>
 8001ac0:	2851      	cmp	r0, #81	; 0x51
 8001ac2:	f000 81a0 	beq.w	8001e06 <??ZbZclAttrDefaultValue_36>
 8001ac6:	28e0      	cmp	r0, #224	; 0xe0
 8001ac8:	f000 81a7 	beq.w	8001e1a <??ZbZclAttrDefaultValue_37>
 8001acc:	28e1      	cmp	r0, #225	; 0xe1
 8001ace:	f000 81ae 	beq.w	8001e2e <??ZbZclAttrDefaultValue_38>
 8001ad2:	28e2      	cmp	r0, #226	; 0xe2
 8001ad4:	f000 81b5 	beq.w	8001e42 <??ZbZclAttrDefaultValue_39>
 8001ad8:	28e8      	cmp	r0, #232	; 0xe8
 8001ada:	f000 81bc 	beq.w	8001e56 <??ZbZclAttrDefaultValue_40>
 8001ade:	28e9      	cmp	r0, #233	; 0xe9
 8001ae0:	f000 81c3 	beq.w	8001e6a <??ZbZclAttrDefaultValue_41>
 8001ae4:	28ea      	cmp	r0, #234	; 0xea
 8001ae6:	f000 81ca 	beq.w	8001e7e <??ZbZclAttrDefaultValue_42>
 8001aea:	28f0      	cmp	r0, #240	; 0xf0
 8001aec:	f000 8152 	beq.w	8001d94 <??ZbZclAttrDefaultValue_43>
 8001af0:	28f1      	cmp	r0, #241	; 0xf1
 8001af2:	f000 815b 	beq.w	8001dac <??ZbZclAttrDefaultValue_44>
 8001af6:	28ff      	cmp	r0, #255	; 0xff
 8001af8:	f040 81cb 	bne.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001afc <??ZbZclAttrDefaultValue_0>:
 8001afc:	2000      	movs	r0, #0
 8001afe:	0007      	movs	r7, r0
 8001b00:	e1c7      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001b02 <??ZbZclAttrDefaultValue_8>:
 8001b02:	1c70      	adds	r0, r6, #1
 8001b04:	4285      	cmp	r5, r0
 8001b06:	f0c0 81c4 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b0a <??ZbZclAttrDefaultValue_47>:
 8001b0a:	20ff      	movs	r0, #255	; 0xff
 8001b0c:	f888 0000 	strb.w	r0, [r8]
 8001b10:	f118 0801 	adds.w	r8, r8, #1
 8001b14:	1c76      	adds	r6, r6, #1

08001b16 <??ZbZclAttrDefaultValue_7>:
 8001b16:	1c70      	adds	r0, r6, #1
 8001b18:	4285      	cmp	r5, r0
 8001b1a:	f0c0 81ba 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b1e <??ZbZclAttrDefaultValue_48>:
 8001b1e:	20ff      	movs	r0, #255	; 0xff
 8001b20:	f888 0000 	strb.w	r0, [r8]
 8001b24:	f118 0801 	adds.w	r8, r8, #1
 8001b28:	1c76      	adds	r6, r6, #1

08001b2a <??ZbZclAttrDefaultValue_6>:
 8001b2a:	1c70      	adds	r0, r6, #1
 8001b2c:	4285      	cmp	r5, r0
 8001b2e:	f0c0 81b0 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b32 <??ZbZclAttrDefaultValue_49>:
 8001b32:	20ff      	movs	r0, #255	; 0xff
 8001b34:	f888 0000 	strb.w	r0, [r8]
 8001b38:	f118 0801 	adds.w	r8, r8, #1
 8001b3c:	1c76      	adds	r6, r6, #1

08001b3e <??ZbZclAttrDefaultValue_5>:
 8001b3e:	1c70      	adds	r0, r6, #1
 8001b40:	4285      	cmp	r5, r0
 8001b42:	f0c0 81a6 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b46 <??ZbZclAttrDefaultValue_50>:
 8001b46:	20ff      	movs	r0, #255	; 0xff
 8001b48:	f888 0000 	strb.w	r0, [r8]
 8001b4c:	f118 0801 	adds.w	r8, r8, #1
 8001b50:	1c76      	adds	r6, r6, #1

08001b52 <??ZbZclAttrDefaultValue_4>:
 8001b52:	1c70      	adds	r0, r6, #1
 8001b54:	4285      	cmp	r5, r0
 8001b56:	f0c0 819c 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b5a <??ZbZclAttrDefaultValue_51>:
 8001b5a:	20ff      	movs	r0, #255	; 0xff
 8001b5c:	f888 0000 	strb.w	r0, [r8]
 8001b60:	f118 0801 	adds.w	r8, r8, #1
 8001b64:	1c76      	adds	r6, r6, #1

08001b66 <??ZbZclAttrDefaultValue_3>:
 8001b66:	1c70      	adds	r0, r6, #1
 8001b68:	4285      	cmp	r5, r0
 8001b6a:	f0c0 8192 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b6e <??ZbZclAttrDefaultValue_52>:
 8001b6e:	20ff      	movs	r0, #255	; 0xff
 8001b70:	f888 0000 	strb.w	r0, [r8]
 8001b74:	f118 0801 	adds.w	r8, r8, #1
 8001b78:	1c76      	adds	r6, r6, #1

08001b7a <??ZbZclAttrDefaultValue_2>:
 8001b7a:	1c70      	adds	r0, r6, #1
 8001b7c:	4285      	cmp	r5, r0
 8001b7e:	f0c0 8188 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b82 <??ZbZclAttrDefaultValue_53>:
 8001b82:	20ff      	movs	r0, #255	; 0xff
 8001b84:	f888 0000 	strb.w	r0, [r8]
 8001b88:	f118 0801 	adds.w	r8, r8, #1
 8001b8c:	1c76      	adds	r6, r6, #1

08001b8e <??ZbZclAttrDefaultValue_1>:
 8001b8e:	1c70      	adds	r0, r6, #1
 8001b90:	4285      	cmp	r5, r0
 8001b92:	f0c0 817e 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001b96 <??ZbZclAttrDefaultValue_54>:
 8001b96:	20ff      	movs	r0, #255	; 0xff
 8001b98:	f888 0000 	strb.w	r0, [r8]
 8001b9c:	f118 0801 	adds.w	r8, r8, #1
 8001ba0:	1c76      	adds	r6, r6, #1
 8001ba2:	0037      	movs	r7, r6
 8001ba4:	e175      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001ba6 <??ZbZclAttrDefaultValue_9>:
 8001ba6:	2000      	movs	r0, #0
 8001ba8:	f888 0000 	strb.w	r0, [r8]
 8001bac:	f118 0801 	adds.w	r8, r8, #1
 8001bb0:	2001      	movs	r0, #1
 8001bb2:	0007      	movs	r7, r0
 8001bb4:	e16d      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001bb6 <??ZbZclAttrDefaultValue_17>:
 8001bb6:	1c70      	adds	r0, r6, #1
 8001bb8:	4285      	cmp	r5, r0
 8001bba:	f0c0 816a 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001bbe <??ZbZclAttrDefaultValue_55>:
 8001bbe:	2000      	movs	r0, #0
 8001bc0:	f888 0000 	strb.w	r0, [r8]
 8001bc4:	f118 0801 	adds.w	r8, r8, #1
 8001bc8:	1c76      	adds	r6, r6, #1

08001bca <??ZbZclAttrDefaultValue_16>:
 8001bca:	1c70      	adds	r0, r6, #1
 8001bcc:	4285      	cmp	r5, r0
 8001bce:	f0c0 8160 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001bd2 <??ZbZclAttrDefaultValue_56>:
 8001bd2:	2000      	movs	r0, #0
 8001bd4:	f888 0000 	strb.w	r0, [r8]
 8001bd8:	f118 0801 	adds.w	r8, r8, #1
 8001bdc:	1c76      	adds	r6, r6, #1

08001bde <??ZbZclAttrDefaultValue_15>:
 8001bde:	1c70      	adds	r0, r6, #1
 8001be0:	4285      	cmp	r5, r0
 8001be2:	f0c0 8156 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001be6 <??ZbZclAttrDefaultValue_57>:
 8001be6:	2000      	movs	r0, #0
 8001be8:	f888 0000 	strb.w	r0, [r8]
 8001bec:	f118 0801 	adds.w	r8, r8, #1
 8001bf0:	1c76      	adds	r6, r6, #1

08001bf2 <??ZbZclAttrDefaultValue_14>:
 8001bf2:	1c70      	adds	r0, r6, #1
 8001bf4:	4285      	cmp	r5, r0
 8001bf6:	f0c0 814c 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001bfa <??ZbZclAttrDefaultValue_58>:
 8001bfa:	2000      	movs	r0, #0
 8001bfc:	f888 0000 	strb.w	r0, [r8]
 8001c00:	f118 0801 	adds.w	r8, r8, #1
 8001c04:	1c76      	adds	r6, r6, #1

08001c06 <??ZbZclAttrDefaultValue_13>:
 8001c06:	1c70      	adds	r0, r6, #1
 8001c08:	4285      	cmp	r5, r0
 8001c0a:	f0c0 8142 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c0e <??ZbZclAttrDefaultValue_59>:
 8001c0e:	2000      	movs	r0, #0
 8001c10:	f888 0000 	strb.w	r0, [r8]
 8001c14:	f118 0801 	adds.w	r8, r8, #1
 8001c18:	1c76      	adds	r6, r6, #1

08001c1a <??ZbZclAttrDefaultValue_12>:
 8001c1a:	1c70      	adds	r0, r6, #1
 8001c1c:	4285      	cmp	r5, r0
 8001c1e:	f0c0 8138 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c22 <??ZbZclAttrDefaultValue_60>:
 8001c22:	2000      	movs	r0, #0
 8001c24:	f888 0000 	strb.w	r0, [r8]
 8001c28:	f118 0801 	adds.w	r8, r8, #1
 8001c2c:	1c76      	adds	r6, r6, #1

08001c2e <??ZbZclAttrDefaultValue_11>:
 8001c2e:	1c70      	adds	r0, r6, #1
 8001c30:	4285      	cmp	r5, r0
 8001c32:	f0c0 812e 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c36 <??ZbZclAttrDefaultValue_61>:
 8001c36:	2000      	movs	r0, #0
 8001c38:	f888 0000 	strb.w	r0, [r8]
 8001c3c:	f118 0801 	adds.w	r8, r8, #1
 8001c40:	1c76      	adds	r6, r6, #1

08001c42 <??ZbZclAttrDefaultValue_10>:
 8001c42:	1c70      	adds	r0, r6, #1
 8001c44:	4285      	cmp	r5, r0
 8001c46:	f0c0 8124 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c4a <??ZbZclAttrDefaultValue_62>:
 8001c4a:	2000      	movs	r0, #0
 8001c4c:	f888 0000 	strb.w	r0, [r8]
 8001c50:	f118 0801 	adds.w	r8, r8, #1
 8001c54:	1c76      	adds	r6, r6, #1
 8001c56:	0037      	movs	r7, r6
 8001c58:	e11b      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001c5a <??ZbZclAttrDefaultValue_25>:
 8001c5a:	1c70      	adds	r0, r6, #1
 8001c5c:	4285      	cmp	r5, r0
 8001c5e:	f0c0 8118 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c62 <??ZbZclAttrDefaultValue_63>:
 8001c62:	2000      	movs	r0, #0
 8001c64:	f888 0000 	strb.w	r0, [r8]
 8001c68:	f118 0801 	adds.w	r8, r8, #1
 8001c6c:	1c76      	adds	r6, r6, #1

08001c6e <??ZbZclAttrDefaultValue_24>:
 8001c6e:	1c70      	adds	r0, r6, #1
 8001c70:	4285      	cmp	r5, r0
 8001c72:	f0c0 810e 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c76 <??ZbZclAttrDefaultValue_64>:
 8001c76:	2000      	movs	r0, #0
 8001c78:	f888 0000 	strb.w	r0, [r8]
 8001c7c:	f118 0801 	adds.w	r8, r8, #1
 8001c80:	1c76      	adds	r6, r6, #1

08001c82 <??ZbZclAttrDefaultValue_23>:
 8001c82:	1c70      	adds	r0, r6, #1
 8001c84:	4285      	cmp	r5, r0
 8001c86:	f0c0 8104 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c8a <??ZbZclAttrDefaultValue_65>:
 8001c8a:	2000      	movs	r0, #0
 8001c8c:	f888 0000 	strb.w	r0, [r8]
 8001c90:	f118 0801 	adds.w	r8, r8, #1
 8001c94:	1c76      	adds	r6, r6, #1

08001c96 <??ZbZclAttrDefaultValue_22>:
 8001c96:	1c70      	adds	r0, r6, #1
 8001c98:	4285      	cmp	r5, r0
 8001c9a:	f0c0 80fa 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001c9e <??ZbZclAttrDefaultValue_66>:
 8001c9e:	2000      	movs	r0, #0
 8001ca0:	f888 0000 	strb.w	r0, [r8]
 8001ca4:	f118 0801 	adds.w	r8, r8, #1
 8001ca8:	1c76      	adds	r6, r6, #1

08001caa <??ZbZclAttrDefaultValue_21>:
 8001caa:	1c70      	adds	r0, r6, #1
 8001cac:	4285      	cmp	r5, r0
 8001cae:	f0c0 80f0 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001cb2 <??ZbZclAttrDefaultValue_67>:
 8001cb2:	2000      	movs	r0, #0
 8001cb4:	f888 0000 	strb.w	r0, [r8]
 8001cb8:	f118 0801 	adds.w	r8, r8, #1
 8001cbc:	1c76      	adds	r6, r6, #1

08001cbe <??ZbZclAttrDefaultValue_20>:
 8001cbe:	1c70      	adds	r0, r6, #1
 8001cc0:	4285      	cmp	r5, r0
 8001cc2:	f0c0 80e6 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001cc6 <??ZbZclAttrDefaultValue_68>:
 8001cc6:	2000      	movs	r0, #0
 8001cc8:	f888 0000 	strb.w	r0, [r8]
 8001ccc:	f118 0801 	adds.w	r8, r8, #1
 8001cd0:	1c76      	adds	r6, r6, #1

08001cd2 <??ZbZclAttrDefaultValue_19>:
 8001cd2:	1c70      	adds	r0, r6, #1
 8001cd4:	4285      	cmp	r5, r0
 8001cd6:	f0c0 80dc 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001cda <??ZbZclAttrDefaultValue_69>:
 8001cda:	2000      	movs	r0, #0
 8001cdc:	f888 0000 	strb.w	r0, [r8]
 8001ce0:	f118 0801 	adds.w	r8, r8, #1
 8001ce4:	1c76      	adds	r6, r6, #1

08001ce6 <??ZbZclAttrDefaultValue_18>:
 8001ce6:	1c70      	adds	r0, r6, #1
 8001ce8:	4285      	cmp	r5, r0
 8001cea:	f0c0 80d2 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001cee <??ZbZclAttrDefaultValue_70>:
 8001cee:	2080      	movs	r0, #128	; 0x80
 8001cf0:	f888 0000 	strb.w	r0, [r8]
 8001cf4:	f118 0801 	adds.w	r8, r8, #1
 8001cf8:	1c76      	adds	r6, r6, #1
 8001cfa:	0037      	movs	r7, r6
 8001cfc:	e0c9      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001cfe <??ZbZclAttrDefaultValue_26>:
 8001cfe:	2d02      	cmp	r5, #2
 8001d00:	f0c0 80c7 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d04 <??ZbZclAttrDefaultValue_71>:
 8001d04:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8001d08:	4640      	mov	r0, r8
 8001d0a:	f7fe fa93 	bl	8000234 <putle16>
 8001d0e:	2002      	movs	r0, #2
 8001d10:	0007      	movs	r7, r0
 8001d12:	e0be      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d14 <??ZbZclAttrDefaultValue_27>:
 8001d14:	2d04      	cmp	r5, #4
 8001d16:	f0c0 80bc 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d1a <??ZbZclAttrDefaultValue_72>:
 8001d1a:	495f      	ldr	r1, [pc, #380]	; (8001e98 <??DataTable1>)
 8001d1c:	4640      	mov	r0, r8
 8001d1e:	f7fe fa9b 	bl	8000258 <putle32>
 8001d22:	2004      	movs	r0, #4
 8001d24:	0007      	movs	r7, r0
 8001d26:	e0b4      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d28 <??ZbZclAttrDefaultValue_28>:
 8001d28:	2d08      	cmp	r5, #8
 8001d2a:	f0c0 80b2 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d2e <??ZbZclAttrDefaultValue_73>:
 8001d2e:	f07f 0201 	mvns.w	r2, #1
 8001d32:	4b5a      	ldr	r3, [pc, #360]	; (8001e9c <??DataTable1_1>)
 8001d34:	4640      	mov	r0, r8
 8001d36:	f7fe fac2 	bl	80002be <putle64>
 8001d3a:	2008      	movs	r0, #8
 8001d3c:	0007      	movs	r7, r0
 8001d3e:	e0a8      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d40 <??ZbZclAttrDefaultValue_29>:
 8001d40:	2d02      	cmp	r5, #2
 8001d42:	f0c0 80a6 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d46 <??ZbZclAttrDefaultValue_74>:
 8001d46:	21ff      	movs	r1, #255	; 0xff
 8001d48:	4640      	mov	r0, r8
 8001d4a:	f7fe fa73 	bl	8000234 <putle16>
 8001d4e:	2002      	movs	r0, #2
 8001d50:	0007      	movs	r7, r0
 8001d52:	e09e      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d54 <??ZbZclAttrDefaultValue_30>:
 8001d54:	2d02      	cmp	r5, #2
 8001d56:	f0c0 809c 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d5a <??ZbZclAttrDefaultValue_75>:
 8001d5a:	21ff      	movs	r1, #255	; 0xff
 8001d5c:	4640      	mov	r0, r8
 8001d5e:	f7fe fa69 	bl	8000234 <putle16>
 8001d62:	2002      	movs	r0, #2
 8001d64:	0007      	movs	r7, r0
 8001d66:	e094      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d68 <??ZbZclAttrDefaultValue_31>:
 8001d68:	2d04      	cmp	r5, #4
 8001d6a:	f0c0 8092 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d6e <??ZbZclAttrDefaultValue_76>:
 8001d6e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001d72:	4640      	mov	r0, r8
 8001d74:	f7fe fa70 	bl	8000258 <putle32>
 8001d78:	2004      	movs	r0, #4
 8001d7a:	0007      	movs	r7, r0
 8001d7c:	e089      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d7e <??ZbZclAttrDefaultValue_32>:
 8001d7e:	2d04      	cmp	r5, #4
 8001d80:	f0c0 8087 	bcc.w	8001e92 <??ZbZclAttrDefaultValue_45>

08001d84 <??ZbZclAttrDefaultValue_77>:
 8001d84:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001d88:	4640      	mov	r0, r8
 8001d8a:	f7fe fa65 	bl	8000258 <putle32>
 8001d8e:	2004      	movs	r0, #4
 8001d90:	0007      	movs	r7, r0
 8001d92:	e07e      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d94 <??ZbZclAttrDefaultValue_43>:
 8001d94:	2d08      	cmp	r5, #8
 8001d96:	d37c      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001d98 <??ZbZclAttrDefaultValue_78>:
 8001d98:	f05f 32ff 	movs.w	r2, #4294967295	; 0xffffffff
 8001d9c:	f05f 33ff 	movs.w	r3, #4294967295	; 0xffffffff
 8001da0:	4640      	mov	r0, r8
 8001da2:	f7fe fa8c 	bl	80002be <putle64>
 8001da6:	2008      	movs	r0, #8
 8001da8:	0007      	movs	r7, r0
 8001daa:	e072      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001dac <??ZbZclAttrDefaultValue_44>:
 8001dac:	2d10      	cmp	r5, #16
 8001dae:	d370      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001db0 <??ZbZclAttrDefaultValue_79>:
 8001db0:	f05f 0910 	movs.w	r9, #16
 8001db4:	f05f 0a00 	movs.w	sl, #0
 8001db8:	46c3      	mov	fp, r8
 8001dba:	4652      	mov	r2, sl
 8001dbc:	4649      	mov	r1, r9
 8001dbe:	4658      	mov	r0, fp
 8001dc0:	f003 fe51 	bl	8005a66 <__aeabi_memset>
 8001dc4:	2010      	movs	r0, #16
 8001dc6:	0007      	movs	r7, r0
 8001dc8:	e063      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001dca <??ZbZclAttrDefaultValue_33>:
 8001dca:	2d02      	cmp	r5, #2
 8001dcc:	d361      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001dce <??ZbZclAttrDefaultValue_80>:
 8001dce:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001dd2:	4640      	mov	r0, r8
 8001dd4:	f7fe fa2e 	bl	8000234 <putle16>
 8001dd8:	2002      	movs	r0, #2
 8001dda:	0007      	movs	r7, r0
 8001ddc:	e059      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001dde <??ZbZclAttrDefaultValue_34>:
 8001dde:	2d02      	cmp	r5, #2
 8001de0:	d357      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001de2 <??ZbZclAttrDefaultValue_81>:
 8001de2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001de6:	4640      	mov	r0, r8
 8001de8:	f7fe fa24 	bl	8000234 <putle16>
 8001dec:	2002      	movs	r0, #2
 8001dee:	0007      	movs	r7, r0
 8001df0:	e04f      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001df2 <??ZbZclAttrDefaultValue_35>:
 8001df2:	2d02      	cmp	r5, #2
 8001df4:	d34d      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001df6 <??ZbZclAttrDefaultValue_82>:
 8001df6:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001dfa:	4640      	mov	r0, r8
 8001dfc:	f7fe fa1a 	bl	8000234 <putle16>
 8001e00:	2002      	movs	r0, #2
 8001e02:	0007      	movs	r7, r0
 8001e04:	e045      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e06 <??ZbZclAttrDefaultValue_36>:
 8001e06:	2d02      	cmp	r5, #2
 8001e08:	d343      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e0a <??ZbZclAttrDefaultValue_83>:
 8001e0a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001e0e:	4640      	mov	r0, r8
 8001e10:	f7fe fa10 	bl	8000234 <putle16>
 8001e14:	2002      	movs	r0, #2
 8001e16:	0007      	movs	r7, r0
 8001e18:	e03b      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e1a <??ZbZclAttrDefaultValue_37>:
 8001e1a:	2d04      	cmp	r5, #4
 8001e1c:	d339      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e1e <??ZbZclAttrDefaultValue_84>:
 8001e1e:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8001e22:	4640      	mov	r0, r8
 8001e24:	f7fe fa18 	bl	8000258 <putle32>
 8001e28:	2004      	movs	r0, #4
 8001e2a:	0007      	movs	r7, r0
 8001e2c:	e031      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e2e <??ZbZclAttrDefaultValue_38>:
 8001e2e:	2d04      	cmp	r5, #4
 8001e30:	d32f      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e32 <??ZbZclAttrDefaultValue_85>:
 8001e32:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8001e36:	4640      	mov	r0, r8
 8001e38:	f7fe fa0e 	bl	8000258 <putle32>
 8001e3c:	2004      	movs	r0, #4
 8001e3e:	0007      	movs	r7, r0
 8001e40:	e027      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e42 <??ZbZclAttrDefaultValue_39>:
 8001e42:	2d04      	cmp	r5, #4
 8001e44:	d325      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e46 <??ZbZclAttrDefaultValue_86>:
 8001e46:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8001e4a:	4640      	mov	r0, r8
 8001e4c:	f7fe fa04 	bl	8000258 <putle32>
 8001e50:	2004      	movs	r0, #4
 8001e52:	0007      	movs	r7, r0
 8001e54:	e01d      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e56 <??ZbZclAttrDefaultValue_40>:
 8001e56:	2d02      	cmp	r5, #2
 8001e58:	d31b      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e5a <??ZbZclAttrDefaultValue_87>:
 8001e5a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001e5e:	4640      	mov	r0, r8
 8001e60:	f7fe f9e8 	bl	8000234 <putle16>
 8001e64:	2002      	movs	r0, #2
 8001e66:	0007      	movs	r7, r0
 8001e68:	e013      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e6a <??ZbZclAttrDefaultValue_41>:
 8001e6a:	2d02      	cmp	r5, #2
 8001e6c:	d311      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e6e <??ZbZclAttrDefaultValue_88>:
 8001e6e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001e72:	4640      	mov	r0, r8
 8001e74:	f7fe f9de 	bl	8000234 <putle16>
 8001e78:	2002      	movs	r0, #2
 8001e7a:	0007      	movs	r7, r0
 8001e7c:	e009      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e7e <??ZbZclAttrDefaultValue_42>:
 8001e7e:	2d04      	cmp	r5, #4
 8001e80:	d307      	bcc.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e82 <??ZbZclAttrDefaultValue_89>:
 8001e82:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8001e86:	4640      	mov	r0, r8
 8001e88:	f7fe f9e6 	bl	8000258 <putle32>
 8001e8c:	2004      	movs	r0, #4
 8001e8e:	0007      	movs	r7, r0
 8001e90:	e7ff      	b.n	8001e92 <??ZbZclAttrDefaultValue_45>

08001e92 <??ZbZclAttrDefaultValue_45>:
 8001e92:	0038      	movs	r0, r7
 8001e94:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001e98 <??DataTable1>:
 8001e98:	fffe 00ff                                   ....

08001e9c <??DataTable1_1>:
 8001e9c:	ffff 001f                                   ....

08001ea0 <ZbZclAttrTypeLength>:
 8001ea0:	0001      	movs	r1, r0
 8001ea2:	0008      	movs	r0, r1
 8001ea4:	b2c0      	uxtb	r0, r0
 8001ea6:	2800      	cmp	r0, #0
 8001ea8:	f000 8081 	beq.w	8001fae <??ZbZclAttrTypeLength_0>
 8001eac:	2808      	cmp	r0, #8
 8001eae:	d06c      	beq.n	8001f8a <??ZbZclAttrTypeLength_1>
 8001eb0:	2809      	cmp	r0, #9
 8001eb2:	d06c      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001eb4:	280a      	cmp	r0, #10
 8001eb6:	d06c      	beq.n	8001f92 <??ZbZclAttrTypeLength_3>
 8001eb8:	280b      	cmp	r0, #11
 8001eba:	d06c      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001ebc:	280c      	cmp	r0, #12
 8001ebe:	d06c      	beq.n	8001f9a <??ZbZclAttrTypeLength_5>
 8001ec0:	280d      	cmp	r0, #13
 8001ec2:	d06c      	beq.n	8001f9e <??ZbZclAttrTypeLength_6>
 8001ec4:	280e      	cmp	r0, #14
 8001ec6:	d06c      	beq.n	8001fa2 <??ZbZclAttrTypeLength_7>
 8001ec8:	280f      	cmp	r0, #15
 8001eca:	d06c      	beq.n	8001fa6 <??ZbZclAttrTypeLength_8>
 8001ecc:	2810      	cmp	r0, #16
 8001ece:	d05c      	beq.n	8001f8a <??ZbZclAttrTypeLength_1>
 8001ed0:	2818      	cmp	r0, #24
 8001ed2:	d05a      	beq.n	8001f8a <??ZbZclAttrTypeLength_1>
 8001ed4:	2819      	cmp	r0, #25
 8001ed6:	d05a      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001ed8:	281a      	cmp	r0, #26
 8001eda:	d05a      	beq.n	8001f92 <??ZbZclAttrTypeLength_3>
 8001edc:	281b      	cmp	r0, #27
 8001ede:	d05a      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001ee0:	281c      	cmp	r0, #28
 8001ee2:	d05a      	beq.n	8001f9a <??ZbZclAttrTypeLength_5>
 8001ee4:	281d      	cmp	r0, #29
 8001ee6:	d05a      	beq.n	8001f9e <??ZbZclAttrTypeLength_6>
 8001ee8:	281e      	cmp	r0, #30
 8001eea:	d05a      	beq.n	8001fa2 <??ZbZclAttrTypeLength_7>
 8001eec:	281f      	cmp	r0, #31
 8001eee:	d05a      	beq.n	8001fa6 <??ZbZclAttrTypeLength_8>
 8001ef0:	2820      	cmp	r0, #32
 8001ef2:	d04a      	beq.n	8001f8a <??ZbZclAttrTypeLength_1>
 8001ef4:	2821      	cmp	r0, #33	; 0x21
 8001ef6:	d04a      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001ef8:	2822      	cmp	r0, #34	; 0x22
 8001efa:	d04a      	beq.n	8001f92 <??ZbZclAttrTypeLength_3>
 8001efc:	2823      	cmp	r0, #35	; 0x23
 8001efe:	d04a      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f00:	2824      	cmp	r0, #36	; 0x24
 8001f02:	d04a      	beq.n	8001f9a <??ZbZclAttrTypeLength_5>
 8001f04:	2825      	cmp	r0, #37	; 0x25
 8001f06:	d04a      	beq.n	8001f9e <??ZbZclAttrTypeLength_6>
 8001f08:	2826      	cmp	r0, #38	; 0x26
 8001f0a:	d04a      	beq.n	8001fa2 <??ZbZclAttrTypeLength_7>
 8001f0c:	2827      	cmp	r0, #39	; 0x27
 8001f0e:	d04a      	beq.n	8001fa6 <??ZbZclAttrTypeLength_8>
 8001f10:	2828      	cmp	r0, #40	; 0x28
 8001f12:	d03a      	beq.n	8001f8a <??ZbZclAttrTypeLength_1>
 8001f14:	2829      	cmp	r0, #41	; 0x29
 8001f16:	d03a      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001f18:	282a      	cmp	r0, #42	; 0x2a
 8001f1a:	d03a      	beq.n	8001f92 <??ZbZclAttrTypeLength_3>
 8001f1c:	282b      	cmp	r0, #43	; 0x2b
 8001f1e:	d03a      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f20:	282c      	cmp	r0, #44	; 0x2c
 8001f22:	d03a      	beq.n	8001f9a <??ZbZclAttrTypeLength_5>
 8001f24:	282d      	cmp	r0, #45	; 0x2d
 8001f26:	d03a      	beq.n	8001f9e <??ZbZclAttrTypeLength_6>
 8001f28:	282e      	cmp	r0, #46	; 0x2e
 8001f2a:	d03a      	beq.n	8001fa2 <??ZbZclAttrTypeLength_7>
 8001f2c:	282f      	cmp	r0, #47	; 0x2f
 8001f2e:	d03a      	beq.n	8001fa6 <??ZbZclAttrTypeLength_8>
 8001f30:	2830      	cmp	r0, #48	; 0x30
 8001f32:	d02a      	beq.n	8001f8a <??ZbZclAttrTypeLength_1>
 8001f34:	2831      	cmp	r0, #49	; 0x31
 8001f36:	d02a      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001f38:	2838      	cmp	r0, #56	; 0x38
 8001f3a:	d028      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001f3c:	2839      	cmp	r0, #57	; 0x39
 8001f3e:	d02a      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f40:	283a      	cmp	r0, #58	; 0x3a
 8001f42:	d030      	beq.n	8001fa6 <??ZbZclAttrTypeLength_8>
 8001f44:	2841      	cmp	r0, #65	; 0x41
 8001f46:	d032      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f48:	2842      	cmp	r0, #66	; 0x42
 8001f4a:	d030      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f4c:	2843      	cmp	r0, #67	; 0x43
 8001f4e:	d02e      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f50:	2844      	cmp	r0, #68	; 0x44
 8001f52:	d02c      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f54:	2848      	cmp	r0, #72	; 0x48
 8001f56:	d02a      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f58:	284c      	cmp	r0, #76	; 0x4c
 8001f5a:	d028      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f5c:	2850      	cmp	r0, #80	; 0x50
 8001f5e:	d026      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f60:	2851      	cmp	r0, #81	; 0x51
 8001f62:	d024      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f64:	28e0      	cmp	r0, #224	; 0xe0
 8001f66:	d016      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f68:	28e1      	cmp	r0, #225	; 0xe1
 8001f6a:	d014      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f6c:	28e2      	cmp	r0, #226	; 0xe2
 8001f6e:	d012      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f70:	28e8      	cmp	r0, #232	; 0xe8
 8001f72:	d00c      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001f74:	28e9      	cmp	r0, #233	; 0xe9
 8001f76:	d00a      	beq.n	8001f8e <??ZbZclAttrTypeLength_2>
 8001f78:	28ea      	cmp	r0, #234	; 0xea
 8001f7a:	d00c      	beq.n	8001f96 <??ZbZclAttrTypeLength_4>
 8001f7c:	28f0      	cmp	r0, #240	; 0xf0
 8001f7e:	d012      	beq.n	8001fa6 <??ZbZclAttrTypeLength_8>
 8001f80:	28f1      	cmp	r0, #241	; 0xf1
 8001f82:	d012      	beq.n	8001faa <??ZbZclAttrTypeLength_9>
 8001f84:	28ff      	cmp	r0, #255	; 0xff
 8001f86:	d012      	beq.n	8001fae <??ZbZclAttrTypeLength_0>
 8001f88:	e013      	b.n	8001fb2 <??ZbZclAttrTypeLength_10>

08001f8a <??ZbZclAttrTypeLength_1>:
 8001f8a:	2001      	movs	r0, #1
 8001f8c:	e012      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001f8e <??ZbZclAttrTypeLength_2>:
 8001f8e:	2002      	movs	r0, #2
 8001f90:	e010      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001f92 <??ZbZclAttrTypeLength_3>:
 8001f92:	2003      	movs	r0, #3
 8001f94:	e00e      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001f96 <??ZbZclAttrTypeLength_4>:
 8001f96:	2004      	movs	r0, #4
 8001f98:	e00c      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001f9a <??ZbZclAttrTypeLength_5>:
 8001f9a:	2005      	movs	r0, #5
 8001f9c:	e00a      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001f9e <??ZbZclAttrTypeLength_6>:
 8001f9e:	2006      	movs	r0, #6
 8001fa0:	e008      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001fa2 <??ZbZclAttrTypeLength_7>:
 8001fa2:	2007      	movs	r0, #7
 8001fa4:	e006      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001fa6 <??ZbZclAttrTypeLength_8>:
 8001fa6:	2008      	movs	r0, #8
 8001fa8:	e004      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001faa <??ZbZclAttrTypeLength_9>:
 8001faa:	2010      	movs	r0, #16
 8001fac:	e002      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001fae <??ZbZclAttrTypeLength_0>:
 8001fae:	2000      	movs	r0, #0
 8001fb0:	e000      	b.n	8001fb4 <??ZbZclAttrTypeLength_11>

08001fb2 <??ZbZclAttrTypeLength_10>:
 8001fb2:	2000      	movs	r0, #0

08001fb4 <??ZbZclAttrTypeLength_11>:
 8001fb4:	4770      	bx	lr

08001fb6 <ZbZclAttrParseLength>:
 8001fb6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001fba:	0006      	movs	r6, r0
 8001fbc:	000c      	movs	r4, r1
 8001fbe:	0015      	movs	r5, r2
 8001fc0:	001f      	movs	r7, r3
 8001fc2:	0038      	movs	r0, r7
 8001fc4:	b2c0      	uxtb	r0, r0
 8001fc6:	280f      	cmp	r0, #15
 8001fc8:	d302      	bcc.n	8001fd0 <??ZbZclAttrParseLength_0>
 8001fca:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8001fce:	e0a1      	b.n	8002114 <??ZbZclAttrParseLength_1>

08001fd0 <??ZbZclAttrParseLength_0>:
 8001fd0:	0030      	movs	r0, r6
 8001fd2:	b2c0      	uxtb	r0, r0
 8001fd4:	f7ff ff64 	bl	8001ea0 <ZbZclAttrTypeLength>
 8001fd8:	0001      	movs	r1, r0
 8001fda:	2901      	cmp	r1, #1
 8001fdc:	db06      	blt.n	8001fec <??ZbZclAttrParseLength_2>
 8001fde:	428d      	cmp	r5, r1
 8001fe0:	d202      	bcs.n	8001fe8 <??ZbZclAttrParseLength_3>
 8001fe2:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8001fe6:	e095      	b.n	8002114 <??ZbZclAttrParseLength_1>

08001fe8 <??ZbZclAttrParseLength_3>:
 8001fe8:	0008      	movs	r0, r1
 8001fea:	e093      	b.n	8002114 <??ZbZclAttrParseLength_1>

08001fec <??ZbZclAttrParseLength_2>:
 8001fec:	2c00      	cmp	r4, #0
 8001fee:	d101      	bne.n	8001ff4 <??ZbZclAttrParseLength_4>
 8001ff0:	0028      	movs	r0, r5
 8001ff2:	e08f      	b.n	8002114 <??ZbZclAttrParseLength_1>

08001ff4 <??ZbZclAttrParseLength_4>:
 8001ff4:	f05f 39ff 	movs.w	r9, #4294967295	; 0xffffffff
 8001ff8:	0030      	movs	r0, r6
 8001ffa:	b2c0      	uxtb	r0, r0
 8001ffc:	3841      	subs	r0, #65	; 0x41
 8001ffe:	2801      	cmp	r0, #1
 8002000:	d90a      	bls.n	8002018 <??ZbZclAttrParseLength_5>
 8002002:	1e80      	subs	r0, r0, #2
 8002004:	2801      	cmp	r0, #1
 8002006:	d914      	bls.n	8002032 <??ZbZclAttrParseLength_6>
 8002008:	1f40      	subs	r0, r0, #5
 800200a:	d027      	beq.n	800205c <??ZbZclAttrParseLength_7>
 800200c:	1f00      	subs	r0, r0, #4
 800200e:	d04b      	beq.n	80020a8 <??ZbZclAttrParseLength_8>
 8002010:	1f00      	subs	r0, r0, #4
 8002012:	2801      	cmp	r0, #1
 8002014:	d922      	bls.n	800205c <??ZbZclAttrParseLength_7>
 8002016:	e074      	b.n	8002102 <??ZbZclAttrParseLength_10>

08002018 <??ZbZclAttrParseLength_5>:
 8002018:	2d00      	cmp	r5, #0
 800201a:	d072      	beq.n	8002102 <??ZbZclAttrParseLength_10>

0800201c <??ZbZclAttrParseLength_11>:
 800201c:	7820      	ldrb	r0, [r4, #0]
 800201e:	28ff      	cmp	r0, #255	; 0xff
 8002020:	d102      	bne.n	8002028 <??ZbZclAttrParseLength_12>
 8002022:	f05f 0901 	movs.w	r9, #1
 8002026:	e003      	b.n	8002030 <??ZbZclAttrParseLength_13>

08002028 <??ZbZclAttrParseLength_12>:
 8002028:	f894 9000 	ldrb.w	r9, [r4]
 800202c:	f119 0901 	adds.w	r9, r9, #1

08002030 <??ZbZclAttrParseLength_13>:
 8002030:	e067      	b.n	8002102 <??ZbZclAttrParseLength_10>

08002032 <??ZbZclAttrParseLength_6>:
 8002032:	2d02      	cmp	r5, #2
 8002034:	d365      	bcc.n	8002102 <??ZbZclAttrParseLength_10>

08002036 <??ZbZclAttrParseLength_14>:
 8002036:	0020      	movs	r0, r4
 8002038:	f7fe f8b0 	bl	800019c <pletoh16>
 800203c:	4680      	mov	r8, r0
 800203e:	4640      	mov	r0, r8
 8002040:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8002044:	b280      	uxth	r0, r0
 8002046:	4288      	cmp	r0, r1
 8002048:	d102      	bne.n	8002050 <??ZbZclAttrParseLength_15>
 800204a:	f05f 0902 	movs.w	r9, #2
 800204e:	e004      	b.n	800205a <??ZbZclAttrParseLength_16>

08002050 <??ZbZclAttrParseLength_15>:
 8002050:	46c1      	mov	r9, r8
 8002052:	fa1f f989 	uxth.w	r9, r9
 8002056:	f119 0902 	adds.w	r9, r9, #2

0800205a <??ZbZclAttrParseLength_16>:
 800205a:	e052      	b.n	8002102 <??ZbZclAttrParseLength_10>

0800205c <??ZbZclAttrParseLength_7>:
 800205c:	2d03      	cmp	r5, #3
 800205e:	d350      	bcc.n	8002102 <??ZbZclAttrParseLength_10>

08002060 <??ZbZclAttrParseLength_17>:
 8002060:	7820      	ldrb	r0, [r4, #0]
 8002062:	4683      	mov	fp, r0
 8002064:	1c60      	adds	r0, r4, #1
 8002066:	f7fe f899 	bl	800019c <pletoh16>
 800206a:	4680      	mov	r8, r0
 800206c:	2003      	movs	r0, #3
 800206e:	4681      	mov	r9, r0

08002070 <??ZbZclAttrParseLength_18>:
 8002070:	4640      	mov	r0, r8
 8002072:	b280      	uxth	r0, r0
 8002074:	2800      	cmp	r0, #0
 8002076:	d016      	beq.n	80020a6 <??ZbZclAttrParseLength_19>
 8002078:	f64f 7aff 	movw	sl, #65535	; 0xffff
 800207c:	4640      	mov	r0, r8
 800207e:	b280      	uxth	r0, r0
 8002080:	4550      	cmp	r0, sl
 8002082:	d010      	beq.n	80020a6 <??ZbZclAttrParseLength_19>
 8002084:	1c7b      	adds	r3, r7, #1
 8002086:	b2db      	uxtb	r3, r3
 8002088:	ebb5 0209 	subs.w	r2, r5, r9
 800208c:	eb04 0109 	add.w	r1, r4, r9
 8002090:	4658      	mov	r0, fp
 8002092:	b2c0      	uxtb	r0, r0
 8002094:	f7ff ff8f 	bl	8001fb6 <ZbZclAttrParseLength>
 8002098:	2800      	cmp	r0, #0
 800209a:	d43b      	bmi.n	8002114 <??ZbZclAttrParseLength_1>

0800209c <??ZbZclAttrParseLength_20>:
 800209c:	eb10 0909 	adds.w	r9, r0, r9
 80020a0:	eb1a 0808 	adds.w	r8, sl, r8
 80020a4:	e7e4      	b.n	8002070 <??ZbZclAttrParseLength_18>

080020a6 <??ZbZclAttrParseLength_19>:
 80020a6:	e02c      	b.n	8002102 <??ZbZclAttrParseLength_10>

080020a8 <??ZbZclAttrParseLength_8>:
 80020a8:	2d02      	cmp	r5, #2
 80020aa:	d32a      	bcc.n	8002102 <??ZbZclAttrParseLength_10>

080020ac <??ZbZclAttrParseLength_21>:
 80020ac:	0020      	movs	r0, r4
 80020ae:	f7fe f875 	bl	800019c <pletoh16>
 80020b2:	4680      	mov	r8, r0
 80020b4:	2002      	movs	r0, #2
 80020b6:	4681      	mov	r9, r0

080020b8 <??ZbZclAttrParseLength_22>:
 80020b8:	4640      	mov	r0, r8
 80020ba:	b280      	uxth	r0, r0
 80020bc:	2800      	cmp	r0, #0
 80020be:	d01f      	beq.n	8002100 <??ZbZclAttrParseLength_23>
 80020c0:	f64f 7aff 	movw	sl, #65535	; 0xffff
 80020c4:	4640      	mov	r0, r8
 80020c6:	b280      	uxth	r0, r0
 80020c8:	4550      	cmp	r0, sl
 80020ca:	d019      	beq.n	8002100 <??ZbZclAttrParseLength_23>
 80020cc:	f119 0001 	adds.w	r0, r9, #1
 80020d0:	4285      	cmp	r5, r0
 80020d2:	d315      	bcc.n	8002100 <??ZbZclAttrParseLength_23>

080020d4 <??ZbZclAttrParseLength_24>:
 80020d4:	f814 0009 	ldrb.w	r0, [r4, r9]
 80020d8:	4683      	mov	fp, r0
 80020da:	f119 0901 	adds.w	r9, r9, #1
 80020de:	1c7b      	adds	r3, r7, #1
 80020e0:	b2db      	uxtb	r3, r3
 80020e2:	ebb5 0209 	subs.w	r2, r5, r9
 80020e6:	eb04 0109 	add.w	r1, r4, r9
 80020ea:	4658      	mov	r0, fp
 80020ec:	b2c0      	uxtb	r0, r0
 80020ee:	f7ff ff62 	bl	8001fb6 <ZbZclAttrParseLength>
 80020f2:	2800      	cmp	r0, #0
 80020f4:	d404      	bmi.n	8002100 <??ZbZclAttrParseLength_23>

080020f6 <??ZbZclAttrParseLength_25>:
 80020f6:	eb10 0909 	adds.w	r9, r0, r9
 80020fa:	eb1a 0808 	adds.w	r8, sl, r8
 80020fe:	e7db      	b.n	80020b8 <??ZbZclAttrParseLength_22>

08002100 <??ZbZclAttrParseLength_23>:
 8002100:	e7ff      	b.n	8002102 <??ZbZclAttrParseLength_10>

08002102 <??ZbZclAttrParseLength_10>:
 8002102:	f1b9 0f00 	cmp.w	r9, #0
 8002106:	d401      	bmi.n	800210c <??ZbZclAttrParseLength_26>
 8002108:	454d      	cmp	r5, r9
 800210a:	d202      	bcs.n	8002112 <??ZbZclAttrParseLength_27>

0800210c <??ZbZclAttrParseLength_26>:
 800210c:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8002110:	e000      	b.n	8002114 <??ZbZclAttrParseLength_1>

08002112 <??ZbZclAttrParseLength_27>:
 8002112:	4648      	mov	r0, r9

08002114 <??ZbZclAttrParseLength_1>:
 8002114:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002118 <ZbZclAttrIsAnalog>:
 8002118:	0001      	movs	r1, r0
 800211a:	0008      	movs	r0, r1
 800211c:	b2c0      	uxtb	r0, r0
 800211e:	2820      	cmp	r0, #32
 8002120:	db05      	blt.n	800212e <??ZbZclAttrIsAnalog_0>
 8002122:	0008      	movs	r0, r1
 8002124:	b2c0      	uxtb	r0, r0
 8002126:	2828      	cmp	r0, #40	; 0x28
 8002128:	da01      	bge.n	800212e <??ZbZclAttrIsAnalog_0>
 800212a:	2001      	movs	r0, #1
 800212c:	e026      	b.n	800217c <??ZbZclAttrIsAnalog_1>

0800212e <??ZbZclAttrIsAnalog_0>:
 800212e:	0008      	movs	r0, r1
 8002130:	b2c0      	uxtb	r0, r0
 8002132:	2828      	cmp	r0, #40	; 0x28
 8002134:	db05      	blt.n	8002142 <??ZbZclAttrIsAnalog_2>
 8002136:	0008      	movs	r0, r1
 8002138:	b2c0      	uxtb	r0, r0
 800213a:	2830      	cmp	r0, #48	; 0x30
 800213c:	da01      	bge.n	8002142 <??ZbZclAttrIsAnalog_2>
 800213e:	2001      	movs	r0, #1
 8002140:	e01c      	b.n	800217c <??ZbZclAttrIsAnalog_1>

08002142 <??ZbZclAttrIsAnalog_2>:
 8002142:	0008      	movs	r0, r1
 8002144:	b2c0      	uxtb	r0, r0
 8002146:	2838      	cmp	r0, #56	; 0x38
 8002148:	d007      	beq.n	800215a <??ZbZclAttrIsAnalog_3>
 800214a:	0008      	movs	r0, r1
 800214c:	b2c0      	uxtb	r0, r0
 800214e:	2839      	cmp	r0, #57	; 0x39
 8002150:	d003      	beq.n	800215a <??ZbZclAttrIsAnalog_3>
 8002152:	0008      	movs	r0, r1
 8002154:	b2c0      	uxtb	r0, r0
 8002156:	283a      	cmp	r0, #58	; 0x3a
 8002158:	d101      	bne.n	800215e <??ZbZclAttrIsAnalog_4>

0800215a <??ZbZclAttrIsAnalog_3>:
 800215a:	2001      	movs	r0, #1
 800215c:	e00e      	b.n	800217c <??ZbZclAttrIsAnalog_1>

0800215e <??ZbZclAttrIsAnalog_4>:
 800215e:	0008      	movs	r0, r1
 8002160:	b2c0      	uxtb	r0, r0
 8002162:	28e0      	cmp	r0, #224	; 0xe0
 8002164:	d007      	beq.n	8002176 <??ZbZclAttrIsAnalog_5>
 8002166:	0008      	movs	r0, r1
 8002168:	b2c0      	uxtb	r0, r0
 800216a:	28e1      	cmp	r0, #225	; 0xe1
 800216c:	d003      	beq.n	8002176 <??ZbZclAttrIsAnalog_5>
 800216e:	0008      	movs	r0, r1
 8002170:	b2c0      	uxtb	r0, r0
 8002172:	28e2      	cmp	r0, #226	; 0xe2
 8002174:	d101      	bne.n	800217a <??ZbZclAttrIsAnalog_6>

08002176 <??ZbZclAttrIsAnalog_5>:
 8002176:	2001      	movs	r0, #1
 8002178:	e000      	b.n	800217c <??ZbZclAttrIsAnalog_1>

0800217a <??ZbZclAttrIsAnalog_6>:
 800217a:	2000      	movs	r0, #0

0800217c <??ZbZclAttrIsAnalog_1>:
 800217c:	4770      	bx	lr
	...

08002180 <ZbZclAppendInteger>:
 8002180:	b4f0      	push	{r4, r5, r6, r7}
 8002182:	0004      	movs	r4, r0
 8002184:	000d      	movs	r5, r1
 8002186:	9904      	ldr	r1, [sp, #16]
 8002188:	2700      	movs	r7, #0
 800218a:	2600      	movs	r6, #0
 800218c:	0010      	movs	r0, r2
 800218e:	b2c0      	uxtb	r0, r0
 8002190:	2808      	cmp	r0, #8
 8002192:	f000 80b2 	beq.w	80022fa <??ZbZclAppendInteger_0>
 8002196:	2809      	cmp	r0, #9
 8002198:	f000 80a4 	beq.w	80022e4 <??ZbZclAppendInteger_1>
 800219c:	280a      	cmp	r0, #10
 800219e:	f000 8096 	beq.w	80022ce <??ZbZclAppendInteger_2>
 80021a2:	280b      	cmp	r0, #11
 80021a4:	f000 8088 	beq.w	80022b8 <??ZbZclAppendInteger_3>
 80021a8:	280c      	cmp	r0, #12
 80021aa:	d07a      	beq.n	80022a2 <??ZbZclAppendInteger_4>
 80021ac:	280d      	cmp	r0, #13
 80021ae:	d06d      	beq.n	800228c <??ZbZclAppendInteger_5>
 80021b0:	280e      	cmp	r0, #14
 80021b2:	d060      	beq.n	8002276 <??ZbZclAppendInteger_6>
 80021b4:	280f      	cmp	r0, #15
 80021b6:	d053      	beq.n	8002260 <??ZbZclAppendInteger_7>
 80021b8:	2810      	cmp	r0, #16
 80021ba:	d042      	beq.n	8002242 <??ZbZclAppendInteger_8>
 80021bc:	2818      	cmp	r0, #24
 80021be:	f000 809c 	beq.w	80022fa <??ZbZclAppendInteger_0>
 80021c2:	2819      	cmp	r0, #25
 80021c4:	f000 808e 	beq.w	80022e4 <??ZbZclAppendInteger_1>
 80021c8:	281a      	cmp	r0, #26
 80021ca:	f000 8080 	beq.w	80022ce <??ZbZclAppendInteger_2>
 80021ce:	281b      	cmp	r0, #27
 80021d0:	d072      	beq.n	80022b8 <??ZbZclAppendInteger_3>
 80021d2:	281c      	cmp	r0, #28
 80021d4:	d065      	beq.n	80022a2 <??ZbZclAppendInteger_4>
 80021d6:	281d      	cmp	r0, #29
 80021d8:	d058      	beq.n	800228c <??ZbZclAppendInteger_5>
 80021da:	281e      	cmp	r0, #30
 80021dc:	d04b      	beq.n	8002276 <??ZbZclAppendInteger_6>
 80021de:	281f      	cmp	r0, #31
 80021e0:	d03e      	beq.n	8002260 <??ZbZclAppendInteger_7>
 80021e2:	2820      	cmp	r0, #32
 80021e4:	f000 8089 	beq.w	80022fa <??ZbZclAppendInteger_0>
 80021e8:	2821      	cmp	r0, #33	; 0x21
 80021ea:	d07b      	beq.n	80022e4 <??ZbZclAppendInteger_1>
 80021ec:	2822      	cmp	r0, #34	; 0x22
 80021ee:	d06e      	beq.n	80022ce <??ZbZclAppendInteger_2>
 80021f0:	2823      	cmp	r0, #35	; 0x23
 80021f2:	d061      	beq.n	80022b8 <??ZbZclAppendInteger_3>
 80021f4:	2824      	cmp	r0, #36	; 0x24
 80021f6:	d054      	beq.n	80022a2 <??ZbZclAppendInteger_4>
 80021f8:	2825      	cmp	r0, #37	; 0x25
 80021fa:	d047      	beq.n	800228c <??ZbZclAppendInteger_5>
 80021fc:	2826      	cmp	r0, #38	; 0x26
 80021fe:	d03a      	beq.n	8002276 <??ZbZclAppendInteger_6>
 8002200:	2827      	cmp	r0, #39	; 0x27
 8002202:	d02d      	beq.n	8002260 <??ZbZclAppendInteger_7>
 8002204:	2828      	cmp	r0, #40	; 0x28
 8002206:	d078      	beq.n	80022fa <??ZbZclAppendInteger_0>
 8002208:	2829      	cmp	r0, #41	; 0x29
 800220a:	d06b      	beq.n	80022e4 <??ZbZclAppendInteger_1>
 800220c:	282a      	cmp	r0, #42	; 0x2a
 800220e:	d05e      	beq.n	80022ce <??ZbZclAppendInteger_2>
 8002210:	282b      	cmp	r0, #43	; 0x2b
 8002212:	d051      	beq.n	80022b8 <??ZbZclAppendInteger_3>
 8002214:	282c      	cmp	r0, #44	; 0x2c
 8002216:	d044      	beq.n	80022a2 <??ZbZclAppendInteger_4>
 8002218:	282d      	cmp	r0, #45	; 0x2d
 800221a:	d037      	beq.n	800228c <??ZbZclAppendInteger_5>
 800221c:	282e      	cmp	r0, #46	; 0x2e
 800221e:	d02a      	beq.n	8002276 <??ZbZclAppendInteger_6>
 8002220:	282f      	cmp	r0, #47	; 0x2f
 8002222:	d01d      	beq.n	8002260 <??ZbZclAppendInteger_7>
 8002224:	2830      	cmp	r0, #48	; 0x30
 8002226:	d068      	beq.n	80022fa <??ZbZclAppendInteger_0>
 8002228:	2831      	cmp	r0, #49	; 0x31
 800222a:	d05b      	beq.n	80022e4 <??ZbZclAppendInteger_1>
 800222c:	28e2      	cmp	r0, #226	; 0xe2
 800222e:	d043      	beq.n	80022b8 <??ZbZclAppendInteger_3>
 8002230:	28e8      	cmp	r0, #232	; 0xe8
 8002232:	d057      	beq.n	80022e4 <??ZbZclAppendInteger_1>
 8002234:	28e9      	cmp	r0, #233	; 0xe9
 8002236:	d055      	beq.n	80022e4 <??ZbZclAppendInteger_1>
 8002238:	28ea      	cmp	r0, #234	; 0xea
 800223a:	d03d      	beq.n	80022b8 <??ZbZclAppendInteger_3>
 800223c:	28f0      	cmp	r0, #240	; 0xf0
 800223e:	d00f      	beq.n	8002260 <??ZbZclAppendInteger_7>
 8002240:	e064      	b.n	800230c <??ZbZclAppendInteger_9>

08002242 <??ZbZclAppendInteger_8>:
 8002242:	2900      	cmp	r1, #0
 8002244:	d102      	bne.n	800224c <??ZbZclAppendInteger_10>
 8002246:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 800224a:	e061      	b.n	8002310 <??ZbZclAppendInteger_11>

0800224c <??ZbZclAppendInteger_10>:
 800224c:	2d00      	cmp	r5, #0
 800224e:	d101      	bne.n	8002254 <??ZbZclAppendInteger_12>
 8002250:	2c00      	cmp	r4, #0
 8002252:	d001      	beq.n	8002258 <??ZbZclAppendInteger_13>

08002254 <??ZbZclAppendInteger_12>:
 8002254:	2001      	movs	r0, #1
 8002256:	e000      	b.n	800225a <??ZbZclAppendInteger_14>

08002258 <??ZbZclAppendInteger_13>:
 8002258:	2000      	movs	r0, #0

0800225a <??ZbZclAppendInteger_14>:
 800225a:	7018      	strb	r0, [r3, #0]
 800225c:	2001      	movs	r0, #1
 800225e:	e057      	b.n	8002310 <??ZbZclAppendInteger_11>

08002260 <??ZbZclAppendInteger_7>:
 8002260:	428f      	cmp	r7, r1
 8002262:	d302      	bcc.n	800226a <??ZbZclAppendInteger_15>
 8002264:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8002268:	e052      	b.n	8002310 <??ZbZclAppendInteger_11>

0800226a <??ZbZclAppendInteger_15>:
 800226a:	55dc      	strb	r4, [r3, r7]
 800226c:	1c7f      	adds	r7, r7, #1
 800226e:	0a24      	lsrs	r4, r4, #8
 8002270:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 8002274:	0a2d      	lsrs	r5, r5, #8

08002276 <??ZbZclAppendInteger_6>:
 8002276:	428f      	cmp	r7, r1
 8002278:	d302      	bcc.n	8002280 <??ZbZclAppendInteger_16>
 800227a:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 800227e:	e047      	b.n	8002310 <??ZbZclAppendInteger_11>

08002280 <??ZbZclAppendInteger_16>:
 8002280:	55dc      	strb	r4, [r3, r7]
 8002282:	1c7f      	adds	r7, r7, #1
 8002284:	0a24      	lsrs	r4, r4, #8
 8002286:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 800228a:	0a2d      	lsrs	r5, r5, #8

0800228c <??ZbZclAppendInteger_5>:
 800228c:	428f      	cmp	r7, r1
 800228e:	d302      	bcc.n	8002296 <??ZbZclAppendInteger_17>
 8002290:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8002294:	e03c      	b.n	8002310 <??ZbZclAppendInteger_11>

08002296 <??ZbZclAppendInteger_17>:
 8002296:	55dc      	strb	r4, [r3, r7]
 8002298:	1c7f      	adds	r7, r7, #1
 800229a:	0a24      	lsrs	r4, r4, #8
 800229c:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80022a0:	0a2d      	lsrs	r5, r5, #8

080022a2 <??ZbZclAppendInteger_4>:
 80022a2:	428f      	cmp	r7, r1
 80022a4:	d302      	bcc.n	80022ac <??ZbZclAppendInteger_18>
 80022a6:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80022aa:	e031      	b.n	8002310 <??ZbZclAppendInteger_11>

080022ac <??ZbZclAppendInteger_18>:
 80022ac:	55dc      	strb	r4, [r3, r7]
 80022ae:	1c7f      	adds	r7, r7, #1
 80022b0:	0a24      	lsrs	r4, r4, #8
 80022b2:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80022b6:	0a2d      	lsrs	r5, r5, #8

080022b8 <??ZbZclAppendInteger_3>:
 80022b8:	428f      	cmp	r7, r1
 80022ba:	d302      	bcc.n	80022c2 <??ZbZclAppendInteger_19>
 80022bc:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80022c0:	e026      	b.n	8002310 <??ZbZclAppendInteger_11>

080022c2 <??ZbZclAppendInteger_19>:
 80022c2:	55dc      	strb	r4, [r3, r7]
 80022c4:	1c7f      	adds	r7, r7, #1
 80022c6:	0a24      	lsrs	r4, r4, #8
 80022c8:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80022cc:	0a2d      	lsrs	r5, r5, #8

080022ce <??ZbZclAppendInteger_2>:
 80022ce:	428f      	cmp	r7, r1
 80022d0:	d302      	bcc.n	80022d8 <??ZbZclAppendInteger_20>
 80022d2:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80022d6:	e01b      	b.n	8002310 <??ZbZclAppendInteger_11>

080022d8 <??ZbZclAppendInteger_20>:
 80022d8:	55dc      	strb	r4, [r3, r7]
 80022da:	1c7f      	adds	r7, r7, #1
 80022dc:	0a24      	lsrs	r4, r4, #8
 80022de:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80022e2:	0a2d      	lsrs	r5, r5, #8

080022e4 <??ZbZclAppendInteger_1>:
 80022e4:	428f      	cmp	r7, r1
 80022e6:	d302      	bcc.n	80022ee <??ZbZclAppendInteger_21>
 80022e8:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80022ec:	e010      	b.n	8002310 <??ZbZclAppendInteger_11>

080022ee <??ZbZclAppendInteger_21>:
 80022ee:	55dc      	strb	r4, [r3, r7]
 80022f0:	1c7f      	adds	r7, r7, #1
 80022f2:	0a24      	lsrs	r4, r4, #8
 80022f4:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80022f8:	0a2d      	lsrs	r5, r5, #8

080022fa <??ZbZclAppendInteger_0>:
 80022fa:	428f      	cmp	r7, r1
 80022fc:	d302      	bcc.n	8002304 <??ZbZclAppendInteger_22>
 80022fe:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8002302:	e005      	b.n	8002310 <??ZbZclAppendInteger_11>

08002304 <??ZbZclAppendInteger_22>:
 8002304:	55dc      	strb	r4, [r3, r7]
 8002306:	1c7f      	adds	r7, r7, #1
 8002308:	0038      	movs	r0, r7
 800230a:	e001      	b.n	8002310 <??ZbZclAppendInteger_11>

0800230c <??ZbZclAppendInteger_9>:
 800230c:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff

08002310 <??ZbZclAppendInteger_11>:
 8002310:	bcf0      	pop	{r4, r5, r6, r7}
 8002312:	4770      	bx	lr

08002314 <ZbZclParseInteger>:
 8002314:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002318:	4683      	mov	fp, r0
 800231a:	000e      	movs	r6, r1
 800231c:	4692      	mov	sl, r2
 800231e:	2700      	movs	r7, #0
 8002320:	2400      	movs	r4, #0
 8002322:	2500      	movs	r5, #0
 8002324:	f05f 0800 	movs.w	r8, #0
 8002328:	f05f 0900 	movs.w	r9, #0
 800232c:	4658      	mov	r0, fp
 800232e:	b2c0      	uxtb	r0, r0
 8002330:	f000 f91e 	bl	8002570 <ZbZclAttrIsInteger>
 8002334:	2800      	cmp	r0, #0
 8002336:	d105      	bne.n	8002344 <??ZbZclParseInteger_0>
 8002338:	208d      	movs	r0, #141	; 0x8d
 800233a:	f88a 0000 	strb.w	r0, [sl]
 800233e:	2000      	movs	r0, #0
 8002340:	2100      	movs	r1, #0
 8002342:	e113      	b.n	800256c <??ZbZclParseInteger_1>

08002344 <??ZbZclParseInteger_0>:
 8002344:	2000      	movs	r0, #0
 8002346:	f88a 0000 	strb.w	r0, [sl]
 800234a:	4658      	mov	r0, fp
 800234c:	b2c0      	uxtb	r0, r0
 800234e:	2808      	cmp	r0, #8
 8002350:	f000 8097 	beq.w	8002482 <??ZbZclParseInteger_2>
 8002354:	2809      	cmp	r0, #9
 8002356:	f000 808a 	beq.w	800246e <??ZbZclParseInteger_3>
 800235a:	280a      	cmp	r0, #10
 800235c:	d07d      	beq.n	800245a <??ZbZclParseInteger_4>
 800235e:	280b      	cmp	r0, #11
 8002360:	d071      	beq.n	8002446 <??ZbZclParseInteger_5>
 8002362:	280c      	cmp	r0, #12
 8002364:	d065      	beq.n	8002432 <??ZbZclParseInteger_6>
 8002366:	280d      	cmp	r0, #13
 8002368:	d059      	beq.n	800241e <??ZbZclParseInteger_7>
 800236a:	280e      	cmp	r0, #14
 800236c:	d04d      	beq.n	800240a <??ZbZclParseInteger_8>
 800236e:	280f      	cmp	r0, #15
 8002370:	d046      	beq.n	8002400 <??ZbZclParseInteger_9>
 8002372:	2810      	cmp	r0, #16
 8002374:	f000 8085 	beq.w	8002482 <??ZbZclParseInteger_2>
 8002378:	2818      	cmp	r0, #24
 800237a:	f000 8082 	beq.w	8002482 <??ZbZclParseInteger_2>
 800237e:	2819      	cmp	r0, #25
 8002380:	d075      	beq.n	800246e <??ZbZclParseInteger_3>
 8002382:	281a      	cmp	r0, #26
 8002384:	d069      	beq.n	800245a <??ZbZclParseInteger_4>
 8002386:	281b      	cmp	r0, #27
 8002388:	d05d      	beq.n	8002446 <??ZbZclParseInteger_5>
 800238a:	281c      	cmp	r0, #28
 800238c:	d051      	beq.n	8002432 <??ZbZclParseInteger_6>
 800238e:	281d      	cmp	r0, #29
 8002390:	d045      	beq.n	800241e <??ZbZclParseInteger_7>
 8002392:	281e      	cmp	r0, #30
 8002394:	d039      	beq.n	800240a <??ZbZclParseInteger_8>
 8002396:	281f      	cmp	r0, #31
 8002398:	d032      	beq.n	8002400 <??ZbZclParseInteger_9>
 800239a:	2820      	cmp	r0, #32
 800239c:	d071      	beq.n	8002482 <??ZbZclParseInteger_2>
 800239e:	2821      	cmp	r0, #33	; 0x21
 80023a0:	d065      	beq.n	800246e <??ZbZclParseInteger_3>
 80023a2:	2822      	cmp	r0, #34	; 0x22
 80023a4:	d059      	beq.n	800245a <??ZbZclParseInteger_4>
 80023a6:	2823      	cmp	r0, #35	; 0x23
 80023a8:	d04d      	beq.n	8002446 <??ZbZclParseInteger_5>
 80023aa:	2824      	cmp	r0, #36	; 0x24
 80023ac:	d041      	beq.n	8002432 <??ZbZclParseInteger_6>
 80023ae:	2825      	cmp	r0, #37	; 0x25
 80023b0:	d035      	beq.n	800241e <??ZbZclParseInteger_7>
 80023b2:	2826      	cmp	r0, #38	; 0x26
 80023b4:	d029      	beq.n	800240a <??ZbZclParseInteger_8>
 80023b6:	2827      	cmp	r0, #39	; 0x27
 80023b8:	d022      	beq.n	8002400 <??ZbZclParseInteger_9>
 80023ba:	2828      	cmp	r0, #40	; 0x28
 80023bc:	f000 80ac 	beq.w	8002518 <??ZbZclParseInteger_10>
 80023c0:	2829      	cmp	r0, #41	; 0x29
 80023c2:	f000 809f 	beq.w	8002504 <??ZbZclParseInteger_11>
 80023c6:	282a      	cmp	r0, #42	; 0x2a
 80023c8:	f000 8092 	beq.w	80024f0 <??ZbZclParseInteger_12>
 80023cc:	282b      	cmp	r0, #43	; 0x2b
 80023ce:	f000 8085 	beq.w	80024dc <??ZbZclParseInteger_13>
 80023d2:	282c      	cmp	r0, #44	; 0x2c
 80023d4:	d078      	beq.n	80024c8 <??ZbZclParseInteger_14>
 80023d6:	282d      	cmp	r0, #45	; 0x2d
 80023d8:	d06c      	beq.n	80024b4 <??ZbZclParseInteger_15>
 80023da:	282e      	cmp	r0, #46	; 0x2e
 80023dc:	d060      	beq.n	80024a0 <??ZbZclParseInteger_16>
 80023de:	282f      	cmp	r0, #47	; 0x2f
 80023e0:	d059      	beq.n	8002496 <??ZbZclParseInteger_17>
 80023e2:	2830      	cmp	r0, #48	; 0x30
 80023e4:	d04d      	beq.n	8002482 <??ZbZclParseInteger_2>
 80023e6:	2831      	cmp	r0, #49	; 0x31
 80023e8:	d041      	beq.n	800246e <??ZbZclParseInteger_3>
 80023ea:	28e2      	cmp	r0, #226	; 0xe2
 80023ec:	d02b      	beq.n	8002446 <??ZbZclParseInteger_5>
 80023ee:	28e8      	cmp	r0, #232	; 0xe8
 80023f0:	d03d      	beq.n	800246e <??ZbZclParseInteger_3>
 80023f2:	28e9      	cmp	r0, #233	; 0xe9
 80023f4:	d03b      	beq.n	800246e <??ZbZclParseInteger_3>
 80023f6:	28ea      	cmp	r0, #234	; 0xea
 80023f8:	d025      	beq.n	8002446 <??ZbZclParseInteger_5>
 80023fa:	28f0      	cmp	r0, #240	; 0xf0
 80023fc:	f040 80b1 	bne.w	8002562 <??ZbZclParseInteger_18>

08002400 <??ZbZclParseInteger_9>:
 8002400:	5df0      	ldrb	r0, [r6, r7]
 8002402:	2100      	movs	r1, #0
 8002404:	4304      	orrs	r4, r0
 8002406:	430d      	orrs	r5, r1
 8002408:	1c7f      	adds	r7, r7, #1

0800240a <??ZbZclParseInteger_8>:
 800240a:	5df0      	ldrb	r0, [r6, r7]
 800240c:	2100      	movs	r1, #0
 800240e:	003a      	movs	r2, r7
 8002410:	b2d2      	uxtb	r2, r2
 8002412:	00d2      	lsls	r2, r2, #3
 8002414:	f003 fbc4 	bl	8005ba0 <__aeabi_llsl>
 8002418:	4304      	orrs	r4, r0
 800241a:	430d      	orrs	r5, r1
 800241c:	1c7f      	adds	r7, r7, #1

0800241e <??ZbZclParseInteger_7>:
 800241e:	5df0      	ldrb	r0, [r6, r7]
 8002420:	2100      	movs	r1, #0
 8002422:	003a      	movs	r2, r7
 8002424:	b2d2      	uxtb	r2, r2
 8002426:	00d2      	lsls	r2, r2, #3
 8002428:	f003 fbba 	bl	8005ba0 <__aeabi_llsl>
 800242c:	4304      	orrs	r4, r0
 800242e:	430d      	orrs	r5, r1
 8002430:	1c7f      	adds	r7, r7, #1

08002432 <??ZbZclParseInteger_6>:
 8002432:	5df0      	ldrb	r0, [r6, r7]
 8002434:	2100      	movs	r1, #0
 8002436:	003a      	movs	r2, r7
 8002438:	b2d2      	uxtb	r2, r2
 800243a:	00d2      	lsls	r2, r2, #3
 800243c:	f003 fbb0 	bl	8005ba0 <__aeabi_llsl>
 8002440:	4304      	orrs	r4, r0
 8002442:	430d      	orrs	r5, r1
 8002444:	1c7f      	adds	r7, r7, #1

08002446 <??ZbZclParseInteger_5>:
 8002446:	5df0      	ldrb	r0, [r6, r7]
 8002448:	2100      	movs	r1, #0
 800244a:	003a      	movs	r2, r7
 800244c:	b2d2      	uxtb	r2, r2
 800244e:	00d2      	lsls	r2, r2, #3
 8002450:	f003 fba6 	bl	8005ba0 <__aeabi_llsl>
 8002454:	4304      	orrs	r4, r0
 8002456:	430d      	orrs	r5, r1
 8002458:	1c7f      	adds	r7, r7, #1

0800245a <??ZbZclParseInteger_4>:
 800245a:	5df0      	ldrb	r0, [r6, r7]
 800245c:	2100      	movs	r1, #0
 800245e:	003a      	movs	r2, r7
 8002460:	b2d2      	uxtb	r2, r2
 8002462:	00d2      	lsls	r2, r2, #3
 8002464:	f003 fb9c 	bl	8005ba0 <__aeabi_llsl>
 8002468:	4304      	orrs	r4, r0
 800246a:	430d      	orrs	r5, r1
 800246c:	1c7f      	adds	r7, r7, #1

0800246e <??ZbZclParseInteger_3>:
 800246e:	5df0      	ldrb	r0, [r6, r7]
 8002470:	2100      	movs	r1, #0
 8002472:	003a      	movs	r2, r7
 8002474:	b2d2      	uxtb	r2, r2
 8002476:	00d2      	lsls	r2, r2, #3
 8002478:	f003 fb92 	bl	8005ba0 <__aeabi_llsl>
 800247c:	4304      	orrs	r4, r0
 800247e:	430d      	orrs	r5, r1
 8002480:	1c7f      	adds	r7, r7, #1

08002482 <??ZbZclParseInteger_2>:
 8002482:	5df0      	ldrb	r0, [r6, r7]
 8002484:	2100      	movs	r1, #0
 8002486:	003a      	movs	r2, r7
 8002488:	b2d2      	uxtb	r2, r2
 800248a:	00d2      	lsls	r2, r2, #3
 800248c:	f003 fb88 	bl	8005ba0 <__aeabi_llsl>
 8002490:	4320      	orrs	r0, r4
 8002492:	4329      	orrs	r1, r5
 8002494:	e06a      	b.n	800256c <??ZbZclParseInteger_1>

08002496 <??ZbZclParseInteger_17>:
 8002496:	5df0      	ldrb	r0, [r6, r7]
 8002498:	2100      	movs	r1, #0
 800249a:	4304      	orrs	r4, r0
 800249c:	430d      	orrs	r5, r1
 800249e:	1c7f      	adds	r7, r7, #1

080024a0 <??ZbZclParseInteger_16>:
 80024a0:	5df0      	ldrb	r0, [r6, r7]
 80024a2:	2100      	movs	r1, #0
 80024a4:	003a      	movs	r2, r7
 80024a6:	b2d2      	uxtb	r2, r2
 80024a8:	00d2      	lsls	r2, r2, #3
 80024aa:	f003 fb79 	bl	8005ba0 <__aeabi_llsl>
 80024ae:	4304      	orrs	r4, r0
 80024b0:	430d      	orrs	r5, r1
 80024b2:	1c7f      	adds	r7, r7, #1

080024b4 <??ZbZclParseInteger_15>:
 80024b4:	5df0      	ldrb	r0, [r6, r7]
 80024b6:	2100      	movs	r1, #0
 80024b8:	003a      	movs	r2, r7
 80024ba:	b2d2      	uxtb	r2, r2
 80024bc:	00d2      	lsls	r2, r2, #3
 80024be:	f003 fb6f 	bl	8005ba0 <__aeabi_llsl>
 80024c2:	4304      	orrs	r4, r0
 80024c4:	430d      	orrs	r5, r1
 80024c6:	1c7f      	adds	r7, r7, #1

080024c8 <??ZbZclParseInteger_14>:
 80024c8:	5df0      	ldrb	r0, [r6, r7]
 80024ca:	2100      	movs	r1, #0
 80024cc:	003a      	movs	r2, r7
 80024ce:	b2d2      	uxtb	r2, r2
 80024d0:	00d2      	lsls	r2, r2, #3
 80024d2:	f003 fb65 	bl	8005ba0 <__aeabi_llsl>
 80024d6:	4304      	orrs	r4, r0
 80024d8:	430d      	orrs	r5, r1
 80024da:	1c7f      	adds	r7, r7, #1

080024dc <??ZbZclParseInteger_13>:
 80024dc:	5df0      	ldrb	r0, [r6, r7]
 80024de:	2100      	movs	r1, #0
 80024e0:	003a      	movs	r2, r7
 80024e2:	b2d2      	uxtb	r2, r2
 80024e4:	00d2      	lsls	r2, r2, #3
 80024e6:	f003 fb5b 	bl	8005ba0 <__aeabi_llsl>
 80024ea:	4304      	orrs	r4, r0
 80024ec:	430d      	orrs	r5, r1
 80024ee:	1c7f      	adds	r7, r7, #1

080024f0 <??ZbZclParseInteger_12>:
 80024f0:	5df0      	ldrb	r0, [r6, r7]
 80024f2:	2100      	movs	r1, #0
 80024f4:	003a      	movs	r2, r7
 80024f6:	b2d2      	uxtb	r2, r2
 80024f8:	00d2      	lsls	r2, r2, #3
 80024fa:	f003 fb51 	bl	8005ba0 <__aeabi_llsl>
 80024fe:	4304      	orrs	r4, r0
 8002500:	430d      	orrs	r5, r1
 8002502:	1c7f      	adds	r7, r7, #1

08002504 <??ZbZclParseInteger_11>:
 8002504:	5df0      	ldrb	r0, [r6, r7]
 8002506:	2100      	movs	r1, #0
 8002508:	003a      	movs	r2, r7
 800250a:	b2d2      	uxtb	r2, r2
 800250c:	00d2      	lsls	r2, r2, #3
 800250e:	f003 fb47 	bl	8005ba0 <__aeabi_llsl>
 8002512:	4304      	orrs	r4, r0
 8002514:	430d      	orrs	r5, r1
 8002516:	1c7f      	adds	r7, r7, #1

08002518 <??ZbZclParseInteger_10>:
 8002518:	5df0      	ldrb	r0, [r6, r7]
 800251a:	2100      	movs	r1, #0
 800251c:	003a      	movs	r2, r7
 800251e:	b2d2      	uxtb	r2, r2
 8002520:	00d2      	lsls	r2, r2, #3
 8002522:	f003 fb3d 	bl	8005ba0 <__aeabi_llsl>
 8002526:	4320      	orrs	r0, r4
 8002528:	4329      	orrs	r1, r5
 800252a:	003a      	movs	r2, r7
 800252c:	1c57      	adds	r7, r2, #1
 800252e:	5cb2      	ldrb	r2, [r6, r2]
 8002530:	0612      	lsls	r2, r2, #24
 8002532:	d515      	bpl.n	8002560 <??ZbZclParseInteger_19>
 8002534:	2f08      	cmp	r7, #8
 8002536:	d213      	bcs.n	8002560 <??ZbZclParseInteger_19>
 8002538:	0004      	movs	r4, r0
 800253a:	000d      	movs	r5, r1
 800253c:	2001      	movs	r0, #1
 800253e:	2100      	movs	r1, #0
 8002540:	f1d7 0208 	rsbs	r2, r7, #8
 8002544:	b2d2      	uxtb	r2, r2
 8002546:	00d2      	lsls	r2, r2, #3
 8002548:	f003 fb2a 	bl	8005ba0 <__aeabi_llsl>
 800254c:	1e40      	subs	r0, r0, #1
 800254e:	f171 0100 	sbcs.w	r1, r1, #0
 8002552:	003a      	movs	r2, r7
 8002554:	b2d2      	uxtb	r2, r2
 8002556:	00d2      	lsls	r2, r2, #3
 8002558:	f003 fb22 	bl	8005ba0 <__aeabi_llsl>
 800255c:	4320      	orrs	r0, r4
 800255e:	4329      	orrs	r1, r5

08002560 <??ZbZclParseInteger_19>:
 8002560:	e004      	b.n	800256c <??ZbZclParseInteger_1>

08002562 <??ZbZclParseInteger_18>:
 8002562:	208d      	movs	r0, #141	; 0x8d
 8002564:	f88a 0000 	strb.w	r0, [sl]
 8002568:	2000      	movs	r0, #0
 800256a:	2100      	movs	r1, #0

0800256c <??ZbZclParseInteger_1>:
 800256c:	e8bd 8ff4 	ldmia.w	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002570 <ZbZclAttrIsInteger>:
 8002570:	0001      	movs	r1, r0
 8002572:	2200      	movs	r2, #0
 8002574:	0008      	movs	r0, r1
 8002576:	b2c0      	uxtb	r0, r0
 8002578:	3808      	subs	r0, #8
 800257a:	2808      	cmp	r0, #8
 800257c:	d909      	bls.n	8002592 <??ZbZclAttrIsInteger_0>
 800257e:	3810      	subs	r0, #16
 8002580:	2819      	cmp	r0, #25
 8002582:	d906      	bls.n	8002592 <??ZbZclAttrIsInteger_0>
 8002584:	38ca      	subs	r0, #202	; 0xca
 8002586:	d004      	beq.n	8002592 <??ZbZclAttrIsInteger_0>
 8002588:	1f80      	subs	r0, r0, #6
 800258a:	2802      	cmp	r0, #2
 800258c:	d901      	bls.n	8002592 <??ZbZclAttrIsInteger_0>
 800258e:	3808      	subs	r0, #8
 8002590:	d101      	bne.n	8002596 <??ZbZclAttrIsInteger_1>

08002592 <??ZbZclAttrIsInteger_0>:
 8002592:	2001      	movs	r0, #1
 8002594:	e000      	b.n	8002598 <??ZbZclAttrIsInteger_2>

08002596 <??ZbZclAttrIsInteger_1>:
 8002596:	2000      	movs	r0, #0

08002598 <??ZbZclAttrIsInteger_2>:
 8002598:	b2c0      	uxtb	r0, r0
 800259a:	4770      	bx	lr

0800259c <ZbZclAttrIntegerRangeCheck>:
 800259c:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 80025a0:	0004      	movs	r4, r0
 80025a2:	000d      	movs	r5, r1
 80025a4:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 80025a8:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
 80025ac:	0010      	movs	r0, r2
 80025ae:	b2c0      	uxtb	r0, r0
 80025b0:	2810      	cmp	r0, #16
 80025b2:	d045      	beq.n	8002640 <??ZbZclAttrIntegerRangeCheck_0>
 80025b4:	2818      	cmp	r0, #24
 80025b6:	d051      	beq.n	800265c <??ZbZclAttrIntegerRangeCheck_1>
 80025b8:	2819      	cmp	r0, #25
 80025ba:	d060      	beq.n	800267e <??ZbZclAttrIntegerRangeCheck_2>
 80025bc:	281a      	cmp	r0, #26
 80025be:	d072      	beq.n	80026a6 <??ZbZclAttrIntegerRangeCheck_3>
 80025c0:	281b      	cmp	r0, #27
 80025c2:	f000 8086 	beq.w	80026d2 <??ZbZclAttrIntegerRangeCheck_4>
 80025c6:	281c      	cmp	r0, #28
 80025c8:	f000 8098 	beq.w	80026fc <??ZbZclAttrIntegerRangeCheck_5>
 80025cc:	281d      	cmp	r0, #29
 80025ce:	f000 80a7 	beq.w	8002720 <??ZbZclAttrIntegerRangeCheck_6>
 80025d2:	281e      	cmp	r0, #30
 80025d4:	f000 80b9 	beq.w	800274a <??ZbZclAttrIntegerRangeCheck_7>
 80025d8:	281f      	cmp	r0, #31
 80025da:	f000 80cd 	beq.w	8002778 <??ZbZclAttrIntegerRangeCheck_8>
 80025de:	2820      	cmp	r0, #32
 80025e0:	d03c      	beq.n	800265c <??ZbZclAttrIntegerRangeCheck_1>
 80025e2:	2821      	cmp	r0, #33	; 0x21
 80025e4:	d04b      	beq.n	800267e <??ZbZclAttrIntegerRangeCheck_2>
 80025e6:	2822      	cmp	r0, #34	; 0x22
 80025e8:	d05d      	beq.n	80026a6 <??ZbZclAttrIntegerRangeCheck_3>
 80025ea:	2823      	cmp	r0, #35	; 0x23
 80025ec:	d071      	beq.n	80026d2 <??ZbZclAttrIntegerRangeCheck_4>
 80025ee:	2824      	cmp	r0, #36	; 0x24
 80025f0:	f000 8084 	beq.w	80026fc <??ZbZclAttrIntegerRangeCheck_5>
 80025f4:	2825      	cmp	r0, #37	; 0x25
 80025f6:	f000 8093 	beq.w	8002720 <??ZbZclAttrIntegerRangeCheck_6>
 80025fa:	2826      	cmp	r0, #38	; 0x26
 80025fc:	f000 80a5 	beq.w	800274a <??ZbZclAttrIntegerRangeCheck_7>
 8002600:	2827      	cmp	r0, #39	; 0x27
 8002602:	f000 80b9 	beq.w	8002778 <??ZbZclAttrIntegerRangeCheck_8>
 8002606:	2828      	cmp	r0, #40	; 0x28
 8002608:	f000 80c1 	beq.w	800278e <??ZbZclAttrIntegerRangeCheck_9>
 800260c:	2829      	cmp	r0, #41	; 0x29
 800260e:	f000 80d9 	beq.w	80027c4 <??ZbZclAttrIntegerRangeCheck_10>
 8002612:	282a      	cmp	r0, #42	; 0x2a
 8002614:	f000 80f0 	beq.w	80027f8 <??ZbZclAttrIntegerRangeCheck_11>
 8002618:	282b      	cmp	r0, #43	; 0x2b
 800261a:	f000 8107 	beq.w	800282c <??ZbZclAttrIntegerRangeCheck_12>
 800261e:	282c      	cmp	r0, #44	; 0x2c
 8002620:	f000 8120 	beq.w	8002864 <??ZbZclAttrIntegerRangeCheck_13>
 8002624:	282d      	cmp	r0, #45	; 0x2d
 8002626:	f000 8136 	beq.w	8002896 <??ZbZclAttrIntegerRangeCheck_14>
 800262a:	282e      	cmp	r0, #46	; 0x2e
 800262c:	f000 814b 	beq.w	80028c6 <??ZbZclAttrIntegerRangeCheck_15>
 8002630:	282f      	cmp	r0, #47	; 0x2f
 8002632:	f000 8160 	beq.w	80028f6 <??ZbZclAttrIntegerRangeCheck_16>
 8002636:	2830      	cmp	r0, #48	; 0x30
 8002638:	d010      	beq.n	800265c <??ZbZclAttrIntegerRangeCheck_1>
 800263a:	2831      	cmp	r0, #49	; 0x31
 800263c:	d01f      	beq.n	800267e <??ZbZclAttrIntegerRangeCheck_2>
 800263e:	e164      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

08002640 <??ZbZclAttrIntegerRangeCheck_0>:
 8002640:	2d00      	cmp	r5, #0
 8002642:	d103      	bne.n	800264c <??ZbZclAttrIntegerRangeCheck_18>
 8002644:	2cff      	cmp	r4, #255	; 0xff
 8002646:	d101      	bne.n	800264c <??ZbZclAttrIntegerRangeCheck_18>
 8002648:	2001      	movs	r0, #1
 800264a:	e176      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800264c <??ZbZclAttrIntegerRangeCheck_18>:
 800264c:	2d00      	cmp	r5, #0
 800264e:	db04      	blt.n	800265a <??ZbZclAttrIntegerRangeCheck_20>
 8002650:	dc01      	bgt.n	8002656 <??ZbZclAttrIntegerRangeCheck_21>
 8002652:	2c02      	cmp	r4, #2
 8002654:	d301      	bcc.n	800265a <??ZbZclAttrIntegerRangeCheck_20>

08002656 <??ZbZclAttrIntegerRangeCheck_21>:
 8002656:	2000      	movs	r0, #0
 8002658:	e16f      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800265a <??ZbZclAttrIntegerRangeCheck_20>:
 800265a:	e156      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

0800265c <??ZbZclAttrIntegerRangeCheck_1>:
 800265c:	2d00      	cmp	r5, #0
 800265e:	d103      	bne.n	8002668 <??ZbZclAttrIntegerRangeCheck_23>
 8002660:	2cff      	cmp	r4, #255	; 0xff
 8002662:	d101      	bne.n	8002668 <??ZbZclAttrIntegerRangeCheck_23>
 8002664:	2001      	movs	r0, #1
 8002666:	e168      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002668 <??ZbZclAttrIntegerRangeCheck_23>:
 8002668:	2d00      	cmp	r5, #0
 800266a:	d405      	bmi.n	8002678 <??ZbZclAttrIntegerRangeCheck_24>
 800266c:	2d00      	cmp	r5, #0
 800266e:	db05      	blt.n	800267c <??ZbZclAttrIntegerRangeCheck_25>
 8002670:	dc02      	bgt.n	8002678 <??ZbZclAttrIntegerRangeCheck_24>
 8002672:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8002676:	d301      	bcc.n	800267c <??ZbZclAttrIntegerRangeCheck_25>

08002678 <??ZbZclAttrIntegerRangeCheck_24>:
 8002678:	2000      	movs	r0, #0
 800267a:	e15e      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800267c <??ZbZclAttrIntegerRangeCheck_25>:
 800267c:	e145      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

0800267e <??ZbZclAttrIntegerRangeCheck_2>:
 800267e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8002682:	2100      	movs	r1, #0
 8002684:	428d      	cmp	r5, r1
 8002686:	d103      	bne.n	8002690 <??ZbZclAttrIntegerRangeCheck_27>
 8002688:	4284      	cmp	r4, r0
 800268a:	d101      	bne.n	8002690 <??ZbZclAttrIntegerRangeCheck_27>
 800268c:	2001      	movs	r0, #1
 800268e:	e154      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002690 <??ZbZclAttrIntegerRangeCheck_27>:
 8002690:	2d00      	cmp	r5, #0
 8002692:	d405      	bmi.n	80026a0 <??ZbZclAttrIntegerRangeCheck_28>
 8002694:	2d00      	cmp	r5, #0
 8002696:	db05      	blt.n	80026a4 <??ZbZclAttrIntegerRangeCheck_29>
 8002698:	dc02      	bgt.n	80026a0 <??ZbZclAttrIntegerRangeCheck_28>
 800269a:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
 800269e:	d301      	bcc.n	80026a4 <??ZbZclAttrIntegerRangeCheck_29>

080026a0 <??ZbZclAttrIntegerRangeCheck_28>:
 80026a0:	2000      	movs	r0, #0
 80026a2:	e14a      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080026a4 <??ZbZclAttrIntegerRangeCheck_29>:
 80026a4:	e131      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080026a6 <??ZbZclAttrIntegerRangeCheck_3>:
 80026a6:	f07f 407f 	mvns.w	r0, #4278190080	; 0xff000000
 80026aa:	2100      	movs	r1, #0
 80026ac:	428d      	cmp	r5, r1
 80026ae:	d103      	bne.n	80026b8 <??ZbZclAttrIntegerRangeCheck_31>
 80026b0:	4284      	cmp	r4, r0
 80026b2:	d101      	bne.n	80026b8 <??ZbZclAttrIntegerRangeCheck_31>
 80026b4:	2001      	movs	r0, #1
 80026b6:	e140      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080026b8 <??ZbZclAttrIntegerRangeCheck_31>:
 80026b8:	2d00      	cmp	r5, #0
 80026ba:	d407      	bmi.n	80026cc <??ZbZclAttrIntegerRangeCheck_32>
 80026bc:	f05f 7080 	movs.w	r0, #16777216	; 0x1000000
 80026c0:	2100      	movs	r1, #0
 80026c2:	428d      	cmp	r5, r1
 80026c4:	db04      	blt.n	80026d0 <??ZbZclAttrIntegerRangeCheck_33>
 80026c6:	dc01      	bgt.n	80026cc <??ZbZclAttrIntegerRangeCheck_32>
 80026c8:	4284      	cmp	r4, r0
 80026ca:	d301      	bcc.n	80026d0 <??ZbZclAttrIntegerRangeCheck_33>

080026cc <??ZbZclAttrIntegerRangeCheck_32>:
 80026cc:	2000      	movs	r0, #0
 80026ce:	e134      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080026d0 <??ZbZclAttrIntegerRangeCheck_33>:
 80026d0:	e11b      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080026d2 <??ZbZclAttrIntegerRangeCheck_4>:
 80026d2:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80026d6:	2100      	movs	r1, #0
 80026d8:	428d      	cmp	r5, r1
 80026da:	d103      	bne.n	80026e4 <??ZbZclAttrIntegerRangeCheck_35>
 80026dc:	4284      	cmp	r4, r0
 80026de:	d101      	bne.n	80026e4 <??ZbZclAttrIntegerRangeCheck_35>
 80026e0:	2001      	movs	r0, #1
 80026e2:	e12a      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080026e4 <??ZbZclAttrIntegerRangeCheck_35>:
 80026e4:	2d00      	cmp	r5, #0
 80026e6:	d406      	bmi.n	80026f6 <??ZbZclAttrIntegerRangeCheck_36>
 80026e8:	2000      	movs	r0, #0
 80026ea:	2101      	movs	r1, #1
 80026ec:	428d      	cmp	r5, r1
 80026ee:	db04      	blt.n	80026fa <??ZbZclAttrIntegerRangeCheck_37>
 80026f0:	dc01      	bgt.n	80026f6 <??ZbZclAttrIntegerRangeCheck_36>
 80026f2:	4284      	cmp	r4, r0
 80026f4:	d301      	bcc.n	80026fa <??ZbZclAttrIntegerRangeCheck_37>

080026f6 <??ZbZclAttrIntegerRangeCheck_36>:
 80026f6:	2000      	movs	r0, #0
 80026f8:	e11f      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080026fa <??ZbZclAttrIntegerRangeCheck_37>:
 80026fa:	e106      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080026fc <??ZbZclAttrIntegerRangeCheck_5>:
 80026fc:	2dff      	cmp	r5, #255	; 0xff
 80026fe:	d104      	bne.n	800270a <??ZbZclAttrIntegerRangeCheck_39>
 8002700:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 8002704:	d101      	bne.n	800270a <??ZbZclAttrIntegerRangeCheck_39>
 8002706:	2001      	movs	r0, #1
 8002708:	e117      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800270a <??ZbZclAttrIntegerRangeCheck_39>:
 800270a:	2d00      	cmp	r5, #0
 800270c:	d405      	bmi.n	800271a <??ZbZclAttrIntegerRangeCheck_40>
 800270e:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8002712:	db04      	blt.n	800271e <??ZbZclAttrIntegerRangeCheck_41>
 8002714:	dc01      	bgt.n	800271a <??ZbZclAttrIntegerRangeCheck_40>
 8002716:	2c00      	cmp	r4, #0
 8002718:	d301      	bcc.n	800271e <??ZbZclAttrIntegerRangeCheck_41>

0800271a <??ZbZclAttrIntegerRangeCheck_40>:
 800271a:	2000      	movs	r0, #0
 800271c:	e10d      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800271e <??ZbZclAttrIntegerRangeCheck_41>:
 800271e:	e0f4      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

08002720 <??ZbZclAttrIntegerRangeCheck_6>:
 8002720:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8002724:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8002728:	428d      	cmp	r5, r1
 800272a:	d103      	bne.n	8002734 <??ZbZclAttrIntegerRangeCheck_43>
 800272c:	4284      	cmp	r4, r0
 800272e:	d101      	bne.n	8002734 <??ZbZclAttrIntegerRangeCheck_43>
 8002730:	2001      	movs	r0, #1
 8002732:	e102      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002734 <??ZbZclAttrIntegerRangeCheck_43>:
 8002734:	2d00      	cmp	r5, #0
 8002736:	d405      	bmi.n	8002744 <??ZbZclAttrIntegerRangeCheck_44>
 8002738:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800273c:	db04      	blt.n	8002748 <??ZbZclAttrIntegerRangeCheck_45>
 800273e:	dc01      	bgt.n	8002744 <??ZbZclAttrIntegerRangeCheck_44>
 8002740:	2c00      	cmp	r4, #0
 8002742:	d301      	bcc.n	8002748 <??ZbZclAttrIntegerRangeCheck_45>

08002744 <??ZbZclAttrIntegerRangeCheck_44>:
 8002744:	2000      	movs	r0, #0
 8002746:	e0f8      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002748 <??ZbZclAttrIntegerRangeCheck_45>:
 8002748:	e0df      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

0800274a <??ZbZclAttrIntegerRangeCheck_7>:
 800274a:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 800274e:	f07f 417f 	mvns.w	r1, #4278190080	; 0xff000000
 8002752:	428d      	cmp	r5, r1
 8002754:	d103      	bne.n	800275e <??ZbZclAttrIntegerRangeCheck_47>
 8002756:	4284      	cmp	r4, r0
 8002758:	d101      	bne.n	800275e <??ZbZclAttrIntegerRangeCheck_47>
 800275a:	2001      	movs	r0, #1
 800275c:	e0ed      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800275e <??ZbZclAttrIntegerRangeCheck_47>:
 800275e:	2d00      	cmp	r5, #0
 8002760:	d407      	bmi.n	8002772 <??ZbZclAttrIntegerRangeCheck_48>
 8002762:	2000      	movs	r0, #0
 8002764:	f05f 7180 	movs.w	r1, #16777216	; 0x1000000
 8002768:	428d      	cmp	r5, r1
 800276a:	db04      	blt.n	8002776 <??ZbZclAttrIntegerRangeCheck_49>
 800276c:	dc01      	bgt.n	8002772 <??ZbZclAttrIntegerRangeCheck_48>
 800276e:	4284      	cmp	r4, r0
 8002770:	d301      	bcc.n	8002776 <??ZbZclAttrIntegerRangeCheck_49>

08002772 <??ZbZclAttrIntegerRangeCheck_48>:
 8002772:	2000      	movs	r0, #0
 8002774:	e0e1      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002776 <??ZbZclAttrIntegerRangeCheck_49>:
 8002776:	e0c8      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

08002778 <??ZbZclAttrIntegerRangeCheck_8>:
 8002778:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 800277c:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8002780:	428d      	cmp	r5, r1
 8002782:	d103      	bne.n	800278c <??ZbZclAttrIntegerRangeCheck_51>
 8002784:	4284      	cmp	r4, r0
 8002786:	d101      	bne.n	800278c <??ZbZclAttrIntegerRangeCheck_51>
 8002788:	2001      	movs	r0, #1
 800278a:	e0d6      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800278c <??ZbZclAttrIntegerRangeCheck_51>:
 800278c:	e0bd      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

0800278e <??ZbZclAttrIntegerRangeCheck_9>:
 800278e:	f07f 007f 	mvns.w	r0, #127	; 0x7f
 8002792:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8002796:	428d      	cmp	r5, r1
 8002798:	d103      	bne.n	80027a2 <??ZbZclAttrIntegerRangeCheck_52>
 800279a:	4284      	cmp	r4, r0
 800279c:	d101      	bne.n	80027a2 <??ZbZclAttrIntegerRangeCheck_52>
 800279e:	2001      	movs	r0, #1
 80027a0:	e0cb      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080027a2 <??ZbZclAttrIntegerRangeCheck_52>:
 80027a2:	f07f 007f 	mvns.w	r0, #127	; 0x7f
 80027a6:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 80027aa:	428d      	cmp	r5, r1
 80027ac:	db07      	blt.n	80027be <??ZbZclAttrIntegerRangeCheck_53>
 80027ae:	dc01      	bgt.n	80027b4 <??ZbZclAttrIntegerRangeCheck_54>
 80027b0:	4284      	cmp	r4, r0
 80027b2:	d304      	bcc.n	80027be <??ZbZclAttrIntegerRangeCheck_53>

080027b4 <??ZbZclAttrIntegerRangeCheck_54>:
 80027b4:	2d00      	cmp	r5, #0
 80027b6:	db04      	blt.n	80027c2 <??ZbZclAttrIntegerRangeCheck_55>
 80027b8:	dc01      	bgt.n	80027be <??ZbZclAttrIntegerRangeCheck_53>
 80027ba:	2c80      	cmp	r4, #128	; 0x80
 80027bc:	d301      	bcc.n	80027c2 <??ZbZclAttrIntegerRangeCheck_55>

080027be <??ZbZclAttrIntegerRangeCheck_53>:
 80027be:	2000      	movs	r0, #0
 80027c0:	e0bb      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080027c2 <??ZbZclAttrIntegerRangeCheck_55>:
 80027c2:	e0a2      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080027c4 <??ZbZclAttrIntegerRangeCheck_10>:
 80027c4:	485e      	ldr	r0, [pc, #376]	; (8002940 <??DataTable1>)
 80027c6:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 80027ca:	428d      	cmp	r5, r1
 80027cc:	d103      	bne.n	80027d6 <??ZbZclAttrIntegerRangeCheck_57>
 80027ce:	4284      	cmp	r4, r0
 80027d0:	d101      	bne.n	80027d6 <??ZbZclAttrIntegerRangeCheck_57>
 80027d2:	2001      	movs	r0, #1
 80027d4:	e0b1      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080027d6 <??ZbZclAttrIntegerRangeCheck_57>:
 80027d6:	485a      	ldr	r0, [pc, #360]	; (8002940 <??DataTable1>)
 80027d8:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 80027dc:	428d      	cmp	r5, r1
 80027de:	db08      	blt.n	80027f2 <??ZbZclAttrIntegerRangeCheck_58>
 80027e0:	dc01      	bgt.n	80027e6 <??ZbZclAttrIntegerRangeCheck_59>
 80027e2:	4284      	cmp	r4, r0
 80027e4:	d305      	bcc.n	80027f2 <??ZbZclAttrIntegerRangeCheck_58>

080027e6 <??ZbZclAttrIntegerRangeCheck_59>:
 80027e6:	2d00      	cmp	r5, #0
 80027e8:	db05      	blt.n	80027f6 <??ZbZclAttrIntegerRangeCheck_60>
 80027ea:	dc02      	bgt.n	80027f2 <??ZbZclAttrIntegerRangeCheck_58>
 80027ec:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 80027f0:	d301      	bcc.n	80027f6 <??ZbZclAttrIntegerRangeCheck_60>

080027f2 <??ZbZclAttrIntegerRangeCheck_58>:
 80027f2:	2000      	movs	r0, #0
 80027f4:	e0a1      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080027f6 <??ZbZclAttrIntegerRangeCheck_60>:
 80027f6:	e088      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080027f8 <??ZbZclAttrIntegerRangeCheck_11>:
 80027f8:	4852      	ldr	r0, [pc, #328]	; (8002944 <??DataTable1_1>)
 80027fa:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 80027fe:	428d      	cmp	r5, r1
 8002800:	d103      	bne.n	800280a <??ZbZclAttrIntegerRangeCheck_62>
 8002802:	4284      	cmp	r4, r0
 8002804:	d101      	bne.n	800280a <??ZbZclAttrIntegerRangeCheck_62>
 8002806:	2001      	movs	r0, #1
 8002808:	e097      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800280a <??ZbZclAttrIntegerRangeCheck_62>:
 800280a:	484e      	ldr	r0, [pc, #312]	; (8002944 <??DataTable1_1>)
 800280c:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8002810:	428d      	cmp	r5, r1
 8002812:	db08      	blt.n	8002826 <??ZbZclAttrIntegerRangeCheck_63>
 8002814:	dc01      	bgt.n	800281a <??ZbZclAttrIntegerRangeCheck_64>
 8002816:	4284      	cmp	r4, r0
 8002818:	d305      	bcc.n	8002826 <??ZbZclAttrIntegerRangeCheck_63>

0800281a <??ZbZclAttrIntegerRangeCheck_64>:
 800281a:	2d00      	cmp	r5, #0
 800281c:	db05      	blt.n	800282a <??ZbZclAttrIntegerRangeCheck_65>
 800281e:	dc02      	bgt.n	8002826 <??ZbZclAttrIntegerRangeCheck_63>
 8002820:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 8002824:	d301      	bcc.n	800282a <??ZbZclAttrIntegerRangeCheck_65>

08002826 <??ZbZclAttrIntegerRangeCheck_63>:
 8002826:	2000      	movs	r0, #0
 8002828:	e087      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800282a <??ZbZclAttrIntegerRangeCheck_65>:
 800282a:	e06e      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

0800282c <??ZbZclAttrIntegerRangeCheck_12>:
 800282c:	f05f 4000 	movs.w	r0, #2147483648	; 0x80000000
 8002830:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8002834:	428d      	cmp	r5, r1
 8002836:	d103      	bne.n	8002840 <??ZbZclAttrIntegerRangeCheck_67>
 8002838:	4284      	cmp	r4, r0
 800283a:	d101      	bne.n	8002840 <??ZbZclAttrIntegerRangeCheck_67>
 800283c:	2001      	movs	r0, #1
 800283e:	e07c      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002840 <??ZbZclAttrIntegerRangeCheck_67>:
 8002840:	f05f 4000 	movs.w	r0, #2147483648	; 0x80000000
 8002844:	f05f 31ff 	movs.w	r1, #4294967295	; 0xffffffff
 8002848:	428d      	cmp	r5, r1
 800284a:	db08      	blt.n	800285e <??ZbZclAttrIntegerRangeCheck_68>
 800284c:	dc01      	bgt.n	8002852 <??ZbZclAttrIntegerRangeCheck_69>
 800284e:	4284      	cmp	r4, r0
 8002850:	d305      	bcc.n	800285e <??ZbZclAttrIntegerRangeCheck_68>

08002852 <??ZbZclAttrIntegerRangeCheck_69>:
 8002852:	2d00      	cmp	r5, #0
 8002854:	db05      	blt.n	8002862 <??ZbZclAttrIntegerRangeCheck_70>
 8002856:	dc02      	bgt.n	800285e <??ZbZclAttrIntegerRangeCheck_68>
 8002858:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
 800285c:	d301      	bcc.n	8002862 <??ZbZclAttrIntegerRangeCheck_70>

0800285e <??ZbZclAttrIntegerRangeCheck_68>:
 800285e:	2000      	movs	r0, #0
 8002860:	e06b      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002862 <??ZbZclAttrIntegerRangeCheck_70>:
 8002862:	e052      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

08002864 <??ZbZclAttrIntegerRangeCheck_13>:
 8002864:	2000      	movs	r0, #0
 8002866:	f07f 017f 	mvns.w	r1, #127	; 0x7f
 800286a:	428d      	cmp	r5, r1
 800286c:	d103      	bne.n	8002876 <??ZbZclAttrIntegerRangeCheck_72>
 800286e:	4284      	cmp	r4, r0
 8002870:	d101      	bne.n	8002876 <??ZbZclAttrIntegerRangeCheck_72>
 8002872:	2001      	movs	r0, #1
 8002874:	e061      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002876 <??ZbZclAttrIntegerRangeCheck_72>:
 8002876:	2000      	movs	r0, #0
 8002878:	f07f 017f 	mvns.w	r1, #127	; 0x7f
 800287c:	428d      	cmp	r5, r1
 800287e:	db07      	blt.n	8002890 <??ZbZclAttrIntegerRangeCheck_73>
 8002880:	dc01      	bgt.n	8002886 <??ZbZclAttrIntegerRangeCheck_74>
 8002882:	4284      	cmp	r4, r0
 8002884:	d304      	bcc.n	8002890 <??ZbZclAttrIntegerRangeCheck_73>

08002886 <??ZbZclAttrIntegerRangeCheck_74>:
 8002886:	2d80      	cmp	r5, #128	; 0x80
 8002888:	db04      	blt.n	8002894 <??ZbZclAttrIntegerRangeCheck_75>
 800288a:	dc01      	bgt.n	8002890 <??ZbZclAttrIntegerRangeCheck_73>
 800288c:	2c00      	cmp	r4, #0
 800288e:	d301      	bcc.n	8002894 <??ZbZclAttrIntegerRangeCheck_75>

08002890 <??ZbZclAttrIntegerRangeCheck_73>:
 8002890:	2000      	movs	r0, #0
 8002892:	e052      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002894 <??ZbZclAttrIntegerRangeCheck_75>:
 8002894:	e039      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

08002896 <??ZbZclAttrIntegerRangeCheck_14>:
 8002896:	2000      	movs	r0, #0
 8002898:	4929      	ldr	r1, [pc, #164]	; (8002940 <??DataTable1>)
 800289a:	428d      	cmp	r5, r1
 800289c:	d103      	bne.n	80028a6 <??ZbZclAttrIntegerRangeCheck_77>
 800289e:	4284      	cmp	r4, r0
 80028a0:	d101      	bne.n	80028a6 <??ZbZclAttrIntegerRangeCheck_77>
 80028a2:	2001      	movs	r0, #1
 80028a4:	e049      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080028a6 <??ZbZclAttrIntegerRangeCheck_77>:
 80028a6:	2000      	movs	r0, #0
 80028a8:	4925      	ldr	r1, [pc, #148]	; (8002940 <??DataTable1>)
 80028aa:	428d      	cmp	r5, r1
 80028ac:	db08      	blt.n	80028c0 <??ZbZclAttrIntegerRangeCheck_78>
 80028ae:	dc01      	bgt.n	80028b4 <??ZbZclAttrIntegerRangeCheck_79>
 80028b0:	4284      	cmp	r4, r0
 80028b2:	d305      	bcc.n	80028c0 <??ZbZclAttrIntegerRangeCheck_78>

080028b4 <??ZbZclAttrIntegerRangeCheck_79>:
 80028b4:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 80028b8:	db04      	blt.n	80028c4 <??ZbZclAttrIntegerRangeCheck_80>
 80028ba:	dc01      	bgt.n	80028c0 <??ZbZclAttrIntegerRangeCheck_78>
 80028bc:	2c00      	cmp	r4, #0
 80028be:	d301      	bcc.n	80028c4 <??ZbZclAttrIntegerRangeCheck_80>

080028c0 <??ZbZclAttrIntegerRangeCheck_78>:
 80028c0:	2000      	movs	r0, #0
 80028c2:	e03a      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080028c4 <??ZbZclAttrIntegerRangeCheck_80>:
 80028c4:	e021      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080028c6 <??ZbZclAttrIntegerRangeCheck_15>:
 80028c6:	2000      	movs	r0, #0
 80028c8:	491e      	ldr	r1, [pc, #120]	; (8002944 <??DataTable1_1>)
 80028ca:	428d      	cmp	r5, r1
 80028cc:	d103      	bne.n	80028d6 <??ZbZclAttrIntegerRangeCheck_82>
 80028ce:	4284      	cmp	r4, r0
 80028d0:	d101      	bne.n	80028d6 <??ZbZclAttrIntegerRangeCheck_82>
 80028d2:	2001      	movs	r0, #1
 80028d4:	e031      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080028d6 <??ZbZclAttrIntegerRangeCheck_82>:
 80028d6:	2000      	movs	r0, #0
 80028d8:	491a      	ldr	r1, [pc, #104]	; (8002944 <??DataTable1_1>)
 80028da:	428d      	cmp	r5, r1
 80028dc:	db08      	blt.n	80028f0 <??ZbZclAttrIntegerRangeCheck_83>
 80028de:	dc01      	bgt.n	80028e4 <??ZbZclAttrIntegerRangeCheck_84>
 80028e0:	4284      	cmp	r4, r0
 80028e2:	d305      	bcc.n	80028f0 <??ZbZclAttrIntegerRangeCheck_83>

080028e4 <??ZbZclAttrIntegerRangeCheck_84>:
 80028e4:	f5b5 0f00 	cmp.w	r5, #8388608	; 0x800000
 80028e8:	db04      	blt.n	80028f4 <??ZbZclAttrIntegerRangeCheck_85>
 80028ea:	dc01      	bgt.n	80028f0 <??ZbZclAttrIntegerRangeCheck_83>
 80028ec:	2c00      	cmp	r4, #0
 80028ee:	d301      	bcc.n	80028f4 <??ZbZclAttrIntegerRangeCheck_85>

080028f0 <??ZbZclAttrIntegerRangeCheck_83>:
 80028f0:	2000      	movs	r0, #0
 80028f2:	e022      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

080028f4 <??ZbZclAttrIntegerRangeCheck_85>:
 80028f4:	e009      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

080028f6 <??ZbZclAttrIntegerRangeCheck_16>:
 80028f6:	2000      	movs	r0, #0
 80028f8:	f05f 4100 	movs.w	r1, #2147483648	; 0x80000000
 80028fc:	428d      	cmp	r5, r1
 80028fe:	d103      	bne.n	8002908 <??ZbZclAttrIntegerRangeCheck_87>
 8002900:	4284      	cmp	r4, r0
 8002902:	d101      	bne.n	8002908 <??ZbZclAttrIntegerRangeCheck_87>
 8002904:	2001      	movs	r0, #1
 8002906:	e018      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

08002908 <??ZbZclAttrIntegerRangeCheck_87>:
 8002908:	e7ff      	b.n	800290a <??ZbZclAttrIntegerRangeCheck_17>

0800290a <??ZbZclAttrIntegerRangeCheck_17>:
 800290a:	ea56 0008 	orrs.w	r0, r6, r8
 800290e:	ea57 0109 	orrs.w	r1, r7, r9
 8002912:	2900      	cmp	r1, #0
 8002914:	d103      	bne.n	800291e <??ZbZclAttrIntegerRangeCheck_88>
 8002916:	2800      	cmp	r0, #0
 8002918:	d101      	bne.n	800291e <??ZbZclAttrIntegerRangeCheck_88>
 800291a:	2001      	movs	r0, #1
 800291c:	e00d      	b.n	800293a <??ZbZclAttrIntegerRangeCheck_19>

0800291e <??ZbZclAttrIntegerRangeCheck_88>:
 800291e:	42bd      	cmp	r5, r7
 8002920:	db09      	blt.n	8002936 <??ZbZclAttrIntegerRangeCheck_89>
 8002922:	dc01      	bgt.n	8002928 <??ZbZclAttrIntegerRangeCheck_90>
 8002924:	42b4      	cmp	r4, r6
 8002926:	d306      	bcc.n	8002936 <??ZbZclAttrIntegerRangeCheck_89>

08002928 <??ZbZclAttrIntegerRangeCheck_90>:
 8002928:	45a9      	cmp	r9, r5
 800292a:	db04      	blt.n	8002936 <??ZbZclAttrIntegerRangeCheck_89>
 800292c:	dc01      	bgt.n	8002932 <??ZbZclAttrIntegerRangeCheck_91>
 800292e:	45a0      	cmp	r8, r4
 8002930:	d301      	bcc.n	8002936 <??ZbZclAttrIntegerRangeCheck_89>

08002932 <??ZbZclAttrIntegerRangeCheck_91>:
 8002932:	2001      	movs	r0, #1
 8002934:	e000      	b.n	8002938 <??ZbZclAttrIntegerRangeCheck_92>

08002936 <??ZbZclAttrIntegerRangeCheck_89>:
 8002936:	2000      	movs	r0, #0

08002938 <??ZbZclAttrIntegerRangeCheck_92>:
 8002938:	b2c0      	uxtb	r0, r0

0800293a <??ZbZclAttrIntegerRangeCheck_19>:
 800293a:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800293e:	4770      	bx	lr

08002940 <??DataTable1>:
 8002940:	8000 ffff                                   ....

08002944 <??DataTable1_1>:
 8002944:	0000 ff80                                   ....

08002948 <ZbZclAttrIntegerRead>:
 8002948:	e92d 47f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800294c:	b085      	sub	sp, #20
 800294e:	0006      	movs	r6, r0
 8002950:	000f      	movs	r7, r1
 8002952:	0015      	movs	r5, r2
 8002954:	001c      	movs	r4, r3
 8002956:	2000      	movs	r0, #0
 8002958:	f88d 0009 	strb.w	r0, [sp, #9]
 800295c:	f05f 0808 	movs.w	r8, #8
 8002960:	f05f 0900 	movs.w	r9, #0
 8002964:	f10d 0a0c 	add.w	sl, sp, #12
 8002968:	464a      	mov	r2, r9
 800296a:	4641      	mov	r1, r8
 800296c:	4650      	mov	r0, sl
 800296e:	f003 f87a 	bl	8005a66 <__aeabi_memset>
 8002972:	2000      	movs	r0, #0
 8002974:	9001      	str	r0, [sp, #4]
 8002976:	2008      	movs	r0, #8
 8002978:	9000      	str	r0, [sp, #0]
 800297a:	ab03      	add	r3, sp, #12
 800297c:	f10d 0209 	add.w	r2, sp, #9
 8002980:	0039      	movs	r1, r7
 8002982:	b289      	uxth	r1, r1
 8002984:	0030      	movs	r0, r6
 8002986:	f7fe fcee 	bl	8001366 <ZbZclAttrRead>
 800298a:	f88d 0008 	strb.w	r0, [sp, #8]
 800298e:	2c00      	cmp	r4, #0
 8002990:	d002      	beq.n	8002998 <??ZbZclAttrIntegerRead_0>
 8002992:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8002996:	7020      	strb	r0, [r4, #0]

08002998 <??ZbZclAttrIntegerRead_0>:
 8002998:	f89d 0008 	ldrb.w	r0, [sp, #8]
 800299c:	2800      	cmp	r0, #0
 800299e:	d002      	beq.n	80029a6 <??ZbZclAttrIntegerRead_1>
 80029a0:	2000      	movs	r0, #0
 80029a2:	2100      	movs	r1, #0
 80029a4:	e01a      	b.n	80029dc <??ZbZclAttrIntegerRead_2>

080029a6 <??ZbZclAttrIntegerRead_1>:
 80029a6:	aa02      	add	r2, sp, #8
 80029a8:	a903      	add	r1, sp, #12
 80029aa:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80029ae:	f7ff fcb1 	bl	8002314 <ZbZclParseInteger>
 80029b2:	0002      	movs	r2, r0
 80029b4:	000b      	movs	r3, r1
 80029b6:	2c00      	cmp	r4, #0
 80029b8:	d002      	beq.n	80029c0 <??ZbZclAttrIntegerRead_3>
 80029ba:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80029be:	7020      	strb	r0, [r4, #0]

080029c0 <??ZbZclAttrIntegerRead_3>:
 80029c0:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80029c4:	2800      	cmp	r0, #0
 80029c6:	d002      	beq.n	80029ce <??ZbZclAttrIntegerRead_4>
 80029c8:	2000      	movs	r0, #0
 80029ca:	2100      	movs	r1, #0
 80029cc:	e006      	b.n	80029dc <??ZbZclAttrIntegerRead_2>

080029ce <??ZbZclAttrIntegerRead_4>:
 80029ce:	2d00      	cmp	r5, #0
 80029d0:	d002      	beq.n	80029d8 <??ZbZclAttrIntegerRead_5>
 80029d2:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80029d6:	7028      	strb	r0, [r5, #0]

080029d8 <??ZbZclAttrIntegerRead_5>:
 80029d8:	0010      	movs	r0, r2
 80029da:	0019      	movs	r1, r3

080029dc <??ZbZclAttrIntegerRead_2>:
 80029dc:	b006      	add	sp, #24
 80029de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080029e2 <ZbZclAttrIntegerWrite>:
 80029e2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80029e6:	b087      	sub	sp, #28
 80029e8:	4680      	mov	r8, r0
 80029ea:	4689      	mov	r9, r1
 80029ec:	0014      	movs	r4, r2
 80029ee:	001d      	movs	r5, r3
 80029f0:	f1b8 0f00 	cmp.w	r8, #0
 80029f4:	d101      	bne.n	80029fa <??ZbZclAttrIntegerWrite_0>
 80029f6:	2087      	movs	r0, #135	; 0x87
 80029f8:	e042      	b.n	8002a80 <??ZbZclAttrIntegerWrite_1>

080029fa <??ZbZclAttrIntegerWrite_0>:
 80029fa:	ab04      	add	r3, sp, #16
 80029fc:	f10d 0211 	add.w	r2, sp, #17
 8002a00:	4649      	mov	r1, r9
 8002a02:	b289      	uxth	r1, r1
 8002a04:	4640      	mov	r0, r8
 8002a06:	f7ff ff9f 	bl	8002948 <ZbZclAttrIntegerRead>
 8002a0a:	0006      	movs	r6, r0
 8002a0c:	000f      	movs	r7, r1
 8002a0e:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8002a12:	2800      	cmp	r0, #0
 8002a14:	d002      	beq.n	8002a1c <??ZbZclAttrIntegerWrite_2>
 8002a16:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8002a1a:	e031      	b.n	8002a80 <??ZbZclAttrIntegerWrite_1>

08002a1c <??ZbZclAttrIntegerWrite_2>:
 8002a1c:	42af      	cmp	r7, r5
 8002a1e:	d103      	bne.n	8002a28 <??ZbZclAttrIntegerWrite_3>
 8002a20:	42a6      	cmp	r6, r4
 8002a22:	d101      	bne.n	8002a28 <??ZbZclAttrIntegerWrite_3>
 8002a24:	2000      	movs	r0, #0
 8002a26:	e02b      	b.n	8002a80 <??ZbZclAttrIntegerWrite_1>

08002a28 <??ZbZclAttrIntegerWrite_3>:
 8002a28:	2000      	movs	r0, #0
 8002a2a:	2100      	movs	r1, #0
 8002a2c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8002a30:	2000      	movs	r0, #0
 8002a32:	2100      	movs	r1, #0
 8002a34:	e9cd 0100 	strd	r0, r1, [sp]
 8002a38:	f89d 2011 	ldrb.w	r2, [sp, #17]
 8002a3c:	0020      	movs	r0, r4
 8002a3e:	0029      	movs	r1, r5
 8002a40:	f7ff fdac 	bl	800259c <ZbZclAttrIntegerRangeCheck>
 8002a44:	2800      	cmp	r0, #0
 8002a46:	d101      	bne.n	8002a4c <??ZbZclAttrIntegerWrite_4>
 8002a48:	2087      	movs	r0, #135	; 0x87
 8002a4a:	e019      	b.n	8002a80 <??ZbZclAttrIntegerWrite_1>

08002a4c <??ZbZclAttrIntegerWrite_4>:
 8002a4c:	0022      	movs	r2, r4
 8002a4e:	002b      	movs	r3, r5
 8002a50:	a805      	add	r0, sp, #20
 8002a52:	f7fd fc34 	bl	80002be <putle64>
 8002a56:	2002      	movs	r0, #2
 8002a58:	9001      	str	r0, [sp, #4]
 8002a5a:	2008      	movs	r0, #8
 8002a5c:	9000      	str	r0, [sp, #0]
 8002a5e:	ab05      	add	r3, sp, #20
 8002a60:	464a      	mov	r2, r9
 8002a62:	b292      	uxth	r2, r2
 8002a64:	2100      	movs	r1, #0
 8002a66:	4640      	mov	r0, r8
 8002a68:	f7fe fdcf 	bl	800160a <ZbZclAttrWrite>
 8002a6c:	f88d 0010 	strb.w	r0, [sp, #16]
 8002a70:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8002a74:	2800      	cmp	r0, #0
 8002a76:	d002      	beq.n	8002a7e <??ZbZclAttrIntegerWrite_5>
 8002a78:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8002a7c:	e000      	b.n	8002a80 <??ZbZclAttrIntegerWrite_1>

08002a7e <??ZbZclAttrIntegerWrite_5>:
 8002a7e:	2000      	movs	r0, #0

08002a80 <??ZbZclAttrIntegerWrite_1>:
 8002a80:	b007      	add	sp, #28
 8002a82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002a86 <ZbZclAttrIntegerIncrement>:
 8002a86:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002a8a:	b084      	sub	sp, #16
 8002a8c:	468b      	mov	fp, r1
 8002a8e:	0016      	movs	r6, r2
 8002a90:	001f      	movs	r7, r3
 8002a92:	f05f 0a00 	movs.w	sl, #0
 8002a96:	466b      	mov	r3, sp
 8002a98:	f10d 0201 	add.w	r2, sp, #1
 8002a9c:	4659      	mov	r1, fp
 8002a9e:	b289      	uxth	r1, r1
 8002aa0:	9804      	ldr	r0, [sp, #16]
 8002aa2:	f7ff ff51 	bl	8002948 <ZbZclAttrIntegerRead>
 8002aa6:	0002      	movs	r2, r0
 8002aa8:	000b      	movs	r3, r1
 8002aaa:	f89d 0000 	ldrb.w	r0, [sp]
 8002aae:	2800      	cmp	r0, #0
 8002ab0:	d002      	beq.n	8002ab8 <??ZbZclAttrIntegerIncrement_0>
 8002ab2:	f89d 0000 	ldrb.w	r0, [sp]
 8002ab6:	e03e      	b.n	8002b36 <??ZbZclAttrIntegerIncrement_1>

08002ab8 <??ZbZclAttrIntegerIncrement_0>:
 8002ab8:	eb12 0806 	adds.w	r8, r2, r6
 8002abc:	eb53 0907 	adcs.w	r9, r3, r7
 8002ac0:	e9cd 8902 	strd	r8, r9, [sp, #8]
 8002ac4:	f89d 0001 	ldrb.w	r0, [sp, #1]
 8002ac8:	f7ff f9ea 	bl	8001ea0 <ZbZclAttrTypeLength>
 8002acc:	9001      	str	r0, [sp, #4]
 8002ace:	9801      	ldr	r0, [sp, #4]
 8002ad0:	2801      	cmp	r0, #1
 8002ad2:	d017      	beq.n	8002b04 <??ZbZclAttrIntegerIncrement_2>
 8002ad4:	2802      	cmp	r0, #2
 8002ad6:	d00b      	beq.n	8002af0 <??ZbZclAttrIntegerIncrement_3>
 8002ad8:	2804      	cmp	r0, #4
 8002ada:	d002      	beq.n	8002ae2 <??ZbZclAttrIntegerIncrement_4>
 8002adc:	2808      	cmp	r0, #8
 8002ade:	d118      	bne.n	8002b12 <??ZbZclAttrIntegerIncrement_5>

08002ae0 <??ZbZclAttrIntegerIncrement_6>:
 8002ae0:	e019      	b.n	8002b16 <??ZbZclAttrIntegerIncrement_7>

08002ae2 <??ZbZclAttrIntegerIncrement_4>:
 8002ae2:	f038 0000 	bics.w	r0, r8, #0
 8002ae6:	f039 31ff 	bics.w	r1, r9, #4294967295	; 0xffffffff
 8002aea:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8002aee:	e012      	b.n	8002b16 <??ZbZclAttrIntegerIncrement_7>

08002af0 <??ZbZclAttrIntegerIncrement_3>:
 8002af0:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8002af4:	2100      	movs	r1, #0
 8002af6:	ea18 0000 	ands.w	r0, r8, r0
 8002afa:	ea19 0101 	ands.w	r1, r9, r1
 8002afe:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8002b02:	e008      	b.n	8002b16 <??ZbZclAttrIntegerIncrement_7>

08002b04 <??ZbZclAttrIntegerIncrement_2>:
 8002b04:	f018 00ff 	ands.w	r0, r8, #255	; 0xff
 8002b08:	f019 0100 	ands.w	r1, r9, #0
 8002b0c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8002b10:	e001      	b.n	8002b16 <??ZbZclAttrIntegerIncrement_7>

08002b12 <??ZbZclAttrIntegerIncrement_5>:
 8002b12:	2001      	movs	r0, #1
 8002b14:	4682      	mov	sl, r0

08002b16 <??ZbZclAttrIntegerIncrement_7>:
 8002b16:	4650      	mov	r0, sl
 8002b18:	b2c0      	uxtb	r0, r0
 8002b1a:	2800      	cmp	r0, #0
 8002b1c:	d001      	beq.n	8002b22 <??ZbZclAttrIntegerIncrement_8>
 8002b1e:	2086      	movs	r0, #134	; 0x86
 8002b20:	e009      	b.n	8002b36 <??ZbZclAttrIntegerIncrement_1>

08002b22 <??ZbZclAttrIntegerIncrement_8>:
 8002b22:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8002b26:	0022      	movs	r2, r4
 8002b28:	002b      	movs	r3, r5
 8002b2a:	4659      	mov	r1, fp
 8002b2c:	b289      	uxth	r1, r1
 8002b2e:	9804      	ldr	r0, [sp, #16]
 8002b30:	f7ff ff57 	bl	80029e2 <ZbZclAttrIntegerWrite>
 8002b34:	2000      	movs	r0, #0

08002b36 <??ZbZclAttrIntegerIncrement_1>:
 8002b36:	b005      	add	sp, #20
 8002b38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002b3c <ZbZclAttrEuiRead>:
 8002b3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002b40:	b084      	sub	sp, #16
 8002b42:	0005      	movs	r5, r0
 8002b44:	000e      	movs	r6, r1
 8002b46:	0014      	movs	r4, r2
 8002b48:	f05f 0808 	movs.w	r8, #8
 8002b4c:	f05f 0900 	movs.w	r9, #0
 8002b50:	af02      	add	r7, sp, #8
 8002b52:	464a      	mov	r2, r9
 8002b54:	4641      	mov	r1, r8
 8002b56:	0038      	movs	r0, r7
 8002b58:	f002 ff85 	bl	8005a66 <__aeabi_memset>
 8002b5c:	2000      	movs	r0, #0
 8002b5e:	9001      	str	r0, [sp, #4]
 8002b60:	2008      	movs	r0, #8
 8002b62:	9000      	str	r0, [sp, #0]
 8002b64:	ab02      	add	r3, sp, #8
 8002b66:	2200      	movs	r2, #0
 8002b68:	0031      	movs	r1, r6
 8002b6a:	b289      	uxth	r1, r1
 8002b6c:	0028      	movs	r0, r5
 8002b6e:	f7fe fbfa 	bl	8001366 <ZbZclAttrRead>
 8002b72:	0007      	movs	r7, r0
 8002b74:	2c00      	cmp	r4, #0
 8002b76:	d000      	beq.n	8002b7a <??ZbZclAttrEuiRead_0>
 8002b78:	7027      	strb	r7, [r4, #0]

08002b7a <??ZbZclAttrEuiRead_0>:
 8002b7a:	0038      	movs	r0, r7
 8002b7c:	b2c0      	uxtb	r0, r0
 8002b7e:	2800      	cmp	r0, #0
 8002b80:	d002      	beq.n	8002b88 <??ZbZclAttrEuiRead_1>
 8002b82:	2000      	movs	r0, #0
 8002b84:	2100      	movs	r1, #0
 8002b86:	e002      	b.n	8002b8e <??ZbZclAttrEuiRead_2>

08002b88 <??ZbZclAttrEuiRead_1>:
 8002b88:	a802      	add	r0, sp, #8
 8002b8a:	f7fd fb45 	bl	8000218 <pletoh64>

08002b8e <??ZbZclAttrEuiRead_2>:
 8002b8e:	b005      	add	sp, #20
 8002b90:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002b94 <ZbZclAttrEuiWrite>:
 8002b94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002b98:	b085      	sub	sp, #20
 8002b9a:	4680      	mov	r8, r0
 8002b9c:	4689      	mov	r9, r1
 8002b9e:	0014      	movs	r4, r2
 8002ba0:	001d      	movs	r5, r3
 8002ba2:	f1b8 0f00 	cmp.w	r8, #0
 8002ba6:	d101      	bne.n	8002bac <??ZbZclAttrEuiWrite_0>
 8002ba8:	2087      	movs	r0, #135	; 0x87
 8002baa:	e02e      	b.n	8002c0a <??ZbZclAttrEuiWrite_1>

08002bac <??ZbZclAttrEuiWrite_0>:
 8002bac:	aa02      	add	r2, sp, #8
 8002bae:	4649      	mov	r1, r9
 8002bb0:	b289      	uxth	r1, r1
 8002bb2:	4640      	mov	r0, r8
 8002bb4:	f7ff ffc2 	bl	8002b3c <ZbZclAttrEuiRead>
 8002bb8:	0006      	movs	r6, r0
 8002bba:	000f      	movs	r7, r1
 8002bbc:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8002bc0:	2800      	cmp	r0, #0
 8002bc2:	d002      	beq.n	8002bca <??ZbZclAttrEuiWrite_2>
 8002bc4:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8002bc8:	e01f      	b.n	8002c0a <??ZbZclAttrEuiWrite_1>

08002bca <??ZbZclAttrEuiWrite_2>:
 8002bca:	42af      	cmp	r7, r5
 8002bcc:	d103      	bne.n	8002bd6 <??ZbZclAttrEuiWrite_3>
 8002bce:	42a6      	cmp	r6, r4
 8002bd0:	d101      	bne.n	8002bd6 <??ZbZclAttrEuiWrite_3>
 8002bd2:	2000      	movs	r0, #0
 8002bd4:	e019      	b.n	8002c0a <??ZbZclAttrEuiWrite_1>

08002bd6 <??ZbZclAttrEuiWrite_3>:
 8002bd6:	0022      	movs	r2, r4
 8002bd8:	002b      	movs	r3, r5
 8002bda:	a803      	add	r0, sp, #12
 8002bdc:	f7fd fb6f 	bl	80002be <putle64>
 8002be0:	2002      	movs	r0, #2
 8002be2:	9001      	str	r0, [sp, #4]
 8002be4:	2008      	movs	r0, #8
 8002be6:	9000      	str	r0, [sp, #0]
 8002be8:	ab03      	add	r3, sp, #12
 8002bea:	464a      	mov	r2, r9
 8002bec:	b292      	uxth	r2, r2
 8002bee:	2100      	movs	r1, #0
 8002bf0:	4640      	mov	r0, r8
 8002bf2:	f7fe fd0a 	bl	800160a <ZbZclAttrWrite>
 8002bf6:	f88d 0008 	strb.w	r0, [sp, #8]
 8002bfa:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8002bfe:	2800      	cmp	r0, #0
 8002c00:	d002      	beq.n	8002c08 <??ZbZclAttrEuiWrite_4>
 8002c02:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8002c06:	e000      	b.n	8002c0a <??ZbZclAttrEuiWrite_1>

08002c08 <??ZbZclAttrEuiWrite_4>:
 8002c08:	2000      	movs	r0, #0

08002c0a <??ZbZclAttrEuiWrite_1>:
 8002c0a:	b005      	add	sp, #20
 8002c0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002c10 <ZbZclAttrAppendList>:
 8002c10:	e92d 4ff6 	stmdb	sp!, {r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002c14:	b089      	sub	sp, #36	; 0x24
 8002c16:	0007      	movs	r7, r0
 8002c18:	000e      	movs	r6, r1
 8002c1a:	68b8      	ldr	r0, [r7, #8]
 8002c1c:	9008      	str	r0, [sp, #32]
 8002c1e:	2e00      	cmp	r6, #0
 8002c20:	d002      	beq.n	8002c28 <??ZbZclAttrAppendList_0>
 8002c22:	980a      	ldr	r0, [sp, #40]	; 0x28
 8002c24:	2800      	cmp	r0, #0
 8002c26:	d101      	bne.n	8002c2c <??ZbZclAttrAppendList_1>

08002c28 <??ZbZclAttrAppendList_0>:
 8002c28:	2000      	movs	r0, #0
 8002c2a:	e0c6      	b.n	8002dba <??ZbZclAttrAppendList_2>

08002c2c <??ZbZclAttrAppendList_1>:
 8002c2c:	f05f 0800 	movs.w	r8, #0

08002c30 <??ZbZclAttrAppendList_3>:
 8002c30:	980a      	ldr	r0, [sp, #40]	; 0x28
 8002c32:	4580      	cmp	r8, r0
 8002c34:	f080 80bd 	bcs.w	8002db2 <??ZbZclAttrAppendList_4>
 8002c38:	f05f 0928 	movs.w	r9, #40	; 0x28
 8002c3c:	fb09 f008 	mul.w	r0, r9, r8
 8002c40:	4430      	add	r0, r6
 8002c42:	7900      	ldrb	r0, [r0, #4]
 8002c44:	f010 0ff0 	tst.w	r0, #240	; 0xf0
 8002c48:	d007      	beq.n	8002c5a <??ZbZclAttrAppendList_5>
 8002c4a:	fb09 f008 	mul.w	r0, r9, r8
 8002c4e:	4430      	add	r0, r6
 8002c50:	68c0      	ldr	r0, [r0, #12]
 8002c52:	2800      	cmp	r0, #0
 8002c54:	d101      	bne.n	8002c5a <??ZbZclAttrAppendList_5>
 8002c56:	2001      	movs	r0, #1
 8002c58:	e0af      	b.n	8002dba <??ZbZclAttrAppendList_2>

08002c5a <??ZbZclAttrAppendList_5>:
 8002c5a:	fb09 f008 	mul.w	r0, r9, r8
 8002c5e:	5a31      	ldrh	r1, [r6, r0]
 8002c60:	0038      	movs	r0, r7
 8002c62:	f7fe fa7c 	bl	800115e <ZbZclAttrFind>
 8002c66:	0005      	movs	r5, r0
 8002c68:	2d00      	cmp	r5, #0
 8002c6a:	d003      	beq.n	8002c74 <??ZbZclAttrAppendList_6>
 8002c6c:	0029      	movs	r1, r5
 8002c6e:	0038      	movs	r0, r7
 8002c70:	f000 f8b6 	bl	8002de0 <ZbZclAttrFreeAttr>

08002c74 <??ZbZclAttrAppendList_6>:
 8002c74:	2418      	movs	r4, #24
 8002c76:	f05f 0a00 	movs.w	sl, #0
 8002c7a:	f10d 0b04 	add.w	fp, sp, #4
 8002c7e:	4652      	mov	r2, sl
 8002c80:	0021      	movs	r1, r4
 8002c82:	4658      	mov	r0, fp
 8002c84:	f002 feef 	bl	8005a66 <__aeabi_memset>
 8002c88:	a801      	add	r0, sp, #4
 8002c8a:	9001      	str	r0, [sp, #4]
 8002c8c:	a801      	add	r0, sp, #4
 8002c8e:	9002      	str	r0, [sp, #8]
 8002c90:	fb09 f008 	mul.w	r0, r9, r8
 8002c94:	4430      	add	r0, r6
 8002c96:	9003      	str	r0, [sp, #12]
 8002c98:	fb09 f008 	mul.w	r0, r9, r8
 8002c9c:	4430      	add	r0, r6
 8002c9e:	7900      	ldrb	r0, [r0, #4]
 8002ca0:	0780      	lsls	r0, r0, #30
 8002ca2:	d50b      	bpl.n	8002cbc <??ZbZclAttrAppendList_7>
 8002ca4:	fb09 f008 	mul.w	r0, r9, r8
 8002ca8:	4430      	add	r0, r6
 8002caa:	8c40      	ldrh	r0, [r0, #34]	; 0x22
 8002cac:	f8ad 001a 	strh.w	r0, [sp, #26]
 8002cb0:	fb09 f008 	mul.w	r0, r9, r8
 8002cb4:	4430      	add	r0, r6
 8002cb6:	8c00      	ldrh	r0, [r0, #32]
 8002cb8:	f8ad 0018 	strh.w	r0, [sp, #24]

08002cbc <??ZbZclAttrAppendList_7>:
 8002cbc:	fb09 f008 	mul.w	r0, r9, r8
 8002cc0:	4430      	add	r0, r6
 8002cc2:	7900      	ldrb	r0, [r0, #4]
 8002cc4:	f010 0030 	ands.w	r0, r0, #48	; 0x30
 8002cc8:	2830      	cmp	r0, #48	; 0x30
 8002cca:	d108      	bne.n	8002cde <??ZbZclAttrAppendList_8>
 8002ccc:	2000      	movs	r0, #0
 8002cce:	9000      	str	r0, [sp, #0]
 8002cd0:	fb09 f908 	mul.w	r9, r9, r8
 8002cd4:	eb06 0009 	add.w	r0, r6, r9
 8002cd8:	6880      	ldr	r0, [r0, #8]
 8002cda:	9005      	str	r0, [sp, #20]
 8002cdc:	e034      	b.n	8002d48 <??ZbZclAttrAppendList_9>

08002cde <??ZbZclAttrAppendList_8>:
 8002cde:	fb09 f008 	mul.w	r0, r9, r8
 8002ce2:	4430      	add	r0, r6
 8002ce4:	6880      	ldr	r0, [r0, #8]
 8002ce6:	2800      	cmp	r0, #0
 8002ce8:	d01f      	beq.n	8002d2a <??ZbZclAttrAppendList_10>
 8002cea:	fb09 f908 	mul.w	r9, r9, r8
 8002cee:	eb06 0009 	add.w	r0, r6, r9
 8002cf2:	6880      	ldr	r0, [r0, #8]
 8002cf4:	9005      	str	r0, [sp, #20]
 8002cf6:	9803      	ldr	r0, [sp, #12]
 8002cf8:	7880      	ldrb	r0, [r0, #2]
 8002cfa:	2841      	cmp	r0, #65	; 0x41
 8002cfc:	d003      	beq.n	8002d06 <??ZbZclAttrAppendList_11>
 8002cfe:	9803      	ldr	r0, [sp, #12]
 8002d00:	7880      	ldrb	r0, [r0, #2]
 8002d02:	2842      	cmp	r0, #66	; 0x42
 8002d04:	d103      	bne.n	8002d0e <??ZbZclAttrAppendList_12>

08002d06 <??ZbZclAttrAppendList_11>:
 8002d06:	9805      	ldr	r0, [sp, #20]
 8002d08:	1c40      	adds	r0, r0, #1
 8002d0a:	9005      	str	r0, [sp, #20]
 8002d0c:	e00a      	b.n	8002d24 <??ZbZclAttrAppendList_13>

08002d0e <??ZbZclAttrAppendList_12>:
 8002d0e:	9803      	ldr	r0, [sp, #12]
 8002d10:	7880      	ldrb	r0, [r0, #2]
 8002d12:	2843      	cmp	r0, #67	; 0x43
 8002d14:	d003      	beq.n	8002d1e <??ZbZclAttrAppendList_14>
 8002d16:	9803      	ldr	r0, [sp, #12]
 8002d18:	7880      	ldrb	r0, [r0, #2]
 8002d1a:	2844      	cmp	r0, #68	; 0x44
 8002d1c:	d102      	bne.n	8002d24 <??ZbZclAttrAppendList_13>

08002d1e <??ZbZclAttrAppendList_14>:
 8002d1e:	9805      	ldr	r0, [sp, #20]
 8002d20:	1c80      	adds	r0, r0, #2
 8002d22:	9005      	str	r0, [sp, #20]

08002d24 <??ZbZclAttrAppendList_13>:
 8002d24:	9805      	ldr	r0, [sp, #20]
 8002d26:	9000      	str	r0, [sp, #0]
 8002d28:	e00e      	b.n	8002d48 <??ZbZclAttrAppendList_9>

08002d2a <??ZbZclAttrAppendList_10>:
 8002d2a:	fb09 f908 	mul.w	r9, r9, r8
 8002d2e:	eb06 0009 	add.w	r0, r6, r9
 8002d32:	7880      	ldrb	r0, [r0, #2]
 8002d34:	f7ff f8b4 	bl	8001ea0 <ZbZclAttrTypeLength>
 8002d38:	9005      	str	r0, [sp, #20]
 8002d3a:	9805      	ldr	r0, [sp, #20]
 8002d3c:	2800      	cmp	r0, #0
 8002d3e:	d101      	bne.n	8002d44 <??ZbZclAttrAppendList_15>
 8002d40:	208d      	movs	r0, #141	; 0x8d
 8002d42:	e03a      	b.n	8002dba <??ZbZclAttrAppendList_2>

08002d44 <??ZbZclAttrAppendList_15>:
 8002d44:	9805      	ldr	r0, [sp, #20]
 8002d46:	9000      	str	r0, [sp, #0]

08002d48 <??ZbZclAttrAppendList_9>:
 8002d48:	2300      	movs	r3, #0
 8002d4a:	a236      	add	r2, pc, #216	; (adr r2, 8002e24 <??DataTable1>)
 8002d4c:	9900      	ldr	r1, [sp, #0]
 8002d4e:	3118      	adds	r1, #24
 8002d50:	9808      	ldr	r0, [sp, #32]
 8002d52:	f013 fa4b 	bl	80161ec <zb_heap_alloc>
 8002d56:	0004      	movs	r4, r0
 8002d58:	2c00      	cmp	r4, #0
 8002d5a:	d101      	bne.n	8002d60 <??ZbZclAttrAppendList_16>
 8002d5c:	2089      	movs	r0, #137	; 0x89
 8002d5e:	e02c      	b.n	8002dba <??ZbZclAttrAppendList_2>

08002d60 <??ZbZclAttrAppendList_16>:
 8002d60:	2518      	movs	r5, #24
 8002d62:	f10d 0904 	add.w	r9, sp, #4
 8002d66:	46a2      	mov	sl, r4
 8002d68:	002a      	movs	r2, r5
 8002d6a:	4649      	mov	r1, r9
 8002d6c:	4650      	mov	r0, sl
 8002d6e:	f015 fc10 	bl	8018592 <__aeabi_memcpy>
 8002d72:	9800      	ldr	r0, [sp, #0]
 8002d74:	2800      	cmp	r0, #0
 8002d76:	d00c      	beq.n	8002d92 <??ZbZclAttrAppendList_17>
 8002d78:	f114 0018 	adds.w	r0, r4, #24
 8002d7c:	60e0      	str	r0, [r4, #12]
 8002d7e:	9800      	ldr	r0, [sp, #0]
 8002d80:	9007      	str	r0, [sp, #28]
 8002d82:	2500      	movs	r5, #0
 8002d84:	f8d4 900c 	ldr.w	r9, [r4, #12]
 8002d88:	002a      	movs	r2, r5
 8002d8a:	9907      	ldr	r1, [sp, #28]
 8002d8c:	4648      	mov	r0, r9
 8002d8e:	f002 fe6a 	bl	8005a66 <__aeabi_memset>

08002d92 <??ZbZclAttrAppendList_17>:
 8002d92:	0021      	movs	r1, r4
 8002d94:	0038      	movs	r0, r7
 8002d96:	f7fe f9b3 	bl	8001100 <ZbZclAttrAddSorted>
 8002d9a:	68e0      	ldr	r0, [r4, #12]
 8002d9c:	2800      	cmp	r0, #0
 8002d9e:	d005      	beq.n	8002dac <??ZbZclAttrAppendList_18>
 8002da0:	6922      	ldr	r2, [r4, #16]
 8002da2:	68e1      	ldr	r1, [r4, #12]
 8002da4:	68a0      	ldr	r0, [r4, #8]
 8002da6:	7880      	ldrb	r0, [r0, #2]
 8002da8:	f7fe fdfa 	bl	80019a0 <ZbZclAttrDefaultValue>

08002dac <??ZbZclAttrAppendList_18>:
 8002dac:	f118 0801 	adds.w	r8, r8, #1
 8002db0:	e73e      	b.n	8002c30 <??ZbZclAttrAppendList_3>

08002db2 <??ZbZclAttrAppendList_4>:
 8002db2:	0038      	movs	r0, r7
 8002db4:	f000 ff3a 	bl	8003c2c <zcl_reporting_create_default_reports>
 8002db8:	2000      	movs	r0, #0

08002dba <??ZbZclAttrAppendList_2>:
 8002dba:	b00b      	add	sp, #44	; 0x2c
 8002dbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002dc0 <ZbZclAttrCallbackExec>:
 8002dc0:	b570      	push	{r4, r5, r6, lr}
 8002dc2:	0004      	movs	r4, r0
 8002dc4:	000d      	movs	r5, r1
 8002dc6:	0016      	movs	r6, r2
 8002dc8:	68a8      	ldr	r0, [r5, #8]
 8002dca:	68c0      	ldr	r0, [r0, #12]
 8002dcc:	2800      	cmp	r0, #0
 8002dce:	d005      	beq.n	8002ddc <??ZbZclAttrCallbackExec_0>
 8002dd0:	0031      	movs	r1, r6
 8002dd2:	0020      	movs	r0, r4
 8002dd4:	68aa      	ldr	r2, [r5, #8]
 8002dd6:	68d2      	ldr	r2, [r2, #12]
 8002dd8:	4790      	blx	r2
 8002dda:	e000      	b.n	8002dde <??ZbZclAttrCallbackExec_1>

08002ddc <??ZbZclAttrCallbackExec_0>:
 8002ddc:	2001      	movs	r0, #1

08002dde <??ZbZclAttrCallbackExec_1>:
 8002dde:	bd70      	pop	{r4, r5, r6, pc}

08002de0 <ZbZclAttrFreeAttr>:
 8002de0:	b538      	push	{r3, r4, r5, lr}
 8002de2:	0004      	movs	r4, r0
 8002de4:	000d      	movs	r5, r1
 8002de6:	68a8      	ldr	r0, [r5, #8]
 8002de8:	7900      	ldrb	r0, [r0, #4]
 8002dea:	0780      	lsls	r0, r0, #30
 8002dec:	d50b      	bpl.n	8002e06 <??ZbZclAttrFreeAttr_0>
 8002dee:	2200      	movs	r2, #0
 8002df0:	68a8      	ldr	r0, [r5, #8]
 8002df2:	8801      	ldrh	r1, [r0, #0]
 8002df4:	0020      	movs	r0, r4
 8002df6:	f000 fdfd 	bl	80039f4 <zcl_cluster_attr_report_delete>
 8002dfa:	2201      	movs	r2, #1
 8002dfc:	68a8      	ldr	r0, [r5, #8]
 8002dfe:	8801      	ldrh	r1, [r0, #0]
 8002e00:	0020      	movs	r0, r4
 8002e02:	f000 fdf7 	bl	80039f4 <zcl_cluster_attr_report_delete>

08002e06 <??ZbZclAttrFreeAttr_0>:
 8002e06:	6868      	ldr	r0, [r5, #4]
 8002e08:	6829      	ldr	r1, [r5, #0]
 8002e0a:	6048      	str	r0, [r1, #4]
 8002e0c:	6828      	ldr	r0, [r5, #0]
 8002e0e:	6869      	ldr	r1, [r5, #4]
 8002e10:	6008      	str	r0, [r1, #0]
 8002e12:	602d      	str	r5, [r5, #0]
 8002e14:	606d      	str	r5, [r5, #4]
 8002e16:	2300      	movs	r3, #0
 8002e18:	a202      	add	r2, pc, #8	; (adr r2, 8002e24 <??DataTable1>)
 8002e1a:	0029      	movs	r1, r5
 8002e1c:	68a0      	ldr	r0, [r4, #8]
 8002e1e:	f013 f9f4 	bl	801620a <zb_heap_free>
 8002e22:	bd31      	pop	{r0, r4, r5, pc}

08002e24 <??DataTable1>:
 8002e24:	0000 0000                                   ....

08002e28 <ZbZclAttrFreeList>:
 8002e28:	b570      	push	{r4, r5, r6, lr}
 8002e2a:	0005      	movs	r5, r0

08002e2c <??ZbZclAttrFreeList_0>:
 8002e2c:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8002e2e:	f115 0124 	adds.w	r1, r5, #36	; 0x24
 8002e32:	4288      	cmp	r0, r1
 8002e34:	d001      	beq.n	8002e3a <??ZbZclAttrFreeList_1>
 8002e36:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8002e38:	e000      	b.n	8002e3c <??ZbZclAttrFreeList_2>

08002e3a <??ZbZclAttrFreeList_1>:
 8002e3a:	2400      	movs	r4, #0

08002e3c <??ZbZclAttrFreeList_2>:
 8002e3c:	2c00      	cmp	r4, #0
 8002e3e:	d005      	beq.n	8002e4c <??ZbZclAttrFreeList_3>

08002e40 <??ZbZclAttrFreeList_4>:
 8002e40:	0026      	movs	r6, r4
 8002e42:	0031      	movs	r1, r6
 8002e44:	0028      	movs	r0, r5
 8002e46:	f7ff ffcb 	bl	8002de0 <ZbZclAttrFreeAttr>
 8002e4a:	e7ef      	b.n	8002e2c <??ZbZclAttrFreeList_0>

08002e4c <??ZbZclAttrFreeList_3>:
 8002e4c:	bd70      	pop	{r4, r5, r6, pc}
	...

08002e50 <zcl_reporting_send_conf>:
 8002e50:	000b      	movs	r3, r1
 8002e52:	7e02      	ldrb	r2, [r0, #24]
 8002e54:	2a00      	cmp	r2, #0
 8002e56:	d004      	beq.n	8002e62 <??zcl_reporting_send_conf_0>
 8002e58:	7e02      	ldrb	r2, [r0, #24]
 8002e5a:	2aa4      	cmp	r2, #164	; 0xa4
 8002e5c:	d001      	beq.n	8002e62 <??zcl_reporting_send_conf_0>
 8002e5e:	7e02      	ldrb	r2, [r0, #24]
 8002e60:	2aa3      	cmp	r2, #163	; 0xa3

08002e62 <??zcl_reporting_send_conf_0>:
 8002e62:	4770      	bx	lr

08002e64 <report_command_timer>:
 8002e64:	b570      	push	{r4, r5, r6, lr}
 8002e66:	0004      	movs	r4, r0
 8002e68:	000d      	movs	r5, r1
 8002e6a:	002e      	movs	r6, r5
 8002e6c:	f116 0108 	adds.w	r1, r6, #8
 8002e70:	6830      	ldr	r0, [r6, #0]
 8002e72:	f000 f852 	bl	8002f1a <zcl_reporting_send_report>
 8002e76:	6870      	ldr	r0, [r6, #4]
 8002e78:	f012 fe48 	bl	8015b0c <ZbTimerFree>
 8002e7c:	2300      	movs	r3, #0
 8002e7e:	a2cf      	add	r2, pc, #828	; (adr r2, 80031bc <??DataTable4>)
 8002e80:	0031      	movs	r1, r6
 8002e82:	6830      	ldr	r0, [r6, #0]
 8002e84:	6880      	ldr	r0, [r0, #8]
 8002e86:	f013 f9c0 	bl	801620a <zb_heap_free>
 8002e8a:	bd70      	pop	{r4, r5, r6, pc}

08002e8c <zcl_reporting_queue_report>:
 8002e8c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002e90:	0006      	movs	r6, r0
 8002e92:	000f      	movs	r7, r1
 8002e94:	0014      	movs	r4, r2
 8002e96:	2c00      	cmp	r4, #0
 8002e98:	d104      	bne.n	8002ea4 <??zcl_reporting_queue_report_0>
 8002e9a:	0039      	movs	r1, r7
 8002e9c:	0030      	movs	r0, r6
 8002e9e:	f000 f83c 	bl	8002f1a <zcl_reporting_send_report>
 8002ea2:	e037      	b.n	8002f14 <??zcl_reporting_queue_report_1>

08002ea4 <??zcl_reporting_queue_report_0>:
 8002ea4:	f20f 3814 	addw	r8, pc, #788	; 0x314
 8002ea8:	2300      	movs	r3, #0
 8002eaa:	4642      	mov	r2, r8
 8002eac:	2198      	movs	r1, #152	; 0x98
 8002eae:	68b0      	ldr	r0, [r6, #8]
 8002eb0:	f013 f99c 	bl	80161ec <zb_heap_alloc>
 8002eb4:	0005      	movs	r5, r0
 8002eb6:	2d00      	cmp	r5, #0
 8002eb8:	d101      	bne.n	8002ebe <??zcl_reporting_queue_report_2>
 8002eba:	2000      	movs	r0, #0
 8002ebc:	e02b      	b.n	8002f16 <??zcl_reporting_queue_report_3>

08002ebe <??zcl_reporting_queue_report_2>:
 8002ebe:	f05f 0998 	movs.w	r9, #152	; 0x98
 8002ec2:	f05f 0a00 	movs.w	sl, #0
 8002ec6:	46ab      	mov	fp, r5
 8002ec8:	4652      	mov	r2, sl
 8002eca:	4649      	mov	r1, r9
 8002ecc:	4658      	mov	r0, fp
 8002ece:	f002 fdca 	bl	8005a66 <__aeabi_memset>
 8002ed2:	002a      	movs	r2, r5
 8002ed4:	f8df 1c98 	ldr.w	r1, [pc, #3224]	; 8003b70 <??DataTable9>
 8002ed8:	68b0      	ldr	r0, [r6, #8]
 8002eda:	f012 fdc5 	bl	8015a68 <ZbTimerAlloc>
 8002ede:	6068      	str	r0, [r5, #4]
 8002ee0:	6868      	ldr	r0, [r5, #4]
 8002ee2:	2800      	cmp	r0, #0
 8002ee4:	d107      	bne.n	8002ef6 <??zcl_reporting_queue_report_4>
 8002ee6:	2300      	movs	r3, #0
 8002ee8:	4642      	mov	r2, r8
 8002eea:	0029      	movs	r1, r5
 8002eec:	68b0      	ldr	r0, [r6, #8]
 8002eee:	f013 f98c 	bl	801620a <zb_heap_free>
 8002ef2:	2000      	movs	r0, #0
 8002ef4:	e00f      	b.n	8002f16 <??zcl_reporting_queue_report_3>

08002ef6 <??zcl_reporting_queue_report_4>:
 8002ef6:	602e      	str	r6, [r5, #0]
 8002ef8:	f05f 0890 	movs.w	r8, #144	; 0x90
 8002efc:	46b9      	mov	r9, r7
 8002efe:	f115 0a08 	adds.w	sl, r5, #8
 8002f02:	4642      	mov	r2, r8
 8002f04:	4649      	mov	r1, r9
 8002f06:	4650      	mov	r0, sl
 8002f08:	f015 fb43 	bl	8018592 <__aeabi_memcpy>
 8002f0c:	0021      	movs	r1, r4
 8002f0e:	6868      	ldr	r0, [r5, #4]
 8002f10:	f012 fe30 	bl	8015b74 <ZbTimerReset>

08002f14 <??zcl_reporting_queue_report_1>:
 8002f14:	2001      	movs	r0, #1

08002f16 <??zcl_reporting_queue_report_3>:
 8002f16:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002f1a <zcl_reporting_send_report>:
 8002f1a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002f1e:	b0cc      	sub	sp, #304	; 0x130
 8002f20:	0005      	movs	r5, r0
 8002f22:	000e      	movs	r6, r1
 8002f24:	2400      	movs	r4, #0
 8002f26:	2000      	movs	r0, #0
 8002f28:	f88d 0004 	strb.w	r0, [sp, #4]
 8002f2c:	8a28      	ldrh	r0, [r5, #16]
 8002f2e:	2800      	cmp	r0, #0
 8002f30:	d001      	beq.n	8002f36 <??zcl_reporting_send_report_0>
 8002f32:	2001      	movs	r0, #1
 8002f34:	e000      	b.n	8002f38 <??zcl_reporting_send_report_1>

08002f36 <??zcl_reporting_send_report_0>:
 8002f36:	2000      	movs	r0, #0

08002f38 <??zcl_reporting_send_report_1>:
 8002f38:	f88d 0005 	strb.w	r0, [sp, #5]
 8002f3c:	8a28      	ldrh	r0, [r5, #16]
 8002f3e:	f8ad 0008 	strh.w	r0, [sp, #8]
 8002f42:	7f28      	ldrb	r0, [r5, #28]
 8002f44:	2800      	cmp	r0, #0
 8002f46:	d103      	bne.n	8002f50 <??zcl_reporting_send_report_2>
 8002f48:	2001      	movs	r0, #1
 8002f4a:	f88d 0006 	strb.w	r0, [sp, #6]
 8002f4e:	e002      	b.n	8002f56 <??zcl_reporting_send_report_3>

08002f50 <??zcl_reporting_send_report_2>:
 8002f50:	2000      	movs	r0, #0
 8002f52:	f88d 0006 	strb.w	r0, [sp, #6]

08002f56 <??zcl_reporting_send_report_3>:
 8002f56:	2001      	movs	r0, #1
 8002f58:	f88d 0007 	strb.w	r0, [sp, #7]
 8002f5c:	f012 ff85 	bl	8015e6a <ZbZclGetNextSeqnum>
 8002f60:	f88d 000a 	strb.w	r0, [sp, #10]
 8002f64:	200a      	movs	r0, #10
 8002f66:	f88d 000b 	strb.w	r0, [sp, #11]
 8002f6a:	2205      	movs	r2, #5
 8002f6c:	a903      	add	r1, sp, #12
 8002f6e:	a801      	add	r0, sp, #4
 8002f70:	f7fe f874 	bl	800105c <ZbZclAppendHeader>
 8002f74:	0007      	movs	r7, r0
 8002f76:	2f01      	cmp	r7, #1
 8002f78:	f2c0 8093 	blt.w	80030a2 <??zcl_reporting_send_report_4>

08002f7c <??zcl_reporting_send_report_5>:
 8002f7c:	a91a      	add	r1, sp, #104	; 0x68
 8002f7e:	a803      	add	r0, sp, #12
 8002f80:	0022      	movs	r2, r4
 8002f82:	b2d2      	uxtb	r2, r2
 8002f84:	f841 0032 	str.w	r0, [r1, r2, lsl #3]
 8002f88:	0038      	movs	r0, r7
 8002f8a:	b2c0      	uxtb	r0, r0
 8002f8c:	aa1a      	add	r2, sp, #104	; 0x68
 8002f8e:	0023      	movs	r3, r4
 8002f90:	b2db      	uxtb	r3, r3
 8002f92:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8002f96:	6050      	str	r0, [r2, #4]
 8002f98:	1c64      	adds	r4, r4, #1
 8002f9a:	2000      	movs	r0, #0
 8002f9c:	4680      	mov	r8, r0

08002f9e <??zcl_reporting_send_report_6>:
 8002f9e:	f1b8 0f0c 	cmp.w	r8, #12
 8002fa2:	d22e      	bcs.n	8003002 <??zcl_reporting_send_report_7>
 8002fa4:	220c      	movs	r2, #12
 8002fa6:	fb02 f008 	mul.w	r0, r2, r8
 8002faa:	4430      	add	r0, r6
 8002fac:	7a00      	ldrb	r0, [r0, #8]
 8002fae:	2800      	cmp	r0, #0
 8002fb0:	d027      	beq.n	8003002 <??zcl_reporting_send_report_7>

08002fb2 <??zcl_reporting_send_report_8>:
 8002fb2:	fb02 f008 	mul.w	r0, r2, r8
 8002fb6:	4430      	add	r0, r6
 8002fb8:	3009      	adds	r0, #9
 8002fba:	0023      	movs	r3, r4
 8002fbc:	b2db      	uxtb	r3, r3
 8002fbe:	f841 0033 	str.w	r0, [r1, r3, lsl #3]
 8002fc2:	2003      	movs	r0, #3
 8002fc4:	ab1a      	add	r3, sp, #104	; 0x68
 8002fc6:	46a4      	mov	ip, r4
 8002fc8:	fa5f fc8c 	uxtb.w	ip, ip
 8002fcc:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 8002fd0:	6058      	str	r0, [r3, #4]
 8002fd2:	1c64      	adds	r4, r4, #1
 8002fd4:	fb02 f008 	mul.w	r0, r2, r8
 8002fd8:	4430      	add	r0, r6
 8002fda:	6840      	ldr	r0, [r0, #4]
 8002fdc:	0023      	movs	r3, r4
 8002fde:	b2db      	uxtb	r3, r3
 8002fe0:	f841 0033 	str.w	r0, [r1, r3, lsl #3]
 8002fe4:	fb02 f208 	mul.w	r2, r2, r8
 8002fe8:	eb06 0002 	add.w	r0, r6, r2
 8002fec:	7a00      	ldrb	r0, [r0, #8]
 8002fee:	aa1a      	add	r2, sp, #104	; 0x68
 8002ff0:	0023      	movs	r3, r4
 8002ff2:	b2db      	uxtb	r3, r3
 8002ff4:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8002ff8:	6050      	str	r0, [r2, #4]
 8002ffa:	1c64      	adds	r4, r4, #1
 8002ffc:	f118 0801 	adds.w	r8, r8, #1
 8003000:	e7cd      	b.n	8002f9e <??zcl_reporting_send_report_6>

08003002 <??zcl_reporting_send_report_7>:
 8003002:	2200      	movs	r2, #0
 8003004:	a906      	add	r1, sp, #24
 8003006:	0028      	movs	r0, r5
 8003008:	f7fd fac7 	bl	800059a <ZbZclClusterInitApsdeReq>
 800300c:	a806      	add	r0, sp, #24
 800300e:	f8df 1b68 	ldr.w	r1, [pc, #2920]	; 8003b78 <??DataTable9_2>
 8003012:	6809      	ldr	r1, [r1, #0]
 8003014:	2210      	movs	r2, #16
 8003016:	f015 fabc 	bl	8018592 <__aeabi_memcpy>
 800301a:	2001      	movs	r0, #1
 800301c:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8003020:	f8bd 003c 	ldrh.w	r0, [sp, #60]	; 0x3c
 8003024:	f050 0004 	orrs.w	r0, r0, #4
 8003028:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 800302c:	f8bd 003c 	ldrh.w	r0, [sp, #60]	; 0x3c
 8003030:	f450 7080 	orrs.w	r0, r0, #256	; 0x100
 8003034:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8003038:	7ca8      	ldrb	r0, [r5, #18]
 800303a:	28ab      	cmp	r0, #171	; 0xab
 800303c:	d005      	beq.n	800304a <??zcl_reporting_send_report_9>
 800303e:	f8bd 003c 	ldrh.w	r0, [sp, #60]	; 0x3c
 8003042:	f050 0002 	orrs.w	r0, r0, #2
 8003046:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c

0800304a <??zcl_reporting_send_report_9>:
 800304a:	2001      	movs	r0, #1
 800304c:	f88d 003e 	strb.w	r0, [sp, #62]	; 0x3e
 8003050:	2000      	movs	r0, #0
 8003052:	f88d 003f 	strb.w	r0, [sp, #63]	; 0x3f
 8003056:	a81a      	add	r0, sp, #104	; 0x68
 8003058:	900c      	str	r0, [sp, #48]	; 0x30
 800305a:	0020      	movs	r0, r4
 800305c:	b2c0      	uxtb	r0, r0
 800305e:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
 8003062:	68ab      	ldr	r3, [r5, #8]
 8003064:	f8df 2b14 	ldr.w	r2, [pc, #2836]	; 8003b7c <??DataTable9_3>
 8003068:	a906      	add	r1, sp, #24
 800306a:	68a8      	ldr	r0, [r5, #8]
 800306c:	f012 fac4 	bl	80155f8 <ZbApsdeDataReqCallback>
 8003070:	f88d 0000 	strb.w	r0, [sp]
 8003074:	f89d 0000 	ldrb.w	r0, [sp]
 8003078:	2800      	cmp	r0, #0
 800307a:	d012      	beq.n	80030a2 <??zcl_reporting_send_report_4>
 800307c:	f05f 0920 	movs.w	r9, #32
 8003080:	f05f 0a00 	movs.w	sl, #0
 8003084:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
 8003088:	4652      	mov	r2, sl
 800308a:	4649      	mov	r1, r9
 800308c:	4658      	mov	r0, fp
 800308e:	f002 fcea 	bl	8005a66 <__aeabi_memset>
 8003092:	f89d 0000 	ldrb.w	r0, [sp]
 8003096:	f88d 0060 	strb.w	r0, [sp, #96]	; 0x60
 800309a:	68a9      	ldr	r1, [r5, #8]
 800309c:	a812      	add	r0, sp, #72	; 0x48
 800309e:	f7ff fed7 	bl	8002e50 <zcl_reporting_send_conf>

080030a2 <??zcl_reporting_send_report_4>:
 80030a2:	f05f 0900 	movs.w	r9, #0

080030a6 <??zcl_reporting_send_report_10>:
 80030a6:	f1b9 0f0c 	cmp.w	r9, #12
 80030aa:	d21e      	bcs.n	80030ea <??zcl_reporting_send_report_11>
 80030ac:	f05f 080c 	movs.w	r8, #12
 80030b0:	fb08 f009 	mul.w	r0, r8, r9
 80030b4:	4430      	add	r0, r6
 80030b6:	6840      	ldr	r0, [r0, #4]
 80030b8:	2800      	cmp	r0, #0
 80030ba:	d016      	beq.n	80030ea <??zcl_reporting_send_report_11>

080030bc <??zcl_reporting_send_report_12>:
 80030bc:	2300      	movs	r3, #0
 80030be:	a23f      	add	r2, pc, #252	; (adr r2, 80031bc <??DataTable4>)
 80030c0:	fb08 f009 	mul.w	r0, r8, r9
 80030c4:	4430      	add	r0, r6
 80030c6:	6841      	ldr	r1, [r0, #4]
 80030c8:	68a8      	ldr	r0, [r5, #8]
 80030ca:	f013 f89e 	bl	801620a <zb_heap_free>
 80030ce:	2000      	movs	r0, #0
 80030d0:	fb08 f109 	mul.w	r1, r8, r9
 80030d4:	4431      	add	r1, r6
 80030d6:	6048      	str	r0, [r1, #4]
 80030d8:	2000      	movs	r0, #0
 80030da:	fb08 f809 	mul.w	r8, r8, r9
 80030de:	eb06 0108 	add.w	r1, r6, r8
 80030e2:	7208      	strb	r0, [r1, #8]
 80030e4:	f119 0901 	adds.w	r9, r9, #1
 80030e8:	e7dd      	b.n	80030a6 <??zcl_reporting_send_report_10>

080030ea <??zcl_reporting_send_report_11>:
 80030ea:	b04d      	add	sp, #308	; 0x134
 80030ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080030f0 <zcl_report_check_time>:
 80030f0:	4281      	cmp	r1, r0
 80030f2:	d201      	bcs.n	80030f8 <??zcl_report_check_time_0>
 80030f4:	0008      	movs	r0, r1
 80030f6:	e7ff      	b.n	80030f8 <??zcl_report_check_time_0>

080030f8 <??zcl_report_check_time_0>:
 80030f8:	4770      	bx	lr

080030fa <zcl_report_kick>:
 80030fa:	b538      	push	{r3, r4, r5, lr}
 80030fc:	0004      	movs	r4, r0
 80030fe:	000d      	movs	r5, r1
 8003100:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8003102:	2800      	cmp	r0, #0
 8003104:	d101      	bne.n	800310a <??zcl_report_kick_0>
 8003106:	2000      	movs	r0, #0
 8003108:	e00d      	b.n	8003126 <??zcl_report_kick_1>

0800310a <??zcl_report_kick_0>:
 800310a:	f894 003d 	ldrb.w	r0, [r4, #61]	; 0x3d
 800310e:	2800      	cmp	r0, #0
 8003110:	d001      	beq.n	8003116 <??zcl_report_kick_2>
 8003112:	2001      	movs	r0, #1
 8003114:	e007      	b.n	8003126 <??zcl_report_kick_1>

08003116 <??zcl_report_kick_2>:
 8003116:	2001      	movs	r0, #1
 8003118:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
 800311c:	0029      	movs	r1, r5
 800311e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8003120:	f012 fd28 	bl	8015b74 <ZbTimerReset>
 8003124:	2001      	movs	r0, #1

08003126 <??zcl_report_kick_1>:
 8003126:	bd32      	pop	{r1, r4, r5, pc}

08003128 <ZbZclAttrReportKick>:
 8003128:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800312a:	0004      	movs	r4, r0
 800312c:	000d      	movs	r5, r1
 800312e:	0016      	movs	r6, r2
 8003130:	001f      	movs	r7, r3
 8003132:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8003134:	2800      	cmp	r0, #0
 8003136:	d001      	beq.n	800313c <??ZbZclAttrReportKick_0>
 8003138:	2001      	movs	r0, #1
 800313a:	e010      	b.n	800315e <??ZbZclAttrReportKick_1>

0800313c <??ZbZclAttrReportKick_0>:
 800313c:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
 8003140:	6426      	str	r6, [r4, #64]	; 0x40
 8003142:	6467      	str	r7, [r4, #68]	; 0x44
 8003144:	2100      	movs	r1, #0
 8003146:	0020      	movs	r0, r4
 8003148:	f7ff ffd7 	bl	80030fa <zcl_report_kick>
 800314c:	2800      	cmp	r0, #0
 800314e:	d105      	bne.n	800315c <??ZbZclAttrReportKick_2>
 8003150:	2000      	movs	r0, #0
 8003152:	6420      	str	r0, [r4, #64]	; 0x40
 8003154:	2000      	movs	r0, #0
 8003156:	6460      	str	r0, [r4, #68]	; 0x44
 8003158:	2001      	movs	r0, #1
 800315a:	e000      	b.n	800315e <??ZbZclAttrReportKick_1>

0800315c <??ZbZclAttrReportKick_2>:
 800315c:	2000      	movs	r0, #0

0800315e <??ZbZclAttrReportKick_1>:
 800315e:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

08003160 <zcl_report_append_attr>:
 8003160:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003164:	0004      	movs	r4, r0
 8003166:	000d      	movs	r5, r1
 8003168:	0016      	movs	r6, r2
 800316a:	001f      	movs	r7, r3
 800316c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 8003170:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8003174:	2300      	movs	r3, #0
 8003176:	a211      	add	r2, pc, #68	; (adr r2, 80031bc <??DataTable4>)
 8003178:	4649      	mov	r1, r9
 800317a:	0020      	movs	r0, r4
 800317c:	f013 f836 	bl	80161ec <zb_heap_alloc>
 8003180:	6068      	str	r0, [r5, #4]
 8003182:	6868      	ldr	r0, [r5, #4]
 8003184:	2800      	cmp	r0, #0
 8003186:	d101      	bne.n	800318c <??zcl_report_append_attr_0>
 8003188:	2000      	movs	r0, #0
 800318a:	e014      	b.n	80031b6 <??zcl_report_append_attr_1>

0800318c <??zcl_report_append_attr_0>:
 800318c:	f8cd 9000 	str.w	r9, [sp]
 8003190:	46c2      	mov	sl, r8
 8003192:	f8d5 b004 	ldr.w	fp, [r5, #4]
 8003196:	9a00      	ldr	r2, [sp, #0]
 8003198:	4651      	mov	r1, sl
 800319a:	4658      	mov	r0, fp
 800319c:	f015 f9f9 	bl	8018592 <__aeabi_memcpy>
 80031a0:	f885 9008 	strb.w	r9, [r5, #8]
 80031a4:	802e      	strh	r6, [r5, #0]
 80031a6:	0031      	movs	r1, r6
 80031a8:	b289      	uxth	r1, r1
 80031aa:	f115 0009 	adds.w	r0, r5, #9
 80031ae:	f7fd f841 	bl	8000234 <putle16>
 80031b2:	72ef      	strb	r7, [r5, #11]
 80031b4:	2001      	movs	r0, #1

080031b6 <??zcl_report_append_attr_1>:
 80031b6:	e8bd 8ff2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080031bc <??DataTable4>:
 80031bc:	0000 0000                                   ....

080031c0 <zcl_cluster_report_check_timeout>:
 80031c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80031c4:	0006      	movs	r6, r0
 80031c6:	000f      	movs	r7, r1
 80031c8:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80031ca:	f116 0130 	adds.w	r1, r6, #48	; 0x30
 80031ce:	4288      	cmp	r0, r1
 80031d0:	d001      	beq.n	80031d6 <??zcl_cluster_report_check_timeout_0>
 80031d2:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80031d4:	e000      	b.n	80031d8 <??zcl_cluster_report_check_timeout_1>

080031d6 <??zcl_cluster_report_check_timeout_0>:
 80031d6:	2000      	movs	r0, #0

080031d8 <??zcl_cluster_report_check_timeout_1>:
 80031d8:	2800      	cmp	r0, #0
 80031da:	d101      	bne.n	80031e0 <??zcl_cluster_report_check_timeout_2>
 80031dc:	2000      	movs	r0, #0
 80031de:	e042      	b.n	8003266 <??zcl_cluster_report_check_timeout_3>

080031e0 <??zcl_cluster_report_check_timeout_2>:
 80031e0:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80031e2:	f116 0130 	adds.w	r1, r6, #48	; 0x30
 80031e6:	4288      	cmp	r0, r1
 80031e8:	d001      	beq.n	80031ee <??zcl_cluster_report_check_timeout_4>
 80031ea:	6b35      	ldr	r5, [r6, #48]	; 0x30
 80031ec:	e000      	b.n	80031f0 <??zcl_cluster_report_check_timeout_5>

080031ee <??zcl_cluster_report_check_timeout_4>:
 80031ee:	2500      	movs	r5, #0

080031f0 <??zcl_cluster_report_check_timeout_5>:
 80031f0:	2d00      	cmp	r5, #0
 80031f2:	d037      	beq.n	8003264 <??zcl_cluster_report_check_timeout_6>
 80031f4:	46a8      	mov	r8, r5
 80031f6:	f8b8 0022 	ldrh.w	r0, [r8, #34]	; 0x22
 80031fa:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80031fe:	4288      	cmp	r0, r1
 8003200:	d027      	beq.n	8003252 <??zcl_cluster_report_check_timeout_7>

08003202 <??zcl_cluster_report_check_timeout_8>:
 8003202:	f8b8 0020 	ldrh.w	r0, [r8, #32]
 8003206:	2800      	cmp	r0, #0
 8003208:	d00e      	beq.n	8003228 <??zcl_cluster_report_check_timeout_9>
 800320a:	f8d8 1010 	ldr.w	r1, [r8, #16]
 800320e:	f8b8 9020 	ldrh.w	r9, [r8, #32]
 8003212:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003216:	fb00 1909 	mla	r9, r0, r9, r1
 800321a:	4649      	mov	r1, r9
 800321c:	0038      	movs	r0, r7
 800321e:	f012 fcd9 	bl	8015bd4 <ZbTimeoutRemaining>
 8003222:	0004      	movs	r4, r0
 8003224:	2c00      	cmp	r4, #0
 8003226:	d114      	bne.n	8003252 <??zcl_cluster_report_check_timeout_7>

08003228 <??zcl_cluster_report_check_timeout_9>:
 8003228:	f8b8 0022 	ldrh.w	r0, [r8, #34]	; 0x22
 800322c:	2800      	cmp	r0, #0
 800322e:	d010      	beq.n	8003252 <??zcl_cluster_report_check_timeout_7>

08003230 <??zcl_cluster_report_check_timeout_10>:
 8003230:	f8d8 1010 	ldr.w	r1, [r8, #16]
 8003234:	f8b8 9022 	ldrh.w	r9, [r8, #34]	; 0x22
 8003238:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800323c:	fb00 1909 	mla	r9, r0, r9, r1
 8003240:	4649      	mov	r1, r9
 8003242:	0038      	movs	r0, r7
 8003244:	f012 fcc6 	bl	8015bd4 <ZbTimeoutRemaining>
 8003248:	0004      	movs	r4, r0
 800324a:	2c00      	cmp	r4, #0
 800324c:	d101      	bne.n	8003252 <??zcl_cluster_report_check_timeout_7>

0800324e <??zcl_cluster_report_check_timeout_11>:
 800324e:	2001      	movs	r0, #1
 8003250:	e009      	b.n	8003266 <??zcl_cluster_report_check_timeout_3>

08003252 <??zcl_cluster_report_check_timeout_7>:
 8003252:	6828      	ldr	r0, [r5, #0]
 8003254:	f116 0130 	adds.w	r1, r6, #48	; 0x30
 8003258:	4288      	cmp	r0, r1
 800325a:	d001      	beq.n	8003260 <??zcl_cluster_report_check_timeout_12>
 800325c:	682d      	ldr	r5, [r5, #0]
 800325e:	e7c7      	b.n	80031f0 <??zcl_cluster_report_check_timeout_5>

08003260 <??zcl_cluster_report_check_timeout_12>:
 8003260:	2500      	movs	r5, #0
 8003262:	e7c5      	b.n	80031f0 <??zcl_cluster_report_check_timeout_5>

08003264 <??zcl_cluster_report_check_timeout_6>:
 8003264:	2000      	movs	r0, #0

08003266 <??zcl_cluster_report_check_timeout_3>:
 8003266:	e8bd 83f2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, pc}
	...

0800326c <zcl_cluster_reports_timer>:
 800326c:	e92d 4ff3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003270:	b081      	sub	sp, #4
 8003272:	ed2d 8b04 	vpush	{d8-d9}
 8003276:	b0b0      	sub	sp, #192	; 0xc0
 8003278:	9836      	ldr	r0, [sp, #216]	; 0xd8
 800327a:	9003      	str	r0, [sp, #12]
 800327c:	2000      	movs	r0, #0
 800327e:	9005      	str	r0, [sp, #20]
 8003280:	2000      	movs	r0, #0
 8003282:	9007      	str	r0, [sp, #28]
 8003284:	f8df 08f8 	ldr.w	r0, [pc, #2296]	; 8003b80 <??DataTable9_4>
 8003288:	9006      	str	r0, [sp, #24]
 800328a:	2000      	movs	r0, #0
 800328c:	f88d 0010 	strb.w	r0, [sp, #16]
 8003290:	f05f 0b00 	movs.w	fp, #0
 8003294:	9803      	ldr	r0, [sp, #12]
 8003296:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
 800329a:	f88d 000b 	strb.w	r0, [sp, #11]
 800329e:	2000      	movs	r0, #0
 80032a0:	f88d 000a 	strb.w	r0, [sp, #10]
 80032a4:	2000      	movs	r0, #0
 80032a6:	9903      	ldr	r1, [sp, #12]
 80032a8:	f881 003d 	strb.w	r0, [r1, #61]	; 0x3d
 80032ac:	2000      	movs	r0, #0
 80032ae:	9903      	ldr	r1, [sp, #12]
 80032b0:	f881 003c 	strb.w	r0, [r1, #60]	; 0x3c
 80032b4:	9803      	ldr	r0, [sp, #12]
 80032b6:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80032b8:	9903      	ldr	r1, [sp, #12]
 80032ba:	3130      	adds	r1, #48	; 0x30
 80032bc:	4288      	cmp	r0, r1
 80032be:	d002      	beq.n	80032c6 <??zcl_cluster_reports_timer_1>
 80032c0:	9803      	ldr	r0, [sp, #12]
 80032c2:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80032c4:	e000      	b.n	80032c8 <??zcl_cluster_reports_timer_2>

080032c6 <??zcl_cluster_reports_timer_1>:
 80032c6:	2000      	movs	r0, #0

080032c8 <??zcl_cluster_reports_timer_2>:
 80032c8:	2800      	cmp	r0, #0
 80032ca:	f000 81f7 	beq.w	80036bc <??zcl_cluster_reports_timer_3>

080032ce <??zcl_cluster_reports_timer_4>:
 80032ce:	9835      	ldr	r0, [sp, #212]	; 0xd4
 80032d0:	f012 fd05 	bl	8015cde <ZbZclUptime>
 80032d4:	9009      	str	r0, [sp, #36]	; 0x24
 80032d6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80032d8:	9803      	ldr	r0, [sp, #12]
 80032da:	f7ff ff71 	bl	80031c0 <zcl_cluster_report_check_timeout>
 80032de:	2800      	cmp	r0, #0
 80032e0:	d004      	beq.n	80032ec <??zcl_cluster_reports_timer_5>
 80032e2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80032e4:	f510 707a 	adds.w	r0, r0, #1000	; 0x3e8
 80032e8:	900b      	str	r0, [sp, #44]	; 0x2c
 80032ea:	e001      	b.n	80032f0 <??zcl_cluster_reports_timer_6>

080032ec <??zcl_cluster_reports_timer_5>:
 80032ec:	9809      	ldr	r0, [sp, #36]	; 0x24
 80032ee:	900b      	str	r0, [sp, #44]	; 0x2c

080032f0 <??zcl_cluster_reports_timer_6>:
 80032f0:	2490      	movs	r4, #144	; 0x90
 80032f2:	2500      	movs	r5, #0
 80032f4:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 80032f8:	002a      	movs	r2, r5
 80032fa:	0021      	movs	r1, r4
 80032fc:	4640      	mov	r0, r8
 80032fe:	f002 fbb2 	bl	8005a66 <__aeabi_memset>
 8003302:	2000      	movs	r0, #0
 8003304:	4682      	mov	sl, r0
 8003306:	2000      	movs	r0, #0
 8003308:	f88d 0008 	strb.w	r0, [sp, #8]
 800330c:	9803      	ldr	r0, [sp, #12]
 800330e:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003310:	9903      	ldr	r1, [sp, #12]
 8003312:	3130      	adds	r1, #48	; 0x30
 8003314:	4288      	cmp	r0, r1
 8003316:	d002      	beq.n	800331e <??zcl_cluster_reports_timer_7>
 8003318:	9803      	ldr	r0, [sp, #12]
 800331a:	6b06      	ldr	r6, [r0, #48]	; 0x30
 800331c:	e000      	b.n	8003320 <??zcl_cluster_reports_timer_8>

0800331e <??zcl_cluster_reports_timer_7>:
 800331e:	2600      	movs	r6, #0

08003320 <??zcl_cluster_reports_timer_8>:
 8003320:	2e00      	cmp	r6, #0
 8003322:	f000 817b 	beq.w	800361c <??zcl_cluster_reports_timer_9>
 8003326:	f89d 000b 	ldrb.w	r0, [sp, #11]
 800332a:	f88d 0009 	strb.w	r0, [sp, #9]
 800332e:	f8df 0850 	ldr.w	r0, [pc, #2128]	; 8003b80 <??DataTable9_4>
 8003332:	900a      	str	r0, [sp, #40]	; 0x28
 8003334:	0037      	movs	r7, r6
 8003336:	8c78      	ldrh	r0, [r7, #34]	; 0x22
 8003338:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800333c:	4288      	cmp	r0, r1
 800333e:	f000 8164 	beq.w	800360a <??zcl_cluster_reports_timer_10>

08003342 <??zcl_cluster_reports_timer_11>:
 8003342:	f89d 000b 	ldrb.w	r0, [sp, #11]
 8003346:	2800      	cmp	r0, #0
 8003348:	d116      	bne.n	8003378 <??zcl_cluster_reports_timer_12>
 800334a:	8c38      	ldrh	r0, [r7, #32]
 800334c:	2800      	cmp	r0, #0
 800334e:	d013      	beq.n	8003378 <??zcl_cluster_reports_timer_12>
 8003350:	6939      	ldr	r1, [r7, #16]
 8003352:	8c3c      	ldrh	r4, [r7, #32]
 8003354:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003358:	fb00 1404 	mla	r4, r0, r4, r1
 800335c:	0021      	movs	r1, r4
 800335e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8003360:	f012 fc38 	bl	8015bd4 <ZbTimeoutRemaining>
 8003364:	9008      	str	r0, [sp, #32]
 8003366:	9808      	ldr	r0, [sp, #32]
 8003368:	2800      	cmp	r0, #0
 800336a:	d005      	beq.n	8003378 <??zcl_cluster_reports_timer_12>
 800336c:	9908      	ldr	r1, [sp, #32]
 800336e:	9806      	ldr	r0, [sp, #24]
 8003370:	f7ff febe 	bl	80030f0 <zcl_report_check_time>
 8003374:	9006      	str	r0, [sp, #24]
 8003376:	e148      	b.n	800360a <??zcl_cluster_reports_timer_10>

08003378 <??zcl_cluster_reports_timer_12>:
 8003378:	f89d 000b 	ldrb.w	r0, [sp, #11]
 800337c:	2800      	cmp	r0, #0
 800337e:	d115      	bne.n	80033ac <??zcl_cluster_reports_timer_13>
 8003380:	8c78      	ldrh	r0, [r7, #34]	; 0x22
 8003382:	2800      	cmp	r0, #0
 8003384:	d012      	beq.n	80033ac <??zcl_cluster_reports_timer_13>
 8003386:	6939      	ldr	r1, [r7, #16]
 8003388:	8c7c      	ldrh	r4, [r7, #34]	; 0x22
 800338a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800338e:	fb00 1404 	mla	r4, r0, r4, r1
 8003392:	0021      	movs	r1, r4
 8003394:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8003396:	f012 fc1d 	bl	8015bd4 <ZbTimeoutRemaining>
 800339a:	900a      	str	r0, [sp, #40]	; 0x28
 800339c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800339e:	2800      	cmp	r0, #0
 80033a0:	d104      	bne.n	80033ac <??zcl_cluster_reports_timer_13>
 80033a2:	2001      	movs	r0, #1
 80033a4:	f88d 0009 	strb.w	r0, [sp, #9]
 80033a8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80033aa:	6138      	str	r0, [r7, #16]

080033ac <??zcl_cluster_reports_timer_13>:
 80033ac:	9803      	ldr	r0, [sp, #12]
 80033ae:	8982      	ldrh	r2, [r0, #12]
 80033b0:	9803      	ldr	r0, [sp, #12]
 80033b2:	7b81      	ldrb	r1, [r0, #14]
 80033b4:	9835      	ldr	r0, [sp, #212]	; 0xd4
 80033b6:	f012 fa54 	bl	8015862 <ZbApsBindSrcExists>
 80033ba:	2800      	cmp	r0, #0
 80033bc:	d105      	bne.n	80033ca <??zcl_cluster_reports_timer_14>
 80033be:	990a      	ldr	r1, [sp, #40]	; 0x28
 80033c0:	9806      	ldr	r0, [sp, #24]
 80033c2:	f7ff fe95 	bl	80030f0 <zcl_report_check_time>
 80033c6:	9006      	str	r0, [sp, #24]
 80033c8:	e11f      	b.n	800360a <??zcl_cluster_reports_timer_10>

080033ca <??zcl_cluster_reports_timer_14>:
 80033ca:	9805      	ldr	r0, [sp, #20]
 80033cc:	2800      	cmp	r0, #0
 80033ce:	d10b      	bne.n	80033e8 <??zcl_cluster_reports_timer_15>
 80033d0:	2300      	movs	r3, #0
 80033d2:	a28a      	add	r2, pc, #552	; (adr r2, 80035fc <??zcl_cluster_reports_timer_0>)
 80033d4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80033d8:	9835      	ldr	r0, [sp, #212]	; 0xd4
 80033da:	f012 ff07 	bl	80161ec <zb_heap_alloc>
 80033de:	9005      	str	r0, [sp, #20]
 80033e0:	9805      	ldr	r0, [sp, #20]
 80033e2:	2800      	cmp	r0, #0
 80033e4:	f000 816a 	beq.w	80036bc <??zcl_cluster_reports_timer_3>

080033e8 <??zcl_cluster_reports_timer_15>:
 80033e8:	2000      	movs	r0, #0
 80033ea:	9001      	str	r0, [sp, #4]
 80033ec:	f44f 7080 	mov.w	r0, #256	; 0x100
 80033f0:	9000      	str	r0, [sp, #0]
 80033f2:	9b05      	ldr	r3, [sp, #20]
 80033f4:	f10d 0211 	add.w	r2, sp, #17
 80033f8:	89b9      	ldrh	r1, [r7, #12]
 80033fa:	9803      	ldr	r0, [sp, #12]
 80033fc:	f7fd ffb3 	bl	8001366 <ZbZclAttrRead>
 8003400:	2800      	cmp	r0, #0
 8003402:	d003      	beq.n	800340c <??zcl_cluster_reports_timer_16>
 8003404:	0038      	movs	r0, r7
 8003406:	f000 fb0a 	bl	8003a1e <zcl_reporting_disable>
 800340a:	e094      	b.n	8003536 <??zcl_cluster_reports_timer_17>

0800340c <??zcl_cluster_reports_timer_16>:
 800340c:	2300      	movs	r3, #0
 800340e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003412:	9905      	ldr	r1, [sp, #20]
 8003414:	f89d 0011 	ldrb.w	r0, [sp, #17]
 8003418:	f7fe fdcd 	bl	8001fb6 <ZbZclAttrParseLength>
 800341c:	9007      	str	r0, [sp, #28]
 800341e:	9807      	ldr	r0, [sp, #28]
 8003420:	2800      	cmp	r0, #0
 8003422:	d503      	bpl.n	800342c <??zcl_cluster_reports_timer_18>
 8003424:	0038      	movs	r0, r7
 8003426:	f000 fafa 	bl	8003a1e <zcl_reporting_disable>
 800342a:	e084      	b.n	8003536 <??zcl_cluster_reports_timer_17>

0800342c <??zcl_cluster_reports_timer_18>:
 800342c:	9807      	ldr	r0, [sp, #28]
 800342e:	2800      	cmp	r0, #0
 8003430:	f000 8081 	beq.w	8003536 <??zcl_cluster_reports_timer_17>

08003434 <??zcl_cluster_reports_timer_19>:
 8003434:	7bb8      	ldrb	r0, [r7, #14]
 8003436:	2838      	cmp	r0, #56	; 0x38
 8003438:	db37      	blt.n	80034aa <??zcl_cluster_reports_timer_20>
 800343a:	7bb8      	ldrb	r0, [r7, #14]
 800343c:	283b      	cmp	r0, #59	; 0x3b
 800343e:	da34      	bge.n	80034aa <??zcl_cluster_reports_timer_20>
 8003440:	f10d 0201 	add.w	r2, sp, #1
 8003444:	9905      	ldr	r1, [sp, #20]
 8003446:	7bb8      	ldrb	r0, [r7, #14]
 8003448:	f001 ffd1 	bl	80053ee <ZbZclParseFloat>
 800344c:	eeb0 8a40 	vmov.f32	s16, s0
 8003450:	eef0 8a60 	vmov.f32	s17, s1
 8003454:	f89d 0001 	ldrb.w	r0, [sp, #1]
 8003458:	2800      	cmp	r0, #0
 800345a:	d003      	beq.n	8003464 <??zcl_cluster_reports_timer_21>
 800345c:	0038      	movs	r0, r7
 800345e:	f000 fade 	bl	8003a1e <zcl_reporting_disable>
 8003462:	e068      	b.n	8003536 <??zcl_cluster_reports_timer_17>

08003464 <??zcl_cluster_reports_timer_21>:
 8003464:	ec51 0b18 	vmov	r0, r1, d8
 8003468:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800346c:	f002 fba8 	bl	8005bc0 <__aeabi_dsub>
 8003470:	ec41 0b19 	vmov	d9, r0, r1
 8003474:	ec51 0b19 	vmov	r0, r1, d9
 8003478:	2200      	movs	r2, #0
 800347a:	2300      	movs	r3, #0
 800347c:	f002 ffb8 	bl	80063f0 <__aeabi_cdcmpeq>
 8003480:	d205      	bcs.n	800348e <??zcl_cluster_reports_timer_22>
 8003482:	ec51 0b19 	vmov	r0, r1, d9
 8003486:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 800348a:	ec41 0b19 	vmov	d9, r0, r1

0800348e <??zcl_cluster_reports_timer_22>:
 800348e:	f89d 0009 	ldrb.w	r0, [sp, #9]
 8003492:	2800      	cmp	r0, #0
 8003494:	d106      	bne.n	80034a4 <??zcl_cluster_reports_timer_23>
 8003496:	ec51 0b19 	vmov	r0, r1, d9
 800349a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 800349e:	f002 ffa7 	bl	80063f0 <__aeabi_cdcmpeq>
 80034a2:	d348      	bcc.n	8003536 <??zcl_cluster_reports_timer_17>

080034a4 <??zcl_cluster_reports_timer_23>:
 80034a4:	ed87 8b06 	vstr	d8, [r7, #24]
 80034a8:	e040      	b.n	800352c <??zcl_cluster_reports_timer_24>

080034aa <??zcl_cluster_reports_timer_20>:
 80034aa:	7bb8      	ldrb	r0, [r7, #14]
 80034ac:	f7fe fe34 	bl	8002118 <ZbZclAttrIsAnalog>
 80034b0:	2800      	cmp	r0, #0
 80034b2:	d02b      	beq.n	800350c <??zcl_cluster_reports_timer_25>
 80034b4:	466a      	mov	r2, sp
 80034b6:	9905      	ldr	r1, [sp, #20]
 80034b8:	7bb8      	ldrb	r0, [r7, #14]
 80034ba:	f7fe ff2b 	bl	8002314 <ZbZclParseInteger>
 80034be:	0004      	movs	r4, r0
 80034c0:	000d      	movs	r5, r1
 80034c2:	f89d 0000 	ldrb.w	r0, [sp]
 80034c6:	2800      	cmp	r0, #0
 80034c8:	d003      	beq.n	80034d2 <??zcl_cluster_reports_timer_26>
 80034ca:	0038      	movs	r0, r7
 80034cc:	f000 faa7 	bl	8003a1e <zcl_reporting_disable>
 80034d0:	e031      	b.n	8003536 <??zcl_cluster_reports_timer_17>

080034d2 <??zcl_cluster_reports_timer_26>:
 80034d2:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 80034d6:	ebb4 0800 	subs.w	r8, r4, r0
 80034da:	eb75 0901 	sbcs.w	r9, r5, r1
 80034de:	f1b9 0f00 	cmp.w	r9, #0
 80034e2:	d503      	bpl.n	80034ec <??zcl_cluster_reports_timer_27>
 80034e4:	f1d8 0800 	rsbs	r8, r8, #0
 80034e8:	eb79 0949 	sbcs.w	r9, r9, r9, lsl #1

080034ec <??zcl_cluster_reports_timer_27>:
 80034ec:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80034f0:	2800      	cmp	r0, #0
 80034f2:	d108      	bne.n	8003506 <??zcl_cluster_reports_timer_28>
 80034f4:	4640      	mov	r0, r8
 80034f6:	4649      	mov	r1, r9
 80034f8:	f002 fcec 	bl	8005ed4 <__aeabi_l2d>
 80034fc:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 8003500:	f002 ff76 	bl	80063f0 <__aeabi_cdcmpeq>
 8003504:	d317      	bcc.n	8003536 <??zcl_cluster_reports_timer_17>

08003506 <??zcl_cluster_reports_timer_28>:
 8003506:	e9c7 4506 	strd	r4, r5, [r7, #24]
 800350a:	e00f      	b.n	800352c <??zcl_cluster_reports_timer_24>

0800350c <??zcl_cluster_reports_timer_25>:
 800350c:	9a07      	ldr	r2, [sp, #28]
 800350e:	9905      	ldr	r1, [sp, #20]
 8003510:	2000      	movs	r0, #0
 8003512:	f012 fe89 	bl	8016228 <WpanCrc>
 8003516:	0001      	movs	r1, r0
 8003518:	f89d 0009 	ldrb.w	r0, [sp, #9]
 800351c:	2800      	cmp	r0, #0
 800351e:	d104      	bne.n	800352a <??zcl_cluster_reports_timer_29>
 8003520:	8b38      	ldrh	r0, [r7, #24]
 8003522:	000a      	movs	r2, r1
 8003524:	b292      	uxth	r2, r2
 8003526:	4290      	cmp	r0, r2
 8003528:	d005      	beq.n	8003536 <??zcl_cluster_reports_timer_17>

0800352a <??zcl_cluster_reports_timer_29>:
 800352a:	8339      	strh	r1, [r7, #24]

0800352c <??zcl_cluster_reports_timer_24>:
 800352c:	2001      	movs	r0, #1
 800352e:	f88d 0009 	strb.w	r0, [sp, #9]
 8003532:	9809      	ldr	r0, [sp, #36]	; 0x24
 8003534:	6138      	str	r0, [r7, #16]

08003536 <??zcl_cluster_reports_timer_17>:
 8003536:	f89d 0009 	ldrb.w	r0, [sp, #9]
 800353a:	2800      	cmp	r0, #0
 800353c:	d060      	beq.n	8003600 <??zcl_cluster_reports_timer_30>
 800353e:	9807      	ldr	r0, [sp, #28]
 8003540:	2800      	cmp	r0, #0
 8003542:	d05d      	beq.n	8003600 <??zcl_cluster_reports_timer_30>
 8003544:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8003548:	1c40      	adds	r0, r0, #1
 800354a:	f88d 0010 	strb.w	r0, [sp, #16]
 800354e:	4650      	mov	r0, sl
 8003550:	b2c0      	uxtb	r0, r0
 8003552:	280c      	cmp	r0, #12
 8003554:	d007      	beq.n	8003566 <??zcl_cluster_reports_timer_31>
 8003556:	f89d 0008 	ldrb.w	r0, [sp, #8]
 800355a:	9907      	ldr	r1, [sp, #28]
 800355c:	fa51 f080 	uxtab	r0, r1, r0
 8003560:	1cc0      	adds	r0, r0, #3
 8003562:	2837      	cmp	r0, #55	; 0x37
 8003564:	d314      	bcc.n	8003590 <??zcl_cluster_reports_timer_32>

08003566 <??zcl_cluster_reports_timer_31>:
 8003566:	465a      	mov	r2, fp
 8003568:	a90c      	add	r1, sp, #48	; 0x30
 800356a:	9803      	ldr	r0, [sp, #12]
 800356c:	f7ff fc8e 	bl	8002e8c <zcl_reporting_queue_report>
 8003570:	f11b 0bc8 	adds.w	fp, fp, #200	; 0xc8
 8003574:	2490      	movs	r4, #144	; 0x90
 8003576:	2500      	movs	r5, #0
 8003578:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800357c:	002a      	movs	r2, r5
 800357e:	0021      	movs	r1, r4
 8003580:	4640      	mov	r0, r8
 8003582:	f002 fa70 	bl	8005a66 <__aeabi_memset>
 8003586:	2000      	movs	r0, #0
 8003588:	4682      	mov	sl, r0
 800358a:	2000      	movs	r0, #0
 800358c:	f88d 0008 	strb.w	r0, [sp, #8]

08003590 <??zcl_cluster_reports_timer_32>:
 8003590:	9807      	ldr	r0, [sp, #28]
 8003592:	9001      	str	r0, [sp, #4]
 8003594:	9805      	ldr	r0, [sp, #20]
 8003596:	9000      	str	r0, [sp, #0]
 8003598:	7bbb      	ldrb	r3, [r7, #14]
 800359a:	89ba      	ldrh	r2, [r7, #12]
 800359c:	a90c      	add	r1, sp, #48	; 0x30
 800359e:	4654      	mov	r4, sl
 80035a0:	b2e4      	uxtb	r4, r4
 80035a2:	200c      	movs	r0, #12
 80035a4:	4344      	muls	r4, r0
 80035a6:	4421      	add	r1, r4
 80035a8:	9835      	ldr	r0, [sp, #212]	; 0xd4
 80035aa:	f7ff fdd9 	bl	8003160 <zcl_report_append_attr>
 80035ae:	2800      	cmp	r0, #0
 80035b0:	d02b      	beq.n	800360a <??zcl_cluster_reports_timer_10>

080035b2 <??zcl_cluster_reports_timer_33>:
 80035b2:	f11a 0a01 	adds.w	sl, sl, #1
 80035b6:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80035ba:	9807      	ldr	r0, [sp, #28]
 80035bc:	1841      	adds	r1, r0, r1
 80035be:	1cc9      	adds	r1, r1, #3
 80035c0:	f88d 1008 	strb.w	r1, [sp, #8]
 80035c4:	8c38      	ldrh	r0, [r7, #32]
 80035c6:	2800      	cmp	r0, #0
 80035c8:	d005      	beq.n	80035d6 <??zcl_cluster_reports_timer_34>
 80035ca:	8c39      	ldrh	r1, [r7, #32]
 80035cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80035d0:	4341      	muls	r1, r0
 80035d2:	9108      	str	r1, [sp, #32]
 80035d4:	e00b      	b.n	80035ee <??zcl_cluster_reports_timer_35>

080035d6 <??zcl_cluster_reports_timer_34>:
 80035d6:	8c78      	ldrh	r0, [r7, #34]	; 0x22
 80035d8:	2800      	cmp	r0, #0
 80035da:	d005      	beq.n	80035e8 <??zcl_cluster_reports_timer_36>
 80035dc:	8c79      	ldrh	r1, [r7, #34]	; 0x22
 80035de:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80035e2:	4341      	muls	r1, r0
 80035e4:	9108      	str	r1, [sp, #32]
 80035e6:	e002      	b.n	80035ee <??zcl_cluster_reports_timer_35>

080035e8 <??zcl_cluster_reports_timer_36>:
 80035e8:	f8df 0594 	ldr.w	r0, [pc, #1428]	; 8003b80 <??DataTable9_4>
 80035ec:	9008      	str	r0, [sp, #32]

080035ee <??zcl_cluster_reports_timer_35>:
 80035ee:	9908      	ldr	r1, [sp, #32]
 80035f0:	9806      	ldr	r0, [sp, #24]
 80035f2:	f7ff fd7d 	bl	80030f0 <zcl_report_check_time>
 80035f6:	9006      	str	r0, [sp, #24]
 80035f8:	e007      	b.n	800360a <??zcl_cluster_reports_timer_10>
 80035fa:	bf00      	nop

080035fc <??zcl_cluster_reports_timer_0>:
 80035fc:	0000 0000                                   ....

08003600 <??zcl_cluster_reports_timer_30>:
 8003600:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003602:	9806      	ldr	r0, [sp, #24]
 8003604:	f7ff fd74 	bl	80030f0 <zcl_report_check_time>
 8003608:	9006      	str	r0, [sp, #24]

0800360a <??zcl_cluster_reports_timer_10>:
 800360a:	6830      	ldr	r0, [r6, #0]
 800360c:	9903      	ldr	r1, [sp, #12]
 800360e:	3130      	adds	r1, #48	; 0x30
 8003610:	4288      	cmp	r0, r1
 8003612:	d001      	beq.n	8003618 <??zcl_cluster_reports_timer_37>
 8003614:	6836      	ldr	r6, [r6, #0]
 8003616:	e683      	b.n	8003320 <??zcl_cluster_reports_timer_8>

08003618 <??zcl_cluster_reports_timer_37>:
 8003618:	2600      	movs	r6, #0
 800361a:	e681      	b.n	8003320 <??zcl_cluster_reports_timer_8>

0800361c <??zcl_cluster_reports_timer_9>:
 800361c:	9805      	ldr	r0, [sp, #20]
 800361e:	2800      	cmp	r0, #0
 8003620:	d04c      	beq.n	80036bc <??zcl_cluster_reports_timer_3>
 8003622:	f89d 0010 	ldrb.w	r0, [sp, #16]
 8003626:	2800      	cmp	r0, #0
 8003628:	d042      	beq.n	80036b0 <??zcl_cluster_reports_timer_38>
 800362a:	2001      	movs	r0, #1
 800362c:	9007      	str	r0, [sp, #28]
 800362e:	2001      	movs	r0, #1
 8003630:	9905      	ldr	r1, [sp, #20]
 8003632:	7008      	strb	r0, [r1, #0]
 8003634:	4650      	mov	r0, sl
 8003636:	b2c0      	uxtb	r0, r0
 8003638:	280c      	cmp	r0, #12
 800363a:	d007      	beq.n	800364c <??zcl_cluster_reports_timer_39>
 800363c:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8003640:	9907      	ldr	r1, [sp, #28]
 8003642:	fa51 f080 	uxtab	r0, r1, r0
 8003646:	1cc0      	adds	r0, r0, #3
 8003648:	2837      	cmp	r0, #55	; 0x37
 800364a:	d314      	bcc.n	8003676 <??zcl_cluster_reports_timer_40>

0800364c <??zcl_cluster_reports_timer_39>:
 800364c:	465a      	mov	r2, fp
 800364e:	a90c      	add	r1, sp, #48	; 0x30
 8003650:	9803      	ldr	r0, [sp, #12]
 8003652:	f7ff fc1b 	bl	8002e8c <zcl_reporting_queue_report>
 8003656:	f11b 0bc8 	adds.w	fp, fp, #200	; 0xc8
 800365a:	2490      	movs	r4, #144	; 0x90
 800365c:	2500      	movs	r5, #0
 800365e:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 8003662:	002a      	movs	r2, r5
 8003664:	0021      	movs	r1, r4
 8003666:	4640      	mov	r0, r8
 8003668:	f002 f9fd 	bl	8005a66 <__aeabi_memset>
 800366c:	2000      	movs	r0, #0
 800366e:	4682      	mov	sl, r0
 8003670:	2000      	movs	r0, #0
 8003672:	f88d 0008 	strb.w	r0, [sp, #8]

08003676 <??zcl_cluster_reports_timer_40>:
 8003676:	9807      	ldr	r0, [sp, #28]
 8003678:	9001      	str	r0, [sp, #4]
 800367a:	9805      	ldr	r0, [sp, #20]
 800367c:	9000      	str	r0, [sp, #0]
 800367e:	2330      	movs	r3, #48	; 0x30
 8003680:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8003684:	a90c      	add	r1, sp, #48	; 0x30
 8003686:	4654      	mov	r4, sl
 8003688:	b2e4      	uxtb	r4, r4
 800368a:	200c      	movs	r0, #12
 800368c:	4344      	muls	r4, r0
 800368e:	4421      	add	r1, r4
 8003690:	9835      	ldr	r0, [sp, #212]	; 0xd4
 8003692:	f7ff fd65 	bl	8003160 <zcl_report_append_attr>
 8003696:	2800      	cmp	r0, #0
 8003698:	d001      	beq.n	800369e <??zcl_cluster_reports_timer_41>
 800369a:	f11a 0a01 	adds.w	sl, sl, #1

0800369e <??zcl_cluster_reports_timer_41>:
 800369e:	4650      	mov	r0, sl
 80036a0:	b2c0      	uxtb	r0, r0
 80036a2:	2800      	cmp	r0, #0
 80036a4:	d004      	beq.n	80036b0 <??zcl_cluster_reports_timer_38>
 80036a6:	465a      	mov	r2, fp
 80036a8:	a90c      	add	r1, sp, #48	; 0x30
 80036aa:	9803      	ldr	r0, [sp, #12]
 80036ac:	f7ff fbee 	bl	8002e8c <zcl_reporting_queue_report>

080036b0 <??zcl_cluster_reports_timer_38>:
 80036b0:	2300      	movs	r3, #0
 80036b2:	a2ba      	add	r2, pc, #744	; (adr r2, 800399c <??DataTable7>)
 80036b4:	9905      	ldr	r1, [sp, #20]
 80036b6:	9835      	ldr	r0, [sp, #212]	; 0xd4
 80036b8:	f012 fda7 	bl	801620a <zb_heap_free>

080036bc <??zcl_cluster_reports_timer_3>:
 80036bc:	9806      	ldr	r0, [sp, #24]
 80036be:	28c8      	cmp	r0, #200	; 0xc8
 80036c0:	d201      	bcs.n	80036c6 <??zcl_cluster_reports_timer_42>
 80036c2:	20c8      	movs	r0, #200	; 0xc8
 80036c4:	9006      	str	r0, [sp, #24]

080036c6 <??zcl_cluster_reports_timer_42>:
 80036c6:	9803      	ldr	r0, [sp, #12]
 80036c8:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80036ca:	2800      	cmp	r0, #0
 80036cc:	d00c      	beq.n	80036e8 <??zcl_cluster_reports_timer_43>
 80036ce:	9803      	ldr	r0, [sp, #12]
 80036d0:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80036d2:	9906      	ldr	r1, [sp, #24]
 80036d4:	9803      	ldr	r0, [sp, #12]
 80036d6:	9b03      	ldr	r3, [sp, #12]
 80036d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80036da:	4798      	blx	r3
 80036dc:	2000      	movs	r0, #0
 80036de:	9903      	ldr	r1, [sp, #12]
 80036e0:	6408      	str	r0, [r1, #64]	; 0x40
 80036e2:	2000      	movs	r0, #0
 80036e4:	9903      	ldr	r1, [sp, #12]
 80036e6:	6448      	str	r0, [r1, #68]	; 0x44

080036e8 <??zcl_cluster_reports_timer_43>:
 80036e8:	2301      	movs	r3, #1
 80036ea:	f10d 020a 	add.w	r2, sp, #10
 80036ee:	f240 410c 	movw	r1, #1036	; 0x40c
 80036f2:	9835      	ldr	r0, [sp, #212]	; 0xd4
 80036f4:	f012 fade 	bl	8015cb4 <ZbNwkGet>
 80036f8:	2800      	cmp	r0, #0
 80036fa:	d002      	beq.n	8003702 <??zcl_cluster_reports_timer_44>
 80036fc:	2000      	movs	r0, #0
 80036fe:	f88d 000a 	strb.w	r0, [sp, #10]

08003702 <??zcl_cluster_reports_timer_44>:
 8003702:	f89d 000a 	ldrb.w	r0, [sp, #10]
 8003706:	2800      	cmp	r0, #0
 8003708:	d110      	bne.n	800372c <??zcl_cluster_reports_timer_45>
 800370a:	9803      	ldr	r0, [sp, #12]
 800370c:	6b00      	ldr	r0, [r0, #48]	; 0x30
 800370e:	9903      	ldr	r1, [sp, #12]
 8003710:	3130      	adds	r1, #48	; 0x30
 8003712:	4288      	cmp	r0, r1
 8003714:	d002      	beq.n	800371c <??zcl_cluster_reports_timer_46>
 8003716:	9803      	ldr	r0, [sp, #12]
 8003718:	6b00      	ldr	r0, [r0, #48]	; 0x30
 800371a:	e000      	b.n	800371e <??zcl_cluster_reports_timer_47>

0800371c <??zcl_cluster_reports_timer_46>:
 800371c:	2000      	movs	r0, #0

0800371e <??zcl_cluster_reports_timer_47>:
 800371e:	2800      	cmp	r0, #0
 8003720:	d004      	beq.n	800372c <??zcl_cluster_reports_timer_45>
 8003722:	9906      	ldr	r1, [sp, #24]
 8003724:	9803      	ldr	r0, [sp, #12]
 8003726:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8003728:	f012 fa24 	bl	8015b74 <ZbTimerReset>

0800372c <??zcl_cluster_reports_timer_45>:
 800372c:	b030      	add	sp, #192	; 0xc0
 800372e:	ecbd 8b04 	vpop	{d8-d9}
 8003732:	e8bd 8ff7 	ldmia.w	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08003736 <zcl_attr_reporting_check>:
 8003736:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003738:	0005      	movs	r5, r0
 800373a:	000e      	movs	r6, r1
 800373c:	0017      	movs	r7, r2
 800373e:	2000      	movs	r0, #0
 8003740:	f88d 0000 	strb.w	r0, [sp]
 8003744:	2301      	movs	r3, #1
 8003746:	466a      	mov	r2, sp
 8003748:	f240 410c 	movw	r1, #1036	; 0x40c
 800374c:	68a8      	ldr	r0, [r5, #8]
 800374e:	f012 fab1 	bl	8015cb4 <ZbNwkGet>
 8003752:	2800      	cmp	r0, #0
 8003754:	d002      	beq.n	800375c <??zcl_attr_reporting_check_0>
 8003756:	2000      	movs	r0, #0
 8003758:	f88d 0000 	strb.w	r0, [sp]

0800375c <??zcl_attr_reporting_check_0>:
 800375c:	f89d 0000 	ldrb.w	r0, [sp]
 8003760:	2800      	cmp	r0, #0
 8003762:	d10d      	bne.n	8003780 <??zcl_attr_reporting_check_1>
 8003764:	003a      	movs	r2, r7
 8003766:	b2d2      	uxtb	r2, r2
 8003768:	0031      	movs	r1, r6
 800376a:	b289      	uxth	r1, r1
 800376c:	0028      	movs	r0, r5
 800376e:	f000 f81a 	bl	80037a6 <zcl_reporting_find>
 8003772:	0004      	movs	r4, r0
 8003774:	2c00      	cmp	r4, #0
 8003776:	d003      	beq.n	8003780 <??zcl_attr_reporting_check_1>
 8003778:	21c8      	movs	r1, #200	; 0xc8
 800377a:	0028      	movs	r0, r5
 800377c:	f7ff fcbd 	bl	80030fa <zcl_report_kick>

08003780 <??zcl_attr_reporting_check_1>:
 8003780:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08003782 <ZbZclReportCleanup>:
 8003782:	b570      	push	{r4, r5, r6, lr}
 8003784:	0005      	movs	r5, r0

08003786 <??ZbZclReportCleanup_0>:
 8003786:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8003788:	f115 0130 	adds.w	r1, r5, #48	; 0x30
 800378c:	4288      	cmp	r0, r1
 800378e:	d001      	beq.n	8003794 <??ZbZclReportCleanup_1>
 8003790:	6b2c      	ldr	r4, [r5, #48]	; 0x30
 8003792:	e000      	b.n	8003796 <??ZbZclReportCleanup_2>

08003794 <??ZbZclReportCleanup_1>:
 8003794:	2400      	movs	r4, #0

08003796 <??ZbZclReportCleanup_2>:
 8003796:	2c00      	cmp	r4, #0
 8003798:	d004      	beq.n	80037a4 <??ZbZclReportCleanup_3>

0800379a <??ZbZclReportCleanup_4>:
 800379a:	0026      	movs	r6, r4
 800379c:	0030      	movs	r0, r6
 800379e:	f000 f8ff 	bl	80039a0 <zcl_reporting_delete>
 80037a2:	e7f0      	b.n	8003786 <??ZbZclReportCleanup_0>

080037a4 <??ZbZclReportCleanup_3>:
 80037a4:	bd70      	pop	{r4, r5, r6, pc}

080037a6 <zcl_reporting_find>:
 80037a6:	b470      	push	{r4, r5, r6}
 80037a8:	0004      	movs	r4, r0
 80037aa:	000b      	movs	r3, r1
 80037ac:	0010      	movs	r0, r2
 80037ae:	b2c0      	uxtb	r0, r0
 80037b0:	2801      	cmp	r0, #1
 80037b2:	d101      	bne.n	80037b8 <??zcl_reporting_find_0>
 80037b4:	2000      	movs	r0, #0
 80037b6:	e01c      	b.n	80037f2 <??zcl_reporting_find_1>

080037b8 <??zcl_reporting_find_0>:
 80037b8:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80037ba:	f114 0130 	adds.w	r1, r4, #48	; 0x30
 80037be:	4288      	cmp	r0, r1
 80037c0:	d001      	beq.n	80037c6 <??zcl_reporting_find_2>
 80037c2:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80037c4:	e000      	b.n	80037c8 <??zcl_reporting_find_3>

080037c6 <??zcl_reporting_find_2>:
 80037c6:	2100      	movs	r1, #0

080037c8 <??zcl_reporting_find_3>:
 80037c8:	2900      	cmp	r1, #0
 80037ca:	d011      	beq.n	80037f0 <??zcl_reporting_find_4>
 80037cc:	000d      	movs	r5, r1
 80037ce:	89a8      	ldrh	r0, [r5, #12]
 80037d0:	001e      	movs	r6, r3
 80037d2:	b2b6      	uxth	r6, r6
 80037d4:	42b0      	cmp	r0, r6
 80037d6:	d005      	beq.n	80037e4 <??zcl_reporting_find_5>
 80037d8:	6808      	ldr	r0, [r1, #0]
 80037da:	f114 0630 	adds.w	r6, r4, #48	; 0x30
 80037de:	42b0      	cmp	r0, r6
 80037e0:	d004      	beq.n	80037ec <??zcl_reporting_find_6>
 80037e2:	e001      	b.n	80037e8 <??zcl_reporting_find_7>

080037e4 <??zcl_reporting_find_5>:
 80037e4:	0028      	movs	r0, r5
 80037e6:	e004      	b.n	80037f2 <??zcl_reporting_find_1>

080037e8 <??zcl_reporting_find_7>:
 80037e8:	6809      	ldr	r1, [r1, #0]
 80037ea:	e7ed      	b.n	80037c8 <??zcl_reporting_find_3>

080037ec <??zcl_reporting_find_6>:
 80037ec:	2100      	movs	r1, #0
 80037ee:	e7eb      	b.n	80037c8 <??zcl_reporting_find_3>

080037f0 <??zcl_reporting_find_4>:
 80037f0:	2000      	movs	r0, #0

080037f2 <??zcl_reporting_find_1>:
 80037f2:	bc70      	pop	{r4, r5, r6}
 80037f4:	4770      	bx	lr

080037f6 <zcl_reporting_stack_event>:
 80037f6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80037fa:	0006      	movs	r6, r0
 80037fc:	000f      	movs	r7, r1
 80037fe:	4690      	mov	r8, r2
 8003800:	4699      	mov	r9, r3
 8003802:	46ca      	mov	sl, r9
 8003804:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
 8003808:	d001      	beq.n	800380e <??zcl_reporting_stack_event_0>
 800380a:	2000      	movs	r0, #0
 800380c:	e01b      	b.n	8003846 <??zcl_reporting_stack_event_1>

0800380e <??zcl_reporting_stack_event_0>:
 800380e:	f8da 0030 	ldr.w	r0, [sl, #48]	; 0x30
 8003812:	f11a 0130 	adds.w	r1, sl, #48	; 0x30
 8003816:	4288      	cmp	r0, r1
 8003818:	d002      	beq.n	8003820 <??zcl_reporting_stack_event_2>
 800381a:	f8da 4030 	ldr.w	r4, [sl, #48]	; 0x30
 800381e:	e000      	b.n	8003822 <??zcl_reporting_stack_event_3>

08003820 <??zcl_reporting_stack_event_2>:
 8003820:	2400      	movs	r4, #0

08003822 <??zcl_reporting_stack_event_3>:
 8003822:	2c00      	cmp	r4, #0
 8003824:	d00e      	beq.n	8003844 <??zcl_reporting_stack_event_4>
 8003826:	0025      	movs	r5, r4
 8003828:	2201      	movs	r2, #1
 800382a:	0029      	movs	r1, r5
 800382c:	0030      	movs	r0, r6
 800382e:	f000 f947 	bl	8003ac0 <zcl_reporting_reset_defaults>
 8003832:	6820      	ldr	r0, [r4, #0]
 8003834:	f11a 0130 	adds.w	r1, sl, #48	; 0x30
 8003838:	4288      	cmp	r0, r1
 800383a:	d001      	beq.n	8003840 <??zcl_reporting_stack_event_5>
 800383c:	6824      	ldr	r4, [r4, #0]
 800383e:	e7f0      	b.n	8003822 <??zcl_reporting_stack_event_3>

08003840 <??zcl_reporting_stack_event_5>:
 8003840:	2400      	movs	r4, #0
 8003842:	e7ee      	b.n	8003822 <??zcl_reporting_stack_event_3>

08003844 <??zcl_reporting_stack_event_4>:
 8003844:	2000      	movs	r0, #0

08003846 <??zcl_reporting_stack_event_1>:
 8003846:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800384a <zcl_reporting_save_curr_val>:
 800384a:	e92d 43fe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, lr}
 800384e:	0005      	movs	r5, r0
 8003850:	000e      	movs	r6, r1
 8003852:	68af      	ldr	r7, [r5, #8]
 8003854:	f20f 1944 	addw	r9, pc, #324	; 0x144
 8003858:	2300      	movs	r3, #0
 800385a:	464a      	mov	r2, r9
 800385c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8003860:	0038      	movs	r0, r7
 8003862:	f012 fcc3 	bl	80161ec <zb_heap_alloc>
 8003866:	0004      	movs	r4, r0
 8003868:	2c00      	cmp	r4, #0
 800386a:	d101      	bne.n	8003870 <??zcl_reporting_save_curr_val_0>
 800386c:	2089      	movs	r0, #137	; 0x89
 800386e:	e05d      	b.n	800392c <??zcl_reporting_save_curr_val_1>

08003870 <??zcl_reporting_save_curr_val_0>:
 8003870:	2001      	movs	r0, #1
 8003872:	9001      	str	r0, [sp, #4]
 8003874:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003878:	9000      	str	r0, [sp, #0]
 800387a:	0023      	movs	r3, r4
 800387c:	f10d 0209 	add.w	r2, sp, #9
 8003880:	89b1      	ldrh	r1, [r6, #12]
 8003882:	0028      	movs	r0, r5
 8003884:	f7fd fd6f 	bl	8001366 <ZbZclAttrRead>
 8003888:	f88d 0008 	strb.w	r0, [sp, #8]
 800388c:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8003890:	2800      	cmp	r0, #0
 8003892:	d002      	beq.n	800389a <??zcl_reporting_save_curr_val_2>
 8003894:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8003898:	e048      	b.n	800392c <??zcl_reporting_save_curr_val_1>

0800389a <??zcl_reporting_save_curr_val_2>:
 800389a:	7bb0      	ldrb	r0, [r6, #14]
 800389c:	f89d 1009 	ldrb.w	r1, [sp, #9]
 80038a0:	4288      	cmp	r0, r1
 80038a2:	d001      	beq.n	80038a8 <??zcl_reporting_save_curr_val_3>
 80038a4:	208d      	movs	r0, #141	; 0x8d
 80038a6:	e041      	b.n	800392c <??zcl_reporting_save_curr_val_1>

080038a8 <??zcl_reporting_save_curr_val_3>:
 80038a8:	2300      	movs	r3, #0
 80038aa:	f44f 7280 	mov.w	r2, #256	; 0x100
 80038ae:	0021      	movs	r1, r4
 80038b0:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80038b4:	f7fe fb7f 	bl	8001fb6 <ZbZclAttrParseLength>
 80038b8:	4680      	mov	r8, r0
 80038ba:	f1b8 0f00 	cmp.w	r8, #0
 80038be:	d501      	bpl.n	80038c4 <??zcl_reporting_save_curr_val_4>
 80038c0:	2089      	movs	r0, #137	; 0x89
 80038c2:	e033      	b.n	800392c <??zcl_reporting_save_curr_val_1>

080038c4 <??zcl_reporting_save_curr_val_4>:
 80038c4:	7bb0      	ldrb	r0, [r6, #14]
 80038c6:	f7fe fc27 	bl	8002118 <ZbZclAttrIsAnalog>
 80038ca:	2800      	cmp	r0, #0
 80038cc:	d106      	bne.n	80038dc <??zcl_reporting_save_curr_val_5>
 80038ce:	4642      	mov	r2, r8
 80038d0:	0021      	movs	r1, r4
 80038d2:	2000      	movs	r0, #0
 80038d4:	f012 fca8 	bl	8016228 <WpanCrc>
 80038d8:	8330      	strh	r0, [r6, #24]
 80038da:	e020      	b.n	800391e <??zcl_reporting_save_curr_val_6>

080038dc <??zcl_reporting_save_curr_val_5>:
 80038dc:	7bb0      	ldrb	r0, [r6, #14]
 80038de:	f002 f8ab 	bl	8005a38 <ZbZclAttrIsFloat>
 80038e2:	2800      	cmp	r0, #0
 80038e4:	d00d      	beq.n	8003902 <??zcl_reporting_save_curr_val_7>
 80038e6:	aa02      	add	r2, sp, #8
 80038e8:	0021      	movs	r1, r4
 80038ea:	7bb0      	ldrb	r0, [r6, #14]
 80038ec:	f001 fd7f 	bl	80053ee <ZbZclParseFloat>
 80038f0:	ed86 0b06 	vstr	d0, [r6, #24]
 80038f4:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80038f8:	2800      	cmp	r0, #0
 80038fa:	d010      	beq.n	800391e <??zcl_reporting_save_curr_val_6>
 80038fc:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8003900:	e014      	b.n	800392c <??zcl_reporting_save_curr_val_1>

08003902 <??zcl_reporting_save_curr_val_7>:
 8003902:	aa02      	add	r2, sp, #8
 8003904:	0021      	movs	r1, r4
 8003906:	7bb0      	ldrb	r0, [r6, #14]
 8003908:	f7fe fd04 	bl	8002314 <ZbZclParseInteger>
 800390c:	e9c6 0106 	strd	r0, r1, [r6, #24]
 8003910:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8003914:	2800      	cmp	r0, #0
 8003916:	d002      	beq.n	800391e <??zcl_reporting_save_curr_val_6>
 8003918:	f89d 0008 	ldrb.w	r0, [sp, #8]
 800391c:	e006      	b.n	800392c <??zcl_reporting_save_curr_val_1>

0800391e <??zcl_reporting_save_curr_val_6>:
 800391e:	2300      	movs	r3, #0
 8003920:	464a      	mov	r2, r9
 8003922:	0021      	movs	r1, r4
 8003924:	0038      	movs	r0, r7
 8003926:	f012 fc70 	bl	801620a <zb_heap_free>
 800392a:	2000      	movs	r0, #0

0800392c <??zcl_reporting_save_curr_val_1>:
 800392c:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}

08003930 <zcl_reporting_create_new>:
 8003930:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003934:	0006      	movs	r6, r0
 8003936:	000f      	movs	r7, r1
 8003938:	f8d6 8008 	ldr.w	r8, [r6, #8]
 800393c:	2200      	movs	r2, #0
 800393e:	89b9      	ldrh	r1, [r7, #12]
 8003940:	0030      	movs	r0, r6
 8003942:	f7ff ff30 	bl	80037a6 <zcl_reporting_find>
 8003946:	0005      	movs	r5, r0
 8003948:	2d00      	cmp	r5, #0
 800394a:	d001      	beq.n	8003950 <??zcl_reporting_create_new_0>
 800394c:	0028      	movs	r0, r5
 800394e:	e023      	b.n	8003998 <??zcl_reporting_create_new_1>

08003950 <??zcl_reporting_create_new_0>:
 8003950:	2300      	movs	r3, #0
 8003952:	a212      	add	r2, pc, #72	; (adr r2, 800399c <??DataTable7>)
 8003954:	2138      	movs	r1, #56	; 0x38
 8003956:	4640      	mov	r0, r8
 8003958:	f012 fc48 	bl	80161ec <zb_heap_alloc>
 800395c:	0004      	movs	r4, r0
 800395e:	2c00      	cmp	r4, #0
 8003960:	d101      	bne.n	8003966 <??zcl_reporting_create_new_2>
 8003962:	2000      	movs	r0, #0
 8003964:	e018      	b.n	8003998 <??zcl_reporting_create_new_1>

08003966 <??zcl_reporting_create_new_2>:
 8003966:	2538      	movs	r5, #56	; 0x38
 8003968:	46b9      	mov	r9, r7
 800396a:	46a2      	mov	sl, r4
 800396c:	002a      	movs	r2, r5
 800396e:	4649      	mov	r1, r9
 8003970:	4650      	mov	r0, sl
 8003972:	f014 fe0e 	bl	8018592 <__aeabi_memcpy>
 8003976:	6024      	str	r4, [r4, #0]
 8003978:	6064      	str	r4, [r4, #4]
 800397a:	f116 0030 	adds.w	r0, r6, #48	; 0x30
 800397e:	6020      	str	r0, [r4, #0]
 8003980:	6b70      	ldr	r0, [r6, #52]	; 0x34
 8003982:	6060      	str	r0, [r4, #4]
 8003984:	6820      	ldr	r0, [r4, #0]
 8003986:	6044      	str	r4, [r0, #4]
 8003988:	6860      	ldr	r0, [r4, #4]
 800398a:	6004      	str	r4, [r0, #0]
 800398c:	2201      	movs	r2, #1
 800398e:	0021      	movs	r1, r4
 8003990:	4640      	mov	r0, r8
 8003992:	f000 f895 	bl	8003ac0 <zcl_reporting_reset_defaults>
 8003996:	0020      	movs	r0, r4

08003998 <??zcl_reporting_create_new_1>:
 8003998:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800399c <??DataTable7>:
 800399c:	0000 0000                                   ....

080039a0 <zcl_reporting_delete>:
 80039a0:	b57c      	push	{r2, r3, r4, r5, r6, lr}
 80039a2:	0004      	movs	r4, r0
 80039a4:	68a5      	ldr	r5, [r4, #8]
 80039a6:	68ae      	ldr	r6, [r5, #8]
 80039a8:	2000      	movs	r0, #0
 80039aa:	f88d 0000 	strb.w	r0, [sp]
 80039ae:	6860      	ldr	r0, [r4, #4]
 80039b0:	6821      	ldr	r1, [r4, #0]
 80039b2:	6048      	str	r0, [r1, #4]
 80039b4:	6820      	ldr	r0, [r4, #0]
 80039b6:	6861      	ldr	r1, [r4, #4]
 80039b8:	6008      	str	r0, [r1, #0]
 80039ba:	6024      	str	r4, [r4, #0]
 80039bc:	6064      	str	r4, [r4, #4]
 80039be:	2300      	movs	r3, #0
 80039c0:	a26c      	add	r2, pc, #432	; (adr r2, 8003b74 <??DataTable9_1>)
 80039c2:	0021      	movs	r1, r4
 80039c4:	0030      	movs	r0, r6
 80039c6:	f012 fc20 	bl	801620a <zb_heap_free>
 80039ca:	2301      	movs	r3, #1
 80039cc:	466a      	mov	r2, sp
 80039ce:	f240 410c 	movw	r1, #1036	; 0x40c
 80039d2:	0030      	movs	r0, r6
 80039d4:	f012 f96e 	bl	8015cb4 <ZbNwkGet>
 80039d8:	2800      	cmp	r0, #0
 80039da:	d002      	beq.n	80039e2 <??zcl_reporting_delete_0>
 80039dc:	2000      	movs	r0, #0
 80039de:	f88d 0000 	strb.w	r0, [sp]

080039e2 <??zcl_reporting_delete_0>:
 80039e2:	f89d 0000 	ldrb.w	r0, [sp]
 80039e6:	2800      	cmp	r0, #0
 80039e8:	d103      	bne.n	80039f2 <??zcl_reporting_delete_1>
 80039ea:	21c8      	movs	r1, #200	; 0xc8
 80039ec:	0028      	movs	r0, r5
 80039ee:	f7ff fb84 	bl	80030fa <zcl_report_kick>

080039f2 <??zcl_reporting_delete_1>:
 80039f2:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

080039f4 <zcl_cluster_attr_report_delete>:
 80039f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80039f6:	0005      	movs	r5, r0
 80039f8:	000e      	movs	r6, r1
 80039fa:	0017      	movs	r7, r2
 80039fc:	003a      	movs	r2, r7
 80039fe:	b2d2      	uxtb	r2, r2
 8003a00:	0031      	movs	r1, r6
 8003a02:	b289      	uxth	r1, r1
 8003a04:	0028      	movs	r0, r5
 8003a06:	f7ff fece 	bl	80037a6 <zcl_reporting_find>
 8003a0a:	0004      	movs	r4, r0
 8003a0c:	2c00      	cmp	r4, #0
 8003a0e:	d101      	bne.n	8003a14 <??zcl_cluster_attr_report_delete_0>
 8003a10:	2000      	movs	r0, #0
 8003a12:	e003      	b.n	8003a1c <??zcl_cluster_attr_report_delete_1>

08003a14 <??zcl_cluster_attr_report_delete_0>:
 8003a14:	0020      	movs	r0, r4
 8003a16:	f7ff ffc3 	bl	80039a0 <zcl_reporting_delete>
 8003a1a:	2001      	movs	r0, #1

08003a1c <??zcl_cluster_attr_report_delete_1>:
 8003a1c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

08003a1e <zcl_reporting_disable>:
 8003a1e:	b538      	push	{r3, r4, r5, lr}
 8003a20:	0004      	movs	r4, r0
 8003a22:	68a0      	ldr	r0, [r4, #8]
 8003a24:	6885      	ldr	r5, [r0, #8]
 8003a26:	2000      	movs	r0, #0
 8003a28:	f88d 0000 	strb.w	r0, [sp]
 8003a2c:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8003a30:	8460      	strh	r0, [r4, #34]	; 0x22
 8003a32:	2000      	movs	r0, #0
 8003a34:	8420      	strh	r0, [r4, #32]
 8003a36:	2301      	movs	r3, #1
 8003a38:	466a      	mov	r2, sp
 8003a3a:	f240 410c 	movw	r1, #1036	; 0x40c
 8003a3e:	0028      	movs	r0, r5
 8003a40:	f012 f938 	bl	8015cb4 <ZbNwkGet>
 8003a44:	2800      	cmp	r0, #0
 8003a46:	d002      	beq.n	8003a4e <??zcl_reporting_disable_0>
 8003a48:	2000      	movs	r0, #0
 8003a4a:	f88d 0000 	strb.w	r0, [sp]

08003a4e <??zcl_reporting_disable_0>:
 8003a4e:	f89d 0000 	ldrb.w	r0, [sp]
 8003a52:	2800      	cmp	r0, #0
 8003a54:	d103      	bne.n	8003a5e <??zcl_reporting_disable_1>
 8003a56:	21c8      	movs	r1, #200	; 0xc8
 8003a58:	68a0      	ldr	r0, [r4, #8]
 8003a5a:	f7ff fb4e 	bl	80030fa <zcl_report_kick>

08003a5e <??zcl_reporting_disable_1>:
 8003a5e:	bd31      	pop	{r0, r4, r5, pc}

08003a60 <zcl_reporting_check_default_intvl>:
 8003a60:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003a64:	880a      	ldrh	r2, [r1, #0]
 8003a66:	429a      	cmp	r2, r3
 8003a68:	d00e      	beq.n	8003a88 <??zcl_reporting_check_default_intvl_0>
 8003a6a:	880a      	ldrh	r2, [r1, #0]
 8003a6c:	2a00      	cmp	r2, #0
 8003a6e:	d00b      	beq.n	8003a88 <??zcl_reporting_check_default_intvl_0>
 8003a70:	880a      	ldrh	r2, [r1, #0]
 8003a72:	429a      	cmp	r2, r3
 8003a74:	d102      	bne.n	8003a7c <??zcl_reporting_check_default_intvl_1>
 8003a76:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8003a7a:	800a      	strh	r2, [r1, #0]

08003a7c <??zcl_reporting_check_default_intvl_1>:
 8003a7c:	880a      	ldrh	r2, [r1, #0]
 8003a7e:	8803      	ldrh	r3, [r0, #0]
 8003a80:	429a      	cmp	r2, r3
 8003a82:	d201      	bcs.n	8003a88 <??zcl_reporting_check_default_intvl_0>
 8003a84:	2200      	movs	r2, #0
 8003a86:	8002      	strh	r2, [r0, #0]

08003a88 <??zcl_reporting_check_default_intvl_0>:
 8003a88:	4770      	bx	lr

08003a8a <zcl_reporting_config_attr_defaults>:
 8003a8a:	b57c      	push	{r2, r3, r4, r5, r6, lr}
 8003a8c:	0004      	movs	r4, r0
 8003a8e:	000d      	movs	r5, r1
 8003a90:	0016      	movs	r6, r2
 8003a92:	8aa8      	ldrh	r0, [r5, #20]
 8003a94:	f8ad 0002 	strh.w	r0, [sp, #2]
 8003a98:	8ae8      	ldrh	r0, [r5, #22]
 8003a9a:	f8ad 0000 	strh.w	r0, [sp]
 8003a9e:	4669      	mov	r1, sp
 8003aa0:	f10d 0002 	add.w	r0, sp, #2
 8003aa4:	f7ff ffdc 	bl	8003a60 <zcl_reporting_check_default_intvl>
 8003aa8:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 8003aac:	84b0      	strh	r0, [r6, #36]	; 0x24
 8003aae:	f8bd 0000 	ldrh.w	r0, [sp]
 8003ab2:	84f0      	strh	r0, [r6, #38]	; 0x26
 8003ab4:	2200      	movs	r2, #0
 8003ab6:	0031      	movs	r1, r6
 8003ab8:	0020      	movs	r0, r4
 8003aba:	f000 f801 	bl	8003ac0 <zcl_reporting_reset_defaults>
 8003abe:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

08003ac0 <zcl_reporting_reset_defaults>:
 8003ac0:	b57c      	push	{r2, r3, r4, r5, r6, lr}
 8003ac2:	0004      	movs	r4, r0
 8003ac4:	000d      	movs	r5, r1
 8003ac6:	0016      	movs	r6, r2
 8003ac8:	8ca8      	ldrh	r0, [r5, #36]	; 0x24
 8003aca:	8428      	strh	r0, [r5, #32]
 8003acc:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
 8003ace:	8468      	strh	r0, [r5, #34]	; 0x22
 8003ad0:	8c28      	ldrh	r0, [r5, #32]
 8003ad2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003ad6:	4288      	cmp	r0, r1
 8003ad8:	d106      	bne.n	8003ae8 <??zcl_reporting_reset_defaults_0>
 8003ada:	8c68      	ldrh	r0, [r5, #34]	; 0x22
 8003adc:	2800      	cmp	r0, #0
 8003ade:	d103      	bne.n	8003ae8 <??zcl_reporting_reset_defaults_0>
 8003ae0:	203d      	movs	r0, #61	; 0x3d
 8003ae2:	8468      	strh	r0, [r5, #34]	; 0x22
 8003ae4:	2000      	movs	r0, #0
 8003ae6:	8428      	strh	r0, [r5, #32]

08003ae8 <??zcl_reporting_reset_defaults_0>:
 8003ae8:	ed95 0b0c 	vldr	d0, [r5, #48]	; 0x30
 8003aec:	ed85 0b0a 	vstr	d0, [r5, #40]	; 0x28
 8003af0:	0020      	movs	r0, r4
 8003af2:	f012 f8f4 	bl	8015cde <ZbZclUptime>
 8003af6:	6128      	str	r0, [r5, #16]
 8003af8:	0030      	movs	r0, r6
 8003afa:	b2c0      	uxtb	r0, r0
 8003afc:	2800      	cmp	r0, #0
 8003afe:	d013      	beq.n	8003b28 <??zcl_reporting_reset_defaults_1>
 8003b00:	2301      	movs	r3, #1
 8003b02:	466a      	mov	r2, sp
 8003b04:	f240 410c 	movw	r1, #1036	; 0x40c
 8003b08:	0020      	movs	r0, r4
 8003b0a:	f012 f8d3 	bl	8015cb4 <ZbNwkGet>
 8003b0e:	2800      	cmp	r0, #0
 8003b10:	d002      	beq.n	8003b18 <??zcl_reporting_reset_defaults_2>
 8003b12:	2000      	movs	r0, #0
 8003b14:	f88d 0000 	strb.w	r0, [sp]

08003b18 <??zcl_reporting_reset_defaults_2>:
 8003b18:	f89d 0000 	ldrb.w	r0, [sp]
 8003b1c:	2800      	cmp	r0, #0
 8003b1e:	d103      	bne.n	8003b28 <??zcl_reporting_reset_defaults_1>
 8003b20:	21c8      	movs	r1, #200	; 0xc8
 8003b22:	68a8      	ldr	r0, [r5, #8]
 8003b24:	f7ff fae9 	bl	80030fa <zcl_report_kick>

08003b28 <??zcl_reporting_reset_defaults_1>:
 8003b28:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

08003b2a <zcl_reporting_epsilon_default>:
 8003b2a:	b538      	push	{r3, r4, r5, lr}
 8003b2c:	0004      	movs	r4, r0
 8003b2e:	000d      	movs	r5, r1
 8003b30:	0028      	movs	r0, r5
 8003b32:	b2c0      	uxtb	r0, r0
 8003b34:	2838      	cmp	r0, #56	; 0x38
 8003b36:	db09      	blt.n	8003b4c <??zcl_reporting_epsilon_default_0>
 8003b38:	0028      	movs	r0, r5
 8003b3a:	b2c0      	uxtb	r0, r0
 8003b3c:	283b      	cmp	r0, #59	; 0x3b
 8003b3e:	da05      	bge.n	8003b4c <??zcl_reporting_epsilon_default_0>
 8003b40:	2000      	movs	r0, #0
 8003b42:	f8df 1bd0 	ldr.w	r1, [pc, #3024]	; 8004714 <??DataTable11>
 8003b46:	e9c4 010a 	strd	r0, r1, [r4, #40]	; 0x28
 8003b4a:	e00f      	b.n	8003b6c <??zcl_reporting_epsilon_default_1>

08003b4c <??zcl_reporting_epsilon_default_0>:
 8003b4c:	0028      	movs	r0, r5
 8003b4e:	b2c0      	uxtb	r0, r0
 8003b50:	f7fe fae2 	bl	8002118 <ZbZclAttrIsAnalog>
 8003b54:	2800      	cmp	r0, #0
 8003b56:	d005      	beq.n	8003b64 <??zcl_reporting_epsilon_default_2>
 8003b58:	2000      	movs	r0, #0
 8003b5a:	f8df 1bb8 	ldr.w	r1, [pc, #3000]	; 8004714 <??DataTable11>
 8003b5e:	e9c4 010a 	strd	r0, r1, [r4, #40]	; 0x28
 8003b62:	e003      	b.n	8003b6c <??zcl_reporting_epsilon_default_1>

08003b64 <??zcl_reporting_epsilon_default_2>:
 8003b64:	2000      	movs	r0, #0
 8003b66:	2100      	movs	r1, #0
 8003b68:	e9c4 010a 	strd	r0, r1, [r4, #40]	; 0x28

08003b6c <??zcl_reporting_epsilon_default_1>:
 8003b6c:	bd31      	pop	{r0, r4, r5, pc}
	...

08003b70 <??DataTable9>:
 8003b70:	2e65 0800                                   e...

08003b74 <??DataTable9_1>:
 8003b74:	0000 0000                                   ....

08003b78 <??DataTable9_2>:
 8003b78:	0108 2000                                   ... 

08003b7c <??DataTable9_3>:
 8003b7c:	2e51 0800                                   Q...

08003b80 <??DataTable9_4>:
 8003b80:	ee80 0036                                   ..6.

08003b84 <zcl_reporting_epsilon_check>:
 8003b84:	b510      	push	{r4, lr}
 8003b86:	0004      	movs	r4, r0
 8003b88:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8003b8c:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 8003b8e:	4281      	cmp	r1, r0
 8003b90:	d101      	bne.n	8003b96 <??zcl_reporting_epsilon_check_0>
 8003b92:	2001      	movs	r0, #1
 8003b94:	e049      	b.n	8003c2a <??zcl_reporting_epsilon_check_1>

08003b96 <??zcl_reporting_epsilon_check_0>:
 8003b96:	8c21      	ldrh	r1, [r4, #32]
 8003b98:	4281      	cmp	r1, r0
 8003b9a:	d104      	bne.n	8003ba6 <??zcl_reporting_epsilon_check_2>
 8003b9c:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 8003b9e:	2800      	cmp	r0, #0
 8003ba0:	d101      	bne.n	8003ba6 <??zcl_reporting_epsilon_check_2>
 8003ba2:	2001      	movs	r0, #1
 8003ba4:	e041      	b.n	8003c2a <??zcl_reporting_epsilon_check_1>

08003ba6 <??zcl_reporting_epsilon_check_2>:
 8003ba6:	7ba0      	ldrb	r0, [r4, #14]
 8003ba8:	2838      	cmp	r0, #56	; 0x38
 8003baa:	db1d      	blt.n	8003be8 <??zcl_reporting_epsilon_check_3>
 8003bac:	7ba0      	ldrb	r0, [r4, #14]
 8003bae:	283b      	cmp	r0, #59	; 0x3b
 8003bb0:	da1a      	bge.n	8003be8 <??zcl_reporting_epsilon_check_3>
 8003bb2:	8c20      	ldrh	r0, [r4, #32]
 8003bb4:	2800      	cmp	r0, #0
 8003bb6:	d108      	bne.n	8003bca <??zcl_reporting_epsilon_check_4>
 8003bb8:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
 8003bbc:	2000      	movs	r0, #0
 8003bbe:	2100      	movs	r1, #0
 8003bc0:	f002 fc16 	bl	80063f0 <__aeabi_cdcmpeq>
 8003bc4:	d101      	bne.n	8003bca <??zcl_reporting_epsilon_check_4>
 8003bc6:	2000      	movs	r0, #0
 8003bc8:	e02f      	b.n	8003c2a <??zcl_reporting_epsilon_check_1>

08003bca <??zcl_reporting_epsilon_check_4>:
 8003bca:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
 8003bce:	2200      	movs	r2, #0
 8003bd0:	2300      	movs	r3, #0
 8003bd2:	f002 fc0d 	bl	80063f0 <__aeabi_cdcmpeq>
 8003bd6:	d205      	bcs.n	8003be4 <??zcl_reporting_epsilon_check_5>
 8003bd8:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
 8003bdc:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 8003be0:	e9c4 010a 	strd	r0, r1, [r4, #40]	; 0x28

08003be4 <??zcl_reporting_epsilon_check_5>:
 8003be4:	2001      	movs	r0, #1
 8003be6:	e020      	b.n	8003c2a <??zcl_reporting_epsilon_check_1>

08003be8 <??zcl_reporting_epsilon_check_3>:
 8003be8:	7ba0      	ldrb	r0, [r4, #14]
 8003bea:	f7fe fa95 	bl	8002118 <ZbZclAttrIsAnalog>
 8003bee:	2800      	cmp	r0, #0
 8003bf0:	d01a      	beq.n	8003c28 <??zcl_reporting_epsilon_check_6>
 8003bf2:	8c20      	ldrh	r0, [r4, #32]
 8003bf4:	2800      	cmp	r0, #0
 8003bf6:	d108      	bne.n	8003c0a <??zcl_reporting_epsilon_check_7>
 8003bf8:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
 8003bfc:	2000      	movs	r0, #0
 8003bfe:	2100      	movs	r1, #0
 8003c00:	f002 fbf6 	bl	80063f0 <__aeabi_cdcmpeq>
 8003c04:	d101      	bne.n	8003c0a <??zcl_reporting_epsilon_check_7>
 8003c06:	2000      	movs	r0, #0
 8003c08:	e00f      	b.n	8003c2a <??zcl_reporting_epsilon_check_1>

08003c0a <??zcl_reporting_epsilon_check_7>:
 8003c0a:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
 8003c0e:	2200      	movs	r2, #0
 8003c10:	2300      	movs	r3, #0
 8003c12:	f002 fbed 	bl	80063f0 <__aeabi_cdcmpeq>
 8003c16:	d205      	bcs.n	8003c24 <??zcl_reporting_epsilon_check_8>
 8003c18:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
 8003c1c:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 8003c20:	e9c4 010a 	strd	r0, r1, [r4, #40]	; 0x28

08003c24 <??zcl_reporting_epsilon_check_8>:
 8003c24:	2001      	movs	r0, #1
 8003c26:	e000      	b.n	8003c2a <??zcl_reporting_epsilon_check_1>

08003c28 <??zcl_reporting_epsilon_check_6>:
 8003c28:	2001      	movs	r0, #1

08003c2a <??zcl_reporting_epsilon_check_1>:
 8003c2a:	bd10      	pop	{r4, pc}

08003c2c <zcl_reporting_create_default_reports>:
 8003c2c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003c30:	b090      	sub	sp, #64	; 0x40
 8003c32:	0005      	movs	r5, r0
 8003c34:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003c36:	f115 0124 	adds.w	r1, r5, #36	; 0x24
 8003c3a:	4288      	cmp	r0, r1
 8003c3c:	d001      	beq.n	8003c42 <??zcl_reporting_create_default_reports_0>
 8003c3e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8003c40:	e000      	b.n	8003c44 <??zcl_reporting_create_default_reports_1>

08003c42 <??zcl_reporting_create_default_reports_0>:
 8003c42:	2400      	movs	r4, #0

08003c44 <??zcl_reporting_create_default_reports_1>:
 8003c44:	2c00      	cmp	r4, #0
 8003c46:	d054      	beq.n	8003cf2 <??zcl_reporting_create_default_reports_2>
 8003c48:	0026      	movs	r6, r4
 8003c4a:	68b0      	ldr	r0, [r6, #8]
 8003c4c:	7900      	ldrb	r0, [r0, #4]
 8003c4e:	0780      	lsls	r0, r0, #30
 8003c50:	d546      	bpl.n	8003ce0 <??zcl_reporting_create_default_reports_3>

08003c52 <??zcl_reporting_create_default_reports_4>:
 8003c52:	2200      	movs	r2, #0
 8003c54:	68b0      	ldr	r0, [r6, #8]
 8003c56:	8801      	ldrh	r1, [r0, #0]
 8003c58:	0028      	movs	r0, r5
 8003c5a:	f7ff fda4 	bl	80037a6 <zcl_reporting_find>
 8003c5e:	9001      	str	r0, [sp, #4]
 8003c60:	9801      	ldr	r0, [sp, #4]
 8003c62:	2800      	cmp	r0, #0
 8003c64:	d13c      	bne.n	8003ce0 <??zcl_reporting_create_default_reports_3>

08003c66 <??zcl_reporting_create_default_reports_5>:
 8003c66:	2738      	movs	r7, #56	; 0x38
 8003c68:	f05f 0800 	movs.w	r8, #0
 8003c6c:	f10d 0908 	add.w	r9, sp, #8
 8003c70:	4642      	mov	r2, r8
 8003c72:	0039      	movs	r1, r7
 8003c74:	4648      	mov	r0, r9
 8003c76:	f001 fef6 	bl	8005a66 <__aeabi_memset>
 8003c7a:	68b0      	ldr	r0, [r6, #8]
 8003c7c:	8800      	ldrh	r0, [r0, #0]
 8003c7e:	f8ad 0014 	strh.w	r0, [sp, #20]
 8003c82:	9504      	str	r5, [sp, #16]
 8003c84:	68b0      	ldr	r0, [r6, #8]
 8003c86:	7880      	ldrb	r0, [r0, #2]
 8003c88:	f88d 0016 	strb.w	r0, [sp, #22]
 8003c8c:	68b0      	ldr	r0, [r6, #8]
 8003c8e:	7881      	ldrb	r1, [r0, #2]
 8003c90:	a802      	add	r0, sp, #8
 8003c92:	f7ff ff4a 	bl	8003b2a <zcl_reporting_epsilon_default>
 8003c96:	f05f 0908 	movs.w	r9, #8
 8003c9a:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
 8003c9e:	f10d 0b38 	add.w	fp, sp, #56	; 0x38
 8003ca2:	464a      	mov	r2, r9
 8003ca4:	4651      	mov	r1, sl
 8003ca6:	4658      	mov	r0, fp
 8003ca8:	f014 fc73 	bl	8018592 <__aeabi_memcpy>
 8003cac:	aa02      	add	r2, sp, #8
 8003cae:	0031      	movs	r1, r6
 8003cb0:	68a8      	ldr	r0, [r5, #8]
 8003cb2:	f7ff feea 	bl	8003a8a <zcl_reporting_config_attr_defaults>
 8003cb6:	a902      	add	r1, sp, #8
 8003cb8:	0028      	movs	r0, r5
 8003cba:	f7ff fdc6 	bl	800384a <zcl_reporting_save_curr_val>
 8003cbe:	f88d 0000 	strb.w	r0, [sp]
 8003cc2:	f89d 0000 	ldrb.w	r0, [sp]
 8003cc6:	2800      	cmp	r0, #0
 8003cc8:	d002      	beq.n	8003cd0 <??zcl_reporting_create_default_reports_6>
 8003cca:	f89d 0000 	ldrb.w	r0, [sp]
 8003cce:	e011      	b.n	8003cf4 <??zcl_reporting_create_default_reports_7>

08003cd0 <??zcl_reporting_create_default_reports_6>:
 8003cd0:	a902      	add	r1, sp, #8
 8003cd2:	0028      	movs	r0, r5
 8003cd4:	f7ff fe2c 	bl	8003930 <zcl_reporting_create_new>
 8003cd8:	2800      	cmp	r0, #0
 8003cda:	d101      	bne.n	8003ce0 <??zcl_reporting_create_default_reports_3>
 8003cdc:	2089      	movs	r0, #137	; 0x89
 8003cde:	e009      	b.n	8003cf4 <??zcl_reporting_create_default_reports_7>

08003ce0 <??zcl_reporting_create_default_reports_3>:
 8003ce0:	6820      	ldr	r0, [r4, #0]
 8003ce2:	f115 0124 	adds.w	r1, r5, #36	; 0x24
 8003ce6:	4288      	cmp	r0, r1
 8003ce8:	d001      	beq.n	8003cee <??zcl_reporting_create_default_reports_8>
 8003cea:	6824      	ldr	r4, [r4, #0]
 8003cec:	e7aa      	b.n	8003c44 <??zcl_reporting_create_default_reports_1>

08003cee <??zcl_reporting_create_default_reports_8>:
 8003cee:	2400      	movs	r4, #0
 8003cf0:	e7a8      	b.n	8003c44 <??zcl_reporting_create_default_reports_1>

08003cf2 <??zcl_reporting_create_default_reports_2>:
 8003cf2:	2000      	movs	r0, #0

08003cf4 <??zcl_reporting_create_default_reports_7>:
 8003cf4:	b011      	add	sp, #68	; 0x44
 8003cf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08003cfa <ZbZclHandleConfigReport>:
 8003cfa:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003cfe:	b0c8      	sub	sp, #288	; 0x120
 8003d00:	0004      	movs	r4, r0
 8003d02:	0015      	movs	r5, r2
 8003d04:	68a0      	ldr	r0, [r4, #8]
 8003d06:	9001      	str	r0, [sp, #4]
 8003d08:	2700      	movs	r7, #0
 8003d0a:	2000      	movs	r0, #0
 8003d0c:	f88d 0003 	strb.w	r0, [sp, #3]
 8003d10:	2600      	movs	r6, #0
 8003d12:	2000      	movs	r0, #0
 8003d14:	f88d 0002 	strb.w	r0, [sp, #2]
 8003d18:	f05f 0808 	movs.w	r8, #8
 8003d1c:	f05f 0900 	movs.w	r9, #0
 8003d20:	f10d 0a0c 	add.w	sl, sp, #12
 8003d24:	464a      	mov	r2, r9
 8003d26:	4641      	mov	r1, r8
 8003d28:	4650      	mov	r0, sl
 8003d2a:	f001 fe9c 	bl	8005a66 <__aeabi_memset>
 8003d2e:	2000      	movs	r0, #0
 8003d30:	f88d 000c 	strb.w	r0, [sp, #12]
 8003d34:	9848      	ldr	r0, [sp, #288]	; 0x120
 8003d36:	7840      	ldrb	r0, [r0, #1]
 8003d38:	f88d 000d 	strb.w	r0, [sp, #13]
 8003d3c:	9848      	ldr	r0, [sp, #288]	; 0x120
 8003d3e:	7880      	ldrb	r0, [r0, #2]
 8003d40:	2800      	cmp	r0, #0
 8003d42:	d003      	beq.n	8003d4c <??ZbZclHandleConfigReport_0>
 8003d44:	2000      	movs	r0, #0
 8003d46:	f88d 000e 	strb.w	r0, [sp, #14]
 8003d4a:	e002      	b.n	8003d52 <??ZbZclHandleConfigReport_1>

08003d4c <??ZbZclHandleConfigReport_0>:
 8003d4c:	2001      	movs	r0, #1
 8003d4e:	f88d 000e 	strb.w	r0, [sp, #14]

08003d52 <??ZbZclHandleConfigReport_1>:
 8003d52:	2001      	movs	r0, #1
 8003d54:	f88d 000f 	strb.w	r0, [sp, #15]
 8003d58:	9848      	ldr	r0, [sp, #288]	; 0x120
 8003d5a:	8880      	ldrh	r0, [r0, #4]
 8003d5c:	f8ad 0010 	strh.w	r0, [sp, #16]
 8003d60:	9848      	ldr	r0, [sp, #288]	; 0x120
 8003d62:	7980      	ldrb	r0, [r0, #6]
 8003d64:	f88d 0012 	strb.w	r0, [sp, #18]
 8003d68:	2007      	movs	r0, #7
 8003d6a:	f88d 0013 	strb.w	r0, [sp, #19]
 8003d6e:	2205      	movs	r2, #5
 8003d70:	a916      	add	r1, sp, #88	; 0x58
 8003d72:	a803      	add	r0, sp, #12
 8003d74:	f7fd f972 	bl	800105c <ZbZclAppendHeader>
 8003d78:	9005      	str	r0, [sp, #20]
 8003d7a:	9805      	ldr	r0, [sp, #20]
 8003d7c:	2800      	cmp	r0, #0
 8003d7e:	d506      	bpl.n	8003d8e <??ZbZclHandleConfigReport_2>
 8003d80:	2380      	movs	r3, #128	; 0x80
 8003d82:	9a48      	ldr	r2, [sp, #288]	; 0x120
 8003d84:	0029      	movs	r1, r5
 8003d86:	0020      	movs	r0, r4
 8003d88:	f012 f8f3 	bl	8015f72 <ZbZclSendDefaultResponse>
 8003d8c:	e236      	b.n	80041fc <??ZbZclHandleConfigReport_3>

08003d8e <??ZbZclHandleConfigReport_2>:
 8003d8e:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003d90:	4286      	cmp	r6, r0
 8003d92:	f080 81b4 	bcs.w	80040fe <??ZbZclHandleConfigReport_4>
 8003d96:	f05f 0900 	movs.w	r9, #0
 8003d9a:	f05f 0838 	movs.w	r8, #56	; 0x38
 8003d9e:	f05f 0a00 	movs.w	sl, #0
 8003da2:	f10d 0b18 	add.w	fp, sp, #24
 8003da6:	4652      	mov	r2, sl
 8003da8:	4641      	mov	r1, r8
 8003daa:	4658      	mov	r0, fp
 8003dac:	f001 fe5b 	bl	8005a66 <__aeabi_memset>
 8003db0:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003db2:	1cf1      	adds	r1, r6, #3
 8003db4:	4288      	cmp	r0, r1
 8003db6:	d206      	bcs.n	8003dc6 <??ZbZclHandleConfigReport_5>
 8003db8:	2380      	movs	r3, #128	; 0x80
 8003dba:	9a48      	ldr	r2, [sp, #288]	; 0x120
 8003dbc:	0029      	movs	r1, r5
 8003dbe:	0020      	movs	r0, r4
 8003dc0:	f012 f8d7 	bl	8015f72 <ZbZclSendDefaultResponse>
 8003dc4:	e21a      	b.n	80041fc <??ZbZclHandleConfigReport_3>

08003dc6 <??ZbZclHandleConfigReport_5>:
 8003dc6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003dc8:	5d80      	ldrb	r0, [r0, r6]
 8003dca:	f88d 0001 	strb.w	r0, [sp, #1]
 8003dce:	1c76      	adds	r6, r6, #1
 8003dd0:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003dd2:	4430      	add	r0, r6
 8003dd4:	f7fc f9e2 	bl	800019c <pletoh16>
 8003dd8:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
 8003ddc:	1cb6      	adds	r6, r6, #2
 8003dde:	f89d 0001 	ldrb.w	r0, [sp, #1]
 8003de2:	2800      	cmp	r0, #0
 8003de4:	f040 8159 	bne.w	800409a <??ZbZclHandleConfigReport_6>
 8003de8:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003dea:	1cb1      	adds	r1, r6, #2
 8003dec:	4288      	cmp	r0, r1
 8003dee:	d206      	bcs.n	8003dfe <??ZbZclHandleConfigReport_7>
 8003df0:	2380      	movs	r3, #128	; 0x80
 8003df2:	9a48      	ldr	r2, [sp, #288]	; 0x120
 8003df4:	0029      	movs	r1, r5
 8003df6:	0020      	movs	r0, r4
 8003df8:	f012 f8bb 	bl	8015f72 <ZbZclSendDefaultResponse>
 8003dfc:	e1fe      	b.n	80041fc <??ZbZclHandleConfigReport_3>

08003dfe <??ZbZclHandleConfigReport_7>:
 8003dfe:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003e00:	1c71      	adds	r1, r6, #1
 8003e02:	4288      	cmp	r0, r1
 8003e04:	f0c0 808f 	bcc.w	8003f26 <??ZbZclHandleConfigReport_19>

08003e08 <??ZbZclHandleConfigReport_9>:
 8003e08:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003e0a:	5d80      	ldrb	r0, [r0, r6]
 8003e0c:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26
 8003e10:	1c76      	adds	r6, r6, #1
 8003e12:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003e14:	1cb1      	adds	r1, r6, #2
 8003e16:	4288      	cmp	r0, r1
 8003e18:	f0c0 8085 	bcc.w	8003f26 <??ZbZclHandleConfigReport_19>

08003e1c <??ZbZclHandleConfigReport_10>:
 8003e1c:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003e1e:	4430      	add	r0, r6
 8003e20:	f7fc f9bc 	bl	800019c <pletoh16>
 8003e24:	f8ad 0038 	strh.w	r0, [sp, #56]	; 0x38
 8003e28:	1cb6      	adds	r6, r6, #2
 8003e2a:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003e2c:	1cb1      	adds	r1, r6, #2
 8003e2e:	4288      	cmp	r0, r1
 8003e30:	d379      	bcc.n	8003f26 <??ZbZclHandleConfigReport_19>

08003e32 <??ZbZclHandleConfigReport_11>:
 8003e32:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003e34:	4430      	add	r0, r6
 8003e36:	f7fc f9b1 	bl	800019c <pletoh16>
 8003e3a:	f8ad 003a 	strh.w	r0, [sp, #58]	; 0x3a
 8003e3e:	1cb6      	adds	r6, r6, #2
 8003e40:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 8003e42:	1c71      	adds	r1, r6, #1
 8003e44:	4288      	cmp	r0, r1
 8003e46:	d36e      	bcc.n	8003f26 <??ZbZclHandleConfigReport_19>

08003e48 <??ZbZclHandleConfigReport_12>:
 8003e48:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e4c:	2848      	cmp	r0, #72	; 0x48
 8003e4e:	d00b      	beq.n	8003e68 <??ZbZclHandleConfigReport_13>
 8003e50:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e54:	284c      	cmp	r0, #76	; 0x4c
 8003e56:	d007      	beq.n	8003e68 <??ZbZclHandleConfigReport_13>
 8003e58:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e5c:	2850      	cmp	r0, #80	; 0x50
 8003e5e:	d003      	beq.n	8003e68 <??ZbZclHandleConfigReport_13>
 8003e60:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e64:	2851      	cmp	r0, #81	; 0x51
 8003e66:	d103      	bne.n	8003e70 <??ZbZclHandleConfigReport_14>

08003e68 <??ZbZclHandleConfigReport_13>:
 8003e68:	208c      	movs	r0, #140	; 0x8c
 8003e6a:	f88d 0000 	strb.w	r0, [sp]
 8003e6e:	e12e      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003e70 <??ZbZclHandleConfigReport_14>:
 8003e70:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e74:	2838      	cmp	r0, #56	; 0x38
 8003e76:	db29      	blt.n	8003ecc <??ZbZclHandleConfigReport_16>
 8003e78:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e7c:	283b      	cmp	r0, #59	; 0x3b
 8003e7e:	da25      	bge.n	8003ecc <??ZbZclHandleConfigReport_16>
 8003e80:	2300      	movs	r3, #0
 8003e82:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
 8003e84:	1b92      	subs	r2, r2, r6
 8003e86:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003e88:	eb00 0106 	add.w	r1, r0, r6
 8003e8c:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003e90:	f7fe f891 	bl	8001fb6 <ZbZclAttrParseLength>
 8003e94:	9002      	str	r0, [sp, #8]
 8003e96:	9802      	ldr	r0, [sp, #8]
 8003e98:	2800      	cmp	r0, #0
 8003e9a:	d503      	bpl.n	8003ea4 <??ZbZclHandleConfigReport_17>
 8003e9c:	2085      	movs	r0, #133	; 0x85
 8003e9e:	f88d 0000 	strb.w	r0, [sp]
 8003ea2:	e114      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003ea4 <??ZbZclHandleConfigReport_17>:
 8003ea4:	466a      	mov	r2, sp
 8003ea6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003ea8:	eb00 0106 	add.w	r1, r0, r6
 8003eac:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003eb0:	f001 fa9d 	bl	80053ee <ZbZclParseFloat>
 8003eb4:	ed8d 0b10 	vstr	d0, [sp, #64]	; 0x40
 8003eb8:	f89d 0000 	ldrb.w	r0, [sp]
 8003ebc:	2800      	cmp	r0, #0
 8003ebe:	f040 8106 	bne.w	80040ce <??ZbZclHandleConfigReport_15>

08003ec2 <??ZbZclHandleConfigReport_18>:
 8003ec2:	9802      	ldr	r0, [sp, #8]
 8003ec4:	1986      	adds	r6, r0, r6
 8003ec6:	2001      	movs	r0, #1
 8003ec8:	4681      	mov	r9, r0
 8003eca:	e02c      	b.n	8003f26 <??ZbZclHandleConfigReport_19>

08003ecc <??ZbZclHandleConfigReport_16>:
 8003ecc:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003ed0:	f7fe f922 	bl	8002118 <ZbZclAttrIsAnalog>
 8003ed4:	2800      	cmp	r0, #0
 8003ed6:	d026      	beq.n	8003f26 <??ZbZclHandleConfigReport_19>
 8003ed8:	2300      	movs	r3, #0
 8003eda:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
 8003edc:	1b92      	subs	r2, r2, r6
 8003ede:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003ee0:	eb00 0106 	add.w	r1, r0, r6
 8003ee4:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003ee8:	f7fe f865 	bl	8001fb6 <ZbZclAttrParseLength>
 8003eec:	9002      	str	r0, [sp, #8]
 8003eee:	9802      	ldr	r0, [sp, #8]
 8003ef0:	2800      	cmp	r0, #0
 8003ef2:	d503      	bpl.n	8003efc <??ZbZclHandleConfigReport_20>
 8003ef4:	2085      	movs	r0, #133	; 0x85
 8003ef6:	f88d 0000 	strb.w	r0, [sp]
 8003efa:	e0e8      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003efc <??ZbZclHandleConfigReport_20>:
 8003efc:	466a      	mov	r2, sp
 8003efe:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8003f00:	eb00 0106 	add.w	r1, r0, r6
 8003f04:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003f08:	f7fe fa04 	bl	8002314 <ZbZclParseInteger>
 8003f0c:	f001 ffe2 	bl	8005ed4 <__aeabi_l2d>
 8003f10:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 8003f14:	f89d 0000 	ldrb.w	r0, [sp]
 8003f18:	2800      	cmp	r0, #0
 8003f1a:	f040 80d8 	bne.w	80040ce <??ZbZclHandleConfigReport_15>

08003f1e <??ZbZclHandleConfigReport_21>:
 8003f1e:	9802      	ldr	r0, [sp, #8]
 8003f20:	1986      	adds	r6, r0, r6
 8003f22:	2001      	movs	r0, #1
 8003f24:	4681      	mov	r9, r0

08003f26 <??ZbZclHandleConfigReport_19>:
 8003f26:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8003f2a:	0020      	movs	r0, r4
 8003f2c:	f7fd f917 	bl	800115e <ZbZclAttrFind>
 8003f30:	4682      	mov	sl, r0
 8003f32:	f1ba 0f00 	cmp.w	sl, #0
 8003f36:	d103      	bne.n	8003f40 <??ZbZclHandleConfigReport_22>
 8003f38:	2086      	movs	r0, #134	; 0x86
 8003f3a:	f88d 0000 	strb.w	r0, [sp]
 8003f3e:	e0c6      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003f40 <??ZbZclHandleConfigReport_22>:
 8003f40:	f8da 0008 	ldr.w	r0, [sl, #8]
 8003f44:	8880      	ldrh	r0, [r0, #4]
 8003f46:	0400      	lsls	r0, r0, #16
 8003f48:	d503      	bpl.n	8003f52 <??ZbZclHandleConfigReport_23>
 8003f4a:	2086      	movs	r0, #134	; 0x86
 8003f4c:	f88d 0000 	strb.w	r0, [sp]
 8003f50:	e0bd      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003f52 <??ZbZclHandleConfigReport_23>:
 8003f52:	f8da 0008 	ldr.w	r0, [sl, #8]
 8003f56:	7900      	ldrb	r0, [r0, #4]
 8003f58:	0780      	lsls	r0, r0, #30
 8003f5a:	d403      	bmi.n	8003f64 <??ZbZclHandleConfigReport_24>
 8003f5c:	208c      	movs	r0, #140	; 0x8c
 8003f5e:	f88d 0000 	strb.w	r0, [sp]
 8003f62:	e0b4      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003f64 <??ZbZclHandleConfigReport_24>:
 8003f64:	f64f 7bff 	movw	fp, #65535	; 0xffff
 8003f68:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
 8003f6c:	4558      	cmp	r0, fp
 8003f6e:	d101      	bne.n	8003f74 <??ZbZclHandleConfigReport_25>
 8003f70:	2000      	movs	r0, #0
 8003f72:	4681      	mov	r9, r0

08003f74 <??ZbZclHandleConfigReport_25>:
 8003f74:	f89d 2001 	ldrb.w	r2, [sp, #1]
 8003f78:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8003f7c:	0020      	movs	r0, r4
 8003f7e:	f7ff fc12 	bl	80037a6 <zcl_reporting_find>
 8003f82:	4680      	mov	r8, r0
 8003f84:	f8bd 0038 	ldrh.w	r0, [sp, #56]	; 0x38
 8003f88:	4558      	cmp	r0, fp
 8003f8a:	d11b      	bne.n	8003fc4 <??ZbZclHandleConfigReport_26>
 8003f8c:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
 8003f90:	2800      	cmp	r0, #0
 8003f92:	d117      	bne.n	8003fc4 <??ZbZclHandleConfigReport_26>
 8003f94:	2000      	movs	r0, #0
 8003f96:	4681      	mov	r9, r0
 8003f98:	f1b8 0f00 	cmp.w	r8, #0
 8003f9c:	d00d      	beq.n	8003fba <??ZbZclHandleConfigReport_27>
 8003f9e:	f8b8 0024 	ldrh.w	r0, [r8, #36]	; 0x24
 8003fa2:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8003fa6:	f8b8 0026 	ldrh.w	r0, [r8, #38]	; 0x26
 8003faa:	f8ad 003e 	strh.w	r0, [sp, #62]	; 0x3e
 8003fae:	2200      	movs	r2, #0
 8003fb0:	a906      	add	r1, sp, #24
 8003fb2:	9801      	ldr	r0, [sp, #4]
 8003fb4:	f7ff fd84 	bl	8003ac0 <zcl_reporting_reset_defaults>
 8003fb8:	e004      	b.n	8003fc4 <??ZbZclHandleConfigReport_26>

08003fba <??ZbZclHandleConfigReport_27>:
 8003fba:	aa06      	add	r2, sp, #24
 8003fbc:	4651      	mov	r1, sl
 8003fbe:	9801      	ldr	r0, [sp, #4]
 8003fc0:	f7ff fd63 	bl	8003a8a <zcl_reporting_config_attr_defaults>

08003fc4 <??ZbZclHandleConfigReport_26>:
 8003fc4:	f89d 0026 	ldrb.w	r0, [sp, #38]	; 0x26
 8003fc8:	f8da 1008 	ldr.w	r1, [sl, #8]
 8003fcc:	7889      	ldrb	r1, [r1, #2]
 8003fce:	4288      	cmp	r0, r1
 8003fd0:	d003      	beq.n	8003fda <??ZbZclHandleConfigReport_28>
 8003fd2:	208d      	movs	r0, #141	; 0x8d
 8003fd4:	f88d 0000 	strb.w	r0, [sp]
 8003fd8:	e079      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08003fda <??ZbZclHandleConfigReport_28>:
 8003fda:	f1b8 0f00 	cmp.w	r8, #0
 8003fde:	d021      	beq.n	8004024 <??ZbZclHandleConfigReport_29>
 8003fe0:	f8bd 0038 	ldrh.w	r0, [sp, #56]	; 0x38
 8003fe4:	f8a8 0020 	strh.w	r0, [r8, #32]
 8003fe8:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
 8003fec:	f8a8 0022 	strh.w	r0, [r8, #34]	; 0x22
 8003ff0:	4648      	mov	r0, r9
 8003ff2:	b2c0      	uxtb	r0, r0
 8003ff4:	2800      	cmp	r0, #0
 8003ff6:	d00c      	beq.n	8004012 <??ZbZclHandleConfigReport_30>
 8003ff8:	a806      	add	r0, sp, #24
 8003ffa:	f7ff fdc3 	bl	8003b84 <zcl_reporting_epsilon_check>
 8003ffe:	2800      	cmp	r0, #0
 8004000:	d103      	bne.n	800400a <??ZbZclHandleConfigReport_31>
 8004002:	2085      	movs	r0, #133	; 0x85
 8004004:	f88d 0000 	strb.w	r0, [sp]
 8004008:	e061      	b.n	80040ce <??ZbZclHandleConfigReport_15>

0800400a <??ZbZclHandleConfigReport_31>:
 800400a:	ed9d 0b10 	vldr	d0, [sp, #64]	; 0x40
 800400e:	ed88 0b0a 	vstr	d0, [r8, #40]	; 0x28

08004012 <??ZbZclHandleConfigReport_30>:
 8004012:	9801      	ldr	r0, [sp, #4]
 8004014:	f011 fe63 	bl	8015cde <ZbZclUptime>
 8004018:	f8c8 0010 	str.w	r0, [r8, #16]
 800401c:	2001      	movs	r0, #1
 800401e:	f88d 0002 	strb.w	r0, [sp, #2]
 8004022:	e6b4      	b.n	8003d8e <??ZbZclHandleConfigReport_2>

08004024 <??ZbZclHandleConfigReport_29>:
 8004024:	f8bd 003a 	ldrh.w	r0, [sp, #58]	; 0x3a
 8004028:	4558      	cmp	r0, fp
 800402a:	f43f aeb0 	beq.w	8003d8e <??ZbZclHandleConfigReport_2>

0800402e <??ZbZclHandleConfigReport_32>:
 800402e:	9408      	str	r4, [sp, #32]
 8004030:	4648      	mov	r0, r9
 8004032:	b2c0      	uxtb	r0, r0
 8004034:	2800      	cmp	r0, #0
 8004036:	d008      	beq.n	800404a <??ZbZclHandleConfigReport_33>
 8004038:	a806      	add	r0, sp, #24
 800403a:	f7ff fda3 	bl	8003b84 <zcl_reporting_epsilon_check>
 800403e:	2800      	cmp	r0, #0
 8004040:	d108      	bne.n	8004054 <??ZbZclHandleConfigReport_34>
 8004042:	2085      	movs	r0, #133	; 0x85
 8004044:	f88d 0000 	strb.w	r0, [sp]
 8004048:	e041      	b.n	80040ce <??ZbZclHandleConfigReport_15>

0800404a <??ZbZclHandleConfigReport_33>:
 800404a:	f89d 1026 	ldrb.w	r1, [sp, #38]	; 0x26
 800404e:	a806      	add	r0, sp, #24
 8004050:	f7ff fd6b 	bl	8003b2a <zcl_reporting_epsilon_default>

08004054 <??ZbZclHandleConfigReport_34>:
 8004054:	2008      	movs	r0, #8
 8004056:	9015      	str	r0, [sp, #84]	; 0x54
 8004058:	a810      	add	r0, sp, #64	; 0x40
 800405a:	9014      	str	r0, [sp, #80]	; 0x50
 800405c:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
 8004060:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8004062:	9914      	ldr	r1, [sp, #80]	; 0x50
 8004064:	4658      	mov	r0, fp
 8004066:	f014 fa94 	bl	8018592 <__aeabi_memcpy>
 800406a:	a906      	add	r1, sp, #24
 800406c:	0020      	movs	r0, r4
 800406e:	f7ff fbec 	bl	800384a <zcl_reporting_save_curr_val>
 8004072:	f88d 0000 	strb.w	r0, [sp]
 8004076:	f89d 0000 	ldrb.w	r0, [sp]
 800407a:	2800      	cmp	r0, #0
 800407c:	d127      	bne.n	80040ce <??ZbZclHandleConfigReport_15>

0800407e <??ZbZclHandleConfigReport_35>:
 800407e:	a906      	add	r1, sp, #24
 8004080:	0020      	movs	r0, r4
 8004082:	f7ff fc55 	bl	8003930 <zcl_reporting_create_new>
 8004086:	2800      	cmp	r0, #0
 8004088:	d103      	bne.n	8004092 <??ZbZclHandleConfigReport_36>
 800408a:	2189      	movs	r1, #137	; 0x89
 800408c:	f88d 1000 	strb.w	r1, [sp]
 8004090:	e01d      	b.n	80040ce <??ZbZclHandleConfigReport_15>

08004092 <??ZbZclHandleConfigReport_36>:
 8004092:	2101      	movs	r1, #1
 8004094:	f88d 1002 	strb.w	r1, [sp, #2]
 8004098:	e679      	b.n	8003d8e <??ZbZclHandleConfigReport_2>

0800409a <??ZbZclHandleConfigReport_6>:
 800409a:	f89d 0001 	ldrb.w	r0, [sp, #1]
 800409e:	2801      	cmp	r0, #1
 80040a0:	d10e      	bne.n	80040c0 <??ZbZclHandleConfigReport_37>
 80040a2:	8d28      	ldrh	r0, [r5, #40]	; 0x28
 80040a4:	1cb1      	adds	r1, r6, #2
 80040a6:	4288      	cmp	r0, r1
 80040a8:	d206      	bcs.n	80040b8 <??ZbZclHandleConfigReport_38>
 80040aa:	2380      	movs	r3, #128	; 0x80
 80040ac:	9a48      	ldr	r2, [sp, #288]	; 0x120
 80040ae:	0029      	movs	r1, r5
 80040b0:	0020      	movs	r0, r4
 80040b2:	f011 ff5e 	bl	8015f72 <ZbZclSendDefaultResponse>
 80040b6:	e0a1      	b.n	80041fc <??ZbZclHandleConfigReport_3>

080040b8 <??ZbZclHandleConfigReport_38>:
 80040b8:	208c      	movs	r0, #140	; 0x8c
 80040ba:	f88d 0000 	strb.w	r0, [sp]
 80040be:	e006      	b.n	80040ce <??ZbZclHandleConfigReport_15>

080040c0 <??ZbZclHandleConfigReport_37>:
 80040c0:	2380      	movs	r3, #128	; 0x80
 80040c2:	9a48      	ldr	r2, [sp, #288]	; 0x120
 80040c4:	0029      	movs	r1, r5
 80040c6:	0020      	movs	r0, r4
 80040c8:	f011 ff53 	bl	8015f72 <ZbZclSendDefaultResponse>
 80040cc:	e096      	b.n	80041fc <??ZbZclHandleConfigReport_3>

080040ce <??ZbZclHandleConfigReport_15>:
 80040ce:	f89d 0000 	ldrb.w	r0, [sp]
 80040d2:	f88d 0003 	strb.w	r0, [sp, #3]
 80040d6:	1d38      	adds	r0, r7, #4
 80040d8:	2837      	cmp	r0, #55	; 0x37
 80040da:	d210      	bcs.n	80040fe <??ZbZclHandleConfigReport_4>

080040dc <??ZbZclHandleConfigReport_39>:
 80040dc:	a83a      	add	r0, sp, #232	; 0xe8
 80040de:	f89d 1000 	ldrb.w	r1, [sp]
 80040e2:	55c1      	strb	r1, [r0, r7]
 80040e4:	1c7f      	adds	r7, r7, #1
 80040e6:	f89d 1001 	ldrb.w	r1, [sp, #1]
 80040ea:	55c1      	strb	r1, [r0, r7]
 80040ec:	1c7f      	adds	r7, r7, #1
 80040ee:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 80040f2:	a83a      	add	r0, sp, #232	; 0xe8
 80040f4:	4438      	add	r0, r7
 80040f6:	f7fc f89d 	bl	8000234 <putle16>
 80040fa:	1cbf      	adds	r7, r7, #2
 80040fc:	e647      	b.n	8003d8e <??ZbZclHandleConfigReport_2>

080040fe <??ZbZclHandleConfigReport_4>:
 80040fe:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8004102:	2800      	cmp	r0, #0
 8004104:	d105      	bne.n	8004112 <??ZbZclHandleConfigReport_40>
 8004106:	2000      	movs	r0, #0
 8004108:	2100      	movs	r1, #0
 800410a:	aa3a      	add	r2, sp, #232	; 0xe8
 800410c:	5411      	strb	r1, [r2, r0]
 800410e:	1c40      	adds	r0, r0, #1
 8004110:	0007      	movs	r7, r0

08004112 <??ZbZclHandleConfigReport_40>:
 8004112:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8004116:	2800      	cmp	r0, #0
 8004118:	d127      	bne.n	800416a <??ZbZclHandleConfigReport_41>
 800411a:	f05f 0920 	movs.w	r9, #32
 800411e:	f05f 0800 	movs.w	r8, #0
 8004122:	f10d 0a60 	add.w	sl, sp, #96	; 0x60
 8004126:	4642      	mov	r2, r8
 8004128:	4649      	mov	r1, r9
 800412a:	4650      	mov	r0, sl
 800412c:	f001 fc9b 	bl	8005a66 <__aeabi_memset>
 8004130:	9801      	ldr	r0, [sp, #4]
 8004132:	f011 f94b 	bl	80153cc <ZbExtendedAddress>
 8004136:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 800413a:	8868      	ldrh	r0, [r5, #2]
 800413c:	f88d 0068 	strb.w	r0, [sp, #104]	; 0x68
 8004140:	89a0      	ldrh	r0, [r4, #12]
 8004142:	f8ad 006a 	strh.w	r0, [sp, #106]	; 0x6a
 8004146:	2003      	movs	r0, #3
 8004148:	f88d 0070 	strb.w	r0, [sp, #112]	; 0x70
 800414c:	8a68      	ldrh	r0, [r5, #18]
 800414e:	f8ad 0072 	strh.w	r0, [sp, #114]	; 0x72
 8004152:	8ae8      	ldrh	r0, [r5, #22]
 8004154:	f8ad 0076 	strh.w	r0, [sp, #118]	; 0x76
 8004158:	e9d5 0106 	ldrd	r0, r1, [r5, #24]
 800415c:	e9cd 011e 	strd	r0, r1, [sp, #120]	; 0x78
 8004160:	aa30      	add	r2, sp, #192	; 0xc0
 8004162:	a918      	add	r1, sp, #96	; 0x60
 8004164:	9801      	ldr	r0, [sp, #4]
 8004166:	f011 fb4c 	bl	8015802 <ZbApsmeBindReq>

0800416a <??ZbZclHandleConfigReport_41>:
 800416a:	2200      	movs	r2, #0
 800416c:	a924      	add	r1, sp, #144	; 0x90
 800416e:	0020      	movs	r0, r4
 8004170:	f7fc fa13 	bl	800059a <ZbZclClusterInitApsdeReq>
 8004174:	a824      	add	r0, sp, #144	; 0x90
 8004176:	f115 0110 	adds.w	r1, r5, #16
 800417a:	2210      	movs	r2, #16
 800417c:	f014 fa09 	bl	8018592 <__aeabi_memcpy>
 8004180:	f895 002a 	ldrb.w	r0, [r5, #42]	; 0x2a
 8004184:	f7fc f9a1 	bl	80004ca <ZbZclTxOptsFromSecurityStatus>
 8004188:	f8ad 00b4 	strh.w	r0, [sp, #180]	; 0xb4
 800418c:	f8bd 00b4 	ldrh.w	r0, [sp, #180]	; 0xb4
 8004190:	f450 7080 	orrs.w	r0, r0, #256	; 0x100
 8004194:	f8ad 00b4 	strh.w	r0, [sp, #180]	; 0xb4
 8004198:	2001      	movs	r0, #1
 800419a:	f88d 00b6 	strb.w	r0, [sp, #182]	; 0xb6
 800419e:	2000      	movs	r0, #0
 80041a0:	f88d 00b7 	strb.w	r0, [sp, #183]	; 0xb7
 80041a4:	a816      	add	r0, sp, #88	; 0x58
 80041a6:	9020      	str	r0, [sp, #128]	; 0x80
 80041a8:	a820      	add	r0, sp, #128	; 0x80
 80041aa:	9905      	ldr	r1, [sp, #20]
 80041ac:	6041      	str	r1, [r0, #4]
 80041ae:	a93a      	add	r1, sp, #232	; 0xe8
 80041b0:	6081      	str	r1, [r0, #8]
 80041b2:	60c7      	str	r7, [r0, #12]
 80041b4:	a820      	add	r0, sp, #128	; 0x80
 80041b6:	902a      	str	r0, [sp, #168]	; 0xa8
 80041b8:	2002      	movs	r0, #2
 80041ba:	f8ad 00ac 	strh.w	r0, [sp, #172]	; 0xac
 80041be:	2300      	movs	r3, #0
 80041c0:	2200      	movs	r2, #0
 80041c2:	a924      	add	r1, sp, #144	; 0x90
 80041c4:	9801      	ldr	r0, [sp, #4]
 80041c6:	f011 fa17 	bl	80155f8 <ZbApsdeDataReqCallback>
 80041ca:	f89d 0002 	ldrb.w	r0, [sp, #2]
 80041ce:	2800      	cmp	r0, #0
 80041d0:	d014      	beq.n	80041fc <??ZbZclHandleConfigReport_3>
 80041d2:	2301      	movs	r3, #1
 80041d4:	f10d 0201 	add.w	r2, sp, #1
 80041d8:	f240 410c 	movw	r1, #1036	; 0x40c
 80041dc:	9801      	ldr	r0, [sp, #4]
 80041de:	f011 fd69 	bl	8015cb4 <ZbNwkGet>
 80041e2:	2800      	cmp	r0, #0
 80041e4:	d002      	beq.n	80041ec <??ZbZclHandleConfigReport_43>
 80041e6:	2000      	movs	r0, #0
 80041e8:	f88d 0001 	strb.w	r0, [sp, #1]

080041ec <??ZbZclHandleConfigReport_43>:
 80041ec:	f89d 0001 	ldrb.w	r0, [sp, #1]
 80041f0:	2800      	cmp	r0, #0
 80041f2:	d103      	bne.n	80041fc <??ZbZclHandleConfigReport_3>
 80041f4:	21c8      	movs	r1, #200	; 0xc8
 80041f6:	0020      	movs	r0, r4
 80041f8:	f7fe ff7f 	bl	80030fa <zcl_report_kick>

080041fc <??ZbZclHandleConfigReport_3>:
 80041fc:	b049      	add	sp, #292	; 0x124
 80041fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004202 <ZbZclHandleReadReport>:
 8004202:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004206:	b09a      	sub	sp, #104	; 0x68
 8004208:	4680      	mov	r8, r0
 800420a:	4691      	mov	r9, r2
 800420c:	f05f 0a00 	movs.w	sl, #0
 8004210:	2300      	movs	r3, #0
 8004212:	a28d      	add	r2, pc, #564	; (adr r2, 8004448 <??DataTable10>)
 8004214:	f8b8 101a 	ldrh.w	r1, [r8, #26]
 8004218:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800421c:	f011 ffe6 	bl	80161ec <zb_heap_alloc>
 8004220:	0007      	movs	r7, r0
 8004222:	2f00      	cmp	r7, #0
 8004224:	d106      	bne.n	8004234 <??ZbZclHandleReadReport_0>
 8004226:	2389      	movs	r3, #137	; 0x89
 8004228:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800422a:	4649      	mov	r1, r9
 800422c:	4640      	mov	r0, r8
 800422e:	f011 fea0 	bl	8015f72 <ZbZclSendDefaultResponse>
 8004232:	e105      	b.n	8004440 <??ZbZclHandleReadReport_1>

08004234 <??ZbZclHandleReadReport_0>:
 8004234:	2408      	movs	r4, #8
 8004236:	2500      	movs	r5, #0
 8004238:	ae01      	add	r6, sp, #4
 800423a:	002a      	movs	r2, r5
 800423c:	0021      	movs	r1, r4
 800423e:	0030      	movs	r0, r6
 8004240:	f001 fc11 	bl	8005a66 <__aeabi_memset>
 8004244:	2000      	movs	r0, #0
 8004246:	f88d 0004 	strb.w	r0, [sp, #4]
 800424a:	981a      	ldr	r0, [sp, #104]	; 0x68
 800424c:	7840      	ldrb	r0, [r0, #1]
 800424e:	f88d 0005 	strb.w	r0, [sp, #5]
 8004252:	981a      	ldr	r0, [sp, #104]	; 0x68
 8004254:	7880      	ldrb	r0, [r0, #2]
 8004256:	2800      	cmp	r0, #0
 8004258:	d103      	bne.n	8004262 <??ZbZclHandleReadReport_2>
 800425a:	2001      	movs	r0, #1
 800425c:	f88d 0006 	strb.w	r0, [sp, #6]
 8004260:	e002      	b.n	8004268 <??ZbZclHandleReadReport_3>

08004262 <??ZbZclHandleReadReport_2>:
 8004262:	2000      	movs	r0, #0
 8004264:	f88d 0006 	strb.w	r0, [sp, #6]

08004268 <??ZbZclHandleReadReport_3>:
 8004268:	2001      	movs	r0, #1
 800426a:	f88d 0007 	strb.w	r0, [sp, #7]
 800426e:	981a      	ldr	r0, [sp, #104]	; 0x68
 8004270:	8880      	ldrh	r0, [r0, #4]
 8004272:	f8ad 0008 	strh.w	r0, [sp, #8]
 8004276:	981a      	ldr	r0, [sp, #104]	; 0x68
 8004278:	7980      	ldrb	r0, [r0, #6]
 800427a:	f88d 000a 	strb.w	r0, [sp, #10]
 800427e:	2009      	movs	r0, #9
 8004280:	f88d 000b 	strb.w	r0, [sp, #11]
 8004284:	2205      	movs	r2, #5
 8004286:	0039      	movs	r1, r7
 8004288:	a801      	add	r0, sp, #4
 800428a:	f7fc fee7 	bl	800105c <ZbZclAppendHeader>
 800428e:	0004      	movs	r4, r0
 8004290:	2c00      	cmp	r4, #0
 8004292:	d506      	bpl.n	80042a2 <??ZbZclHandleReadReport_4>
 8004294:	2380      	movs	r3, #128	; 0x80
 8004296:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8004298:	4649      	mov	r1, r9
 800429a:	4640      	mov	r0, r8
 800429c:	f011 fe69 	bl	8015f72 <ZbZclSendDefaultResponse>
 80042a0:	e0ce      	b.n	8004440 <??ZbZclHandleReadReport_1>

080042a2 <??ZbZclHandleReadReport_4>:
 80042a2:	f8b9 0028 	ldrh.w	r0, [r9, #40]	; 0x28
 80042a6:	4582      	cmp	sl, r0
 80042a8:	f080 80a1 	bcs.w	80043ee <??ZbZclHandleReadReport_5>
 80042ac:	f8b9 0028 	ldrh.w	r0, [r9, #40]	; 0x28
 80042b0:	f11a 0103 	adds.w	r1, sl, #3
 80042b4:	4288      	cmp	r0, r1
 80042b6:	d206      	bcs.n	80042c6 <??ZbZclHandleReadReport_6>
 80042b8:	2380      	movs	r3, #128	; 0x80
 80042ba:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80042bc:	4649      	mov	r1, r9
 80042be:	4640      	mov	r0, r8
 80042c0:	f011 fe57 	bl	8015f72 <ZbZclSendDefaultResponse>
 80042c4:	e0bc      	b.n	8004440 <??ZbZclHandleReadReport_1>

080042c6 <??ZbZclHandleReadReport_6>:
 80042c6:	4650      	mov	r0, sl
 80042c8:	f110 0a01 	adds.w	sl, r0, #1
 80042cc:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
 80042d0:	5c08      	ldrb	r0, [r1, r0]
 80042d2:	2800      	cmp	r0, #0
 80042d4:	d003      	beq.n	80042de <??ZbZclHandleReadReport_7>
 80042d6:	2001      	movs	r0, #1
 80042d8:	f88d 0000 	strb.w	r0, [sp]
 80042dc:	e002      	b.n	80042e4 <??ZbZclHandleReadReport_8>

080042de <??ZbZclHandleReadReport_7>:
 80042de:	2000      	movs	r0, #0
 80042e0:	f88d 0000 	strb.w	r0, [sp]

080042e4 <??ZbZclHandleReadReport_8>:
 80042e4:	f8d9 0024 	ldr.w	r0, [r9, #36]	; 0x24
 80042e8:	4450      	add	r0, sl
 80042ea:	f7fb ff57 	bl	800019c <pletoh16>
 80042ee:	f8ad 0002 	strh.w	r0, [sp, #2]
 80042f2:	f11a 0a02 	adds.w	sl, sl, #2
 80042f6:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 80042fa:	4640      	mov	r0, r8
 80042fc:	f7fc ff2f 	bl	800115e <ZbZclAttrFind>
 8004300:	0006      	movs	r6, r0
 8004302:	2e00      	cmp	r6, #0
 8004304:	d102      	bne.n	800430c <??ZbZclHandleReadReport_9>
 8004306:	f05f 0b86 	movs.w	fp, #134	; 0x86
 800430a:	e05c      	b.n	80043c6 <??ZbZclHandleReadReport_10>

0800430c <??ZbZclHandleReadReport_9>:
 800430c:	68b0      	ldr	r0, [r6, #8]
 800430e:	7900      	ldrb	r0, [r0, #4]
 8004310:	0780      	lsls	r0, r0, #30
 8004312:	d402      	bmi.n	800431a <??ZbZclHandleReadReport_11>
 8004314:	f05f 0b8c 	movs.w	fp, #140	; 0x8c
 8004318:	e055      	b.n	80043c6 <??ZbZclHandleReadReport_10>

0800431a <??ZbZclHandleReadReport_11>:
 800431a:	f89d 2000 	ldrb.w	r2, [sp]
 800431e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 8004322:	4640      	mov	r0, r8
 8004324:	f7ff fa3f 	bl	80037a6 <zcl_reporting_find>
 8004328:	0005      	movs	r5, r0
 800432a:	2d00      	cmp	r5, #0
 800432c:	d102      	bne.n	8004334 <??ZbZclHandleReadReport_12>
 800432e:	f05f 0b8b 	movs.w	fp, #139	; 0x8b
 8004332:	e048      	b.n	80043c6 <??ZbZclHandleReadReport_10>

08004334 <??ZbZclHandleReadReport_12>:
 8004334:	8c68      	ldrh	r0, [r5, #34]	; 0x22
 8004336:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800433a:	4288      	cmp	r0, r1
 800433c:	d102      	bne.n	8004344 <??ZbZclHandleReadReport_13>
 800433e:	f05f 0b8b 	movs.w	fp, #139	; 0x8b
 8004342:	e040      	b.n	80043c6 <??ZbZclHandleReadReport_10>

08004344 <??ZbZclHandleReadReport_13>:
 8004344:	2020      	movs	r0, #32
 8004346:	9005      	str	r0, [sp, #20]
 8004348:	2000      	movs	r0, #0
 800434a:	9004      	str	r0, [sp, #16]
 800434c:	f10d 0b18 	add.w	fp, sp, #24
 8004350:	9a04      	ldr	r2, [sp, #16]
 8004352:	9905      	ldr	r1, [sp, #20]
 8004354:	4658      	mov	r0, fp
 8004356:	f001 fb86 	bl	8005a66 <__aeabi_memset>
 800435a:	f89d 0000 	ldrb.w	r0, [sp]
 800435e:	2800      	cmp	r0, #0
 8004360:	d003      	beq.n	800436a <??ZbZclHandleReadReport_14>
 8004362:	2001      	movs	r0, #1
 8004364:	f88d 0018 	strb.w	r0, [sp, #24]
 8004368:	e002      	b.n	8004370 <??ZbZclHandleReadReport_15>

0800436a <??ZbZclHandleReadReport_14>:
 800436a:	2000      	movs	r0, #0
 800436c:	f88d 0018 	strb.w	r0, [sp, #24]

08004370 <??ZbZclHandleReadReport_15>:
 8004370:	89a8      	ldrh	r0, [r5, #12]
 8004372:	f8ad 001a 	strh.w	r0, [sp, #26]
 8004376:	7ba8      	ldrb	r0, [r5, #14]
 8004378:	f88d 001c 	strb.w	r0, [sp, #28]
 800437c:	8c28      	ldrh	r0, [r5, #32]
 800437e:	f8ad 001e 	strh.w	r0, [sp, #30]
 8004382:	8c68      	ldrh	r0, [r5, #34]	; 0x22
 8004384:	f8ad 0020 	strh.w	r0, [sp, #32]
 8004388:	ed95 0b0a 	vldr	d0, [r5, #40]	; 0x28
 800438c:	ed8d 0b0a 	vstr	d0, [sp, #40]	; 0x28
 8004390:	2000      	movs	r0, #0
 8004392:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
 8004396:	2000      	movs	r0, #0
 8004398:	5538      	strb	r0, [r7, r4]
 800439a:	1c64      	adds	r4, r4, #1
 800439c:	f8b8 201a 	ldrh.w	r2, [r8, #26]
 80043a0:	0020      	movs	r0, r4
 80043a2:	b280      	uxth	r0, r0
 80043a4:	1a12      	subs	r2, r2, r0
 80043a6:	eb07 0104 	add.w	r1, r7, r4
 80043aa:	a806      	add	r0, sp, #24
 80043ac:	f000 f896 	bl	80044dc <zcl_append_report_config_record>
 80043b0:	9003      	str	r0, [sp, #12]
 80043b2:	9803      	ldr	r0, [sp, #12]
 80043b4:	2800      	cmp	r0, #0
 80043b6:	d503      	bpl.n	80043c0 <??ZbZclHandleReadReport_16>
 80043b8:	1e64      	subs	r4, r4, #1
 80043ba:	f05f 0b01 	movs.w	fp, #1
 80043be:	e002      	b.n	80043c6 <??ZbZclHandleReadReport_10>

080043c0 <??ZbZclHandleReadReport_16>:
 80043c0:	9803      	ldr	r0, [sp, #12]
 80043c2:	1904      	adds	r4, r0, r4
 80043c4:	e76d      	b.n	80042a2 <??ZbZclHandleReadReport_4>

080043c6 <??ZbZclHandleReadReport_10>:
 80043c6:	f8b8 001a 	ldrh.w	r0, [r8, #26]
 80043ca:	1ce1      	adds	r1, r4, #3
 80043cc:	4288      	cmp	r0, r1
 80043ce:	d30e      	bcc.n	80043ee <??ZbZclHandleReadReport_5>

080043d0 <??ZbZclHandleReadReport_17>:
 80043d0:	f807 b004 	strb.w	fp, [r7, r4]
 80043d4:	1c64      	adds	r4, r4, #1
 80043d6:	f89d 0000 	ldrb.w	r0, [sp]
 80043da:	5538      	strb	r0, [r7, r4]
 80043dc:	1c64      	adds	r4, r4, #1
 80043de:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 80043e2:	eb07 0004 	add.w	r0, r7, r4
 80043e6:	f7fb ff25 	bl	8000234 <putle16>
 80043ea:	1ca4      	adds	r4, r4, #2
 80043ec:	e759      	b.n	80042a2 <??ZbZclHandleReadReport_4>

080043ee <??ZbZclHandleReadReport_5>:
 80043ee:	464a      	mov	r2, r9
 80043f0:	a90e      	add	r1, sp, #56	; 0x38
 80043f2:	4640      	mov	r0, r8
 80043f4:	f7fc f8d1 	bl	800059a <ZbZclClusterInitApsdeReq>
 80043f8:	a80e      	add	r0, sp, #56	; 0x38
 80043fa:	f119 0110 	adds.w	r1, r9, #16
 80043fe:	2210      	movs	r2, #16
 8004400:	f014 f8c7 	bl	8018592 <__aeabi_memcpy>
 8004404:	f899 002a 	ldrb.w	r0, [r9, #42]	; 0x2a
 8004408:	f7fc f85f 	bl	80004ca <ZbZclTxOptsFromSecurityStatus>
 800440c:	f8ad 005c 	strh.w	r0, [sp, #92]	; 0x5c
 8004410:	2001      	movs	r0, #1
 8004412:	f88d 005e 	strb.w	r0, [sp, #94]	; 0x5e
 8004416:	2000      	movs	r0, #0
 8004418:	f88d 005f 	strb.w	r0, [sp, #95]	; 0x5f
 800441c:	9714      	str	r7, [sp, #80]	; 0x50
 800441e:	0020      	movs	r0, r4
 8004420:	f8ad 0054 	strh.w	r0, [sp, #84]	; 0x54
 8004424:	2300      	movs	r3, #0
 8004426:	2200      	movs	r2, #0
 8004428:	a90e      	add	r1, sp, #56	; 0x38
 800442a:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800442e:	f011 f8e3 	bl	80155f8 <ZbApsdeDataReqCallback>
 8004432:	2300      	movs	r3, #0
 8004434:	a204      	add	r2, pc, #16	; (adr r2, 8004448 <??DataTable10>)
 8004436:	0039      	movs	r1, r7
 8004438:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800443c:	f011 fee5 	bl	801620a <zb_heap_free>

08004440 <??ZbZclHandleReadReport_1>:
 8004440:	b01b      	add	sp, #108	; 0x6c
 8004442:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004448 <??DataTable10>:
 8004448:	0000 0000                                   ....

0800444c <ZbZclHandleReportAttr>:
 800444c:	e92d 47fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004450:	0004      	movs	r4, r0
 8004452:	000d      	movs	r5, r1
 8004454:	0016      	movs	r6, r2
 8004456:	f05f 0a00 	movs.w	sl, #0
 800445a:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800445c:	2800      	cmp	r0, #0
 800445e:	d03b      	beq.n	80044d8 <??ZbZclHandleReportAttr_0>

08004460 <??ZbZclHandleReportAttr_1>:
 8004460:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 8004462:	4651      	mov	r1, sl
 8004464:	b289      	uxth	r1, r1
 8004466:	1cc9      	adds	r1, r1, #3
 8004468:	4288      	cmp	r0, r1
 800446a:	d335      	bcc.n	80044d8 <??ZbZclHandleReportAttr_0>

0800446c <??ZbZclHandleReportAttr_3>:
 800446c:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800446e:	4651      	mov	r1, sl
 8004470:	b289      	uxth	r1, r1
 8004472:	4408      	add	r0, r1
 8004474:	f7fb fe92 	bl	800019c <pletoh16>
 8004478:	0007      	movs	r7, r0
 800447a:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800447c:	4651      	mov	r1, sl
 800447e:	b289      	uxth	r1, r1
 8004480:	4408      	add	r0, r1
 8004482:	7880      	ldrb	r0, [r0, #2]
 8004484:	4680      	mov	r8, r0
 8004486:	f11a 0a03 	adds.w	sl, sl, #3
 800448a:	2300      	movs	r3, #0
 800448c:	8d32      	ldrh	r2, [r6, #40]	; 0x28
 800448e:	4650      	mov	r0, sl
 8004490:	b280      	uxth	r0, r0
 8004492:	1a12      	subs	r2, r2, r0
 8004494:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8004496:	4651      	mov	r1, sl
 8004498:	b289      	uxth	r1, r1
 800449a:	4401      	add	r1, r0
 800449c:	4640      	mov	r0, r8
 800449e:	b2c0      	uxtb	r0, r0
 80044a0:	f7fd fd89 	bl	8001fb6 <ZbZclAttrParseLength>
 80044a4:	4681      	mov	r9, r0
 80044a6:	f1b9 0f00 	cmp.w	r9, #0
 80044aa:	d415      	bmi.n	80044d8 <??ZbZclHandleReportAttr_0>

080044ac <??ZbZclHandleReportAttr_4>:
 80044ac:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 80044ae:	ebb0 000a 	subs.w	r0, r0, sl
 80044b2:	b280      	uxth	r0, r0
 80044b4:	9001      	str	r0, [sp, #4]
 80044b6:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80044b8:	4651      	mov	r1, sl
 80044ba:	b289      	uxth	r1, r1
 80044bc:	4408      	add	r0, r1
 80044be:	9000      	str	r0, [sp, #0]
 80044c0:	4643      	mov	r3, r8
 80044c2:	b2db      	uxtb	r3, r3
 80044c4:	003a      	movs	r2, r7
 80044c6:	b292      	uxth	r2, r2
 80044c8:	0031      	movs	r1, r6
 80044ca:	0020      	movs	r0, r4
 80044cc:	f8d4 c05c 	ldr.w	ip, [r4, #92]	; 0x5c
 80044d0:	47e0      	blx	ip
 80044d2:	eb19 0a0a 	adds.w	sl, r9, sl
 80044d6:	e7c3      	b.n	8004460 <??ZbZclHandleReportAttr_1>

080044d8 <??ZbZclHandleReportAttr_0>:
 80044d8:	e8bd 87f3 	ldmia.w	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, pc}

080044dc <zcl_append_report_config_record>:
 80044dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80044e0:	0005      	movs	r5, r0
 80044e2:	000e      	movs	r6, r1
 80044e4:	4690      	mov	r8, r2
 80044e6:	2700      	movs	r7, #0
 80044e8:	7828      	ldrb	r0, [r5, #0]
 80044ea:	2800      	cmp	r0, #0
 80044ec:	d003      	beq.n	80044f6 <??zcl_append_report_config_record_0>
 80044ee:	2801      	cmp	r0, #1
 80044f0:	f000 80f4 	beq.w	80046dc <??zcl_append_report_config_record_1>
 80044f4:	e108      	b.n	8004708 <??zcl_append_report_config_record_2>

080044f6 <??zcl_append_report_config_record_0>:
 80044f6:	7928      	ldrb	r0, [r5, #4]
 80044f8:	f001 fa9e 	bl	8005a38 <ZbZclAttrIsFloat>
 80044fc:	2800      	cmp	r0, #0
 80044fe:	d002      	beq.n	8004506 <??zcl_append_report_config_record_3>
 8004500:	2001      	movs	r0, #1
 8004502:	4681      	mov	r9, r0
 8004504:	e009      	b.n	800451a <??zcl_append_report_config_record_4>

08004506 <??zcl_append_report_config_record_3>:
 8004506:	7928      	ldrb	r0, [r5, #4]
 8004508:	f7fd fe06 	bl	8002118 <ZbZclAttrIsAnalog>
 800450c:	2800      	cmp	r0, #0
 800450e:	d002      	beq.n	8004516 <??zcl_append_report_config_record_5>
 8004510:	2001      	movs	r0, #1
 8004512:	4681      	mov	r9, r0
 8004514:	e001      	b.n	800451a <??zcl_append_report_config_record_4>

08004516 <??zcl_append_report_config_record_5>:
 8004516:	2000      	movs	r0, #0
 8004518:	4681      	mov	r9, r0

0800451a <??zcl_append_report_config_record_4>:
 800451a:	f1b8 0f08 	cmp.w	r8, #8
 800451e:	d202      	bcs.n	8004526 <??zcl_append_report_config_record_6>
 8004520:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8004524:	e0f3      	b.n	800470e <??zcl_append_report_config_record_7>

08004526 <??zcl_append_report_config_record_6>:
 8004526:	7828      	ldrb	r0, [r5, #0]
 8004528:	55f0      	strb	r0, [r6, r7]
 800452a:	1c7f      	adds	r7, r7, #1
 800452c:	8869      	ldrh	r1, [r5, #2]
 800452e:	eb06 0007 	add.w	r0, r6, r7
 8004532:	f7fb fe7f 	bl	8000234 <putle16>
 8004536:	1cbf      	adds	r7, r7, #2
 8004538:	7928      	ldrb	r0, [r5, #4]
 800453a:	55f0      	strb	r0, [r6, r7]
 800453c:	1c7f      	adds	r7, r7, #1
 800453e:	88e9      	ldrh	r1, [r5, #6]
 8004540:	eb06 0007 	add.w	r0, r6, r7
 8004544:	f7fb fe76 	bl	8000234 <putle16>
 8004548:	1cbf      	adds	r7, r7, #2
 800454a:	8929      	ldrh	r1, [r5, #8]
 800454c:	eb06 0007 	add.w	r0, r6, r7
 8004550:	f7fb fe70 	bl	8000234 <putle16>
 8004554:	1cbf      	adds	r7, r7, #2
 8004556:	4648      	mov	r0, r9
 8004558:	b2c0      	uxtb	r0, r0
 800455a:	2800      	cmp	r0, #0
 800455c:	f000 80bd 	beq.w	80046da <??zcl_append_report_config_record_8>
 8004560:	7928      	ldrb	r0, [r5, #4]
 8004562:	f7fd fc9d 	bl	8001ea0 <ZbZclAttrTypeLength>
 8004566:	0004      	movs	r4, r0
 8004568:	2c00      	cmp	r4, #0
 800456a:	d101      	bne.n	8004570 <??zcl_append_report_config_record_9>
 800456c:	2001      	movs	r0, #1
 800456e:	e0ce      	b.n	800470e <??zcl_append_report_config_record_7>

08004570 <??zcl_append_report_config_record_9>:
 8004570:	2c01      	cmp	r4, #1
 8004572:	d00e      	beq.n	8004592 <??zcl_append_report_config_record_10>
 8004574:	f0c0 80af 	bcc.w	80046d6 <??zcl_append_report_config_record_11>
 8004578:	2c03      	cmp	r4, #3
 800457a:	d02f      	beq.n	80045dc <??zcl_append_report_config_record_12>
 800457c:	d319      	bcc.n	80045b2 <??zcl_append_report_config_record_13>
 800457e:	2c05      	cmp	r4, #5
 8004580:	d054      	beq.n	800462c <??zcl_append_report_config_record_14>
 8004582:	d33f      	bcc.n	8004604 <??zcl_append_report_config_record_15>
 8004584:	2c07      	cmp	r4, #7
 8004586:	d07c      	beq.n	8004682 <??zcl_append_report_config_record_16>
 8004588:	d365      	bcc.n	8004656 <??zcl_append_report_config_record_17>
 800458a:	2c08      	cmp	r4, #8
 800458c:	f000 808e 	beq.w	80046ac <??zcl_append_report_config_record_18>
 8004590:	e0a1      	b.n	80046d6 <??zcl_append_report_config_record_11>

08004592 <??zcl_append_report_config_record_10>:
 8004592:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8004596:	2201      	movs	r2, #1
 8004598:	4b5f      	ldr	r3, [pc, #380]	; (8004718 <??DataTable11_1>)
 800459a:	f001 ff21 	bl	80063e0 <__aeabi_cdrcmple>
 800459e:	d801      	bhi.n	80045a4 <??zcl_append_report_config_record_19>
 80045a0:	2001      	movs	r0, #1
 80045a2:	e0b4      	b.n	800470e <??zcl_append_report_config_record_7>

080045a4 <??zcl_append_report_config_record_19>:
 80045a4:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80045a8:	f001 ff5c 	bl	8006464 <__aeabi_d2iz>
 80045ac:	55f0      	strb	r0, [r6, r7]
 80045ae:	1c7f      	adds	r7, r7, #1
 80045b0:	e093      	b.n	80046da <??zcl_append_report_config_record_8>

080045b2 <??zcl_append_report_config_record_13>:
 80045b2:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80045b6:	2201      	movs	r2, #1
 80045b8:	4b58      	ldr	r3, [pc, #352]	; (800471c <??DataTable11_2>)
 80045ba:	f001 ff11 	bl	80063e0 <__aeabi_cdrcmple>
 80045be:	d801      	bhi.n	80045c4 <??zcl_append_report_config_record_20>
 80045c0:	2001      	movs	r0, #1
 80045c2:	e0a4      	b.n	800470e <??zcl_append_report_config_record_7>

080045c4 <??zcl_append_report_config_record_20>:
 80045c4:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80045c8:	f001 ff4c 	bl	8006464 <__aeabi_d2iz>
 80045cc:	0001      	movs	r1, r0
 80045ce:	b289      	uxth	r1, r1
 80045d0:	eb06 0007 	add.w	r0, r6, r7
 80045d4:	f7fb fe2e 	bl	8000234 <putle16>
 80045d8:	1cbf      	adds	r7, r7, #2
 80045da:	e07e      	b.n	80046da <??zcl_append_report_config_record_8>

080045dc <??zcl_append_report_config_record_12>:
 80045dc:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80045e0:	4a4f      	ldr	r2, [pc, #316]	; (8004720 <??DataTable11_3>)
 80045e2:	4b50      	ldr	r3, [pc, #320]	; (8004724 <??DataTable11_4>)
 80045e4:	f001 fefc 	bl	80063e0 <__aeabi_cdrcmple>
 80045e8:	d801      	bhi.n	80045ee <??zcl_append_report_config_record_21>
 80045ea:	2001      	movs	r0, #1
 80045ec:	e08f      	b.n	800470e <??zcl_append_report_config_record_7>

080045ee <??zcl_append_report_config_record_21>:
 80045ee:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80045f2:	f001 ff5f 	bl	80064b4 <__aeabi_d2uiz>
 80045f6:	0001      	movs	r1, r0
 80045f8:	eb06 0007 	add.w	r0, r6, r7
 80045fc:	f7fb fe20 	bl	8000240 <putle24>
 8004600:	1cff      	adds	r7, r7, #3
 8004602:	e06a      	b.n	80046da <??zcl_append_report_config_record_8>

08004604 <??zcl_append_report_config_record_15>:
 8004604:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8004608:	4a47      	ldr	r2, [pc, #284]	; (8004728 <??DataTable11_5>)
 800460a:	4b48      	ldr	r3, [pc, #288]	; (800472c <??DataTable11_6>)
 800460c:	f001 fee8 	bl	80063e0 <__aeabi_cdrcmple>
 8004610:	d801      	bhi.n	8004616 <??zcl_append_report_config_record_22>
 8004612:	2001      	movs	r0, #1
 8004614:	e07b      	b.n	800470e <??zcl_append_report_config_record_7>

08004616 <??zcl_append_report_config_record_22>:
 8004616:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 800461a:	f001 ff4b 	bl	80064b4 <__aeabi_d2uiz>
 800461e:	0001      	movs	r1, r0
 8004620:	eb06 0007 	add.w	r0, r6, r7
 8004624:	f7fb fe18 	bl	8000258 <putle32>
 8004628:	1d3f      	adds	r7, r7, #4
 800462a:	e056      	b.n	80046da <??zcl_append_report_config_record_8>

0800462c <??zcl_append_report_config_record_14>:
 800462c:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8004630:	4a3f      	ldr	r2, [pc, #252]	; (8004730 <??DataTable11_7>)
 8004632:	4b40      	ldr	r3, [pc, #256]	; (8004734 <??DataTable11_8>)
 8004634:	f001 fed4 	bl	80063e0 <__aeabi_cdrcmple>
 8004638:	d801      	bhi.n	800463e <??zcl_append_report_config_record_23>
 800463a:	2001      	movs	r0, #1
 800463c:	e067      	b.n	800470e <??zcl_append_report_config_record_7>

0800463e <??zcl_append_report_config_record_23>:
 800463e:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8004642:	f001 ff6f 	bl	8006524 <__aeabi_d2ulz>
 8004646:	0002      	movs	r2, r0
 8004648:	000b      	movs	r3, r1
 800464a:	eb06 0007 	add.w	r0, r6, r7
 800464e:	f7fb fe0e 	bl	800026e <putle40>
 8004652:	1d7f      	adds	r7, r7, #5
 8004654:	e041      	b.n	80046da <??zcl_append_report_config_record_8>

08004656 <??zcl_append_report_config_record_17>:
 8004656:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 800465a:	f07f 021e 	mvns.w	r2, #30
 800465e:	4b36      	ldr	r3, [pc, #216]	; (8004738 <??DataTable11_9>)
 8004660:	f001 febe 	bl	80063e0 <__aeabi_cdrcmple>
 8004664:	d801      	bhi.n	800466a <??zcl_append_report_config_record_24>
 8004666:	2001      	movs	r0, #1
 8004668:	e051      	b.n	800470e <??zcl_append_report_config_record_7>

0800466a <??zcl_append_report_config_record_24>:
 800466a:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 800466e:	f001 ff59 	bl	8006524 <__aeabi_d2ulz>
 8004672:	0002      	movs	r2, r0
 8004674:	000b      	movs	r3, r1
 8004676:	eb06 0007 	add.w	r0, r6, r7
 800467a:	f7fb fe02 	bl	8000282 <putle48>
 800467e:	1dbf      	adds	r7, r7, #6
 8004680:	e02b      	b.n	80046da <??zcl_append_report_config_record_8>

08004682 <??zcl_append_report_config_record_16>:
 8004682:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8004686:	2201      	movs	r2, #1
 8004688:	4b2c      	ldr	r3, [pc, #176]	; (800473c <??DataTable11_10>)
 800468a:	f001 fea9 	bl	80063e0 <__aeabi_cdrcmple>
 800468e:	d801      	bhi.n	8004694 <??zcl_append_report_config_record_25>
 8004690:	2001      	movs	r0, #1
 8004692:	e03c      	b.n	800470e <??zcl_append_report_config_record_7>

08004694 <??zcl_append_report_config_record_25>:
 8004694:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8004698:	f001 ff44 	bl	8006524 <__aeabi_d2ulz>
 800469c:	0002      	movs	r2, r0
 800469e:	000b      	movs	r3, r1
 80046a0:	eb06 0007 	add.w	r0, r6, r7
 80046a4:	f7fb fdfc 	bl	80002a0 <putle56>
 80046a8:	1dff      	adds	r7, r7, #7
 80046aa:	e016      	b.n	80046da <??zcl_append_report_config_record_8>

080046ac <??zcl_append_report_config_record_18>:
 80046ac:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80046b0:	2201      	movs	r2, #1
 80046b2:	4b23      	ldr	r3, [pc, #140]	; (8004740 <??DataTable11_11>)
 80046b4:	f001 fe94 	bl	80063e0 <__aeabi_cdrcmple>
 80046b8:	d801      	bhi.n	80046be <??zcl_append_report_config_record_26>
 80046ba:	2001      	movs	r0, #1
 80046bc:	e027      	b.n	800470e <??zcl_append_report_config_record_7>

080046be <??zcl_append_report_config_record_26>:
 80046be:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 80046c2:	f001 ff2f 	bl	8006524 <__aeabi_d2ulz>
 80046c6:	0002      	movs	r2, r0
 80046c8:	000b      	movs	r3, r1
 80046ca:	eb06 0007 	add.w	r0, r6, r7
 80046ce:	f7fb fdf6 	bl	80002be <putle64>
 80046d2:	3708      	adds	r7, #8
 80046d4:	e001      	b.n	80046da <??zcl_append_report_config_record_8>

080046d6 <??zcl_append_report_config_record_11>:
 80046d6:	2001      	movs	r0, #1
 80046d8:	e019      	b.n	800470e <??zcl_append_report_config_record_7>

080046da <??zcl_append_report_config_record_8>:
 80046da:	e017      	b.n	800470c <??zcl_append_report_config_record_27>

080046dc <??zcl_append_report_config_record_1>:
 80046dc:	f1b8 0f08 	cmp.w	r8, #8
 80046e0:	d202      	bcs.n	80046e8 <??zcl_append_report_config_record_28>
 80046e2:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80046e6:	e012      	b.n	800470e <??zcl_append_report_config_record_7>

080046e8 <??zcl_append_report_config_record_28>:
 80046e8:	7828      	ldrb	r0, [r5, #0]
 80046ea:	55f0      	strb	r0, [r6, r7]
 80046ec:	1c7f      	adds	r7, r7, #1
 80046ee:	8869      	ldrh	r1, [r5, #2]
 80046f0:	eb06 0007 	add.w	r0, r6, r7
 80046f4:	f7fb fd9e 	bl	8000234 <putle16>
 80046f8:	1cbf      	adds	r7, r7, #2
 80046fa:	8b29      	ldrh	r1, [r5, #24]
 80046fc:	eb06 0007 	add.w	r0, r6, r7
 8004700:	f7fb fd98 	bl	8000234 <putle16>
 8004704:	1cbf      	adds	r7, r7, #2
 8004706:	e001      	b.n	800470c <??zcl_append_report_config_record_27>

08004708 <??zcl_append_report_config_record_2>:
 8004708:	2001      	movs	r0, #1
 800470a:	e000      	b.n	800470e <??zcl_append_report_config_record_7>

0800470c <??zcl_append_report_config_record_27>:
 800470c:	0038      	movs	r0, r7

0800470e <??zcl_append_report_config_record_7>:
 800470e:	e8bd 83f2 	ldmia.w	sp!, {r1, r4, r5, r6, r7, r8, r9, pc}
	...

08004714 <??DataTable11>:
 8004714:	0000 3ff0                                   ...?

08004718 <??DataTable11_1>:
 8004718:	e000 406f                                   ..o@

0800471c <??DataTable11_2>:
 800471c:	ffe0 40ef                                   ...@

08004720 <??DataTable11_3>:
 8004720:	0001 e000                                   ....

08004724 <??DataTable11_4>:
 8004724:	ffff 416f                                   ..oA

08004728 <??DataTable11_5>:
 8004728:	0001 ffe0                                   ....

0800472c <??DataTable11_6>:
 800472c:	ffff 41ef                                   ...A

08004730 <??DataTable11_7>:
 8004730:	e001 ffff                                   ....

08004734 <??DataTable11_8>:
 8004734:	ffff 426f                                   ..oB

08004738 <??DataTable11_9>:
 8004738:	ffff 42ef                                   ...B

0800473c <??DataTable11_10>:
 800473c:	0000 4370                                   ..pC

08004740 <??DataTable11_11>:
 8004740:	0000 43f0                                   ...C

08004744 <ZbZclAttrReportConfigReq>:
 8004744:	e92d 4ff6 	stmdb	sp!, {r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004748:	b09b      	sub	sp, #108	; 0x6c
 800474a:	0004      	movs	r4, r0
 800474c:	000d      	movs	r5, r1
 800474e:	001e      	movs	r6, r3
 8004750:	2700      	movs	r7, #0
 8004752:	7c28      	ldrb	r0, [r5, #16]
 8004754:	2800      	cmp	r0, #0
 8004756:	d002      	beq.n	800475e <??ZbZclAttrReportConfigReq_0>
 8004758:	7c28      	ldrb	r0, [r5, #16]
 800475a:	2807      	cmp	r0, #7
 800475c:	d301      	bcc.n	8004762 <??ZbZclAttrReportConfigReq_1>

0800475e <??ZbZclAttrReportConfigReq_0>:
 800475e:	2001      	movs	r0, #1
 8004760:	e059      	b.n	8004816 <??ZbZclAttrReportConfigReq_2>

08004762 <??ZbZclAttrReportConfigReq_1>:
 8004762:	f05f 0800 	movs.w	r8, #0

08004766 <??ZbZclAttrReportConfigReq_3>:
 8004766:	7c28      	ldrb	r0, [r5, #16]
 8004768:	4580      	cmp	r8, r0
 800476a:	d215      	bcs.n	8004798 <??ZbZclAttrReportConfigReq_4>
 800476c:	ea5f 1048 	movs.w	r0, r8, lsl #5
 8004770:	4428      	add	r0, r5
 8004772:	f110 0918 	adds.w	r9, r0, #24
 8004776:	f1d7 0239 	rsbs	r2, r7, #57	; 0x39
 800477a:	a80c      	add	r0, sp, #48	; 0x30
 800477c:	eb00 0107 	add.w	r1, r0, r7
 8004780:	4648      	mov	r0, r9
 8004782:	f7ff feab 	bl	80044dc <zcl_append_report_config_record>
 8004786:	0001      	movs	r1, r0
 8004788:	2901      	cmp	r1, #1
 800478a:	da01      	bge.n	8004790 <??ZbZclAttrReportConfigReq_5>
 800478c:	2001      	movs	r0, #1
 800478e:	e042      	b.n	8004816 <??ZbZclAttrReportConfigReq_2>

08004790 <??ZbZclAttrReportConfigReq_5>:
 8004790:	19cf      	adds	r7, r1, r7
 8004792:	f118 0801 	adds.w	r8, r8, #1
 8004796:	e7e6      	b.n	8004766 <??ZbZclAttrReportConfigReq_3>

08004798 <??ZbZclAttrReportConfigReq_4>:
 8004798:	f05f 0930 	movs.w	r9, #48	; 0x30
 800479c:	f05f 0a00 	movs.w	sl, #0
 80047a0:	46eb      	mov	fp, sp
 80047a2:	4652      	mov	r2, sl
 80047a4:	4649      	mov	r1, r9
 80047a6:	4658      	mov	r0, fp
 80047a8:	f001 f95d 	bl	8005a66 <__aeabi_memset>
 80047ac:	2000      	movs	r0, #0
 80047ae:	f88d 001a 	strb.w	r0, [sp, #26]
 80047b2:	8a20      	ldrh	r0, [r4, #16]
 80047b4:	2800      	cmp	r0, #0
 80047b6:	d001      	beq.n	80047bc <??ZbZclAttrReportConfigReq_6>
 80047b8:	2001      	movs	r0, #1
 80047ba:	e000      	b.n	80047be <??ZbZclAttrReportConfigReq_7>

080047bc <??ZbZclAttrReportConfigReq_6>:
 80047bc:	2000      	movs	r0, #0

080047be <??ZbZclAttrReportConfigReq_7>:
 80047be:	f88d 001b 	strb.w	r0, [sp, #27]
 80047c2:	8a20      	ldrh	r0, [r4, #16]
 80047c4:	f8ad 001e 	strh.w	r0, [sp, #30]
 80047c8:	2006      	movs	r0, #6
 80047ca:	f88d 0021 	strb.w	r0, [sp, #33]	; 0x21
 80047ce:	f011 fb4c 	bl	8015e6a <ZbZclGetNextSeqnum>
 80047d2:	f88d 0020 	strb.w	r0, [sp, #32]
 80047d6:	4668      	mov	r0, sp
 80047d8:	0029      	movs	r1, r5
 80047da:	2210      	movs	r2, #16
 80047dc:	f013 fed9 	bl	8018592 <__aeabi_memcpy>
 80047e0:	8aa0      	ldrh	r0, [r4, #20]
 80047e2:	f8ad 0010 	strh.w	r0, [sp, #16]
 80047e6:	89a0      	ldrh	r0, [r4, #12]
 80047e8:	f8ad 0012 	strh.w	r0, [sp, #18]
 80047ec:	7ba0      	ldrb	r0, [r4, #14]
 80047ee:	f8ad 0014 	strh.w	r0, [sp, #20]
 80047f2:	8ae0      	ldrh	r0, [r4, #22]
 80047f4:	f8ad 0016 	strh.w	r0, [sp, #22]
 80047f8:	7e20      	ldrb	r0, [r4, #24]
 80047fa:	f88d 0018 	strb.w	r0, [sp, #24]
 80047fe:	7e60      	ldrb	r0, [r4, #25]
 8004800:	f88d 0019 	strb.w	r0, [sp, #25]
 8004804:	a80c      	add	r0, sp, #48	; 0x30
 8004806:	9009      	str	r0, [sp, #36]	; 0x24
 8004808:	970a      	str	r7, [sp, #40]	; 0x28
 800480a:	0033      	movs	r3, r6
 800480c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800480e:	4669      	mov	r1, sp
 8004810:	68a0      	ldr	r0, [r4, #8]
 8004812:	f011 fb55 	bl	8015ec0 <ZbZclCommandReq>

08004816 <??ZbZclAttrReportConfigReq_2>:
 8004816:	b01d      	add	sp, #116	; 0x74
 8004818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800481c <ZbZclAttrReportReadReq>:
 800481c:	e92d 4ff6 	stmdb	sp!, {r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004820:	b09b      	sub	sp, #108	; 0x6c
 8004822:	0005      	movs	r5, r0
 8004824:	000e      	movs	r6, r1
 8004826:	001f      	movs	r7, r3
 8004828:	2400      	movs	r4, #0
 800482a:	7c30      	ldrb	r0, [r6, #16]
 800482c:	2800      	cmp	r0, #0
 800482e:	d002      	beq.n	8004836 <??ZbZclAttrReportReadReq_0>
 8004830:	7c30      	ldrb	r0, [r6, #16]
 8004832:	2807      	cmp	r0, #7
 8004834:	d301      	bcc.n	800483a <??ZbZclAttrReportReadReq_1>

08004836 <??ZbZclAttrReportReadReq_0>:
 8004836:	2001      	movs	r0, #1
 8004838:	e050      	b.n	80048dc <??ZbZclAttrReportReadReq_2>

0800483a <??ZbZclAttrReportReadReq_1>:
 800483a:	f05f 0800 	movs.w	r8, #0

0800483e <??ZbZclAttrReportReadReq_3>:
 800483e:	7c30      	ldrb	r0, [r6, #16]
 8004840:	4580      	cmp	r8, r0
 8004842:	d217      	bcs.n	8004874 <??ZbZclAttrReportReadReq_4>
 8004844:	1ce0      	adds	r0, r4, #3
 8004846:	283a      	cmp	r0, #58	; 0x3a
 8004848:	d301      	bcc.n	800484e <??ZbZclAttrReportReadReq_5>
 800484a:	2001      	movs	r0, #1
 800484c:	e046      	b.n	80048dc <??ZbZclAttrReportReadReq_2>

0800484e <??ZbZclAttrReportReadReq_5>:
 800484e:	ea5f 1048 	movs.w	r0, r8, lsl #5
 8004852:	4430      	add	r0, r6
 8004854:	7e00      	ldrb	r0, [r0, #24]
 8004856:	a90c      	add	r1, sp, #48	; 0x30
 8004858:	5508      	strb	r0, [r1, r4]
 800485a:	1c64      	adds	r4, r4, #1
 800485c:	ea5f 1048 	movs.w	r0, r8, lsl #5
 8004860:	4430      	add	r0, r6
 8004862:	8b41      	ldrh	r1, [r0, #26]
 8004864:	a80c      	add	r0, sp, #48	; 0x30
 8004866:	4420      	add	r0, r4
 8004868:	f7fb fce4 	bl	8000234 <putle16>
 800486c:	1ca4      	adds	r4, r4, #2
 800486e:	f118 0801 	adds.w	r8, r8, #1
 8004872:	e7e4      	b.n	800483e <??ZbZclAttrReportReadReq_3>

08004874 <??ZbZclAttrReportReadReq_4>:
 8004874:	f05f 0930 	movs.w	r9, #48	; 0x30
 8004878:	f05f 0a00 	movs.w	sl, #0
 800487c:	46eb      	mov	fp, sp
 800487e:	4652      	mov	r2, sl
 8004880:	4649      	mov	r1, r9
 8004882:	4658      	mov	r0, fp
 8004884:	f001 f8ef 	bl	8005a66 <__aeabi_memset>
 8004888:	2000      	movs	r0, #0
 800488a:	f88d 001a 	strb.w	r0, [sp, #26]
 800488e:	2008      	movs	r0, #8
 8004890:	f88d 0021 	strb.w	r0, [sp, #33]	; 0x21
 8004894:	f011 fae9 	bl	8015e6a <ZbZclGetNextSeqnum>
 8004898:	f88d 0020 	strb.w	r0, [sp, #32]
 800489c:	4668      	mov	r0, sp
 800489e:	0031      	movs	r1, r6
 80048a0:	2210      	movs	r2, #16
 80048a2:	f013 fe76 	bl	8018592 <__aeabi_memcpy>
 80048a6:	8aa8      	ldrh	r0, [r5, #20]
 80048a8:	f8ad 0010 	strh.w	r0, [sp, #16]
 80048ac:	89a8      	ldrh	r0, [r5, #12]
 80048ae:	f8ad 0012 	strh.w	r0, [sp, #18]
 80048b2:	7ba8      	ldrb	r0, [r5, #14]
 80048b4:	f8ad 0014 	strh.w	r0, [sp, #20]
 80048b8:	8ae8      	ldrh	r0, [r5, #22]
 80048ba:	f8ad 0016 	strh.w	r0, [sp, #22]
 80048be:	7e28      	ldrb	r0, [r5, #24]
 80048c0:	f88d 0018 	strb.w	r0, [sp, #24]
 80048c4:	7e68      	ldrb	r0, [r5, #25]
 80048c6:	f88d 0019 	strb.w	r0, [sp, #25]
 80048ca:	a80c      	add	r0, sp, #48	; 0x30
 80048cc:	9009      	str	r0, [sp, #36]	; 0x24
 80048ce:	940a      	str	r4, [sp, #40]	; 0x28
 80048d0:	003b      	movs	r3, r7
 80048d2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80048d4:	4669      	mov	r1, sp
 80048d6:	68a8      	ldr	r0, [r5, #8]
 80048d8:	f011 faf2 	bl	8015ec0 <ZbZclCommandReq>

080048dc <??ZbZclAttrReportReadReq_2>:
 80048dc:	b01d      	add	sp, #116	; 0x74
 80048de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080048e2 <ZbZclAttrReportConfigDefault>:
 80048e2:	e92d 47fc 	stmdb	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80048e6:	0007      	movs	r7, r0
 80048e8:	4688      	mov	r8, r1
 80048ea:	4691      	mov	r9, r2
 80048ec:	469a      	mov	sl, r3
 80048ee:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80048f0:	4641      	mov	r1, r8
 80048f2:	b289      	uxth	r1, r1
 80048f4:	0038      	movs	r0, r7
 80048f6:	f7fc fc32 	bl	800115e <ZbZclAttrFind>
 80048fa:	0005      	movs	r5, r0
 80048fc:	2d00      	cmp	r5, #0
 80048fe:	d101      	bne.n	8004904 <??ZbZclAttrReportConfigDefault_0>
 8004900:	2086      	movs	r0, #134	; 0x86
 8004902:	e02b      	b.n	800495c <??ZbZclAttrReportConfigDefault_1>

08004904 <??ZbZclAttrReportConfigDefault_0>:
 8004904:	68a8      	ldr	r0, [r5, #8]
 8004906:	7900      	ldrb	r0, [r0, #4]
 8004908:	0780      	lsls	r0, r0, #30
 800490a:	d401      	bmi.n	8004910 <??ZbZclAttrReportConfigDefault_2>
 800490c:	208c      	movs	r0, #140	; 0x8c
 800490e:	e025      	b.n	800495c <??ZbZclAttrReportConfigDefault_1>

08004910 <??ZbZclAttrReportConfigDefault_2>:
 8004910:	2200      	movs	r2, #0
 8004912:	4641      	mov	r1, r8
 8004914:	b289      	uxth	r1, r1
 8004916:	0038      	movs	r0, r7
 8004918:	f7fe ff45 	bl	80037a6 <zcl_reporting_find>
 800491c:	0006      	movs	r6, r0
 800491e:	2e00      	cmp	r6, #0
 8004920:	d101      	bne.n	8004926 <??ZbZclAttrReportConfigDefault_3>
 8004922:	208b      	movs	r0, #139	; 0x8b
 8004924:	e01a      	b.n	800495c <??ZbZclAttrReportConfigDefault_1>

08004926 <??ZbZclAttrReportConfigDefault_3>:
 8004926:	f8ad 9002 	strh.w	r9, [sp, #2]
 800492a:	f8ad a000 	strh.w	sl, [sp]
 800492e:	4669      	mov	r1, sp
 8004930:	f10d 0002 	add.w	r0, sp, #2
 8004934:	f7ff f894 	bl	8003a60 <zcl_reporting_check_default_intvl>
 8004938:	f8bd 0002 	ldrh.w	r0, [sp, #2]
 800493c:	84b0      	strh	r0, [r6, #36]	; 0x24
 800493e:	f8bd 0000 	ldrh.w	r0, [sp]
 8004942:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004944:	2c00      	cmp	r4, #0
 8004946:	d003      	beq.n	8004950 <??ZbZclAttrReportConfigDefault_4>
 8004948:	ed94 0b00 	vldr	d0, [r4]
 800494c:	ed86 0b0c 	vstr	d0, [r6, #48]	; 0x30

08004950 <??ZbZclAttrReportConfigDefault_4>:
 8004950:	2201      	movs	r2, #1
 8004952:	0031      	movs	r1, r6
 8004954:	68b8      	ldr	r0, [r7, #8]
 8004956:	f7ff f8b3 	bl	8003ac0 <zcl_reporting_reset_defaults>
 800495a:	2000      	movs	r0, #0

0800495c <??ZbZclAttrReportConfigDefault_1>:
 800495c:	e8bd 87f6 	ldmia.w	sp!, {r1, r2, r4, r5, r6, r7, r8, r9, sl, pc}

08004960 <ZbZclClusterReportCallbackAttach>:
 8004960:	65c1      	str	r1, [r0, #92]	; 0x5c
 8004962:	4770      	bx	lr

08004964 <zcl_cluster_command_dummy>:
 8004964:	0003      	movs	r3, r0
 8004966:	20ff      	movs	r0, #255	; 0xff
 8004968:	4770      	bx	lr

0800496a <ZbZclClusterAlloc>:
 800496a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800496e:	0006      	movs	r6, r0
 8004970:	000f      	movs	r7, r1
 8004972:	4698      	mov	r8, r3
 8004974:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8004976:	2f6c      	cmp	r7, #108	; 0x6c
 8004978:	d201      	bcs.n	800497e <??ZbZclClusterAlloc_0>
 800497a:	2000      	movs	r0, #0
 800497c:	e083      	b.n	8004a86 <??ZbZclClusterAlloc_1>

0800497e <??ZbZclClusterAlloc_0>:
 800497e:	f20f 2914 	addw	r9, pc, #532	; 0x214
 8004982:	2300      	movs	r3, #0
 8004984:	464a      	mov	r2, r9
 8004986:	0039      	movs	r1, r7
 8004988:	0030      	movs	r0, r6
 800498a:	f011 fc2f 	bl	80161ec <zb_heap_alloc>
 800498e:	0004      	movs	r4, r0
 8004990:	2c00      	cmp	r4, #0
 8004992:	d101      	bne.n	8004998 <??ZbZclClusterAlloc_2>
 8004994:	2000      	movs	r0, #0
 8004996:	e076      	b.n	8004a86 <??ZbZclClusterAlloc_1>

08004998 <??ZbZclClusterAlloc_2>:
 8004998:	9701      	str	r7, [sp, #4]
 800499a:	f05f 0a00 	movs.w	sl, #0
 800499e:	46a3      	mov	fp, r4
 80049a0:	4652      	mov	r2, sl
 80049a2:	9901      	ldr	r1, [sp, #4]
 80049a4:	4658      	mov	r0, fp
 80049a6:	f001 f85e 	bl	8005a66 <__aeabi_memset>
 80049aa:	6024      	str	r4, [r4, #0]
 80049ac:	6064      	str	r4, [r4, #4]
 80049ae:	60a6      	str	r6, [r4, #8]
 80049b0:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 80049b4:	81a0      	strh	r0, [r4, #12]
 80049b6:	f884 800e 	strb.w	r8, [r4, #14]
 80049ba:	2000      	movs	r0, #0
 80049bc:	8220      	strh	r0, [r4, #16]
 80049be:	f44f 7082 	mov.w	r0, #260	; 0x104
 80049c2:	82a0      	strh	r0, [r4, #20]
 80049c4:	200f      	movs	r0, #15
 80049c6:	82e0      	strh	r0, [r4, #22]
 80049c8:	2001      	movs	r0, #1
 80049ca:	7620      	strb	r0, [r4, #24]
 80049cc:	2000      	movs	r0, #0
 80049ce:	7660      	strb	r0, [r4, #25]
 80049d0:	2039      	movs	r0, #57	; 0x39
 80049d2:	8360      	strh	r0, [r4, #26]
 80049d4:	7725      	strb	r5, [r4, #28]
 80049d6:	f114 0024 	adds.w	r0, r4, #36	; 0x24
 80049da:	6260      	str	r0, [r4, #36]	; 0x24
 80049dc:	f114 0024 	adds.w	r0, r4, #36	; 0x24
 80049e0:	62a0      	str	r0, [r4, #40]	; 0x28
 80049e2:	f114 0030 	adds.w	r0, r4, #48	; 0x30
 80049e6:	6320      	str	r0, [r4, #48]	; 0x30
 80049e8:	f114 0030 	adds.w	r0, r4, #48	; 0x30
 80049ec:	6360      	str	r0, [r4, #52]	; 0x34
 80049ee:	9400      	str	r4, [sp, #0]
 80049f0:	f8df 33d4 	ldr.w	r3, [pc, #980]	; 8004dc8 <??DataTable5_1>
 80049f4:	2281      	movs	r2, #129	; 0x81
 80049f6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80049fa:	0030      	movs	r0, r6
 80049fc:	f010 ff78 	bl	80158f0 <ZbMsgFilterRegister>
 8004a00:	62e0      	str	r0, [r4, #44]	; 0x2c
 8004a02:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004a04:	2800      	cmp	r0, #0
 8004a06:	d104      	bne.n	8004a12 <??ZbZclClusterAlloc_3>
 8004a08:	0020      	movs	r0, r4
 8004a0a:	f000 f870 	bl	8004aee <ZbZclClusterFree>
 8004a0e:	2000      	movs	r0, #0
 8004a10:	e039      	b.n	8004a86 <??ZbZclClusterAlloc_1>

08004a12 <??ZbZclClusterAlloc_3>:
 8004a12:	0022      	movs	r2, r4
 8004a14:	f8df 13b4 	ldr.w	r1, [pc, #948]	; 8004dcc <??DataTable5_2>
 8004a18:	0030      	movs	r0, r6
 8004a1a:	f011 f825 	bl	8015a68 <ZbTimerAlloc>
 8004a1e:	63a0      	str	r0, [r4, #56]	; 0x38
 8004a20:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8004a22:	2800      	cmp	r0, #0
 8004a24:	d104      	bne.n	8004a30 <??ZbZclClusterAlloc_4>
 8004a26:	0020      	movs	r0, r4
 8004a28:	f000 f861 	bl	8004aee <ZbZclClusterFree>
 8004a2c:	2000      	movs	r0, #0
 8004a2e:	e02a      	b.n	8004a86 <??ZbZclClusterAlloc_1>

08004a30 <??ZbZclClusterAlloc_4>:
 8004a30:	0022      	movs	r2, r4
 8004a32:	f20f 1125 	addw	r1, pc, #293	; 0x125
 8004a36:	0030      	movs	r0, r6
 8004a38:	f011 f816 	bl	8015a68 <ZbTimerAlloc>
 8004a3c:	6520      	str	r0, [r4, #80]	; 0x50
 8004a3e:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8004a40:	2800      	cmp	r0, #0
 8004a42:	d104      	bne.n	8004a4e <??ZbZclClusterAlloc_5>
 8004a44:	0020      	movs	r0, r4
 8004a46:	f000 f852 	bl	8004aee <ZbZclClusterFree>
 8004a4a:	2000      	movs	r0, #0
 8004a4c:	e01b      	b.n	8004a86 <??ZbZclClusterAlloc_1>

08004a4e <??ZbZclClusterAlloc_5>:
 8004a4e:	21ac      	movs	r1, #172	; 0xac
 8004a50:	0020      	movs	r0, r4
 8004a52:	f7fb fc6c 	bl	800032e <ZbZclClusterSetMinSecurity>
 8004a56:	2201      	movs	r2, #1
 8004a58:	f8df 1374 	ldr.w	r1, [pc, #884]	; 8004dd0 <??DataTable5_3>
 8004a5c:	0020      	movs	r0, r4
 8004a5e:	f7fe f8d7 	bl	8002c10 <ZbZclAttrAppendList>
 8004a62:	2800      	cmp	r0, #0
 8004a64:	d007      	beq.n	8004a76 <??ZbZclClusterAlloc_6>
 8004a66:	2300      	movs	r3, #0
 8004a68:	464a      	mov	r2, r9
 8004a6a:	0021      	movs	r1, r4
 8004a6c:	0030      	movs	r0, r6
 8004a6e:	f011 fbcc 	bl	801620a <zb_heap_free>
 8004a72:	2000      	movs	r0, #0
 8004a74:	e007      	b.n	8004a86 <??ZbZclClusterAlloc_1>

08004a76 <??ZbZclClusterAlloc_6>:
 8004a76:	2201      	movs	r2, #1
 8004a78:	2300      	movs	r3, #0
 8004a7a:	f64f 71fd 	movw	r1, #65533	; 0xfffd
 8004a7e:	0020      	movs	r0, r4
 8004a80:	f7fd ffaf 	bl	80029e2 <ZbZclAttrIntegerWrite>
 8004a84:	0020      	movs	r0, r4

08004a86 <??ZbZclClusterAlloc_1>:
 8004a86:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004a8a <ZbZclClusterAttach>:
 8004a8a:	b510      	push	{r4, lr}
 8004a8c:	0004      	movs	r4, r0
 8004a8e:	7ba0      	ldrb	r0, [r4, #14]
 8004a90:	28ff      	cmp	r0, #255	; 0xff
 8004a92:	d104      	bne.n	8004a9e <??ZbZclClusterAttach_0>
 8004a94:	89a0      	ldrh	r0, [r4, #12]
 8004a96:	2800      	cmp	r0, #0
 8004a98:	d001      	beq.n	8004a9e <??ZbZclClusterAttach_0>
 8004a9a:	89a0      	ldrh	r0, [r4, #12]
 8004a9c:	280a      	cmp	r0, #10

08004a9e <??ZbZclClusterAttach_0>:
 8004a9e:	7ba0      	ldrb	r0, [r4, #14]
 8004aa0:	28ff      	cmp	r0, #255	; 0xff
 8004aa2:	d00b      	beq.n	8004abc <??ZbZclClusterAttach_1>
 8004aa4:	7f23      	ldrb	r3, [r4, #28]
 8004aa6:	8aa2      	ldrh	r2, [r4, #20]
 8004aa8:	7ba1      	ldrb	r1, [r4, #14]
 8004aaa:	0020      	movs	r0, r4
 8004aac:	f011 fb03 	bl	80160b6 <ZbZclClusterBind>
 8004ab0:	0001      	movs	r1, r0
 8004ab2:	b2c9      	uxtb	r1, r1
 8004ab4:	2900      	cmp	r1, #0
 8004ab6:	d001      	beq.n	8004abc <??ZbZclClusterAttach_1>
 8004ab8:	b2c0      	uxtb	r0, r0
 8004aba:	e005      	b.n	8004ac8 <??ZbZclClusterAttach_2>

08004abc <??ZbZclClusterAttach_1>:
 8004abc:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8004abe:	2800      	cmp	r0, #0
 8004ac0:	d101      	bne.n	8004ac6 <??ZbZclClusterAttach_3>
 8004ac2:	48c4      	ldr	r0, [pc, #784]	; (8004dd4 <??DataTable5_4>)
 8004ac4:	65a0      	str	r0, [r4, #88]	; 0x58

08004ac6 <??ZbZclClusterAttach_3>:
 8004ac6:	2000      	movs	r0, #0

08004ac8 <??ZbZclClusterAttach_2>:
 8004ac8:	bd10      	pop	{r4, pc}

08004aca <ZbZclClusterDetach>:
 8004aca:	b510      	push	{r4, lr}
 8004acc:	0004      	movs	r4, r0
 8004ace:	68a0      	ldr	r0, [r4, #8]
 8004ad0:	2800      	cmp	r0, #0
 8004ad2:	d00b      	beq.n	8004aec <??ZbZclClusterDetach_0>

08004ad4 <??ZbZclClusterDetach_1>:
 8004ad4:	0020      	movs	r0, r4
 8004ad6:	f011 fb31 	bl	801613c <ZbZclClusterUnbind>
 8004ada:	0020      	movs	r0, r4
 8004adc:	f011 fb5a 	bl	8016194 <ZbZclClusterRemoveAlarmResetHandler>
 8004ae0:	7ba0      	ldrb	r0, [r4, #14]
 8004ae2:	28ff      	cmp	r0, #255	; 0xff
 8004ae4:	d002      	beq.n	8004aec <??ZbZclClusterDetach_0>
 8004ae6:	0020      	movs	r0, r4
 8004ae8:	f011 fab0 	bl	801604c <ZbZclClusterEndpointRemove>

08004aec <??ZbZclClusterDetach_0>:
 8004aec:	bd10      	pop	{r4, pc}

08004aee <ZbZclClusterFree>:
 8004aee:	b538      	push	{r3, r4, r5, lr}
 8004af0:	0005      	movs	r5, r0
 8004af2:	68ac      	ldr	r4, [r5, #8]
 8004af4:	2c00      	cmp	r4, #0
 8004af6:	d02d      	beq.n	8004b54 <??ZbZclClusterFree_0>

08004af8 <??ZbZclClusterFree_1>:
 8004af8:	6d28      	ldr	r0, [r5, #80]	; 0x50
 8004afa:	2800      	cmp	r0, #0
 8004afc:	d004      	beq.n	8004b08 <??ZbZclClusterFree_2>
 8004afe:	6d28      	ldr	r0, [r5, #80]	; 0x50
 8004b00:	f011 f804 	bl	8015b0c <ZbTimerFree>
 8004b04:	2000      	movs	r0, #0
 8004b06:	6528      	str	r0, [r5, #80]	; 0x50

08004b08 <??ZbZclClusterFree_2>:
 8004b08:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8004b0a:	2800      	cmp	r0, #0
 8004b0c:	d004      	beq.n	8004b18 <??ZbZclClusterFree_3>
 8004b0e:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8004b10:	f010 fffc 	bl	8015b0c <ZbTimerFree>
 8004b14:	2000      	movs	r0, #0
 8004b16:	63a8      	str	r0, [r5, #56]	; 0x38

08004b18 <??ZbZclClusterFree_3>:
 8004b18:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8004b1a:	2800      	cmp	r0, #0
 8004b1c:	d005      	beq.n	8004b2a <??ZbZclClusterFree_4>
 8004b1e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8004b20:	0020      	movs	r0, r4
 8004b22:	f010 ff49 	bl	80159b8 <ZbMsgFilterRemove>
 8004b26:	2000      	movs	r0, #0
 8004b28:	62e8      	str	r0, [r5, #44]	; 0x2c

08004b2a <??ZbZclClusterFree_4>:
 8004b2a:	0028      	movs	r0, r5
 8004b2c:	f7fe fe29 	bl	8003782 <ZbZclReportCleanup>
 8004b30:	0028      	movs	r0, r5
 8004b32:	f7ff ffca 	bl	8004aca <ZbZclClusterDetach>
 8004b36:	0028      	movs	r0, r5
 8004b38:	f7fe f976 	bl	8002e28 <ZbZclAttrFreeList>
 8004b3c:	6ea8      	ldr	r0, [r5, #104]	; 0x68
 8004b3e:	2800      	cmp	r0, #0
 8004b40:	d002      	beq.n	8004b48 <??ZbZclClusterFree_5>
 8004b42:	0028      	movs	r0, r5
 8004b44:	6ea9      	ldr	r1, [r5, #104]	; 0x68
 8004b46:	4788      	blx	r1

08004b48 <??ZbZclClusterFree_5>:
 8004b48:	2300      	movs	r3, #0
 8004b4a:	a212      	add	r2, pc, #72	; (adr r2, 8004b94 <??DataTable4>)
 8004b4c:	0029      	movs	r1, r5
 8004b4e:	0020      	movs	r0, r4
 8004b50:	f011 fb5b 	bl	801620a <zb_heap_free>

08004b54 <??ZbZclClusterFree_0>:
 8004b54:	bd31      	pop	{r0, r4, r5, pc}
	...

08004b58 <zcl_cluster_persist_timer>:
 8004b58:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8004b5a:	0005      	movs	r5, r0
 8004b5c:	000e      	movs	r6, r1
 8004b5e:	0037      	movs	r7, r6
 8004b60:	a902      	add	r1, sp, #8
 8004b62:	0038      	movs	r0, r7
 8004b64:	f000 f818 	bl	8004b98 <zcl_persist_read_attrs>
 8004b68:	0004      	movs	r4, r0
 8004b6a:	2c00      	cmp	r4, #0
 8004b6c:	d010      	beq.n	8004b90 <??zcl_cluster_persist_timer_0>
 8004b6e:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 8004b72:	9001      	str	r0, [sp, #4]
 8004b74:	9400      	str	r4, [sp, #0]
 8004b76:	7bbb      	ldrb	r3, [r7, #14]
 8004b78:	b29b      	uxth	r3, r3
 8004b7a:	7f3a      	ldrb	r2, [r7, #28]
 8004b7c:	89b9      	ldrh	r1, [r7, #12]
 8004b7e:	68b8      	ldr	r0, [r7, #8]
 8004b80:	f000 f92a 	bl	8004dd8 <zcl_persist_send_cache>
 8004b84:	2300      	movs	r3, #0
 8004b86:	a203      	add	r2, pc, #12	; (adr r2, 8004b94 <??DataTable4>)
 8004b88:	0021      	movs	r1, r4
 8004b8a:	68b8      	ldr	r0, [r7, #8]
 8004b8c:	f011 fb3d 	bl	801620a <zb_heap_free>

08004b90 <??zcl_cluster_persist_timer_0>:
 8004b90:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

08004b94 <??DataTable4>:
 8004b94:	0000 0000                                   ....

08004b98 <zcl_persist_read_attrs>:
 8004b98:	e92d 4ff2 	stmdb	sp!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004b9c:	b08c      	sub	sp, #48	; 0x30
 8004b9e:	0007      	movs	r7, r0
 8004ba0:	f05f 0b00 	movs.w	fp, #0
 8004ba4:	f05f 0900 	movs.w	r9, #0
 8004ba8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004baa:	f117 0124 	adds.w	r1, r7, #36	; 0x24
 8004bae:	4288      	cmp	r0, r1
 8004bb0:	d001      	beq.n	8004bb6 <??zcl_persist_read_attrs_0>
 8004bb2:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8004bb4:	e000      	b.n	8004bb8 <??zcl_persist_read_attrs_1>

08004bb6 <??zcl_persist_read_attrs_0>:
 8004bb6:	2400      	movs	r4, #0

08004bb8 <??zcl_persist_read_attrs_1>:
 8004bb8:	2c00      	cmp	r4, #0
 8004bba:	d01e      	beq.n	8004bfa <??zcl_persist_read_attrs_2>
 8004bbc:	46a0      	mov	r8, r4
 8004bbe:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004bc2:	7900      	ldrb	r0, [r0, #4]
 8004bc4:	0740      	lsls	r0, r0, #29
 8004bc6:	d50f      	bpl.n	8004be8 <??zcl_persist_read_attrs_3>

08004bc8 <??zcl_persist_read_attrs_4>:
 8004bc8:	f8d8 0010 	ldr.w	r0, [r8, #16]
 8004bcc:	2800      	cmp	r0, #0
 8004bce:	d004      	beq.n	8004bda <??zcl_persist_read_attrs_5>
 8004bd0:	f8d8 0010 	ldr.w	r0, [r8, #16]
 8004bd4:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8004bd8:	d300      	bcc.n	8004bdc <??zcl_persist_read_attrs_6>

08004bda <??zcl_persist_read_attrs_5>:
 8004bda:	e005      	b.n	8004be8 <??zcl_persist_read_attrs_3>

08004bdc <??zcl_persist_read_attrs_6>:
 8004bdc:	f119 0904 	adds.w	r9, r9, #4
 8004be0:	f8d8 0010 	ldr.w	r0, [r8, #16]
 8004be4:	eb10 0909 	adds.w	r9, r0, r9

08004be8 <??zcl_persist_read_attrs_3>:
 8004be8:	6820      	ldr	r0, [r4, #0]
 8004bea:	f117 0124 	adds.w	r1, r7, #36	; 0x24
 8004bee:	4288      	cmp	r0, r1
 8004bf0:	d001      	beq.n	8004bf6 <??zcl_persist_read_attrs_7>
 8004bf2:	6824      	ldr	r4, [r4, #0]
 8004bf4:	e7e0      	b.n	8004bb8 <??zcl_persist_read_attrs_1>

08004bf6 <??zcl_persist_read_attrs_7>:
 8004bf6:	2400      	movs	r4, #0
 8004bf8:	e7de      	b.n	8004bb8 <??zcl_persist_read_attrs_1>

08004bfa <??zcl_persist_read_attrs_2>:
 8004bfa:	4648      	mov	r0, r9
 8004bfc:	b280      	uxth	r0, r0
 8004bfe:	2800      	cmp	r0, #0
 8004c00:	d101      	bne.n	8004c06 <??zcl_persist_read_attrs_8>
 8004c02:	2000      	movs	r0, #0
 8004c04:	e0db      	b.n	8004dbe <??zcl_persist_read_attrs_9>

08004c06 <??zcl_persist_read_attrs_8>:
 8004c06:	2300      	movs	r3, #0
 8004c08:	a26e      	add	r2, pc, #440	; (adr r2, 8004dc4 <??DataTable5>)
 8004c0a:	4649      	mov	r1, r9
 8004c0c:	b289      	uxth	r1, r1
 8004c0e:	68b8      	ldr	r0, [r7, #8]
 8004c10:	f011 faec 	bl	80161ec <zb_heap_alloc>
 8004c14:	0005      	movs	r5, r0
 8004c16:	2d00      	cmp	r5, #0
 8004c18:	d101      	bne.n	8004c1e <??zcl_persist_read_attrs_10>
 8004c1a:	2000      	movs	r0, #0
 8004c1c:	e0cf      	b.n	8004dbe <??zcl_persist_read_attrs_9>

08004c1e <??zcl_persist_read_attrs_10>:
 8004c1e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8004c20:	f117 0124 	adds.w	r1, r7, #36	; 0x24
 8004c24:	4288      	cmp	r0, r1
 8004c26:	d001      	beq.n	8004c2c <??zcl_persist_read_attrs_11>
 8004c28:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 8004c2a:	e000      	b.n	8004c2e <??zcl_persist_read_attrs_12>

08004c2c <??zcl_persist_read_attrs_11>:
 8004c2c:	2400      	movs	r4, #0

08004c2e <??zcl_persist_read_attrs_12>:
 8004c2e:	2c00      	cmp	r4, #0
 8004c30:	f000 80c1 	beq.w	8004db6 <??zcl_persist_read_attrs_13>
 8004c34:	46a0      	mov	r8, r4
 8004c36:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004c3a:	7900      	ldrb	r0, [r0, #4]
 8004c3c:	0740      	lsls	r0, r0, #29
 8004c3e:	f140 80b1 	bpl.w	8004da4 <??zcl_persist_read_attrs_14>

08004c42 <??zcl_persist_read_attrs_15>:
 8004c42:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004c46:	7900      	ldrb	r0, [r0, #4]
 8004c48:	06c0      	lsls	r0, r0, #27
 8004c4a:	d566      	bpl.n	8004d1a <??zcl_persist_read_attrs_16>
 8004c4c:	4658      	mov	r0, fp
 8004c4e:	b280      	uxth	r0, r0
 8004c50:	4428      	add	r0, r5
 8004c52:	1d00      	adds	r0, r0, #4
 8004c54:	9001      	str	r0, [sp, #4]
 8004c56:	4649      	mov	r1, r9
 8004c58:	b289      	uxth	r1, r1
 8004c5a:	4658      	mov	r0, fp
 8004c5c:	b280      	uxth	r0, r0
 8004c5e:	1a09      	subs	r1, r1, r0
 8004c60:	1f08      	subs	r0, r1, #4
 8004c62:	f8ad 0000 	strh.w	r0, [sp]
 8004c66:	2020      	movs	r0, #32
 8004c68:	9003      	str	r0, [sp, #12]
 8004c6a:	2000      	movs	r0, #0
 8004c6c:	9002      	str	r0, [sp, #8]
 8004c6e:	f10d 0a10 	add.w	sl, sp, #16
 8004c72:	9a02      	ldr	r2, [sp, #8]
 8004c74:	9903      	ldr	r1, [sp, #12]
 8004c76:	4650      	mov	r0, sl
 8004c78:	f000 fef5 	bl	8005a66 <__aeabi_memset>
 8004c7c:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004c80:	9004      	str	r0, [sp, #16]
 8004c82:	2000      	movs	r0, #0
 8004c84:	f88d 0014 	strb.w	r0, [sp, #20]
 8004c88:	9801      	ldr	r0, [sp, #4]
 8004c8a:	9006      	str	r0, [sp, #24]
 8004c8c:	f8bd 0000 	ldrh.w	r0, [sp]
 8004c90:	9007      	str	r0, [sp, #28]
 8004c92:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8004c94:	900b      	str	r0, [sp, #44]	; 0x2c
 8004c96:	aa04      	add	r2, sp, #16
 8004c98:	4641      	mov	r1, r8
 8004c9a:	0038      	movs	r0, r7
 8004c9c:	f7fe f890 	bl	8002dc0 <ZbZclAttrCallbackExec>
 8004ca0:	4682      	mov	sl, r0
 8004ca2:	4650      	mov	r0, sl
 8004ca4:	b2c0      	uxtb	r0, r0
 8004ca6:	2800      	cmp	r0, #0
 8004ca8:	d17c      	bne.n	8004da4 <??zcl_persist_read_attrs_14>

08004caa <??zcl_persist_read_attrs_17>:
 8004caa:	2300      	movs	r3, #0
 8004cac:	f8bd 2000 	ldrh.w	r2, [sp]
 8004cb0:	9901      	ldr	r1, [sp, #4]
 8004cb2:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004cb6:	7880      	ldrb	r0, [r0, #2]
 8004cb8:	f7fd f97d 	bl	8001fb6 <ZbZclAttrParseLength>
 8004cbc:	0006      	movs	r6, r0
 8004cbe:	2e01      	cmp	r6, #1
 8004cc0:	db02      	blt.n	8004cc8 <??zcl_persist_read_attrs_18>
 8004cc2:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
 8004cc6:	db00      	blt.n	8004cca <??zcl_persist_read_attrs_19>

08004cc8 <??zcl_persist_read_attrs_18>:
 8004cc8:	e06c      	b.n	8004da4 <??zcl_persist_read_attrs_14>

08004cca <??zcl_persist_read_attrs_19>:
 8004cca:	4648      	mov	r0, r9
 8004ccc:	b280      	uxth	r0, r0
 8004cce:	4659      	mov	r1, fp
 8004cd0:	b289      	uxth	r1, r1
 8004cd2:	fa11 f186 	uxtah	r1, r1, r6
 8004cd6:	1d09      	adds	r1, r1, #4
 8004cd8:	4288      	cmp	r0, r1
 8004cda:	d207      	bcs.n	8004cec <??zcl_persist_read_attrs_20>
 8004cdc:	2300      	movs	r3, #0
 8004cde:	a239      	add	r2, pc, #228	; (adr r2, 8004dc4 <??DataTable5>)
 8004ce0:	0029      	movs	r1, r5
 8004ce2:	68b8      	ldr	r0, [r7, #8]
 8004ce4:	f011 fa91 	bl	801620a <zb_heap_free>
 8004ce8:	2000      	movs	r0, #0
 8004cea:	e068      	b.n	8004dbe <??zcl_persist_read_attrs_9>

08004cec <??zcl_persist_read_attrs_20>:
 8004cec:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004cf0:	8801      	ldrh	r1, [r0, #0]
 8004cf2:	4658      	mov	r0, fp
 8004cf4:	b280      	uxth	r0, r0
 8004cf6:	4428      	add	r0, r5
 8004cf8:	f7fb fa9c 	bl	8000234 <putle16>
 8004cfc:	f11b 0b02 	adds.w	fp, fp, #2
 8004d00:	0030      	movs	r0, r6
 8004d02:	0001      	movs	r1, r0
 8004d04:	b289      	uxth	r1, r1
 8004d06:	4658      	mov	r0, fp
 8004d08:	b280      	uxth	r0, r0
 8004d0a:	4428      	add	r0, r5
 8004d0c:	f7fb fa92 	bl	8000234 <putle16>
 8004d10:	f11b 0b02 	adds.w	fp, fp, #2
 8004d14:	eb16 0b0b 	adds.w	fp, r6, fp
 8004d18:	e044      	b.n	8004da4 <??zcl_persist_read_attrs_14>

08004d1a <??zcl_persist_read_attrs_16>:
 8004d1a:	2300      	movs	r3, #0
 8004d1c:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8004d20:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8004d24:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004d28:	7880      	ldrb	r0, [r0, #2]
 8004d2a:	f7fd f944 	bl	8001fb6 <ZbZclAttrParseLength>
 8004d2e:	0006      	movs	r6, r0
 8004d30:	2e01      	cmp	r6, #1
 8004d32:	db02      	blt.n	8004d3a <??zcl_persist_read_attrs_21>
 8004d34:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
 8004d38:	db00      	blt.n	8004d3c <??zcl_persist_read_attrs_22>

08004d3a <??zcl_persist_read_attrs_21>:
 8004d3a:	e033      	b.n	8004da4 <??zcl_persist_read_attrs_14>

08004d3c <??zcl_persist_read_attrs_22>:
 8004d3c:	4648      	mov	r0, r9
 8004d3e:	b280      	uxth	r0, r0
 8004d40:	4659      	mov	r1, fp
 8004d42:	b289      	uxth	r1, r1
 8004d44:	fa11 f186 	uxtah	r1, r1, r6
 8004d48:	1d09      	adds	r1, r1, #4
 8004d4a:	4288      	cmp	r0, r1
 8004d4c:	d207      	bcs.n	8004d5e <??zcl_persist_read_attrs_23>
 8004d4e:	2300      	movs	r3, #0
 8004d50:	a21c      	add	r2, pc, #112	; (adr r2, 8004dc4 <??DataTable5>)
 8004d52:	0029      	movs	r1, r5
 8004d54:	68b8      	ldr	r0, [r7, #8]
 8004d56:	f011 fa58 	bl	801620a <zb_heap_free>
 8004d5a:	2000      	movs	r0, #0
 8004d5c:	e02f      	b.n	8004dbe <??zcl_persist_read_attrs_9>

08004d5e <??zcl_persist_read_attrs_23>:
 8004d5e:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8004d62:	8801      	ldrh	r1, [r0, #0]
 8004d64:	4658      	mov	r0, fp
 8004d66:	b280      	uxth	r0, r0
 8004d68:	4428      	add	r0, r5
 8004d6a:	f7fb fa63 	bl	8000234 <putle16>
 8004d6e:	f11b 0b02 	adds.w	fp, fp, #2
 8004d72:	0030      	movs	r0, r6
 8004d74:	0001      	movs	r1, r0
 8004d76:	b289      	uxth	r1, r1
 8004d78:	4658      	mov	r0, fp
 8004d7a:	b280      	uxth	r0, r0
 8004d7c:	4428      	add	r0, r5
 8004d7e:	f7fb fa59 	bl	8000234 <putle16>
 8004d82:	f11b 0b02 	adds.w	fp, fp, #2
 8004d86:	9601      	str	r6, [sp, #4]
 8004d88:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8004d8c:	9000      	str	r0, [sp, #0]
 8004d8e:	4658      	mov	r0, fp
 8004d90:	b280      	uxth	r0, r0
 8004d92:	eb05 0a00 	add.w	sl, r5, r0
 8004d96:	9a01      	ldr	r2, [sp, #4]
 8004d98:	9900      	ldr	r1, [sp, #0]
 8004d9a:	4650      	mov	r0, sl
 8004d9c:	f013 fbf9 	bl	8018592 <__aeabi_memcpy>
 8004da0:	eb16 0b0b 	adds.w	fp, r6, fp

08004da4 <??zcl_persist_read_attrs_14>:
 8004da4:	6820      	ldr	r0, [r4, #0]
 8004da6:	f117 0124 	adds.w	r1, r7, #36	; 0x24
 8004daa:	4288      	cmp	r0, r1
 8004dac:	d001      	beq.n	8004db2 <??zcl_persist_read_attrs_24>
 8004dae:	6824      	ldr	r4, [r4, #0]
 8004db0:	e73d      	b.n	8004c2e <??zcl_persist_read_attrs_12>

08004db2 <??zcl_persist_read_attrs_24>:
 8004db2:	2400      	movs	r4, #0
 8004db4:	e73b      	b.n	8004c2e <??zcl_persist_read_attrs_12>

08004db6 <??zcl_persist_read_attrs_13>:
 8004db6:	980c      	ldr	r0, [sp, #48]	; 0x30
 8004db8:	f8a0 b000 	strh.w	fp, [r0]
 8004dbc:	0028      	movs	r0, r5

08004dbe <??zcl_persist_read_attrs_9>:
 8004dbe:	b00d      	add	sp, #52	; 0x34
 8004dc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004dc4 <??DataTable5>:
 8004dc4:	0000 0000                                   ....

08004dc8 <??DataTable5_1>:
 8004dc8:	37f7 0800                                   .7..

08004dcc <??DataTable5_2>:
 8004dcc:	326d 0800                                   m2..

08004dd0 <??DataTable5_3>:
 8004dd0:	99a0 0801                                   ....

08004dd4 <??DataTable5_4>:
 8004dd4:	4965 0800                                   eI..

08004dd8 <zcl_persist_send_cache>:
 8004dd8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ddc:	b098      	sub	sp, #96	; 0x60
 8004dde:	0005      	movs	r5, r0
 8004de0:	001e      	movs	r6, r3
 8004de2:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8004de4:	f05f 0900 	movs.w	r9, #0
 8004de8:	0030      	movs	r0, r6
 8004dea:	b280      	uxth	r0, r0
 8004dec:	28ff      	cmp	r0, #255	; 0xff
 8004dee:	d101      	bne.n	8004df4 <??zcl_persist_send_cache_0>
 8004df0:	2085      	movs	r0, #133	; 0x85
 8004df2:	e0a1      	b.n	8004f38 <??zcl_persist_send_cache_1>

08004df4 <??zcl_persist_send_cache_0>:
 8004df4:	0020      	movs	r0, r4
 8004df6:	b280      	uxth	r0, r0
 8004df8:	f64f 71fb 	movw	r1, #65531	; 0xfffb
 8004dfc:	4288      	cmp	r0, r1
 8004dfe:	d301      	bcc.n	8004e04 <??zcl_persist_send_cache_2>
 8004e00:	2089      	movs	r0, #137	; 0x89
 8004e02:	e099      	b.n	8004f38 <??zcl_persist_send_cache_1>

08004e04 <??zcl_persist_send_cache_2>:
 8004e04:	f05f 0a08 	movs.w	sl, #8
 8004e08:	f05f 0b00 	movs.w	fp, #0
 8004e0c:	466f      	mov	r7, sp
 8004e0e:	465a      	mov	r2, fp
 8004e10:	4651      	mov	r1, sl
 8004e12:	0038      	movs	r0, r7
 8004e14:	f000 fe27 	bl	8005a66 <__aeabi_memset>
 8004e18:	2001      	movs	r0, #1
 8004e1a:	f88d 0000 	strb.w	r0, [sp]
 8004e1e:	2001      	movs	r0, #1
 8004e20:	f88d 0001 	strb.w	r0, [sp, #1]
 8004e24:	2000      	movs	r0, #0
 8004e26:	f88d 0002 	strb.w	r0, [sp, #2]
 8004e2a:	2001      	movs	r0, #1
 8004e2c:	f88d 0003 	strb.w	r0, [sp, #3]
 8004e30:	f64f 78fe 	movw	r8, #65534	; 0xfffe
 8004e34:	f8ad 8004 	strh.w	r8, [sp, #4]
 8004e38:	f011 f817 	bl	8015e6a <ZbZclGetNextSeqnum>
 8004e3c:	f88d 0006 	strb.w	r0, [sp, #6]
 8004e40:	2000      	movs	r0, #0
 8004e42:	f88d 0007 	strb.w	r0, [sp, #7]
 8004e46:	2205      	movs	r2, #5
 8004e48:	a904      	add	r1, sp, #16
 8004e4a:	4668      	mov	r0, sp
 8004e4c:	f7fc f906 	bl	800105c <ZbZclAppendHeader>
 8004e50:	0007      	movs	r7, r0
 8004e52:	2f00      	cmp	r7, #0
 8004e54:	d501      	bpl.n	8004e5a <??zcl_persist_send_cache_3>
 8004e56:	2085      	movs	r0, #133	; 0x85
 8004e58:	e06e      	b.n	8004f38 <??zcl_persist_send_cache_1>

08004e5a <??zcl_persist_send_cache_3>:
 8004e5a:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
 8004e5e:	a804      	add	r0, sp, #16
 8004e60:	f84a 0039 	str.w	r0, [sl, r9, lsl #3]
 8004e64:	a812      	add	r0, sp, #72	; 0x48
 8004e66:	eb00 00c9 	add.w	r0, r0, r9, lsl #3
 8004e6a:	6047      	str	r7, [r0, #4]
 8004e6c:	f119 0901 	adds.w	r9, r9, #1
 8004e70:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
 8004e74:	a802      	add	r0, sp, #8
 8004e76:	f7fb f9dd 	bl	8000234 <putle16>
 8004e7a:	f89d 0068 	ldrb.w	r0, [sp, #104]	; 0x68
 8004e7e:	f88d 000a 	strb.w	r0, [sp, #10]
 8004e82:	a802      	add	r0, sp, #8
 8004e84:	f84a 0039 	str.w	r0, [sl, r9, lsl #3]
 8004e88:	2003      	movs	r0, #3
 8004e8a:	a912      	add	r1, sp, #72	; 0x48
 8004e8c:	eb01 01c9 	add.w	r1, r1, r9, lsl #3
 8004e90:	6048      	str	r0, [r1, #4]
 8004e92:	f119 0901 	adds.w	r9, r9, #1
 8004e96:	9824      	ldr	r0, [sp, #144]	; 0x90
 8004e98:	f84a 0039 	str.w	r0, [sl, r9, lsl #3]
 8004e9c:	0020      	movs	r0, r4
 8004e9e:	b280      	uxth	r0, r0
 8004ea0:	a912      	add	r1, sp, #72	; 0x48
 8004ea2:	eb01 01c9 	add.w	r1, r1, r9, lsl #3
 8004ea6:	6048      	str	r0, [r1, #4]
 8004ea8:	f119 0901 	adds.w	r9, r9, #1
 8004eac:	f8cd 900c 	str.w	r9, [sp, #12]
 8004eb0:	f05f 0a30 	movs.w	sl, #48	; 0x30
 8004eb4:	f05f 0900 	movs.w	r9, #0
 8004eb8:	f10d 0b18 	add.w	fp, sp, #24
 8004ebc:	464a      	mov	r2, r9
 8004ebe:	4651      	mov	r1, sl
 8004ec0:	4658      	mov	r0, fp
 8004ec2:	f000 fdd0 	bl	8005a66 <__aeabi_memset>
 8004ec6:	2003      	movs	r0, #3
 8004ec8:	f88d 0018 	strb.w	r0, [sp, #24]
 8004ecc:	0028      	movs	r0, r5
 8004ece:	f010 fa7d 	bl	80153cc <ZbExtendedAddress>
 8004ed2:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8004ed6:	20ff      	movs	r0, #255	; 0xff
 8004ed8:	f8ad 001a 	strh.w	r0, [sp, #26]
 8004edc:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8004ee0:	f8ad 0028 	strh.w	r0, [sp, #40]	; 0x28
 8004ee4:	f8ad 802a 	strh.w	r8, [sp, #42]	; 0x2a
 8004ee8:	f8ad 602c 	strh.w	r6, [sp, #44]	; 0x2c
 8004eec:	a812      	add	r0, sp, #72	; 0x48
 8004eee:	900c      	str	r0, [sp, #48]	; 0x30
 8004ef0:	9803      	ldr	r0, [sp, #12]
 8004ef2:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
 8004ef6:	2000      	movs	r0, #0
 8004ef8:	f88d 003e 	strb.w	r0, [sp, #62]	; 0x3e
 8004efc:	2000      	movs	r0, #0
 8004efe:	f88d 003f 	strb.w	r0, [sp, #63]	; 0x3f
 8004f02:	f44f 7080 	mov.w	r0, #256	; 0x100
 8004f06:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8004f0a:	f8bd 003c 	ldrh.w	r0, [sp, #60]	; 0x3c
 8004f0e:	f050 0008 	orrs.w	r0, r0, #8
 8004f12:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8004f16:	f8bd 003c 	ldrh.w	r0, [sp, #60]	; 0x3c
 8004f1a:	f050 0004 	orrs.w	r0, r0, #4
 8004f1e:	f8ad 003c 	strh.w	r0, [sp, #60]	; 0x3c
 8004f22:	2300      	movs	r3, #0
 8004f24:	2200      	movs	r2, #0
 8004f26:	a906      	add	r1, sp, #24
 8004f28:	0028      	movs	r0, r5
 8004f2a:	f010 fb65 	bl	80155f8 <ZbApsdeDataReqCallback>
 8004f2e:	2800      	cmp	r0, #0
 8004f30:	d001      	beq.n	8004f36 <??zcl_persist_send_cache_4>
 8004f32:	2001      	movs	r0, #1
 8004f34:	e000      	b.n	8004f38 <??zcl_persist_send_cache_1>

08004f36 <??zcl_persist_send_cache_4>:
 8004f36:	2000      	movs	r0, #0

08004f38 <??zcl_persist_send_cache_1>:
 8004f38:	b01b      	add	sp, #108	; 0x6c
 8004f3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004f3e <ZbZclHandleGetSceneData>:
 8004f3e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004f42:	b0a2      	sub	sp, #136	; 0x88
 8004f44:	0004      	movs	r4, r0
 8004f46:	000d      	movs	r5, r1
 8004f48:	0016      	movs	r6, r2
 8004f4a:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8004f4c:	2800      	cmp	r0, #0
 8004f4e:	d106      	bne.n	8004f5e <??ZbZclHandleGetSceneData_0>
 8004f50:	2381      	movs	r3, #129	; 0x81
 8004f52:	002a      	movs	r2, r5
 8004f54:	0031      	movs	r1, r6
 8004f56:	0020      	movs	r0, r4
 8004f58:	f011 f80b 	bl	8015f72 <ZbZclSendDefaultResponse>
 8004f5c:	e06b      	b.n	8005036 <??ZbZclHandleGetSceneData_1>

08004f5e <??ZbZclHandleGetSceneData_0>:
 8004f5e:	2708      	movs	r7, #8
 8004f60:	f05f 0800 	movs.w	r8, #0
 8004f64:	46e9      	mov	r9, sp
 8004f66:	4642      	mov	r2, r8
 8004f68:	0039      	movs	r1, r7
 8004f6a:	4648      	mov	r0, r9
 8004f6c:	f000 fd7b 	bl	8005a66 <__aeabi_memset>
 8004f70:	2000      	movs	r0, #0
 8004f72:	f88d 0000 	strb.w	r0, [sp]
 8004f76:	2001      	movs	r0, #1
 8004f78:	f88d 0001 	strb.w	r0, [sp, #1]
 8004f7c:	78a8      	ldrb	r0, [r5, #2]
 8004f7e:	2800      	cmp	r0, #0
 8004f80:	d103      	bne.n	8004f8a <??ZbZclHandleGetSceneData_2>
 8004f82:	2001      	movs	r0, #1
 8004f84:	f88d 0002 	strb.w	r0, [sp, #2]
 8004f88:	e002      	b.n	8004f90 <??ZbZclHandleGetSceneData_3>

08004f8a <??ZbZclHandleGetSceneData_2>:
 8004f8a:	2000      	movs	r0, #0
 8004f8c:	f88d 0002 	strb.w	r0, [sp, #2]

08004f90 <??ZbZclHandleGetSceneData_3>:
 8004f90:	2001      	movs	r0, #1
 8004f92:	f88d 0003 	strb.w	r0, [sp, #3]
 8004f96:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 8004f9a:	f8ad 0004 	strh.w	r0, [sp, #4]
 8004f9e:	79a8      	ldrb	r0, [r5, #6]
 8004fa0:	f88d 0006 	strb.w	r0, [sp, #6]
 8004fa4:	20f0      	movs	r0, #240	; 0xf0
 8004fa6:	f88d 0007 	strb.w	r0, [sp, #7]
 8004faa:	8b62      	ldrh	r2, [r4, #26]
 8004fac:	a90e      	add	r1, sp, #56	; 0x38
 8004fae:	4668      	mov	r0, sp
 8004fb0:	f7fc f854 	bl	800105c <ZbZclAppendHeader>
 8004fb4:	0007      	movs	r7, r0
 8004fb6:	2f00      	cmp	r7, #0
 8004fb8:	d506      	bpl.n	8004fc8 <??ZbZclHandleGetSceneData_4>
 8004fba:	2380      	movs	r3, #128	; 0x80
 8004fbc:	002a      	movs	r2, r5
 8004fbe:	0031      	movs	r1, r6
 8004fc0:	0020      	movs	r0, r4
 8004fc2:	f010 ffd6 	bl	8015f72 <ZbZclSendDefaultResponse>
 8004fc6:	e036      	b.n	8005036 <??ZbZclHandleGetSceneData_1>

08004fc8 <??ZbZclHandleGetSceneData_4>:
 8004fc8:	46b9      	mov	r9, r7
 8004fca:	f1d9 024d 	rsbs	r2, r9, #77	; 0x4d
 8004fce:	b2d2      	uxtb	r2, r2
 8004fd0:	a80e      	add	r0, sp, #56	; 0x38
 8004fd2:	eb00 0109 	add.w	r1, r0, r9
 8004fd6:	0020      	movs	r0, r4
 8004fd8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8004fda:	4798      	blx	r3
 8004fdc:	4680      	mov	r8, r0
 8004fde:	4640      	mov	r0, r8
 8004fe0:	b2c0      	uxtb	r0, r0
 8004fe2:	2800      	cmp	r0, #0
 8004fe4:	d106      	bne.n	8004ff4 <??ZbZclHandleGetSceneData_5>
 8004fe6:	2381      	movs	r3, #129	; 0x81
 8004fe8:	002a      	movs	r2, r5
 8004fea:	0031      	movs	r1, r6
 8004fec:	0020      	movs	r0, r4
 8004fee:	f010 ffc0 	bl	8015f72 <ZbZclSendDefaultResponse>
 8004ff2:	e020      	b.n	8005036 <??ZbZclHandleGetSceneData_1>

08004ff4 <??ZbZclHandleGetSceneData_5>:
 8004ff4:	fa59 f988 	uxtab	r9, r9, r8
 8004ff8:	0032      	movs	r2, r6
 8004ffa:	a902      	add	r1, sp, #8
 8004ffc:	0020      	movs	r0, r4
 8004ffe:	f7fb facc 	bl	800059a <ZbZclClusterInitApsdeReq>
 8005002:	a802      	add	r0, sp, #8
 8005004:	f116 0110 	adds.w	r1, r6, #16
 8005008:	2210      	movs	r2, #16
 800500a:	f013 fac2 	bl	8018592 <__aeabi_memcpy>
 800500e:	2000      	movs	r0, #0
 8005010:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
 8005014:	2000      	movs	r0, #0
 8005016:	f88d 002e 	strb.w	r0, [sp, #46]	; 0x2e
 800501a:	2000      	movs	r0, #0
 800501c:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
 8005020:	a80e      	add	r0, sp, #56	; 0x38
 8005022:	9008      	str	r0, [sp, #32]
 8005024:	4648      	mov	r0, r9
 8005026:	f8ad 0024 	strh.w	r0, [sp, #36]	; 0x24
 800502a:	2300      	movs	r3, #0
 800502c:	2200      	movs	r2, #0
 800502e:	a902      	add	r1, sp, #8
 8005030:	68a0      	ldr	r0, [r4, #8]
 8005032:	f010 fae1 	bl	80155f8 <ZbApsdeDataReqCallback>

08005036 <??ZbZclHandleGetSceneData_1>:
 8005036:	b023      	add	sp, #140	; 0x8c
 8005038:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800503c <ZbZclHandleSetSceneData>:
 800503c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005040:	b0a4      	sub	sp, #144	; 0x90
 8005042:	0004      	movs	r4, r0
 8005044:	000d      	movs	r5, r1
 8005046:	0016      	movs	r6, r2
 8005048:	6e60      	ldr	r0, [r4, #100]	; 0x64
 800504a:	2800      	cmp	r0, #0
 800504c:	d106      	bne.n	800505c <??ZbZclHandleSetSceneData_0>
 800504e:	2381      	movs	r3, #129	; 0x81
 8005050:	002a      	movs	r2, r5
 8005052:	0031      	movs	r1, r6
 8005054:	0020      	movs	r0, r4
 8005056:	f010 ff8c 	bl	8015f72 <ZbZclSendDefaultResponse>
 800505a:	e086      	b.n	800516a <??ZbZclHandleSetSceneData_1>

0800505c <??ZbZclHandleSetSceneData_0>:
 800505c:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 800505e:	2805      	cmp	r0, #5
 8005060:	da06      	bge.n	8005070 <??ZbZclHandleSetSceneData_2>
 8005062:	2380      	movs	r3, #128	; 0x80
 8005064:	002a      	movs	r2, r5
 8005066:	0031      	movs	r1, r6
 8005068:	0020      	movs	r0, r4
 800506a:	f010 ff82 	bl	8015f72 <ZbZclSendDefaultResponse>
 800506e:	e07c      	b.n	800516a <??ZbZclHandleSetSceneData_1>

08005070 <??ZbZclHandleSetSceneData_2>:
 8005070:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8005072:	f7fb f8a4 	bl	80001be <pletoh32>
 8005076:	0007      	movs	r7, r0
 8005078:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800507a:	7900      	ldrb	r0, [r0, #4]
 800507c:	f88d 0000 	strb.w	r0, [sp]
 8005080:	f89d 0000 	ldrb.w	r0, [sp]
 8005084:	1d40      	adds	r0, r0, #5
 8005086:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8005088:	4288      	cmp	r0, r1
 800508a:	d206      	bcs.n	800509a <??ZbZclHandleSetSceneData_3>
 800508c:	2380      	movs	r3, #128	; 0x80
 800508e:	002a      	movs	r2, r5
 8005090:	0031      	movs	r1, r6
 8005092:	0020      	movs	r0, r4
 8005094:	f010 ff6d 	bl	8015f72 <ZbZclSendDefaultResponse>
 8005098:	e067      	b.n	800516a <??ZbZclHandleSetSceneData_1>

0800509a <??ZbZclHandleSetSceneData_3>:
 800509a:	003b      	movs	r3, r7
 800509c:	b29b      	uxth	r3, r3
 800509e:	f89d 2000 	ldrb.w	r2, [sp]
 80050a2:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80050a4:	1d41      	adds	r1, r0, #5
 80050a6:	0020      	movs	r0, r4
 80050a8:	f8d4 c064 	ldr.w	ip, [r4, #100]	; 0x64
 80050ac:	47e0      	blx	ip
 80050ae:	4680      	mov	r8, r0
 80050b0:	f05f 0908 	movs.w	r9, #8
 80050b4:	f05f 0a00 	movs.w	sl, #0
 80050b8:	f10d 0b04 	add.w	fp, sp, #4
 80050bc:	4652      	mov	r2, sl
 80050be:	4649      	mov	r1, r9
 80050c0:	4658      	mov	r0, fp
 80050c2:	f000 fcd0 	bl	8005a66 <__aeabi_memset>
 80050c6:	2000      	movs	r0, #0
 80050c8:	f88d 0004 	strb.w	r0, [sp, #4]
 80050cc:	2001      	movs	r0, #1
 80050ce:	f88d 0005 	strb.w	r0, [sp, #5]
 80050d2:	78a8      	ldrb	r0, [r5, #2]
 80050d4:	2800      	cmp	r0, #0
 80050d6:	d103      	bne.n	80050e0 <??ZbZclHandleSetSceneData_4>
 80050d8:	2001      	movs	r0, #1
 80050da:	f88d 0006 	strb.w	r0, [sp, #6]
 80050de:	e002      	b.n	80050e6 <??ZbZclHandleSetSceneData_5>

080050e0 <??ZbZclHandleSetSceneData_4>:
 80050e0:	2000      	movs	r0, #0
 80050e2:	f88d 0006 	strb.w	r0, [sp, #6]

080050e6 <??ZbZclHandleSetSceneData_5>:
 80050e6:	2001      	movs	r0, #1
 80050e8:	f88d 0007 	strb.w	r0, [sp, #7]
 80050ec:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 80050f0:	f8ad 0008 	strh.w	r0, [sp, #8]
 80050f4:	79a8      	ldrb	r0, [r5, #6]
 80050f6:	f88d 000a 	strb.w	r0, [sp, #10]
 80050fa:	20f1      	movs	r0, #241	; 0xf1
 80050fc:	f88d 000b 	strb.w	r0, [sp, #11]
 8005100:	8b62      	ldrh	r2, [r4, #26]
 8005102:	a910      	add	r1, sp, #64	; 0x40
 8005104:	a801      	add	r0, sp, #4
 8005106:	f7fb ffa9 	bl	800105c <ZbZclAppendHeader>
 800510a:	4681      	mov	r9, r0
 800510c:	f1b9 0f00 	cmp.w	r9, #0
 8005110:	d506      	bpl.n	8005120 <??ZbZclHandleSetSceneData_6>
 8005112:	2380      	movs	r3, #128	; 0x80
 8005114:	002a      	movs	r2, r5
 8005116:	0031      	movs	r1, r6
 8005118:	0020      	movs	r0, r4
 800511a:	f010 ff2a 	bl	8015f72 <ZbZclSendDefaultResponse>
 800511e:	e024      	b.n	800516a <??ZbZclHandleSetSceneData_1>

08005120 <??ZbZclHandleSetSceneData_6>:
 8005120:	46ca      	mov	sl, r9
 8005122:	a810      	add	r0, sp, #64	; 0x40
 8005124:	f800 800a 	strb.w	r8, [r0, sl]
 8005128:	f11a 0a01 	adds.w	sl, sl, #1
 800512c:	0032      	movs	r2, r6
 800512e:	a904      	add	r1, sp, #16
 8005130:	0020      	movs	r0, r4
 8005132:	f7fb fa32 	bl	800059a <ZbZclClusterInitApsdeReq>
 8005136:	a804      	add	r0, sp, #16
 8005138:	f116 0110 	adds.w	r1, r6, #16
 800513c:	2210      	movs	r2, #16
 800513e:	f013 fa28 	bl	8018592 <__aeabi_memcpy>
 8005142:	2000      	movs	r0, #0
 8005144:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
 8005148:	2000      	movs	r0, #0
 800514a:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
 800514e:	2000      	movs	r0, #0
 8005150:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
 8005154:	a810      	add	r0, sp, #64	; 0x40
 8005156:	900a      	str	r0, [sp, #40]	; 0x28
 8005158:	4650      	mov	r0, sl
 800515a:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
 800515e:	2300      	movs	r3, #0
 8005160:	2200      	movs	r2, #0
 8005162:	a904      	add	r1, sp, #16
 8005164:	68a0      	ldr	r0, [r4, #8]
 8005166:	f010 fa47 	bl	80155f8 <ZbApsdeDataReqCallback>

0800516a <??ZbZclHandleSetSceneData_1>:
 800516a:	b025      	add	sp, #148	; 0x94
 800516c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08005170 <ZbZclAppendFloat>:
 8005170:	e92d 4ff5 	stmdb	sp!, {r0, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005174:	b081      	sub	sp, #4
 8005176:	ed2d 8b04 	vpush	{d8-d9}
 800517a:	b084      	sub	sp, #16
 800517c:	eeb0 8a40 	vmov.f32	s16, s0
 8005180:	eef0 8a60 	vmov.f32	s17, s1
 8005184:	000e      	movs	r6, r1
 8005186:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
 800518a:	2838      	cmp	r0, #56	; 0x38
 800518c:	d149      	bne.n	8005222 <??ZbZclAppendFloat_0>
 800518e:	2400      	movs	r4, #0
 8005190:	2510      	movs	r5, #16
 8005192:	f07f 070e 	mvns.w	r7, #14
 8005196:	980a      	ldr	r0, [sp, #40]	; 0x28
 8005198:	2802      	cmp	r0, #2
 800519a:	d202      	bcs.n	80051a2 <??ZbZclAppendFloat_1>
 800519c:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80051a0:	e120      	b.n	80053e4 <??ZbZclAppendFloat_2>

080051a2 <??ZbZclAppendFloat_1>:
 80051a2:	003a      	movs	r2, r7
 80051a4:	0029      	movs	r1, r5
 80051a6:	4668      	mov	r0, sp
 80051a8:	eeb0 0a48 	vmov.f32	s0, s16
 80051ac:	eef0 0a68 	vmov.f32	s1, s17
 80051b0:	f000 fb08 	bl	80057c4 <ZbZclFloatFrexp>
 80051b4:	eeb0 9a40 	vmov.f32	s18, s0
 80051b8:	eef0 9a60 	vmov.f32	s19, s1
 80051bc:	f8dd 8000 	ldr.w	r8, [sp]
 80051c0:	ebb8 0807 	subs.w	r8, r8, r7
 80051c4:	ea5f 2888 	movs.w	r8, r8, lsl #10
 80051c8:	f418 48f8 	ands.w	r8, r8, #31744	; 0x7c00
 80051cc:	ec51 0b19 	vmov	r0, r1, d9
 80051d0:	2200      	movs	r2, #0
 80051d2:	2300      	movs	r3, #0
 80051d4:	f001 f90c 	bl	80063f0 <__aeabi_cdcmpeq>
 80051d8:	d210      	bcs.n	80051fc <??ZbZclAppendFloat_3>
 80051da:	ec51 0b19 	vmov	r0, r1, d9
 80051de:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 80051e2:	f001 f93f 	bl	8006464 <__aeabi_d2iz>
 80051e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80051ea:	fb10 f101 	smulbb	r1, r0, r1
 80051ee:	0589      	lsls	r1, r1, #22
 80051f0:	0d89      	lsrs	r1, r1, #22
 80051f2:	ea58 0101 	orrs.w	r1, r8, r1
 80051f6:	f451 4100 	orrs.w	r1, r1, #32768	; 0x8000
 80051fa:	e00b      	b.n	8005214 <??ZbZclAppendFloat_4>

080051fc <??ZbZclAppendFloat_3>:
 80051fc:	ec51 0b19 	vmov	r0, r1, d9
 8005200:	f001 f930 	bl	8006464 <__aeabi_d2iz>
 8005204:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8005208:	fb10 f101 	smulbb	r1, r0, r1
 800520c:	0589      	lsls	r1, r1, #22
 800520e:	0d89      	lsrs	r1, r1, #22
 8005210:	ea58 0101 	orrs.w	r1, r8, r1

08005214 <??ZbZclAppendFloat_4>:
 8005214:	7031      	strb	r1, [r6, #0]
 8005216:	0008      	movs	r0, r1
 8005218:	b280      	uxth	r0, r0
 800521a:	0a00      	lsrs	r0, r0, #8
 800521c:	7070      	strb	r0, [r6, #1]
 800521e:	2002      	movs	r0, #2
 8005220:	e0e0      	b.n	80053e4 <??ZbZclAppendFloat_2>

08005222 <??ZbZclAppendFloat_0>:
 8005222:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
 8005226:	2839      	cmp	r0, #57	; 0x39
 8005228:	d14e      	bne.n	80052c8 <??ZbZclAppendFloat_5>
 800522a:	2400      	movs	r4, #0
 800522c:	2580      	movs	r5, #128	; 0x80
 800522e:	f07f 077e 	mvns.w	r7, #126	; 0x7e
 8005232:	980a      	ldr	r0, [sp, #40]	; 0x28
 8005234:	2804      	cmp	r0, #4
 8005236:	d202      	bcs.n	800523e <??ZbZclAppendFloat_6>
 8005238:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 800523c:	e0d2      	b.n	80053e4 <??ZbZclAppendFloat_2>

0800523e <??ZbZclAppendFloat_6>:
 800523e:	003a      	movs	r2, r7
 8005240:	0029      	movs	r1, r5
 8005242:	4668      	mov	r0, sp
 8005244:	eeb0 0a48 	vmov.f32	s0, s16
 8005248:	eef0 0a68 	vmov.f32	s1, s17
 800524c:	f000 faba 	bl	80057c4 <ZbZclFloatFrexp>
 8005250:	eeb0 9a40 	vmov.f32	s18, s0
 8005254:	eef0 9a60 	vmov.f32	s19, s1
 8005258:	f8dd 8000 	ldr.w	r8, [sp]
 800525c:	ebb8 0807 	subs.w	r8, r8, r7
 8005260:	ea5f 58c8 	movs.w	r8, r8, lsl #23
 8005264:	f018 48ff 	ands.w	r8, r8, #2139095040	; 0x7f800000
 8005268:	ec51 0b19 	vmov	r0, r1, d9
 800526c:	2200      	movs	r2, #0
 800526e:	2300      	movs	r3, #0
 8005270:	f001 f8be 	bl	80063f0 <__aeabi_cdcmpeq>
 8005274:	d210      	bcs.n	8005298 <??ZbZclAppendFloat_7>
 8005276:	ec51 0b19 	vmov	r0, r1, d9
 800527a:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 800527e:	f001 f919 	bl	80064b4 <__aeabi_d2uiz>
 8005282:	0001      	movs	r1, r0
 8005284:	f45f 0000 	movs.w	r0, #8388608	; 0x800000
 8005288:	4341      	muls	r1, r0
 800528a:	0249      	lsls	r1, r1, #9
 800528c:	0a49      	lsrs	r1, r1, #9
 800528e:	ea58 0101 	orrs.w	r1, r8, r1
 8005292:	f051 4100 	orrs.w	r1, r1, #2147483648	; 0x80000000
 8005296:	e00b      	b.n	80052b0 <??ZbZclAppendFloat_8>

08005298 <??ZbZclAppendFloat_7>:
 8005298:	ec51 0b19 	vmov	r0, r1, d9
 800529c:	f001 f90a 	bl	80064b4 <__aeabi_d2uiz>
 80052a0:	0001      	movs	r1, r0
 80052a2:	f45f 0000 	movs.w	r0, #8388608	; 0x800000
 80052a6:	4341      	muls	r1, r0
 80052a8:	0249      	lsls	r1, r1, #9
 80052aa:	0a49      	lsrs	r1, r1, #9
 80052ac:	ea58 0101 	orrs.w	r1, r8, r1

080052b0 <??ZbZclAppendFloat_8>:
 80052b0:	7031      	strb	r1, [r6, #0]
 80052b2:	0008      	movs	r0, r1
 80052b4:	0a00      	lsrs	r0, r0, #8
 80052b6:	7070      	strb	r0, [r6, #1]
 80052b8:	0008      	movs	r0, r1
 80052ba:	0c00      	lsrs	r0, r0, #16
 80052bc:	70b0      	strb	r0, [r6, #2]
 80052be:	0008      	movs	r0, r1
 80052c0:	0e00      	lsrs	r0, r0, #24
 80052c2:	70f0      	strb	r0, [r6, #3]
 80052c4:	2004      	movs	r0, #4
 80052c6:	e08d      	b.n	80053e4 <??ZbZclAppendFloat_2>

080052c8 <??ZbZclAppendFloat_5>:
 80052c8:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
 80052cc:	283a      	cmp	r0, #58	; 0x3a
 80052ce:	f040 8087 	bne.w	80053e0 <??ZbZclAppendFloat_9>
 80052d2:	2400      	movs	r4, #0
 80052d4:	2500      	movs	r5, #0
 80052d6:	f44f 6780 	mov.w	r7, #1024	; 0x400
 80052da:	f8df 8744 	ldr.w	r8, [pc, #1860]	; 8005a20 <??DataTable3>
 80052de:	980a      	ldr	r0, [sp, #40]	; 0x28
 80052e0:	2808      	cmp	r0, #8
 80052e2:	d202      	bcs.n	80052ea <??ZbZclAppendFloat_10>
 80052e4:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 80052e8:	e07c      	b.n	80053e4 <??ZbZclAppendFloat_2>

080052ea <??ZbZclAppendFloat_10>:
 80052ea:	4642      	mov	r2, r8
 80052ec:	0039      	movs	r1, r7
 80052ee:	4668      	mov	r0, sp
 80052f0:	eeb0 0a48 	vmov.f32	s0, s16
 80052f4:	eef0 0a68 	vmov.f32	s1, s17
 80052f8:	f000 fa64 	bl	80057c4 <ZbZclFloatFrexp>
 80052fc:	eeb0 9a40 	vmov.f32	s18, s0
 8005300:	eef0 9a60 	vmov.f32	s19, s1
 8005304:	9800      	ldr	r0, [sp, #0]
 8005306:	17c1      	asrs	r1, r0, #31
 8005308:	ea5f 79e8 	movs.w	r9, r8, asr #31
 800530c:	ebb0 0008 	subs.w	r0, r0, r8
 8005310:	eb71 0109 	sbcs.w	r1, r1, r9
 8005314:	0501      	lsls	r1, r0, #20
 8005316:	2000      	movs	r0, #0
 8005318:	2200      	movs	r2, #0
 800531a:	f8df 3708 	ldr.w	r3, [pc, #1800]	; 8005a24 <??DataTable3_1>
 800531e:	4010      	ands	r0, r2
 8005320:	4019      	ands	r1, r3
 8005322:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005326:	ec51 0b19 	vmov	r0, r1, d9
 800532a:	2200      	movs	r2, #0
 800532c:	2300      	movs	r3, #0
 800532e:	f001 f85f 	bl	80063f0 <__aeabi_cdcmpeq>
 8005332:	d21f      	bcs.n	8005374 <??ZbZclAppendFloat_11>
 8005334:	ec51 0b19 	vmov	r0, r1, d9
 8005338:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 800533c:	f001 f8f2 	bl	8006524 <__aeabi_d2ulz>
 8005340:	2200      	movs	r2, #0
 8005342:	f45f 1380 	movs.w	r3, #1048576	; 0x100000
 8005346:	fba2 ab00 	umull	sl, fp, r2, r0
 800534a:	fb02 bb01 	mla	fp, r2, r1, fp
 800534e:	fb03 bb00 	mla	fp, r3, r0, fp
 8005352:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8005356:	f8df 16d0 	ldr.w	r1, [pc, #1744]	; 8005a28 <??DataTable3_2>
 800535a:	ea1a 0000 	ands.w	r0, sl, r0
 800535e:	ea1b 0101 	ands.w	r1, fp, r1
 8005362:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005366:	4310      	orrs	r0, r2
 8005368:	4319      	orrs	r1, r3
 800536a:	f050 0200 	orrs.w	r2, r0, #0
 800536e:	f051 4300 	orrs.w	r3, r1, #2147483648	; 0x80000000
 8005372:	e018      	b.n	80053a6 <??ZbZclAppendFloat_12>

08005374 <??ZbZclAppendFloat_11>:
 8005374:	ec51 0b19 	vmov	r0, r1, d9
 8005378:	f001 f8d4 	bl	8006524 <__aeabi_d2ulz>
 800537c:	2200      	movs	r2, #0
 800537e:	f45f 1380 	movs.w	r3, #1048576	; 0x100000
 8005382:	fba2 ab00 	umull	sl, fp, r2, r0
 8005386:	fb02 bb01 	mla	fp, r2, r1, fp
 800538a:	fb03 bb00 	mla	fp, r3, r0, fp
 800538e:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8005392:	f8df 1694 	ldr.w	r1, [pc, #1684]	; 8005a28 <??DataTable3_2>
 8005396:	ea1a 0000 	ands.w	r0, sl, r0
 800539a:	ea1b 0101 	ands.w	r1, fp, r1
 800539e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80053a2:	4302      	orrs	r2, r0
 80053a4:	430b      	orrs	r3, r1

080053a6 <??ZbZclAppendFloat_12>:
 80053a6:	7032      	strb	r2, [r6, #0]
 80053a8:	0010      	movs	r0, r2
 80053aa:	b280      	uxth	r0, r0
 80053ac:	0a00      	lsrs	r0, r0, #8
 80053ae:	7070      	strb	r0, [r6, #1]
 80053b0:	0010      	movs	r0, r2
 80053b2:	0c00      	lsrs	r0, r0, #16
 80053b4:	70b0      	strb	r0, [r6, #2]
 80053b6:	0010      	movs	r0, r2
 80053b8:	0e00      	lsrs	r0, r0, #24
 80053ba:	70f0      	strb	r0, [r6, #3]
 80053bc:	7133      	strb	r3, [r6, #4]
 80053be:	0010      	movs	r0, r2
 80053c0:	0019      	movs	r1, r3
 80053c2:	0a08      	lsrs	r0, r1, #8
 80053c4:	2100      	movs	r1, #0
 80053c6:	7170      	strb	r0, [r6, #5]
 80053c8:	0010      	movs	r0, r2
 80053ca:	0019      	movs	r1, r3
 80053cc:	0c08      	lsrs	r0, r1, #16
 80053ce:	2100      	movs	r1, #0
 80053d0:	71b0      	strb	r0, [r6, #6]
 80053d2:	0010      	movs	r0, r2
 80053d4:	0019      	movs	r1, r3
 80053d6:	0e08      	lsrs	r0, r1, #24
 80053d8:	2100      	movs	r1, #0
 80053da:	71f0      	strb	r0, [r6, #7]
 80053dc:	2008      	movs	r0, #8
 80053de:	e001      	b.n	80053e4 <??ZbZclAppendFloat_2>

080053e0 <??ZbZclAppendFloat_9>:
 80053e0:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff

080053e4 <??ZbZclAppendFloat_2>:
 80053e4:	b004      	add	sp, #16
 80053e6:	ecbd 8b04 	vpop	{d8-d9}
 80053ea:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080053ee <ZbZclParseFloat>:
 80053ee:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80053f2:	ed2d 8b02 	vpush	{d8}
 80053f6:	000e      	movs	r6, r1
 80053f8:	4691      	mov	r9, r2
 80053fa:	2000      	movs	r0, #0
 80053fc:	f889 0000 	strb.w	r0, [r9]
 8005400:	f89d 0008 	ldrb.w	r0, [sp, #8]
 8005404:	2838      	cmp	r0, #56	; 0x38
 8005406:	d006      	beq.n	8005416 <??ZbZclParseFloat_0>
 8005408:	f0c0 8138 	bcc.w	800567c <??ZbZclParseFloat_1>
 800540c:	283a      	cmp	r0, #58	; 0x3a
 800540e:	f000 80ad 	beq.w	800556c <??ZbZclParseFloat_2>
 8005412:	d354      	bcc.n	80054be <??ZbZclParseFloat_3>
 8005414:	e132      	b.n	800567c <??ZbZclParseFloat_1>

08005416 <??ZbZclParseFloat_0>:
 8005416:	0030      	movs	r0, r6
 8005418:	f7fa fec0 	bl	800019c <pletoh16>
 800541c:	0004      	movs	r4, r0
 800541e:	0020      	movs	r0, r4
 8005420:	b280      	uxth	r0, r0
 8005422:	f410 40f8 	ands.w	r0, r0, #31744	; 0x7c00
 8005426:	f5b0 4ff8 	cmp.w	r0, #31744	; 0x7c00
 800542a:	d121      	bne.n	8005470 <??ZbZclParseFloat_4>
 800542c:	05a0      	lsls	r0, r4, #22
 800542e:	d008      	beq.n	8005442 <??ZbZclParseFloat_5>
 8005430:	2000      	movs	r0, #0
 8005432:	2100      	movs	r1, #0
 8005434:	2200      	movs	r2, #0
 8005436:	2300      	movs	r3, #0
 8005438:	f000 fea4 	bl	8006184 <__aeabi_ddiv>
 800543c:	ec41 0b10 	vmov	d0, r0, r1
 8005440:	e127      	b.n	8005692 <??ZbZclParseFloat_6>

08005442 <??ZbZclParseFloat_5>:
 8005442:	0420      	lsls	r0, r4, #16
 8005444:	d50a      	bpl.n	800545c <??ZbZclParseFloat_7>
 8005446:	2000      	movs	r0, #0
 8005448:	f8df 15e0 	ldr.w	r1, [pc, #1504]	; 8005a2c <??DataTable3_3>
 800544c:	2200      	movs	r2, #0
 800544e:	f05f 4300 	movs.w	r3, #2147483648	; 0x80000000
 8005452:	f000 fe97 	bl	8006184 <__aeabi_ddiv>
 8005456:	ec41 0b10 	vmov	d0, r0, r1
 800545a:	e008      	b.n	800546e <??ZbZclParseFloat_8>

0800545c <??ZbZclParseFloat_7>:
 800545c:	2000      	movs	r0, #0
 800545e:	f8df 15cc 	ldr.w	r1, [pc, #1484]	; 8005a2c <??DataTable3_3>
 8005462:	2200      	movs	r2, #0
 8005464:	2300      	movs	r3, #0
 8005466:	f000 fe8d 	bl	8006184 <__aeabi_ddiv>
 800546a:	ec41 0b10 	vmov	d0, r0, r1

0800546e <??ZbZclParseFloat_8>:
 800546e:	e110      	b.n	8005692 <??ZbZclParseFloat_6>

08005470 <??ZbZclParseFloat_4>:
 8005470:	f3c4 2884 	ubfx	r8, r4, #10, #5
 8005474:	4645      	mov	r5, r8
 8005476:	b2ad      	uxth	r5, r5
 8005478:	3d0f      	subs	r5, #15
 800547a:	3d0a      	subs	r5, #10
 800547c:	f414 4ff8 	tst.w	r4, #31744	; 0x7c00
 8005480:	d004      	beq.n	800548c <??ZbZclParseFloat_9>
 8005482:	05a7      	lsls	r7, r4, #22
 8005484:	0dbf      	lsrs	r7, r7, #22
 8005486:	f517 6780 	adds.w	r7, r7, #1024	; 0x400
 800548a:	e002      	b.n	8005492 <??ZbZclParseFloat_10>

0800548c <??ZbZclParseFloat_9>:
 800548c:	1c6d      	adds	r5, r5, #1
 800548e:	05a7      	lsls	r7, r4, #22
 8005490:	0dbf      	lsrs	r7, r7, #22

08005492 <??ZbZclParseFloat_10>:
 8005492:	0038      	movs	r0, r7
 8005494:	b280      	uxth	r0, r0
 8005496:	f000 fcd1 	bl	8005e3c <__aeabi_ui2d>
 800549a:	ec41 0b18 	vmov	d8, r0, r1
 800549e:	0420      	lsls	r0, r4, #16
 80054a0:	d505      	bpl.n	80054ae <??ZbZclParseFloat_11>
 80054a2:	ec51 0b18 	vmov	r0, r1, d8
 80054a6:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 80054aa:	ec41 0b18 	vmov	d8, r0, r1

080054ae <??ZbZclParseFloat_11>:
 80054ae:	0028      	movs	r0, r5
 80054b0:	eeb0 0a48 	vmov.f32	s0, s16
 80054b4:	eef0 0a68 	vmov.f32	s1, s17
 80054b8:	f000 f8ef 	bl	800569a <ZbZclFloatLdexp>
 80054bc:	e0e9      	b.n	8005692 <??ZbZclParseFloat_6>

080054be <??ZbZclParseFloat_3>:
 80054be:	0030      	movs	r0, r6
 80054c0:	f7fa fe7d 	bl	80001be <pletoh32>
 80054c4:	0004      	movs	r4, r0
 80054c6:	f014 40ff 	ands.w	r0, r4, #2139095040	; 0x7f800000
 80054ca:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 80054ce:	d121      	bne.n	8005514 <??ZbZclParseFloat_12>
 80054d0:	0260      	lsls	r0, r4, #9
 80054d2:	d008      	beq.n	80054e6 <??ZbZclParseFloat_13>
 80054d4:	2000      	movs	r0, #0
 80054d6:	2100      	movs	r1, #0
 80054d8:	2200      	movs	r2, #0
 80054da:	2300      	movs	r3, #0
 80054dc:	f000 fe52 	bl	8006184 <__aeabi_ddiv>
 80054e0:	ec41 0b10 	vmov	d0, r0, r1
 80054e4:	e0d5      	b.n	8005692 <??ZbZclParseFloat_6>

080054e6 <??ZbZclParseFloat_13>:
 80054e6:	2c00      	cmp	r4, #0
 80054e8:	d50a      	bpl.n	8005500 <??ZbZclParseFloat_14>
 80054ea:	2000      	movs	r0, #0
 80054ec:	f8df 153c 	ldr.w	r1, [pc, #1340]	; 8005a2c <??DataTable3_3>
 80054f0:	2200      	movs	r2, #0
 80054f2:	f05f 4300 	movs.w	r3, #2147483648	; 0x80000000
 80054f6:	f000 fe45 	bl	8006184 <__aeabi_ddiv>
 80054fa:	ec41 0b10 	vmov	d0, r0, r1
 80054fe:	e008      	b.n	8005512 <??ZbZclParseFloat_15>

08005500 <??ZbZclParseFloat_14>:
 8005500:	2000      	movs	r0, #0
 8005502:	f8df 1528 	ldr.w	r1, [pc, #1320]	; 8005a2c <??DataTable3_3>
 8005506:	2200      	movs	r2, #0
 8005508:	2300      	movs	r3, #0
 800550a:	f000 fe3b 	bl	8006184 <__aeabi_ddiv>
 800550e:	ec41 0b10 	vmov	d0, r0, r1

08005512 <??ZbZclParseFloat_15>:
 8005512:	e0be      	b.n	8005692 <??ZbZclParseFloat_6>

08005514 <??ZbZclParseFloat_12>:
 8005514:	0025      	movs	r5, r4
 8005516:	0ded      	lsrs	r5, r5, #23
 8005518:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 800551c:	002f      	movs	r7, r5
 800551e:	b2bf      	uxth	r7, r7
 8005520:	3f7f      	subs	r7, #127	; 0x7f
 8005522:	3f17      	subs	r7, #23
 8005524:	f014 4fff 	tst.w	r4, #2139095040	; 0x7f800000
 8005528:	d006      	beq.n	8005538 <??ZbZclParseFloat_16>
 800552a:	ea5f 2844 	movs.w	r8, r4, lsl #9
 800552e:	ea5f 2858 	movs.w	r8, r8, lsr #9
 8005532:	f518 0800 	adds.w	r8, r8, #8388608	; 0x800000
 8005536:	e004      	b.n	8005542 <??ZbZclParseFloat_17>

08005538 <??ZbZclParseFloat_16>:
 8005538:	1c7f      	adds	r7, r7, #1
 800553a:	ea5f 2844 	movs.w	r8, r4, lsl #9
 800553e:	ea5f 2858 	movs.w	r8, r8, lsr #9

08005542 <??ZbZclParseFloat_17>:
 8005542:	4640      	mov	r0, r8
 8005544:	f000 fc7a 	bl	8005e3c <__aeabi_ui2d>
 8005548:	ec41 0b18 	vmov	d8, r0, r1
 800554c:	2c00      	cmp	r4, #0
 800554e:	d505      	bpl.n	800555c <??ZbZclParseFloat_18>
 8005550:	ec51 0b18 	vmov	r0, r1, d8
 8005554:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 8005558:	ec41 0b18 	vmov	d8, r0, r1

0800555c <??ZbZclParseFloat_18>:
 800555c:	0038      	movs	r0, r7
 800555e:	eeb0 0a48 	vmov.f32	s0, s16
 8005562:	eef0 0a68 	vmov.f32	s1, s17
 8005566:	f000 f898 	bl	800569a <ZbZclFloatLdexp>
 800556a:	e092      	b.n	8005692 <??ZbZclParseFloat_6>

0800556c <??ZbZclParseFloat_2>:
 800556c:	0030      	movs	r0, r6
 800556e:	f7fa fe53 	bl	8000218 <pletoh64>
 8005572:	0004      	movs	r4, r0
 8005574:	000d      	movs	r5, r1
 8005576:	2000      	movs	r0, #0
 8005578:	f8df 14a8 	ldr.w	r1, [pc, #1192]	; 8005a24 <??DataTable3_1>
 800557c:	ea14 0200 	ands.w	r2, r4, r0
 8005580:	ea15 0301 	ands.w	r3, r5, r1
 8005584:	f05f 0a00 	movs.w	sl, #0
 8005588:	f8df b498 	ldr.w	fp, [pc, #1176]	; 8005a24 <??DataTable3_1>
 800558c:	455b      	cmp	r3, fp
 800558e:	d131      	bne.n	80055f4 <??ZbZclParseFloat_19>
 8005590:	4552      	cmp	r2, sl
 8005592:	d12f      	bne.n	80055f4 <??ZbZclParseFloat_19>
 8005594:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8005598:	f8df 148c 	ldr.w	r1, [pc, #1164]	; 8005a28 <??DataTable3_2>
 800559c:	4020      	ands	r0, r4
 800559e:	4029      	ands	r1, r5
 80055a0:	2900      	cmp	r1, #0
 80055a2:	d101      	bne.n	80055a8 <??ZbZclParseFloat_20>
 80055a4:	2800      	cmp	r0, #0
 80055a6:	d008      	beq.n	80055ba <??ZbZclParseFloat_21>

080055a8 <??ZbZclParseFloat_20>:
 80055a8:	2000      	movs	r0, #0
 80055aa:	2100      	movs	r1, #0
 80055ac:	2200      	movs	r2, #0
 80055ae:	2300      	movs	r3, #0
 80055b0:	f000 fde8 	bl	8006184 <__aeabi_ddiv>
 80055b4:	ec41 0b10 	vmov	d0, r0, r1
 80055b8:	e06b      	b.n	8005692 <??ZbZclParseFloat_6>

080055ba <??ZbZclParseFloat_21>:
 80055ba:	f014 0000 	ands.w	r0, r4, #0
 80055be:	f015 4100 	ands.w	r1, r5, #2147483648	; 0x80000000
 80055c2:	2900      	cmp	r1, #0
 80055c4:	d101      	bne.n	80055ca <??ZbZclParseFloat_22>
 80055c6:	2800      	cmp	r0, #0
 80055c8:	d00a      	beq.n	80055e0 <??ZbZclParseFloat_23>

080055ca <??ZbZclParseFloat_22>:
 80055ca:	2000      	movs	r0, #0
 80055cc:	f8df 145c 	ldr.w	r1, [pc, #1116]	; 8005a2c <??DataTable3_3>
 80055d0:	2200      	movs	r2, #0
 80055d2:	f05f 4300 	movs.w	r3, #2147483648	; 0x80000000
 80055d6:	f000 fdd5 	bl	8006184 <__aeabi_ddiv>
 80055da:	ec41 0b10 	vmov	d0, r0, r1
 80055de:	e008      	b.n	80055f2 <??ZbZclParseFloat_24>

080055e0 <??ZbZclParseFloat_23>:
 80055e0:	2000      	movs	r0, #0
 80055e2:	f8df 1448 	ldr.w	r1, [pc, #1096]	; 8005a2c <??DataTable3_3>
 80055e6:	2200      	movs	r2, #0
 80055e8:	2300      	movs	r3, #0
 80055ea:	f000 fdcb 	bl	8006184 <__aeabi_ddiv>
 80055ee:	ec41 0b10 	vmov	d0, r0, r1

080055f2 <??ZbZclParseFloat_24>:
 80055f2:	e04e      	b.n	8005692 <??ZbZclParseFloat_6>

080055f4 <??ZbZclParseFloat_19>:
 80055f4:	0022      	movs	r2, r4
 80055f6:	002b      	movs	r3, r5
 80055f8:	0d1a      	lsrs	r2, r3, #20
 80055fa:	2300      	movs	r3, #0
 80055fc:	4690      	mov	r8, r2
 80055fe:	ea5f 5848 	movs.w	r8, r8, lsl #21
 8005602:	ea5f 5858 	movs.w	r8, r8, lsr #21
 8005606:	4647      	mov	r7, r8
 8005608:	b2bf      	uxth	r7, r7
 800560a:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 800560e:	3f34      	subs	r7, #52	; 0x34
 8005610:	4020      	ands	r0, r4
 8005612:	4029      	ands	r1, r5
 8005614:	2900      	cmp	r1, #0
 8005616:	d101      	bne.n	800561c <??ZbZclParseFloat_25>
 8005618:	2800      	cmp	r0, #0
 800561a:	d00a      	beq.n	8005632 <??ZbZclParseFloat_26>

0800561c <??ZbZclParseFloat_25>:
 800561c:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8005620:	f8df 1404 	ldr.w	r1, [pc, #1028]	; 8005a28 <??DataTable3_2>
 8005624:	4020      	ands	r0, r4
 8005626:	4029      	ands	r1, r5
 8005628:	f110 0a00 	adds.w	sl, r0, #0
 800562c:	f551 1b80 	adcs.w	fp, r1, #1048576	; 0x100000
 8005630:	e008      	b.n	8005644 <??ZbZclParseFloat_27>

08005632 <??ZbZclParseFloat_26>:
 8005632:	1c7f      	adds	r7, r7, #1
 8005634:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8005638:	f8df 13ec 	ldr.w	r1, [pc, #1004]	; 8005a28 <??DataTable3_2>
 800563c:	ea14 0a00 	ands.w	sl, r4, r0
 8005640:	ea15 0b01 	ands.w	fp, r5, r1

08005644 <??ZbZclParseFloat_27>:
 8005644:	4650      	mov	r0, sl
 8005646:	4659      	mov	r1, fp
 8005648:	f000 fc3c 	bl	8005ec4 <__aeabi_ul2d>
 800564c:	ec41 0b18 	vmov	d8, r0, r1
 8005650:	f014 0000 	ands.w	r0, r4, #0
 8005654:	f015 4100 	ands.w	r1, r5, #2147483648	; 0x80000000
 8005658:	2900      	cmp	r1, #0
 800565a:	d101      	bne.n	8005660 <??ZbZclParseFloat_28>
 800565c:	2800      	cmp	r0, #0
 800565e:	d005      	beq.n	800566c <??ZbZclParseFloat_29>

08005660 <??ZbZclParseFloat_28>:
 8005660:	ec51 0b18 	vmov	r0, r1, d8
 8005664:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 8005668:	ec41 0b18 	vmov	d8, r0, r1

0800566c <??ZbZclParseFloat_29>:
 800566c:	0038      	movs	r0, r7
 800566e:	eeb0 0a48 	vmov.f32	s0, s16
 8005672:	eef0 0a68 	vmov.f32	s1, s17
 8005676:	f000 f810 	bl	800569a <ZbZclFloatLdexp>
 800567a:	e00a      	b.n	8005692 <??ZbZclParseFloat_6>

0800567c <??ZbZclParseFloat_1>:
 800567c:	208d      	movs	r0, #141	; 0x8d
 800567e:	f889 0000 	strb.w	r0, [r9]
 8005682:	2000      	movs	r0, #0
 8005684:	2100      	movs	r1, #0
 8005686:	2200      	movs	r2, #0
 8005688:	2300      	movs	r3, #0
 800568a:	f000 fd7b 	bl	8006184 <__aeabi_ddiv>
 800568e:	ec41 0b10 	vmov	d0, r0, r1

08005692 <??ZbZclParseFloat_6>:
 8005692:	ecbd 8b02 	vpop	{d8}
 8005696:	e8bd 8ff1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800569a <ZbZclFloatLdexp>:
 800569a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800569e:	ed2d 8b04 	vpush	{d8-d9}
 80056a2:	b084      	sub	sp, #16
 80056a4:	eeb0 8a40 	vmov.f32	s16, s0
 80056a8:	eef0 8a60 	vmov.f32	s17, s1
 80056ac:	0006      	movs	r6, r0
 80056ae:	2730      	movs	r7, #48	; 0x30
 80056b0:	ec53 2b18 	vmov	r2, r3, d8
 80056b4:	ec51 0b18 	vmov	r0, r1, d8
 80056b8:	f000 fe9a 	bl	80063f0 <__aeabi_cdcmpeq>
 80056bc:	d10c      	bne.n	80056d8 <??ZbZclFloatLdexp_0>
 80056be:	ec53 2b18 	vmov	r2, r3, d8
 80056c2:	ec51 0b18 	vmov	r0, r1, d8
 80056c6:	f000 fa7d 	bl	8005bc4 <__adddf3>
 80056ca:	0002      	movs	r2, r0
 80056cc:	000b      	movs	r3, r1
 80056ce:	ec51 0b18 	vmov	r0, r1, d8
 80056d2:	f000 fe8d 	bl	80063f0 <__aeabi_cdcmpeq>
 80056d6:	d104      	bne.n	80056e2 <??ZbZclFloatLdexp_1>

080056d8 <??ZbZclFloatLdexp_0>:
 80056d8:	eeb0 0a48 	vmov.f32	s0, s16
 80056dc:	eef0 0a68 	vmov.f32	s1, s17
 80056e0:	e06b      	b.n	80057ba <??ZbZclFloatLdexp_2>

080056e2 <??ZbZclFloatLdexp_1>:
 80056e2:	2e01      	cmp	r6, #1
 80056e4:	db2c      	blt.n	8005740 <??ZbZclFloatLdexp_3>
 80056e6:	2401      	movs	r4, #1
 80056e8:	2500      	movs	r5, #0
 80056ea:	0020      	movs	r0, r4
 80056ec:	0029      	movs	r1, r5
 80056ee:	003a      	movs	r2, r7
 80056f0:	f000 fa56 	bl	8005ba0 <__aeabi_llsl>
 80056f4:	4680      	mov	r8, r0
 80056f6:	4689      	mov	r9, r1
 80056f8:	4640      	mov	r0, r8
 80056fa:	4649      	mov	r1, r9
 80056fc:	f000 fbe2 	bl	8005ec4 <__aeabi_ul2d>
 8005700:	ec41 0b19 	vmov	d9, r0, r1

08005704 <??ZbZclFloatLdexp_4>:
 8005704:	42be      	cmp	r6, r7
 8005706:	db09      	blt.n	800571c <??ZbZclFloatLdexp_5>
 8005708:	ec51 0b18 	vmov	r0, r1, d8
 800570c:	ec53 2b19 	vmov	r2, r3, d9
 8005710:	f000 fc0e 	bl	8005f30 <__aeabi_dmul>
 8005714:	ec41 0b18 	vmov	d8, r0, r1
 8005718:	1bf6      	subs	r6, r6, r7
 800571a:	e7f3      	b.n	8005704 <??ZbZclFloatLdexp_4>

0800571c <??ZbZclFloatLdexp_5>:
 800571c:	0020      	movs	r0, r4
 800571e:	0029      	movs	r1, r5
 8005720:	0032      	movs	r2, r6
 8005722:	f000 fa3d 	bl	8005ba0 <__aeabi_llsl>
 8005726:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800572a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800572e:	f000 fbc9 	bl	8005ec4 <__aeabi_ul2d>
 8005732:	ec53 2b18 	vmov	r2, r3, d8
 8005736:	f000 fbfb 	bl	8005f30 <__aeabi_dmul>
 800573a:	ec41 0b18 	vmov	d8, r0, r1
 800573e:	e038      	b.n	80057b2 <??ZbZclFloatLdexp_6>

08005740 <??ZbZclFloatLdexp_3>:
 8005740:	2e00      	cmp	r6, #0
 8005742:	d536      	bpl.n	80057b2 <??ZbZclFloatLdexp_6>
 8005744:	2401      	movs	r4, #1
 8005746:	2500      	movs	r5, #0
 8005748:	0020      	movs	r0, r4
 800574a:	0029      	movs	r1, r5
 800574c:	003a      	movs	r2, r7
 800574e:	f000 fa27 	bl	8005ba0 <__aeabi_llsl>
 8005752:	4682      	mov	sl, r0
 8005754:	468b      	mov	fp, r1
 8005756:	4650      	mov	r0, sl
 8005758:	4659      	mov	r1, fp
 800575a:	f000 fbb3 	bl	8005ec4 <__aeabi_ul2d>
 800575e:	0002      	movs	r2, r0
 8005760:	000b      	movs	r3, r1
 8005762:	2000      	movs	r0, #0
 8005764:	49b1      	ldr	r1, [pc, #708]	; (8005a2c <??DataTable3_3>)
 8005766:	f000 fd0d 	bl	8006184 <__aeabi_ddiv>
 800576a:	ec41 0b19 	vmov	d9, r0, r1
 800576e:	f1d6 0800 	rsbs	r8, r6, #0

08005772 <??ZbZclFloatLdexp_7>:
 8005772:	45b8      	cmp	r8, r7
 8005774:	db0a      	blt.n	800578c <??ZbZclFloatLdexp_8>
 8005776:	ec53 2b18 	vmov	r2, r3, d8
 800577a:	ec51 0b19 	vmov	r0, r1, d9
 800577e:	f000 fbd7 	bl	8005f30 <__aeabi_dmul>
 8005782:	ec41 0b18 	vmov	d8, r0, r1
 8005786:	ebb8 0807 	subs.w	r8, r8, r7
 800578a:	e7f2      	b.n	8005772 <??ZbZclFloatLdexp_7>

0800578c <??ZbZclFloatLdexp_8>:
 800578c:	0020      	movs	r0, r4
 800578e:	0029      	movs	r1, r5
 8005790:	4642      	mov	r2, r8
 8005792:	f000 fa05 	bl	8005ba0 <__aeabi_llsl>
 8005796:	e9cd 0100 	strd	r0, r1, [sp]
 800579a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800579e:	f000 fb91 	bl	8005ec4 <__aeabi_ul2d>
 80057a2:	0002      	movs	r2, r0
 80057a4:	000b      	movs	r3, r1
 80057a6:	ec51 0b18 	vmov	r0, r1, d8
 80057aa:	f000 fceb 	bl	8006184 <__aeabi_ddiv>
 80057ae:	ec41 0b18 	vmov	d8, r0, r1

080057b2 <??ZbZclFloatLdexp_6>:
 80057b2:	eeb0 0a48 	vmov.f32	s0, s16
 80057b6:	eef0 0a68 	vmov.f32	s1, s17

080057ba <??ZbZclFloatLdexp_2>:
 80057ba:	b004      	add	sp, #16
 80057bc:	ecbd 8b04 	vpop	{d8-d9}
 80057c0:	e8bd 8ff1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080057c4 <ZbZclFloatFrexp>:
 80057c4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80057c8:	ed2d 8b06 	vpush	{d8-d10}
 80057cc:	b086      	sub	sp, #24
 80057ce:	eeb0 8a40 	vmov.f32	s16, s0
 80057d2:	eef0 8a60 	vmov.f32	s17, s1
 80057d6:	4682      	mov	sl, r0
 80057d8:	000e      	movs	r6, r1
 80057da:	4693      	mov	fp, r2
 80057dc:	2730      	movs	r7, #48	; 0x30
 80057de:	f05f 0800 	movs.w	r8, #0
 80057e2:	f05f 0901 	movs.w	r9, #1
 80057e6:	eeb0 9a48 	vmov.f32	s18, s16
 80057ea:	eef0 9a68 	vmov.f32	s19, s17
 80057ee:	ec51 0b18 	vmov	r0, r1, d8
 80057f2:	2200      	movs	r2, #0
 80057f4:	2300      	movs	r3, #0
 80057f6:	f000 fdfb 	bl	80063f0 <__aeabi_cdcmpeq>
 80057fa:	d208      	bcs.n	800580e <??ZbZclFloatFrexp_0>
 80057fc:	f05f 30ff 	movs.w	r0, #4294967295	; 0xffffffff
 8005800:	4681      	mov	r9, r0
 8005802:	ec51 0b19 	vmov	r0, r1, d9
 8005806:	f091 4100 	eors.w	r1, r1, #2147483648	; 0x80000000
 800580a:	ec41 0b19 	vmov	d9, r0, r1

0800580e <??ZbZclFloatFrexp_0>:
 800580e:	ec53 2b19 	vmov	r2, r3, d9
 8005812:	ec51 0b19 	vmov	r0, r1, d9
 8005816:	f000 fdeb 	bl	80063f0 <__aeabi_cdcmpeq>
 800581a:	d00b      	beq.n	8005834 <??ZbZclFloatFrexp_1>
 800581c:	f8ca 6000 	str.w	r6, [sl]
 8005820:	4648      	mov	r0, r9
 8005822:	f000 fb1b 	bl	8005e5c <__aeabi_i2d>
 8005826:	2200      	movs	r2, #0
 8005828:	4b81      	ldr	r3, [pc, #516]	; (8005a30 <??DataTable3_4>)
 800582a:	f000 fb81 	bl	8005f30 <__aeabi_dmul>
 800582e:	ec41 0b10 	vmov	d0, r0, r1
 8005832:	e0ef      	b.n	8005a14 <??ZbZclFloatFrexp_2>

08005834 <??ZbZclFloatFrexp_1>:
 8005834:	2000      	movs	r0, #0
 8005836:	497d      	ldr	r1, [pc, #500]	; (8005a2c <??DataTable3_3>)
 8005838:	2200      	movs	r2, #0
 800583a:	2300      	movs	r3, #0
 800583c:	f000 fca2 	bl	8006184 <__aeabi_ddiv>
 8005840:	ec53 2b19 	vmov	r2, r3, d9
 8005844:	f000 fdd4 	bl	80063f0 <__aeabi_cdcmpeq>
 8005848:	d00b      	beq.n	8005862 <??ZbZclFloatFrexp_3>
 800584a:	2000      	movs	r0, #0
 800584c:	4977      	ldr	r1, [pc, #476]	; (8005a2c <??DataTable3_3>)
 800584e:	2200      	movs	r2, #0
 8005850:	f05f 4300 	movs.w	r3, #2147483648	; 0x80000000
 8005854:	f000 fc96 	bl	8006184 <__aeabi_ddiv>
 8005858:	ec53 2b19 	vmov	r2, r3, d9
 800585c:	f000 fdc8 	bl	80063f0 <__aeabi_cdcmpeq>
 8005860:	d107      	bne.n	8005872 <??ZbZclFloatFrexp_4>

08005862 <??ZbZclFloatFrexp_3>:
 8005862:	f8ca 6000 	str.w	r6, [sl]
 8005866:	4648      	mov	r0, r9
 8005868:	f000 faf8 	bl	8005e5c <__aeabi_i2d>
 800586c:	ec41 0b10 	vmov	d0, r0, r1
 8005870:	e0d0      	b.n	8005a14 <??ZbZclFloatFrexp_2>

08005872 <??ZbZclFloatFrexp_4>:
 8005872:	ec53 2b19 	vmov	r2, r3, d9
 8005876:	ec51 0b19 	vmov	r0, r1, d9
 800587a:	f000 f9a3 	bl	8005bc4 <__adddf3>
 800587e:	ec53 2b19 	vmov	r2, r3, d9
 8005882:	f000 fdb5 	bl	80063f0 <__aeabi_cdcmpeq>
 8005886:	d10b      	bne.n	80058a0 <??ZbZclFloatFrexp_5>
 8005888:	f8ca b000 	str.w	fp, [sl]
 800588c:	4648      	mov	r0, r9
 800588e:	f000 fae5 	bl	8005e5c <__aeabi_i2d>
 8005892:	2200      	movs	r2, #0
 8005894:	2300      	movs	r3, #0
 8005896:	f000 fb4b 	bl	8005f30 <__aeabi_dmul>
 800589a:	ec41 0b10 	vmov	d0, r0, r1
 800589e:	e0b9      	b.n	8005a14 <??ZbZclFloatFrexp_2>

080058a0 <??ZbZclFloatFrexp_5>:
 80058a0:	ec51 0b19 	vmov	r0, r1, d9
 80058a4:	2200      	movs	r2, #0
 80058a6:	f05f 4380 	movs.w	r3, #1073741824	; 0x40000000
 80058aa:	f000 fd99 	bl	80063e0 <__aeabi_cdrcmple>
 80058ae:	d854      	bhi.n	800595a <??ZbZclFloatFrexp_6>
 80058b0:	2001      	movs	r0, #1
 80058b2:	2100      	movs	r1, #0
 80058b4:	003a      	movs	r2, r7
 80058b6:	f000 f973 	bl	8005ba0 <__aeabi_llsl>
 80058ba:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80058be:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80058c2:	f000 faff 	bl	8005ec4 <__aeabi_ul2d>
 80058c6:	0002      	movs	r2, r0
 80058c8:	000b      	movs	r3, r1
 80058ca:	2000      	movs	r0, #0
 80058cc:	4957      	ldr	r1, [pc, #348]	; (8005a2c <??DataTable3_3>)
 80058ce:	f000 fc59 	bl	8006184 <__aeabi_ddiv>
 80058d2:	ec41 0b1a 	vmov	d10, r0, r1
 80058d6:	2002      	movs	r0, #2
 80058d8:	2100      	movs	r1, #0
 80058da:	003a      	movs	r2, r7
 80058dc:	f000 f960 	bl	8005ba0 <__aeabi_llsl>
 80058e0:	e9cd 0100 	strd	r0, r1, [sp]

080058e4 <??ZbZclFloatFrexp_7>:
 80058e4:	e9dd 0100 	ldrd	r0, r1, [sp]
 80058e8:	f000 faec 	bl	8005ec4 <__aeabi_ul2d>
 80058ec:	0002      	movs	r2, r0
 80058ee:	000b      	movs	r3, r1
 80058f0:	ec51 0b19 	vmov	r0, r1, d9
 80058f4:	f000 fd74 	bl	80063e0 <__aeabi_cdrcmple>
 80058f8:	d813      	bhi.n	8005922 <??ZbZclFloatFrexp_8>
 80058fa:	ec53 2b19 	vmov	r2, r3, d9
 80058fe:	ec51 0b1a 	vmov	r0, r1, d10
 8005902:	f000 fb15 	bl	8005f30 <__aeabi_dmul>
 8005906:	ec41 0b19 	vmov	d9, r0, r1
 800590a:	eb17 0808 	adds.w	r8, r7, r8
 800590e:	45b0      	cmp	r8, r6
 8005910:	dbe8      	blt.n	80058e4 <??ZbZclFloatFrexp_7>
 8005912:	f8ca 6000 	str.w	r6, [sl]
 8005916:	4648      	mov	r0, r9
 8005918:	f000 faa0 	bl	8005e5c <__aeabi_i2d>
 800591c:	ec41 0b10 	vmov	d0, r0, r1
 8005920:	e078      	b.n	8005a14 <??ZbZclFloatFrexp_2>

08005922 <??ZbZclFloatFrexp_8>:
 8005922:	ec51 0b19 	vmov	r0, r1, d9
 8005926:	2200      	movs	r2, #0
 8005928:	f05f 4380 	movs.w	r3, #1073741824	; 0x40000000
 800592c:	f000 fd58 	bl	80063e0 <__aeabi_cdrcmple>
 8005930:	d865      	bhi.n	80059fe <??ZbZclFloatFrexp_9>
 8005932:	ec53 2b19 	vmov	r2, r3, d9
 8005936:	2000      	movs	r0, #0
 8005938:	493e      	ldr	r1, [pc, #248]	; (8005a34 <??DataTable3_5>)
 800593a:	f000 faf9 	bl	8005f30 <__aeabi_dmul>
 800593e:	ec41 0b19 	vmov	d9, r0, r1
 8005942:	f118 0801 	adds.w	r8, r8, #1
 8005946:	45b0      	cmp	r8, r6
 8005948:	dbeb      	blt.n	8005922 <??ZbZclFloatFrexp_8>
 800594a:	f8ca 6000 	str.w	r6, [sl]
 800594e:	4648      	mov	r0, r9
 8005950:	f000 fa84 	bl	8005e5c <__aeabi_i2d>
 8005954:	ec41 0b10 	vmov	d0, r0, r1
 8005958:	e05c      	b.n	8005a14 <??ZbZclFloatFrexp_2>

0800595a <??ZbZclFloatFrexp_6>:
 800595a:	ec51 0b19 	vmov	r0, r1, d9
 800595e:	2200      	movs	r2, #0
 8005960:	4b32      	ldr	r3, [pc, #200]	; (8005a2c <??DataTable3_3>)
 8005962:	f000 fd45 	bl	80063f0 <__aeabi_cdcmpeq>
 8005966:	d24a      	bcs.n	80059fe <??ZbZclFloatFrexp_9>
 8005968:	2401      	movs	r4, #1
 800596a:	2500      	movs	r5, #0
 800596c:	0020      	movs	r0, r4
 800596e:	0029      	movs	r1, r5
 8005970:	003a      	movs	r2, r7
 8005972:	f000 f915 	bl	8005ba0 <__aeabi_llsl>
 8005976:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800597a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 800597e:	f000 faa1 	bl	8005ec4 <__aeabi_ul2d>
 8005982:	ec41 0b1a 	vmov	d10, r0, r1
 8005986:	0020      	movs	r0, r4
 8005988:	0029      	movs	r1, r5
 800598a:	003a      	movs	r2, r7
 800598c:	f000 f908 	bl	8005ba0 <__aeabi_llsl>
 8005990:	e9cd 0100 	strd	r0, r1, [sp]

08005994 <??ZbZclFloatFrexp_10>:
 8005994:	e9dd 0100 	ldrd	r0, r1, [sp]
 8005998:	f000 fa94 	bl	8005ec4 <__aeabi_ul2d>
 800599c:	0002      	movs	r2, r0
 800599e:	000b      	movs	r3, r1
 80059a0:	2000      	movs	r0, #0
 80059a2:	4922      	ldr	r1, [pc, #136]	; (8005a2c <??DataTable3_3>)
 80059a4:	f000 fbee 	bl	8006184 <__aeabi_ddiv>
 80059a8:	0002      	movs	r2, r0
 80059aa:	000b      	movs	r3, r1
 80059ac:	ec51 0b18 	vmov	r0, r1, d8
 80059b0:	f000 fd1e 	bl	80063f0 <__aeabi_cdcmpeq>
 80059b4:	d20e      	bcs.n	80059d4 <??ZbZclFloatFrexp_11>
 80059b6:	ebb8 0007 	subs.w	r0, r8, r7
 80059ba:	4583      	cmp	fp, r0
 80059bc:	da0a      	bge.n	80059d4 <??ZbZclFloatFrexp_11>

080059be <??ZbZclFloatFrexp_12>:
 80059be:	ec53 2b19 	vmov	r2, r3, d9
 80059c2:	ec51 0b1a 	vmov	r0, r1, d10
 80059c6:	f000 fab3 	bl	8005f30 <__aeabi_dmul>
 80059ca:	ec41 0b19 	vmov	d9, r0, r1
 80059ce:	ebb8 0807 	subs.w	r8, r8, r7
 80059d2:	e7df      	b.n	8005994 <??ZbZclFloatFrexp_10>

080059d4 <??ZbZclFloatFrexp_11>:
 80059d4:	ec51 0b19 	vmov	r0, r1, d9
 80059d8:	2200      	movs	r2, #0
 80059da:	4b14      	ldr	r3, [pc, #80]	; (8005a2c <??DataTable3_3>)
 80059dc:	f000 fd08 	bl	80063f0 <__aeabi_cdcmpeq>
 80059e0:	d20d      	bcs.n	80059fe <??ZbZclFloatFrexp_9>
 80059e2:	f1b8 0801 	subs.w	r8, r8, #1
 80059e6:	45d8      	cmp	r8, fp
 80059e8:	d009      	beq.n	80059fe <??ZbZclFloatFrexp_9>

080059ea <??ZbZclFloatFrexp_13>:
 80059ea:	ec53 2b19 	vmov	r2, r3, d9
 80059ee:	2000      	movs	r0, #0
 80059f0:	f05f 4180 	movs.w	r1, #1073741824	; 0x40000000
 80059f4:	f000 fa9c 	bl	8005f30 <__aeabi_dmul>
 80059f8:	ec41 0b19 	vmov	d9, r0, r1
 80059fc:	e7ea      	b.n	80059d4 <??ZbZclFloatFrexp_11>

080059fe <??ZbZclFloatFrexp_9>:
 80059fe:	f8ca 8000 	str.w	r8, [sl]
 8005a02:	4648      	mov	r0, r9
 8005a04:	f000 fa2a 	bl	8005e5c <__aeabi_i2d>
 8005a08:	ec53 2b19 	vmov	r2, r3, d9
 8005a0c:	f000 fa90 	bl	8005f30 <__aeabi_dmul>
 8005a10:	ec41 0b10 	vmov	d0, r0, r1

08005a14 <??ZbZclFloatFrexp_2>:
 8005a14:	b006      	add	sp, #24
 8005a16:	ecbd 8b06 	vpop	{d8-d10}
 8005a1a:	e8bd 8ff1 	ldmia.w	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005a20 <??DataTable3>:
 8005a20:	fc01 ffff                                   ....

08005a24 <??DataTable3_1>:
 8005a24:	0000 7ff0                                   ....

08005a28 <??DataTable3_2>:
 8005a28:	ffff 000f                                   ....

08005a2c <??DataTable3_3>:
 8005a2c:	0000 3ff0                                   ...?

08005a30 <??DataTable3_4>:
 8005a30:	0000 3ff8                                   ...?

08005a34 <??DataTable3_5>:
 8005a34:	0000 3fe0                                   ...?

08005a38 <ZbZclAttrIsFloat>:
 8005a38:	0001      	movs	r1, r0
 8005a3a:	0008      	movs	r0, r1
 8005a3c:	b2c0      	uxtb	r0, r0
 8005a3e:	2838      	cmp	r0, #56	; 0x38
 8005a40:	db05      	blt.n	8005a4e <??ZbZclAttrIsFloat_0>
 8005a42:	0008      	movs	r0, r1
 8005a44:	b2c0      	uxtb	r0, r0
 8005a46:	283b      	cmp	r0, #59	; 0x3b
 8005a48:	da01      	bge.n	8005a4e <??ZbZclAttrIsFloat_0>
 8005a4a:	2001      	movs	r0, #1
 8005a4c:	e000      	b.n	8005a50 <??ZbZclAttrIsFloat_1>

08005a4e <??ZbZclAttrIsFloat_0>:
 8005a4e:	2000      	movs	r0, #0

08005a50 <??ZbZclAttrIsFloat_1>:
 8005a50:	4770      	bx	lr

08005a52 <strcmp>:
 8005a52:	f810 2b01 	ldrb.w	r2, [r0], #1
 8005a56:	f811 3b01 	ldrb.w	r3, [r1], #1
 8005a5a:	2a01      	cmp	r2, #1
 8005a5c:	bf28      	it	cs
 8005a5e:	429a      	cmpcs	r2, r3
 8005a60:	d0f7      	beq.n	8005a52 <strcmp>
 8005a62:	1ad0      	subs	r0, r2, r3
 8005a64:	4770      	bx	lr

08005a66 <__aeabi_memset>:
 8005a66:	b470      	push	{r4, r5, r6}
 8005a68:	0784      	lsls	r4, r0, #30
 8005a6a:	d046      	beq.n	8005afa <__aeabi_memset+0x94>
 8005a6c:	1e4c      	subs	r4, r1, #1
 8005a6e:	2900      	cmp	r1, #0
 8005a70:	d041      	beq.n	8005af6 <__aeabi_memset+0x90>
 8005a72:	b2d5      	uxtb	r5, r2
 8005a74:	4603      	mov	r3, r0
 8005a76:	e002      	b.n	8005a7e <__aeabi_memset+0x18>
 8005a78:	1e61      	subs	r1, r4, #1
 8005a7a:	b3e4      	cbz	r4, 8005af6 <__aeabi_memset+0x90>
 8005a7c:	460c      	mov	r4, r1
 8005a7e:	f803 5b01 	strb.w	r5, [r3], #1
 8005a82:	0799      	lsls	r1, r3, #30
 8005a84:	d1f8      	bne.n	8005a78 <__aeabi_memset+0x12>
 8005a86:	2c03      	cmp	r4, #3
 8005a88:	d92e      	bls.n	8005ae8 <__aeabi_memset+0x82>
 8005a8a:	b2d5      	uxtb	r5, r2
 8005a8c:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8005a90:	2c0f      	cmp	r4, #15
 8005a92:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8005a96:	d919      	bls.n	8005acc <__aeabi_memset+0x66>
 8005a98:	4626      	mov	r6, r4
 8005a9a:	f103 0110 	add.w	r1, r3, #16
 8005a9e:	3e10      	subs	r6, #16
 8005aa0:	2e0f      	cmp	r6, #15
 8005aa2:	f841 5c10 	str.w	r5, [r1, #-16]
 8005aa6:	f841 5c0c 	str.w	r5, [r1, #-12]
 8005aaa:	f841 5c08 	str.w	r5, [r1, #-8]
 8005aae:	f841 5c04 	str.w	r5, [r1, #-4]
 8005ab2:	f101 0110 	add.w	r1, r1, #16
 8005ab6:	d8f2      	bhi.n	8005a9e <__aeabi_memset+0x38>
 8005ab8:	f1a4 0110 	sub.w	r1, r4, #16
 8005abc:	f021 010f 	bic.w	r1, r1, #15
 8005ac0:	f004 040f 	and.w	r4, r4, #15
 8005ac4:	3110      	adds	r1, #16
 8005ac6:	2c03      	cmp	r4, #3
 8005ac8:	440b      	add	r3, r1
 8005aca:	d90d      	bls.n	8005ae8 <__aeabi_memset+0x82>
 8005acc:	461e      	mov	r6, r3
 8005ace:	4621      	mov	r1, r4
 8005ad0:	3904      	subs	r1, #4
 8005ad2:	2903      	cmp	r1, #3
 8005ad4:	f846 5b04 	str.w	r5, [r6], #4
 8005ad8:	d8fa      	bhi.n	8005ad0 <__aeabi_memset+0x6a>
 8005ada:	1f21      	subs	r1, r4, #4
 8005adc:	f021 0103 	bic.w	r1, r1, #3
 8005ae0:	3104      	adds	r1, #4
 8005ae2:	440b      	add	r3, r1
 8005ae4:	f004 0403 	and.w	r4, r4, #3
 8005ae8:	b12c      	cbz	r4, 8005af6 <__aeabi_memset+0x90>
 8005aea:	b2d2      	uxtb	r2, r2
 8005aec:	441c      	add	r4, r3
 8005aee:	f803 2b01 	strb.w	r2, [r3], #1
 8005af2:	42a3      	cmp	r3, r4
 8005af4:	d1fb      	bne.n	8005aee <__aeabi_memset+0x88>
 8005af6:	bc70      	pop	{r4, r5, r6}
 8005af8:	4770      	bx	lr
 8005afa:	460c      	mov	r4, r1
 8005afc:	4603      	mov	r3, r0
 8005afe:	e7c2      	b.n	8005a86 <__aeabi_memset+0x20>

08005b00 <memchr>:
 8005b00:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8005b04:	2a10      	cmp	r2, #16
 8005b06:	db2b      	blt.n	8005b60 <memchr+0x60>
 8005b08:	f010 0f07 	tst.w	r0, #7
 8005b0c:	d008      	beq.n	8005b20 <memchr+0x20>
 8005b0e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8005b12:	3a01      	subs	r2, #1
 8005b14:	428b      	cmp	r3, r1
 8005b16:	d02d      	beq.n	8005b74 <memchr+0x74>
 8005b18:	f010 0f07 	tst.w	r0, #7
 8005b1c:	b342      	cbz	r2, 8005b70 <memchr+0x70>
 8005b1e:	d1f6      	bne.n	8005b0e <memchr+0xe>
 8005b20:	b4f0      	push	{r4, r5, r6, r7}
 8005b22:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8005b26:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 8005b2a:	f022 0407 	bic.w	r4, r2, #7
 8005b2e:	f07f 0700 	mvns.w	r7, #0
 8005b32:	2300      	movs	r3, #0
 8005b34:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8005b38:	3c08      	subs	r4, #8
 8005b3a:	ea85 0501 	eor.w	r5, r5, r1
 8005b3e:	ea86 0601 	eor.w	r6, r6, r1
 8005b42:	fa85 f547 	uadd8	r5, r5, r7
 8005b46:	faa3 f587 	sel	r5, r3, r7
 8005b4a:	fa86 f647 	uadd8	r6, r6, r7
 8005b4e:	faa5 f687 	sel	r6, r5, r7
 8005b52:	b98e      	cbnz	r6, 8005b78 <memchr+0x78>
 8005b54:	d1ee      	bne.n	8005b34 <memchr+0x34>
 8005b56:	bcf0      	pop	{r4, r5, r6, r7}
 8005b58:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8005b5c:	f002 0207 	and.w	r2, r2, #7
 8005b60:	b132      	cbz	r2, 8005b70 <memchr+0x70>
 8005b62:	f810 3b01 	ldrb.w	r3, [r0], #1
 8005b66:	3a01      	subs	r2, #1
 8005b68:	ea83 0301 	eor.w	r3, r3, r1
 8005b6c:	b113      	cbz	r3, 8005b74 <memchr+0x74>
 8005b6e:	d1f8      	bne.n	8005b62 <memchr+0x62>
 8005b70:	2000      	movs	r0, #0
 8005b72:	4770      	bx	lr
 8005b74:	3801      	subs	r0, #1
 8005b76:	4770      	bx	lr
 8005b78:	2d00      	cmp	r5, #0
 8005b7a:	bf06      	itte	eq
 8005b7c:	4635      	moveq	r5, r6
 8005b7e:	3803      	subeq	r0, #3
 8005b80:	3807      	subne	r0, #7
 8005b82:	f015 0f01 	tst.w	r5, #1
 8005b86:	d107      	bne.n	8005b98 <memchr+0x98>
 8005b88:	3001      	adds	r0, #1
 8005b8a:	f415 7f80 	tst.w	r5, #256	; 0x100
 8005b8e:	bf02      	ittt	eq
 8005b90:	3001      	addeq	r0, #1
 8005b92:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8005b96:	3001      	addeq	r0, #1
 8005b98:	bcf0      	pop	{r4, r5, r6, r7}
 8005b9a:	3801      	subs	r0, #1
 8005b9c:	4770      	bx	lr
 8005b9e:	bf00      	nop

08005ba0 <__aeabi_llsl>:
 8005ba0:	4091      	lsls	r1, r2
 8005ba2:	0003      	movs	r3, r0
 8005ba4:	4090      	lsls	r0, r2
 8005ba6:	469c      	mov	ip, r3
 8005ba8:	3a20      	subs	r2, #32
 8005baa:	4093      	lsls	r3, r2
 8005bac:	4319      	orrs	r1, r3
 8005bae:	4252      	negs	r2, r2
 8005bb0:	4663      	mov	r3, ip
 8005bb2:	40d3      	lsrs	r3, r2
 8005bb4:	4319      	orrs	r1, r3
 8005bb6:	4770      	bx	lr

08005bb8 <__aeabi_drsub>:
 8005bb8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8005bbc:	e002      	b.n	8005bc4 <__adddf3>
 8005bbe:	bf00      	nop

08005bc0 <__aeabi_dsub>:
 8005bc0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08005bc4 <__adddf3>:
 8005bc4:	b530      	push	{r4, r5, lr}
 8005bc6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8005bca:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8005bce:	ea94 0f05 	teq	r4, r5
 8005bd2:	bf08      	it	eq
 8005bd4:	ea90 0f02 	teqeq	r0, r2
 8005bd8:	bf1f      	itttt	ne
 8005bda:	ea54 0c00 	orrsne.w	ip, r4, r0
 8005bde:	ea55 0c02 	orrsne.w	ip, r5, r2
 8005be2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8005be6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8005bea:	f000 80e2 	beq.w	8005db2 <__adddf3+0x1ee>
 8005bee:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8005bf2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8005bf6:	bfb8      	it	lt
 8005bf8:	426d      	neglt	r5, r5
 8005bfa:	dd0c      	ble.n	8005c16 <__adddf3+0x52>
 8005bfc:	442c      	add	r4, r5
 8005bfe:	ea80 0202 	eor.w	r2, r0, r2
 8005c02:	ea81 0303 	eor.w	r3, r1, r3
 8005c06:	ea82 0000 	eor.w	r0, r2, r0
 8005c0a:	ea83 0101 	eor.w	r1, r3, r1
 8005c0e:	ea80 0202 	eor.w	r2, r0, r2
 8005c12:	ea81 0303 	eor.w	r3, r1, r3
 8005c16:	2d36      	cmp	r5, #54	; 0x36
 8005c18:	bf88      	it	hi
 8005c1a:	bd30      	pophi	{r4, r5, pc}
 8005c1c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8005c20:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8005c24:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8005c28:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8005c2c:	d002      	beq.n	8005c34 <__adddf3+0x70>
 8005c2e:	4240      	negs	r0, r0
 8005c30:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8005c34:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8005c38:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8005c3c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8005c40:	d002      	beq.n	8005c48 <__adddf3+0x84>
 8005c42:	4252      	negs	r2, r2
 8005c44:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8005c48:	ea94 0f05 	teq	r4, r5
 8005c4c:	f000 80a7 	beq.w	8005d9e <__adddf3+0x1da>
 8005c50:	f1a4 0401 	sub.w	r4, r4, #1
 8005c54:	f1d5 0e20 	rsbs	lr, r5, #32
 8005c58:	db0d      	blt.n	8005c76 <__adddf3+0xb2>
 8005c5a:	fa02 fc0e 	lsl.w	ip, r2, lr
 8005c5e:	fa22 f205 	lsr.w	r2, r2, r5
 8005c62:	1880      	adds	r0, r0, r2
 8005c64:	f141 0100 	adc.w	r1, r1, #0
 8005c68:	fa03 f20e 	lsl.w	r2, r3, lr
 8005c6c:	1880      	adds	r0, r0, r2
 8005c6e:	fa43 f305 	asr.w	r3, r3, r5
 8005c72:	4159      	adcs	r1, r3
 8005c74:	e00e      	b.n	8005c94 <__adddf3+0xd0>
 8005c76:	f1a5 0520 	sub.w	r5, r5, #32
 8005c7a:	f10e 0e20 	add.w	lr, lr, #32
 8005c7e:	2a01      	cmp	r2, #1
 8005c80:	fa03 fc0e 	lsl.w	ip, r3, lr
 8005c84:	bf28      	it	cs
 8005c86:	f04c 0c02 	orrcs.w	ip, ip, #2
 8005c8a:	fa43 f305 	asr.w	r3, r3, r5
 8005c8e:	18c0      	adds	r0, r0, r3
 8005c90:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8005c94:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8005c98:	d507      	bpl.n	8005caa <__adddf3+0xe6>
 8005c9a:	f04f 0e00 	mov.w	lr, #0
 8005c9e:	f1dc 0c00 	rsbs	ip, ip, #0
 8005ca2:	eb7e 0000 	sbcs.w	r0, lr, r0
 8005ca6:	eb6e 0101 	sbc.w	r1, lr, r1
 8005caa:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8005cae:	d31b      	bcc.n	8005ce8 <__adddf3+0x124>
 8005cb0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8005cb4:	d30c      	bcc.n	8005cd0 <__adddf3+0x10c>
 8005cb6:	0849      	lsrs	r1, r1, #1
 8005cb8:	ea5f 0030 	movs.w	r0, r0, rrx
 8005cbc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8005cc0:	f104 0401 	add.w	r4, r4, #1
 8005cc4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8005cc8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8005ccc:	f080 809a 	bcs.w	8005e04 <__adddf3+0x240>
 8005cd0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8005cd4:	bf08      	it	eq
 8005cd6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8005cda:	f150 0000 	adcs.w	r0, r0, #0
 8005cde:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8005ce2:	ea41 0105 	orr.w	r1, r1, r5
 8005ce6:	bd30      	pop	{r4, r5, pc}
 8005ce8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8005cec:	4140      	adcs	r0, r0
 8005cee:	eb41 0101 	adc.w	r1, r1, r1
 8005cf2:	3c01      	subs	r4, #1
 8005cf4:	bf28      	it	cs
 8005cf6:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8005cfa:	d2e9      	bcs.n	8005cd0 <__adddf3+0x10c>
 8005cfc:	f091 0f00 	teq	r1, #0
 8005d00:	bf04      	itt	eq
 8005d02:	4601      	moveq	r1, r0
 8005d04:	2000      	moveq	r0, #0
 8005d06:	fab1 f381 	clz	r3, r1
 8005d0a:	bf08      	it	eq
 8005d0c:	3320      	addeq	r3, #32
 8005d0e:	f1a3 030b 	sub.w	r3, r3, #11
 8005d12:	f1b3 0220 	subs.w	r2, r3, #32
 8005d16:	da0c      	bge.n	8005d32 <__adddf3+0x16e>
 8005d18:	320c      	adds	r2, #12
 8005d1a:	dd08      	ble.n	8005d2e <__adddf3+0x16a>
 8005d1c:	f102 0c14 	add.w	ip, r2, #20
 8005d20:	f1c2 020c 	rsb	r2, r2, #12
 8005d24:	fa01 f00c 	lsl.w	r0, r1, ip
 8005d28:	fa21 f102 	lsr.w	r1, r1, r2
 8005d2c:	e00c      	b.n	8005d48 <__adddf3+0x184>
 8005d2e:	f102 0214 	add.w	r2, r2, #20
 8005d32:	bfd8      	it	le
 8005d34:	f1c2 0c20 	rsble	ip, r2, #32
 8005d38:	fa01 f102 	lsl.w	r1, r1, r2
 8005d3c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8005d40:	bfdc      	itt	le
 8005d42:	ea41 010c 	orrle.w	r1, r1, ip
 8005d46:	4090      	lslle	r0, r2
 8005d48:	1ae4      	subs	r4, r4, r3
 8005d4a:	bfa2      	ittt	ge
 8005d4c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8005d50:	4329      	orrge	r1, r5
 8005d52:	bd30      	popge	{r4, r5, pc}
 8005d54:	ea6f 0404 	mvn.w	r4, r4
 8005d58:	3c1f      	subs	r4, #31
 8005d5a:	da1c      	bge.n	8005d96 <__adddf3+0x1d2>
 8005d5c:	340c      	adds	r4, #12
 8005d5e:	dc0e      	bgt.n	8005d7e <__adddf3+0x1ba>
 8005d60:	f104 0414 	add.w	r4, r4, #20
 8005d64:	f1c4 0220 	rsb	r2, r4, #32
 8005d68:	fa20 f004 	lsr.w	r0, r0, r4
 8005d6c:	fa01 f302 	lsl.w	r3, r1, r2
 8005d70:	ea40 0003 	orr.w	r0, r0, r3
 8005d74:	fa21 f304 	lsr.w	r3, r1, r4
 8005d78:	ea45 0103 	orr.w	r1, r5, r3
 8005d7c:	bd30      	pop	{r4, r5, pc}
 8005d7e:	f1c4 040c 	rsb	r4, r4, #12
 8005d82:	f1c4 0220 	rsb	r2, r4, #32
 8005d86:	fa20 f002 	lsr.w	r0, r0, r2
 8005d8a:	fa01 f304 	lsl.w	r3, r1, r4
 8005d8e:	ea40 0003 	orr.w	r0, r0, r3
 8005d92:	4629      	mov	r1, r5
 8005d94:	bd30      	pop	{r4, r5, pc}
 8005d96:	fa21 f004 	lsr.w	r0, r1, r4
 8005d9a:	4629      	mov	r1, r5
 8005d9c:	bd30      	pop	{r4, r5, pc}
 8005d9e:	f094 0f00 	teq	r4, #0
 8005da2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8005da6:	bf06      	itte	eq
 8005da8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8005dac:	3401      	addeq	r4, #1
 8005dae:	3d01      	subne	r5, #1
 8005db0:	e74e      	b.n	8005c50 <__adddf3+0x8c>
 8005db2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8005db6:	bf18      	it	ne
 8005db8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8005dbc:	d029      	beq.n	8005e12 <__adddf3+0x24e>
 8005dbe:	ea94 0f05 	teq	r4, r5
 8005dc2:	bf08      	it	eq
 8005dc4:	ea90 0f02 	teqeq	r0, r2
 8005dc8:	d005      	beq.n	8005dd6 <__adddf3+0x212>
 8005dca:	ea54 0c00 	orrs.w	ip, r4, r0
 8005dce:	bf04      	itt	eq
 8005dd0:	4619      	moveq	r1, r3
 8005dd2:	4610      	moveq	r0, r2
 8005dd4:	bd30      	pop	{r4, r5, pc}
 8005dd6:	ea91 0f03 	teq	r1, r3
 8005dda:	bf1e      	ittt	ne
 8005ddc:	2100      	movne	r1, #0
 8005dde:	2000      	movne	r0, #0
 8005de0:	bd30      	popne	{r4, r5, pc}
 8005de2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8005de6:	d105      	bne.n	8005df4 <__adddf3+0x230>
 8005de8:	0040      	lsls	r0, r0, #1
 8005dea:	4149      	adcs	r1, r1
 8005dec:	bf28      	it	cs
 8005dee:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8005df2:	bd30      	pop	{r4, r5, pc}
 8005df4:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8005df8:	bf3c      	itt	cc
 8005dfa:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8005dfe:	bd30      	popcc	{r4, r5, pc}
 8005e00:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8005e04:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8005e08:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8005e0c:	f04f 0000 	mov.w	r0, #0
 8005e10:	bd30      	pop	{r4, r5, pc}
 8005e12:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8005e16:	bf1a      	itte	ne
 8005e18:	4619      	movne	r1, r3
 8005e1a:	4610      	movne	r0, r2
 8005e1c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8005e20:	bf1c      	itt	ne
 8005e22:	460b      	movne	r3, r1
 8005e24:	4602      	movne	r2, r0
 8005e26:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8005e2a:	bf06      	itte	eq
 8005e2c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8005e30:	ea91 0f03 	teqeq	r1, r3
 8005e34:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8005e38:	bd30      	pop	{r4, r5, pc}
 8005e3a:	bf00      	nop

08005e3c <__aeabi_ui2d>:
 8005e3c:	f090 0f00 	teq	r0, #0
 8005e40:	bf04      	itt	eq
 8005e42:	2100      	moveq	r1, #0
 8005e44:	4770      	bxeq	lr
 8005e46:	b530      	push	{r4, r5, lr}
 8005e48:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8005e4c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8005e50:	f04f 0500 	mov.w	r5, #0
 8005e54:	f04f 0100 	mov.w	r1, #0
 8005e58:	e750      	b.n	8005cfc <__adddf3+0x138>
 8005e5a:	bf00      	nop

08005e5c <__aeabi_i2d>:
 8005e5c:	f090 0f00 	teq	r0, #0
 8005e60:	bf04      	itt	eq
 8005e62:	2100      	moveq	r1, #0
 8005e64:	4770      	bxeq	lr
 8005e66:	b530      	push	{r4, r5, lr}
 8005e68:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8005e6c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8005e70:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8005e74:	bf48      	it	mi
 8005e76:	4240      	negmi	r0, r0
 8005e78:	f04f 0100 	mov.w	r1, #0
 8005e7c:	e73e      	b.n	8005cfc <__adddf3+0x138>
 8005e7e:	bf00      	nop

08005e80 <__aeabi_f2d>:
 8005e80:	0042      	lsls	r2, r0, #1
 8005e82:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8005e86:	ea4f 0131 	mov.w	r1, r1, rrx
 8005e8a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8005e8e:	bf1f      	itttt	ne
 8005e90:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8005e94:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8005e98:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8005e9c:	4770      	bxne	lr
 8005e9e:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8005ea2:	bf08      	it	eq
 8005ea4:	4770      	bxeq	lr
 8005ea6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8005eaa:	bf04      	itt	eq
 8005eac:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8005eb0:	4770      	bxeq	lr
 8005eb2:	b530      	push	{r4, r5, lr}
 8005eb4:	f44f 7460 	mov.w	r4, #896	; 0x380
 8005eb8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8005ebc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8005ec0:	e71c      	b.n	8005cfc <__adddf3+0x138>
 8005ec2:	bf00      	nop

08005ec4 <__aeabi_ul2d>:
 8005ec4:	ea50 0201 	orrs.w	r2, r0, r1
 8005ec8:	bf08      	it	eq
 8005eca:	4770      	bxeq	lr
 8005ecc:	b530      	push	{r4, r5, lr}
 8005ece:	f04f 0500 	mov.w	r5, #0
 8005ed2:	e00a      	b.n	8005eea <__aeabi_l2d+0x16>

08005ed4 <__aeabi_l2d>:
 8005ed4:	ea50 0201 	orrs.w	r2, r0, r1
 8005ed8:	bf08      	it	eq
 8005eda:	4770      	bxeq	lr
 8005edc:	b530      	push	{r4, r5, lr}
 8005ede:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8005ee2:	d502      	bpl.n	8005eea <__aeabi_l2d+0x16>
 8005ee4:	4240      	negs	r0, r0
 8005ee6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8005eea:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8005eee:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8005ef2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8005ef6:	f43f aed8 	beq.w	8005caa <__adddf3+0xe6>
 8005efa:	f04f 0203 	mov.w	r2, #3
 8005efe:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8005f02:	bf18      	it	ne
 8005f04:	3203      	addne	r2, #3
 8005f06:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8005f0a:	bf18      	it	ne
 8005f0c:	3203      	addne	r2, #3
 8005f0e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8005f12:	f1c2 0320 	rsb	r3, r2, #32
 8005f16:	fa00 fc03 	lsl.w	ip, r0, r3
 8005f1a:	fa20 f002 	lsr.w	r0, r0, r2
 8005f1e:	fa01 fe03 	lsl.w	lr, r1, r3
 8005f22:	ea40 000e 	orr.w	r0, r0, lr
 8005f26:	fa21 f102 	lsr.w	r1, r1, r2
 8005f2a:	4414      	add	r4, r2
 8005f2c:	e6bd      	b.n	8005caa <__adddf3+0xe6>
 8005f2e:	bf00      	nop

08005f30 <__aeabi_dmul>:
 8005f30:	b570      	push	{r4, r5, r6, lr}
 8005f32:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8005f36:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8005f3a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8005f3e:	bf1d      	ittte	ne
 8005f40:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8005f44:	ea94 0f0c 	teqne	r4, ip
 8005f48:	ea95 0f0c 	teqne	r5, ip
 8005f4c:	f000 f8de 	bleq	800610c <__aeabi_dmul+0x1dc>
 8005f50:	442c      	add	r4, r5
 8005f52:	ea81 0603 	eor.w	r6, r1, r3
 8005f56:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8005f5a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8005f5e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8005f62:	bf18      	it	ne
 8005f64:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8005f68:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8005f6c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8005f70:	d038      	beq.n	8005fe4 <__aeabi_dmul+0xb4>
 8005f72:	fba0 ce02 	umull	ip, lr, r0, r2
 8005f76:	f04f 0500 	mov.w	r5, #0
 8005f7a:	fbe1 e502 	umlal	lr, r5, r1, r2
 8005f7e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8005f82:	fbe0 e503 	umlal	lr, r5, r0, r3
 8005f86:	f04f 0600 	mov.w	r6, #0
 8005f8a:	fbe1 5603 	umlal	r5, r6, r1, r3
 8005f8e:	f09c 0f00 	teq	ip, #0
 8005f92:	bf18      	it	ne
 8005f94:	f04e 0e01 	orrne.w	lr, lr, #1
 8005f98:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8005f9c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8005fa0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8005fa4:	d204      	bcs.n	8005fb0 <__aeabi_dmul+0x80>
 8005fa6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8005faa:	416d      	adcs	r5, r5
 8005fac:	eb46 0606 	adc.w	r6, r6, r6
 8005fb0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8005fb4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8005fb8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8005fbc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8005fc0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8005fc4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8005fc8:	bf88      	it	hi
 8005fca:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8005fce:	d81e      	bhi.n	800600e <__aeabi_dmul+0xde>
 8005fd0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8005fd4:	bf08      	it	eq
 8005fd6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8005fda:	f150 0000 	adcs.w	r0, r0, #0
 8005fde:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8005fe2:	bd70      	pop	{r4, r5, r6, pc}
 8005fe4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8005fe8:	ea46 0101 	orr.w	r1, r6, r1
 8005fec:	ea40 0002 	orr.w	r0, r0, r2
 8005ff0:	ea81 0103 	eor.w	r1, r1, r3
 8005ff4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8005ff8:	bfc2      	ittt	gt
 8005ffa:	ebd4 050c 	rsbsgt	r5, r4, ip
 8005ffe:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8006002:	bd70      	popgt	{r4, r5, r6, pc}
 8006004:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8006008:	f04f 0e00 	mov.w	lr, #0
 800600c:	3c01      	subs	r4, #1
 800600e:	f300 80ab 	bgt.w	8006168 <__aeabi_dmul+0x238>
 8006012:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8006016:	bfde      	ittt	le
 8006018:	2000      	movle	r0, #0
 800601a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800601e:	bd70      	pople	{r4, r5, r6, pc}
 8006020:	f1c4 0400 	rsb	r4, r4, #0
 8006024:	3c20      	subs	r4, #32
 8006026:	da35      	bge.n	8006094 <__aeabi_dmul+0x164>
 8006028:	340c      	adds	r4, #12
 800602a:	dc1b      	bgt.n	8006064 <__aeabi_dmul+0x134>
 800602c:	f104 0414 	add.w	r4, r4, #20
 8006030:	f1c4 0520 	rsb	r5, r4, #32
 8006034:	fa00 f305 	lsl.w	r3, r0, r5
 8006038:	fa20 f004 	lsr.w	r0, r0, r4
 800603c:	fa01 f205 	lsl.w	r2, r1, r5
 8006040:	ea40 0002 	orr.w	r0, r0, r2
 8006044:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8006048:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800604c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8006050:	fa21 f604 	lsr.w	r6, r1, r4
 8006054:	eb42 0106 	adc.w	r1, r2, r6
 8006058:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800605c:	bf08      	it	eq
 800605e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8006062:	bd70      	pop	{r4, r5, r6, pc}
 8006064:	f1c4 040c 	rsb	r4, r4, #12
 8006068:	f1c4 0520 	rsb	r5, r4, #32
 800606c:	fa00 f304 	lsl.w	r3, r0, r4
 8006070:	fa20 f005 	lsr.w	r0, r0, r5
 8006074:	fa01 f204 	lsl.w	r2, r1, r4
 8006078:	ea40 0002 	orr.w	r0, r0, r2
 800607c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8006080:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8006084:	f141 0100 	adc.w	r1, r1, #0
 8006088:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800608c:	bf08      	it	eq
 800608e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8006092:	bd70      	pop	{r4, r5, r6, pc}
 8006094:	f1c4 0520 	rsb	r5, r4, #32
 8006098:	fa00 f205 	lsl.w	r2, r0, r5
 800609c:	ea4e 0e02 	orr.w	lr, lr, r2
 80060a0:	fa20 f304 	lsr.w	r3, r0, r4
 80060a4:	fa01 f205 	lsl.w	r2, r1, r5
 80060a8:	ea43 0302 	orr.w	r3, r3, r2
 80060ac:	fa21 f004 	lsr.w	r0, r1, r4
 80060b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80060b4:	fa21 f204 	lsr.w	r2, r1, r4
 80060b8:	ea20 0002 	bic.w	r0, r0, r2
 80060bc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80060c0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80060c4:	bf08      	it	eq
 80060c6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80060ca:	bd70      	pop	{r4, r5, r6, pc}
 80060cc:	f094 0f00 	teq	r4, #0
 80060d0:	d10f      	bne.n	80060f2 <__aeabi_dmul+0x1c2>
 80060d2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80060d6:	0040      	lsls	r0, r0, #1
 80060d8:	eb41 0101 	adc.w	r1, r1, r1
 80060dc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80060e0:	bf08      	it	eq
 80060e2:	3c01      	subeq	r4, #1
 80060e4:	d0f7      	beq.n	80060d6 <__aeabi_dmul+0x1a6>
 80060e6:	ea41 0106 	orr.w	r1, r1, r6
 80060ea:	f095 0f00 	teq	r5, #0
 80060ee:	bf18      	it	ne
 80060f0:	4770      	bxne	lr
 80060f2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80060f6:	0052      	lsls	r2, r2, #1
 80060f8:	eb43 0303 	adc.w	r3, r3, r3
 80060fc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8006100:	bf08      	it	eq
 8006102:	3d01      	subeq	r5, #1
 8006104:	d0f7      	beq.n	80060f6 <__aeabi_dmul+0x1c6>
 8006106:	ea43 0306 	orr.w	r3, r3, r6
 800610a:	4770      	bx	lr
 800610c:	ea94 0f0c 	teq	r4, ip
 8006110:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8006114:	bf18      	it	ne
 8006116:	ea95 0f0c 	teqne	r5, ip
 800611a:	d00c      	beq.n	8006136 <__aeabi_dmul+0x206>
 800611c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8006120:	bf18      	it	ne
 8006122:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8006126:	d1d1      	bne.n	80060cc <__aeabi_dmul+0x19c>
 8006128:	ea81 0103 	eor.w	r1, r1, r3
 800612c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8006130:	f04f 0000 	mov.w	r0, #0
 8006134:	bd70      	pop	{r4, r5, r6, pc}
 8006136:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800613a:	bf06      	itte	eq
 800613c:	4610      	moveq	r0, r2
 800613e:	4619      	moveq	r1, r3
 8006140:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8006144:	d019      	beq.n	800617a <__aeabi_dmul+0x24a>
 8006146:	ea94 0f0c 	teq	r4, ip
 800614a:	d102      	bne.n	8006152 <__aeabi_dmul+0x222>
 800614c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8006150:	d113      	bne.n	800617a <__aeabi_dmul+0x24a>
 8006152:	ea95 0f0c 	teq	r5, ip
 8006156:	d105      	bne.n	8006164 <__aeabi_dmul+0x234>
 8006158:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800615c:	bf1c      	itt	ne
 800615e:	4610      	movne	r0, r2
 8006160:	4619      	movne	r1, r3
 8006162:	d10a      	bne.n	800617a <__aeabi_dmul+0x24a>
 8006164:	ea81 0103 	eor.w	r1, r1, r3
 8006168:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800616c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8006170:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8006174:	f04f 0000 	mov.w	r0, #0
 8006178:	bd70      	pop	{r4, r5, r6, pc}
 800617a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800617e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8006182:	bd70      	pop	{r4, r5, r6, pc}

08006184 <__aeabi_ddiv>:
 8006184:	b570      	push	{r4, r5, r6, lr}
 8006186:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800618a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800618e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8006192:	bf1d      	ittte	ne
 8006194:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8006198:	ea94 0f0c 	teqne	r4, ip
 800619c:	ea95 0f0c 	teqne	r5, ip
 80061a0:	f000 f8a7 	bleq	80062f2 <__aeabi_ddiv+0x16e>
 80061a4:	eba4 0405 	sub.w	r4, r4, r5
 80061a8:	ea81 0e03 	eor.w	lr, r1, r3
 80061ac:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80061b0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80061b4:	f000 8088 	beq.w	80062c8 <__aeabi_ddiv+0x144>
 80061b8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80061bc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80061c0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80061c4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80061c8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80061cc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80061d0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80061d4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80061d8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80061dc:	429d      	cmp	r5, r3
 80061de:	bf08      	it	eq
 80061e0:	4296      	cmpeq	r6, r2
 80061e2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80061e6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80061ea:	d202      	bcs.n	80061f2 <__aeabi_ddiv+0x6e>
 80061ec:	085b      	lsrs	r3, r3, #1
 80061ee:	ea4f 0232 	mov.w	r2, r2, rrx
 80061f2:	1ab6      	subs	r6, r6, r2
 80061f4:	eb65 0503 	sbc.w	r5, r5, r3
 80061f8:	085b      	lsrs	r3, r3, #1
 80061fa:	ea4f 0232 	mov.w	r2, r2, rrx
 80061fe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8006202:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8006206:	ebb6 0e02 	subs.w	lr, r6, r2
 800620a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800620e:	bf22      	ittt	cs
 8006210:	1ab6      	subcs	r6, r6, r2
 8006212:	4675      	movcs	r5, lr
 8006214:	ea40 000c 	orrcs.w	r0, r0, ip
 8006218:	085b      	lsrs	r3, r3, #1
 800621a:	ea4f 0232 	mov.w	r2, r2, rrx
 800621e:	ebb6 0e02 	subs.w	lr, r6, r2
 8006222:	eb75 0e03 	sbcs.w	lr, r5, r3
 8006226:	bf22      	ittt	cs
 8006228:	1ab6      	subcs	r6, r6, r2
 800622a:	4675      	movcs	r5, lr
 800622c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8006230:	085b      	lsrs	r3, r3, #1
 8006232:	ea4f 0232 	mov.w	r2, r2, rrx
 8006236:	ebb6 0e02 	subs.w	lr, r6, r2
 800623a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800623e:	bf22      	ittt	cs
 8006240:	1ab6      	subcs	r6, r6, r2
 8006242:	4675      	movcs	r5, lr
 8006244:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8006248:	085b      	lsrs	r3, r3, #1
 800624a:	ea4f 0232 	mov.w	r2, r2, rrx
 800624e:	ebb6 0e02 	subs.w	lr, r6, r2
 8006252:	eb75 0e03 	sbcs.w	lr, r5, r3
 8006256:	bf22      	ittt	cs
 8006258:	1ab6      	subcs	r6, r6, r2
 800625a:	4675      	movcs	r5, lr
 800625c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8006260:	ea55 0e06 	orrs.w	lr, r5, r6
 8006264:	d018      	beq.n	8006298 <__aeabi_ddiv+0x114>
 8006266:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800626a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800626e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8006272:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8006276:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800627a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800627e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8006282:	d1c0      	bne.n	8006206 <__aeabi_ddiv+0x82>
 8006284:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8006288:	d10b      	bne.n	80062a2 <__aeabi_ddiv+0x11e>
 800628a:	ea41 0100 	orr.w	r1, r1, r0
 800628e:	f04f 0000 	mov.w	r0, #0
 8006292:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8006296:	e7b6      	b.n	8006206 <__aeabi_ddiv+0x82>
 8006298:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800629c:	bf04      	itt	eq
 800629e:	4301      	orreq	r1, r0
 80062a0:	2000      	moveq	r0, #0
 80062a2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80062a6:	bf88      	it	hi
 80062a8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80062ac:	f63f aeaf 	bhi.w	800600e <__aeabi_dmul+0xde>
 80062b0:	ebb5 0c03 	subs.w	ip, r5, r3
 80062b4:	bf04      	itt	eq
 80062b6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80062ba:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80062be:	f150 0000 	adcs.w	r0, r0, #0
 80062c2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80062c6:	bd70      	pop	{r4, r5, r6, pc}
 80062c8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80062cc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80062d0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80062d4:	bfc2      	ittt	gt
 80062d6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80062da:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80062de:	bd70      	popgt	{r4, r5, r6, pc}
 80062e0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80062e4:	f04f 0e00 	mov.w	lr, #0
 80062e8:	3c01      	subs	r4, #1
 80062ea:	e690      	b.n	800600e <__aeabi_dmul+0xde>
 80062ec:	ea45 0e06 	orr.w	lr, r5, r6
 80062f0:	e68d      	b.n	800600e <__aeabi_dmul+0xde>
 80062f2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80062f6:	ea94 0f0c 	teq	r4, ip
 80062fa:	bf08      	it	eq
 80062fc:	ea95 0f0c 	teqeq	r5, ip
 8006300:	f43f af3b 	beq.w	800617a <__aeabi_dmul+0x24a>
 8006304:	ea94 0f0c 	teq	r4, ip
 8006308:	d10a      	bne.n	8006320 <__aeabi_ddiv+0x19c>
 800630a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800630e:	f47f af34 	bne.w	800617a <__aeabi_dmul+0x24a>
 8006312:	ea95 0f0c 	teq	r5, ip
 8006316:	f47f af25 	bne.w	8006164 <__aeabi_dmul+0x234>
 800631a:	4610      	mov	r0, r2
 800631c:	4619      	mov	r1, r3
 800631e:	e72c      	b.n	800617a <__aeabi_dmul+0x24a>
 8006320:	ea95 0f0c 	teq	r5, ip
 8006324:	d106      	bne.n	8006334 <__aeabi_ddiv+0x1b0>
 8006326:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800632a:	f43f aefd 	beq.w	8006128 <__aeabi_dmul+0x1f8>
 800632e:	4610      	mov	r0, r2
 8006330:	4619      	mov	r1, r3
 8006332:	e722      	b.n	800617a <__aeabi_dmul+0x24a>
 8006334:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8006338:	bf18      	it	ne
 800633a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800633e:	f47f aec5 	bne.w	80060cc <__aeabi_dmul+0x19c>
 8006342:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8006346:	f47f af0d 	bne.w	8006164 <__aeabi_dmul+0x234>
 800634a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800634e:	f47f aeeb 	bne.w	8006128 <__aeabi_dmul+0x1f8>
 8006352:	e712      	b.n	800617a <__aeabi_dmul+0x24a>

08006354 <__gedf2>:
 8006354:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8006358:	e006      	b.n	8006368 <__cmpdf2+0x4>
 800635a:	bf00      	nop

0800635c <__ledf2>:
 800635c:	f04f 0c01 	mov.w	ip, #1
 8006360:	e002      	b.n	8006368 <__cmpdf2+0x4>
 8006362:	bf00      	nop

08006364 <__cmpdf2>:
 8006364:	f04f 0c01 	mov.w	ip, #1
 8006368:	f84d cd04 	str.w	ip, [sp, #-4]!
 800636c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8006370:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8006374:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8006378:	bf18      	it	ne
 800637a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800637e:	d01b      	beq.n	80063b8 <__cmpdf2+0x54>
 8006380:	b001      	add	sp, #4
 8006382:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8006386:	bf0c      	ite	eq
 8006388:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800638c:	ea91 0f03 	teqne	r1, r3
 8006390:	bf02      	ittt	eq
 8006392:	ea90 0f02 	teqeq	r0, r2
 8006396:	2000      	moveq	r0, #0
 8006398:	4770      	bxeq	lr
 800639a:	f110 0f00 	cmn.w	r0, #0
 800639e:	ea91 0f03 	teq	r1, r3
 80063a2:	bf58      	it	pl
 80063a4:	4299      	cmppl	r1, r3
 80063a6:	bf08      	it	eq
 80063a8:	4290      	cmpeq	r0, r2
 80063aa:	bf2c      	ite	cs
 80063ac:	17d8      	asrcs	r0, r3, #31
 80063ae:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80063b2:	f040 0001 	orr.w	r0, r0, #1
 80063b6:	4770      	bx	lr
 80063b8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80063bc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80063c0:	d102      	bne.n	80063c8 <__cmpdf2+0x64>
 80063c2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80063c6:	d107      	bne.n	80063d8 <__cmpdf2+0x74>
 80063c8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80063cc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80063d0:	d1d6      	bne.n	8006380 <__cmpdf2+0x1c>
 80063d2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80063d6:	d0d3      	beq.n	8006380 <__cmpdf2+0x1c>
 80063d8:	f85d 0b04 	ldr.w	r0, [sp], #4
 80063dc:	4770      	bx	lr
 80063de:	bf00      	nop

080063e0 <__aeabi_cdrcmple>:
 80063e0:	4684      	mov	ip, r0
 80063e2:	4610      	mov	r0, r2
 80063e4:	4662      	mov	r2, ip
 80063e6:	468c      	mov	ip, r1
 80063e8:	4619      	mov	r1, r3
 80063ea:	4663      	mov	r3, ip
 80063ec:	e000      	b.n	80063f0 <__aeabi_cdcmpeq>
 80063ee:	bf00      	nop

080063f0 <__aeabi_cdcmpeq>:
 80063f0:	b501      	push	{r0, lr}
 80063f2:	f7ff ffb7 	bl	8006364 <__cmpdf2>
 80063f6:	2800      	cmp	r0, #0
 80063f8:	bf48      	it	mi
 80063fa:	f110 0f00 	cmnmi.w	r0, #0
 80063fe:	bd01      	pop	{r0, pc}

08006400 <__aeabi_dcmpeq>:
 8006400:	f84d ed08 	str.w	lr, [sp, #-8]!
 8006404:	f7ff fff4 	bl	80063f0 <__aeabi_cdcmpeq>
 8006408:	bf0c      	ite	eq
 800640a:	2001      	moveq	r0, #1
 800640c:	2000      	movne	r0, #0
 800640e:	f85d fb08 	ldr.w	pc, [sp], #8
 8006412:	bf00      	nop

08006414 <__aeabi_dcmplt>:
 8006414:	f84d ed08 	str.w	lr, [sp, #-8]!
 8006418:	f7ff ffea 	bl	80063f0 <__aeabi_cdcmpeq>
 800641c:	bf34      	ite	cc
 800641e:	2001      	movcc	r0, #1
 8006420:	2000      	movcs	r0, #0
 8006422:	f85d fb08 	ldr.w	pc, [sp], #8
 8006426:	bf00      	nop

08006428 <__aeabi_dcmple>:
 8006428:	f84d ed08 	str.w	lr, [sp, #-8]!
 800642c:	f7ff ffe0 	bl	80063f0 <__aeabi_cdcmpeq>
 8006430:	bf94      	ite	ls
 8006432:	2001      	movls	r0, #1
 8006434:	2000      	movhi	r0, #0
 8006436:	f85d fb08 	ldr.w	pc, [sp], #8
 800643a:	bf00      	nop

0800643c <__aeabi_dcmpge>:
 800643c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8006440:	f7ff ffce 	bl	80063e0 <__aeabi_cdrcmple>
 8006444:	bf94      	ite	ls
 8006446:	2001      	movls	r0, #1
 8006448:	2000      	movhi	r0, #0
 800644a:	f85d fb08 	ldr.w	pc, [sp], #8
 800644e:	bf00      	nop

08006450 <__aeabi_dcmpgt>:
 8006450:	f84d ed08 	str.w	lr, [sp, #-8]!
 8006454:	f7ff ffc4 	bl	80063e0 <__aeabi_cdrcmple>
 8006458:	bf34      	ite	cc
 800645a:	2001      	movcc	r0, #1
 800645c:	2000      	movcs	r0, #0
 800645e:	f85d fb08 	ldr.w	pc, [sp], #8
 8006462:	bf00      	nop

08006464 <__aeabi_d2iz>:
 8006464:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8006468:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800646c:	d215      	bcs.n	800649a <__aeabi_d2iz+0x36>
 800646e:	d511      	bpl.n	8006494 <__aeabi_d2iz+0x30>
 8006470:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8006474:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8006478:	d912      	bls.n	80064a0 <__aeabi_d2iz+0x3c>
 800647a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800647e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8006482:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8006486:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800648a:	fa23 f002 	lsr.w	r0, r3, r2
 800648e:	bf18      	it	ne
 8006490:	4240      	negne	r0, r0
 8006492:	4770      	bx	lr
 8006494:	f04f 0000 	mov.w	r0, #0
 8006498:	4770      	bx	lr
 800649a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800649e:	d105      	bne.n	80064ac <__aeabi_d2iz+0x48>
 80064a0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80064a4:	bf08      	it	eq
 80064a6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80064aa:	4770      	bx	lr
 80064ac:	f04f 0000 	mov.w	r0, #0
 80064b0:	4770      	bx	lr
 80064b2:	bf00      	nop

080064b4 <__aeabi_d2uiz>:
 80064b4:	004a      	lsls	r2, r1, #1
 80064b6:	d211      	bcs.n	80064dc <__aeabi_d2uiz+0x28>
 80064b8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80064bc:	d211      	bcs.n	80064e2 <__aeabi_d2uiz+0x2e>
 80064be:	d50d      	bpl.n	80064dc <__aeabi_d2uiz+0x28>
 80064c0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80064c4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80064c8:	d40e      	bmi.n	80064e8 <__aeabi_d2uiz+0x34>
 80064ca:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80064ce:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80064d2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80064d6:	fa23 f002 	lsr.w	r0, r3, r2
 80064da:	4770      	bx	lr
 80064dc:	f04f 0000 	mov.w	r0, #0
 80064e0:	4770      	bx	lr
 80064e2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80064e6:	d102      	bne.n	80064ee <__aeabi_d2uiz+0x3a>
 80064e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80064ec:	4770      	bx	lr
 80064ee:	f04f 0000 	mov.w	r0, #0
 80064f2:	4770      	bx	lr

080064f4 <__aeabi_d2lz>:
 80064f4:	b538      	push	{r3, r4, r5, lr}
 80064f6:	2200      	movs	r2, #0
 80064f8:	2300      	movs	r3, #0
 80064fa:	4604      	mov	r4, r0
 80064fc:	460d      	mov	r5, r1
 80064fe:	f7ff ff89 	bl	8006414 <__aeabi_dcmplt>
 8006502:	b928      	cbnz	r0, 8006510 <__aeabi_d2lz+0x1c>
 8006504:	4620      	mov	r0, r4
 8006506:	4629      	mov	r1, r5
 8006508:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800650c:	f000 b80a 	b.w	8006524 <__aeabi_d2ulz>
 8006510:	4620      	mov	r0, r4
 8006512:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 8006516:	f000 f805 	bl	8006524 <__aeabi_d2ulz>
 800651a:	4240      	negs	r0, r0
 800651c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8006520:	bd38      	pop	{r3, r4, r5, pc}
 8006522:	bf00      	nop

08006524 <__aeabi_d2ulz>:
 8006524:	b5d0      	push	{r4, r6, r7, lr}
 8006526:	4b0c      	ldr	r3, [pc, #48]	; (8006558 <__aeabi_d2ulz+0x34>)
 8006528:	2200      	movs	r2, #0
 800652a:	4606      	mov	r6, r0
 800652c:	460f      	mov	r7, r1
 800652e:	f7ff fcff 	bl	8005f30 <__aeabi_dmul>
 8006532:	f7ff ffbf 	bl	80064b4 <__aeabi_d2uiz>
 8006536:	4604      	mov	r4, r0
 8006538:	f7ff fc80 	bl	8005e3c <__aeabi_ui2d>
 800653c:	4b07      	ldr	r3, [pc, #28]	; (800655c <__aeabi_d2ulz+0x38>)
 800653e:	2200      	movs	r2, #0
 8006540:	f7ff fcf6 	bl	8005f30 <__aeabi_dmul>
 8006544:	4602      	mov	r2, r0
 8006546:	460b      	mov	r3, r1
 8006548:	4630      	mov	r0, r6
 800654a:	4639      	mov	r1, r7
 800654c:	f7ff fb38 	bl	8005bc0 <__aeabi_dsub>
 8006550:	f7ff ffb0 	bl	80064b4 <__aeabi_d2uiz>
 8006554:	4621      	mov	r1, r4
 8006556:	bdd0      	pop	{r4, r6, r7, pc}
 8006558:	3df00000 	.word	0x3df00000
 800655c:	41f00000 	.word	0x41f00000

08006560 <LL_C2_PWR_SetPowerMode>:
  *
  *         (*) Not available on devices STM32WB15xx, STM32WB10xx, STM32WB1Mxx
  * @retval None
  */
__STATIC_INLINE void LL_C2_PWR_SetPowerMode(uint32_t LowPowerMode)
{
 8006560:	b480      	push	{r7}
 8006562:	b083      	sub	sp, #12
 8006564:	af00      	add	r7, sp, #0
 8006566:	6078      	str	r0, [r7, #4]
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, LowPowerMode);
 8006568:	4b07      	ldr	r3, [pc, #28]	; (8006588 <LL_C2_PWR_SetPowerMode+0x28>)
 800656a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800656e:	f023 0207 	bic.w	r2, r3, #7
 8006572:	4905      	ldr	r1, [pc, #20]	; (8006588 <LL_C2_PWR_SetPowerMode+0x28>)
 8006574:	687b      	ldr	r3, [r7, #4]
 8006576:	4313      	orrs	r3, r2
 8006578:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 800657c:	bf00      	nop
 800657e:	370c      	adds	r7, #12
 8006580:	46bd      	mov	sp, r7
 8006582:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006586:	4770      	bx	lr
 8006588:	58000400 	.word	0x58000400

0800658c <LL_EXTI_EnableIT_32_63>:
  *         @arg @ref LL_EXTI_LINE_ALL_32_63
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
 800658c:	b480      	push	{r7}
 800658e:	b083      	sub	sp, #12
 8006590:	af00      	add	r7, sp, #0
 8006592:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR2, ExtiLine);
 8006594:	4b06      	ldr	r3, [pc, #24]	; (80065b0 <LL_EXTI_EnableIT_32_63+0x24>)
 8006596:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800659a:	4905      	ldr	r1, [pc, #20]	; (80065b0 <LL_EXTI_EnableIT_32_63+0x24>)
 800659c:	687b      	ldr	r3, [r7, #4]
 800659e:	4313      	orrs	r3, r2
 80065a0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 80065a4:	bf00      	nop
 80065a6:	370c      	adds	r7, #12
 80065a8:	46bd      	mov	sp, r7
 80065aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80065ae:	4770      	bx	lr
 80065b0:	58000800 	.word	0x58000800

080065b4 <LL_C2_EXTI_EnableIT_32_63>:
  *         @arg @ref LL_EXTI_LINE_ALL_32_63
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_C2_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
 80065b4:	b480      	push	{r7}
 80065b6:	b083      	sub	sp, #12
 80065b8:	af00      	add	r7, sp, #0
 80065ba:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 80065bc:	4b06      	ldr	r3, [pc, #24]	; (80065d8 <LL_C2_EXTI_EnableIT_32_63+0x24>)
 80065be:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 80065c2:	4905      	ldr	r1, [pc, #20]	; (80065d8 <LL_C2_EXTI_EnableIT_32_63+0x24>)
 80065c4:	687b      	ldr	r3, [r7, #4]
 80065c6:	4313      	orrs	r3, r2
 80065c8:	f8c1 30d0 	str.w	r3, [r1, #208]	; 0xd0
}
 80065cc:	bf00      	nop
 80065ce:	370c      	adds	r7, #12
 80065d0:	46bd      	mov	sp, r7
 80065d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80065d6:	4770      	bx	lr
 80065d8:	58000800 	.word	0x58000800

080065dc <LL_RCC_SetClkAfterWakeFromStop>:
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_MSI
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
{
 80065dc:	b480      	push	{r7}
 80065de:	b083      	sub	sp, #12
 80065e0:	af00      	add	r7, sp, #0
 80065e2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 80065e4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80065e8:	689b      	ldr	r3, [r3, #8]
 80065ea:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 80065ee:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80065f2:	687b      	ldr	r3, [r7, #4]
 80065f4:	4313      	orrs	r3, r2
 80065f6:	608b      	str	r3, [r1, #8]
}
 80065f8:	bf00      	nop
 80065fa:	370c      	adds	r7, #12
 80065fc:	46bd      	mov	sp, r7
 80065fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006602:	4770      	bx	lr

08006604 <APPE_Init>:
EXTI_HandleTypeDef exti_handle;
/* USER CODE END PFP */

/* Functions Definition ------------------------------------------------------*/
void APPE_Init( void )
{
 8006604:	b580      	push	{r7, lr}
 8006606:	af00      	add	r7, sp, #0
    SystemPower_Config(); /**< Configure the system Power Mode */
 8006608:	f000 f826 	bl	8006658 <SystemPower_Config>

    HW_TS_Init(hw_ts_InitMode_Full, &hrtc); /**< Initialize the TimerServer */
 800660c:	4909      	ldr	r1, [pc, #36]	; (8006634 <APPE_Init+0x30>)
 800660e:	2000      	movs	r0, #0
 8006610:	f000 fdec 	bl	80071ec <HW_TS_Init>

    Init_Debug();
 8006614:	f000 f810 	bl	8006638 <Init_Debug>
    /**
     * The Standby mode should not be entered before the initialization is over
     * The default state of the Low Power Manager is to allow the Standby Mode so an request is needed here
     */
    UTIL_LPM_SetOffMode(1 << CFG_LPM_APP, UTIL_LPM_DISABLE);
 8006618:	2101      	movs	r1, #1
 800661a:	2001      	movs	r0, #1
 800661c:	f011 fa86 	bl	8017b2c <UTIL_LPM_SetOffMode>
    Led_Init();
 8006620:	f000 f8ba 	bl	8006798 <Led_Init>
    Button_Init();
 8006624:	f000 f8c5 	bl	80067b2 <Button_Init>
    RxUART_Init();
 8006628:	f000 f95a 	bl	80068e0 <RxUART_Init>
    appe_Tl_Init(); /* Initialize all transport layers */
 800662c:	f000 f824 	bl	8006678 <appe_Tl_Init>
     * From now, the application is waiting for the ready event ( VS_HCI_C2_Ready )
     * received on the system channel before starting the Zigbee Stack
     * This system event is received with APPE_SysUserEvtRx()
     */

    return;
 8006630:	bf00      	nop
}
 8006632:	bd80      	pop	{r7, pc}
 8006634:	20000d4c 	.word	0x20000d4c

08006638 <Init_Debug>:
 *
 * LOCAL FUNCTIONS
 *
 *************************************************************/
static void Init_Debug( void )
{
 8006638:	b580      	push	{r7, lr}
 800663a:	af00      	add	r7, sp, #0
#if (CFG_DEBUGGER_SUPPORTED == 1)
  /**
   * Keep debugger enabled while in any low power mode
   */
  HAL_DBGMCU_EnableDBGSleepMode();
 800663c:	f002 ffae 	bl	800959c <HAL_DBGMCU_EnableDBGSleepMode>

  /***************** ENABLE DEBUGGER *************************************/
  LL_EXTI_EnableIT_32_63(LL_EXTI_LINE_48);
 8006640:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8006644:	f7ff ffa2 	bl	800658c <LL_EXTI_EnableIT_32_63>
  LL_C2_EXTI_EnableIT_32_63(LL_EXTI_LINE_48);
 8006648:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800664c:	f7ff ffb2 	bl	80065b4 <LL_C2_EXTI_EnableIT_32_63>
  HAL_DBGMCU_DisableDBGStandbyMode();

#endif /* (CFG_DEBUGGER_SUPPORTED == 1) */

#if(CFG_DEBUG_TRACE != 0)
  DbgTraceInit();
 8006650:	f00e f858 	bl	8014704 <DbgTraceInit>
#endif

  return;
 8006654:	bf00      	nop
}
 8006656:	bd80      	pop	{r7, pc}

08006658 <SystemPower_Config>:
 *
 * @param  None
 * @retval None
 */
static void SystemPower_Config(void)
{
 8006658:	b580      	push	{r7, lr}
 800665a:	af00      	add	r7, sp, #0

  /**
   * Select HSI as system clock source after Wake Up from Stop mode
   */
  LL_RCC_SetClkAfterWakeFromStop(LL_RCC_STOP_WAKEUPCLOCK_HSI);
 800665c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006660:	f7ff ffbc 	bl	80065dc <LL_RCC_SetClkAfterWakeFromStop>

  /* Initialize low power manager */
  UTIL_LPM_Init();
 8006664:	f011 fa50 	bl	8017b08 <UTIL_LPM_Init>
  /* Initialize the CPU2 reset value before starting CPU2 with C2BOOT */
  LL_C2_PWR_SetPowerMode(LL_PWR_MODE_SHUTDOWN);
 8006668:	2004      	movs	r0, #4
 800666a:	f7ff ff79 	bl	8006560 <LL_C2_PWR_SetPowerMode>

#if (CFG_USB_INTERFACE_ENABLE != 0)
  /**
   *  Enable USB power
   */
  HAL_PWREx_EnableVddUSB();
 800666e:	f005 fb05 	bl	800bc7c <HAL_PWREx_EnableVddUSB>
#endif

  return;
 8006672:	bf00      	nop
}
 8006674:	bd80      	pop	{r7, pc}
	...

08006678 <appe_Tl_Init>:

static void appe_Tl_Init( void )
{
 8006678:	b580      	push	{r7, lr}
 800667a:	b088      	sub	sp, #32
 800667c:	af00      	add	r7, sp, #0
  TL_MM_Config_t tl_mm_config;
  SHCI_TL_HciInitConf_t SHci_Tl_Init_Conf;
  /**< Reference table initialization */
  TL_Init();
 800667e:	f00d f947 	bl	8013910 <TL_Init>

  /**< System channel initialization */
  UTIL_SEQ_RegTask( 1<< CFG_TASK_SYSTEM_HCI_ASYNCH_EVT, UTIL_SEQ_RFU, shci_user_evt_proc );
 8006682:	4a14      	ldr	r2, [pc, #80]	; (80066d4 <appe_Tl_Init+0x5c>)
 8006684:	2100      	movs	r1, #0
 8006686:	2004      	movs	r0, #4
 8006688:	f011 fb7c 	bl	8017d84 <UTIL_SEQ_RegTask>
  SHci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&SystemCmdBuffer;
 800668c:	4b12      	ldr	r3, [pc, #72]	; (80066d8 <appe_Tl_Init+0x60>)
 800668e:	603b      	str	r3, [r7, #0]
  SHci_Tl_Init_Conf.StatusNotCallBack = APPE_SysStatusNot;
 8006690:	4b12      	ldr	r3, [pc, #72]	; (80066dc <appe_Tl_Init+0x64>)
 8006692:	607b      	str	r3, [r7, #4]
  shci_init(APPE_SysUserEvtRx, (void*) &SHci_Tl_Init_Conf);
 8006694:	463b      	mov	r3, r7
 8006696:	4619      	mov	r1, r3
 8006698:	4811      	ldr	r0, [pc, #68]	; (80066e0 <appe_Tl_Init+0x68>)
 800669a:	f00c fffb 	bl	8013694 <shci_init>

  /**< Memory Manager channel initialization */
  memset(&tl_mm_config, 0, sizeof(TL_MM_Config_t));
 800669e:	f107 0308 	add.w	r3, r7, #8
 80066a2:	2218      	movs	r2, #24
 80066a4:	2100      	movs	r1, #0
 80066a6:	4618      	mov	r0, r3
 80066a8:	f011 feda 	bl	8018460 <memset>
  tl_mm_config.p_BleSpareEvtBuffer = 0;
 80066ac:	2300      	movs	r3, #0
 80066ae:	60bb      	str	r3, [r7, #8]
  tl_mm_config.p_SystemSpareEvtBuffer = SystemSpareEvtBuffer;
 80066b0:	4b0c      	ldr	r3, [pc, #48]	; (80066e4 <appe_Tl_Init+0x6c>)
 80066b2:	60fb      	str	r3, [r7, #12]
  tl_mm_config.p_AsynchEvtPool = EvtPool;
 80066b4:	4b0c      	ldr	r3, [pc, #48]	; (80066e8 <appe_Tl_Init+0x70>)
 80066b6:	613b      	str	r3, [r7, #16]
  tl_mm_config.AsynchEvtPoolSize = POOL_SIZE;
 80066b8:	f240 533c 	movw	r3, #1340	; 0x53c
 80066bc:	617b      	str	r3, [r7, #20]
  TL_MM_Init( &tl_mm_config );
 80066be:	f107 0308 	add.w	r3, r7, #8
 80066c2:	4618      	mov	r0, r3
 80066c4:	f00d fa80 	bl	8013bc8 <TL_MM_Init>

  TL_Enable();
 80066c8:	f00d f91c 	bl	8013904 <TL_Enable>

  return;
 80066cc:	bf00      	nop
}
 80066ce:	3720      	adds	r7, #32
 80066d0:	46bd      	mov	sp, r7
 80066d2:	bd80      	pop	{r7, pc}
 80066d4:	080136cd 	.word	0x080136cd
 80066d8:	20030620 	.word	0x20030620
 80066dc:	080066ed 	.word	0x080066ed
 80066e0:	08006703 	.word	0x08006703
 80066e4:	2003072c 	.word	0x2003072c
 80066e8:	200300e4 	.word	0x200300e4

080066ec <APPE_SysStatusNot>:


static void APPE_SysStatusNot(SHCI_TL_CmdStatus_t status)
{
 80066ec:	b480      	push	{r7}
 80066ee:	b083      	sub	sp, #12
 80066f0:	af00      	add	r7, sp, #0
 80066f2:	4603      	mov	r3, r0
 80066f4:	71fb      	strb	r3, [r7, #7]
    UNUSED(status);
    return;
 80066f6:	bf00      	nop
}
 80066f8:	370c      	adds	r7, #12
 80066fa:	46bd      	mov	sp, r7
 80066fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006700:	4770      	bx	lr

08006702 <APPE_SysUserEvtRx>:
 * The buffer shall not be released
 * ( eg ((tSHCI_UserEvtRxParam*)pPayload)->status shall be set to SHCI_TL_UserEventFlow_Disable )
 * When the status is not filled, the buffer is released by default
 */
static void APPE_SysUserEvtRx( void * pPayload )
{
 8006702:	b580      	push	{r7, lr}
 8006704:	b084      	sub	sp, #16
 8006706:	af00      	add	r7, sp, #0
 8006708:	6078      	str	r0, [r7, #4]
  TL_AsynchEvt_t *p_sys_event;
  p_sys_event = (TL_AsynchEvt_t*)(((tSHCI_UserEvtRxParam*)pPayload)->pckt->evtserial.evt.payload);
 800670a:	687b      	ldr	r3, [r7, #4]
 800670c:	685b      	ldr	r3, [r3, #4]
 800670e:	330b      	adds	r3, #11
 8006710:	60fb      	str	r3, [r7, #12]

  switch(p_sys_event->subevtcode)
 8006712:	68fb      	ldr	r3, [r7, #12]
 8006714:	881b      	ldrh	r3, [r3, #0]
 8006716:	b29b      	uxth	r3, r3
 8006718:	f5b3 4f12 	cmp.w	r3, #37376	; 0x9200
 800671c:	d004      	beq.n	8006728 <APPE_SysUserEvtRx+0x26>
 800671e:	f249 2201 	movw	r2, #37377	; 0x9201
 8006722:	4293      	cmp	r3, r2
 8006724:	d003      	beq.n	800672e <APPE_SysUserEvtRx+0x2c>
         break;
     case SHCI_SUB_EVT_ERROR_NOTIF:
         APPE_SysEvtError((SCHI_SystemErrCode_t) (p_sys_event->payload[0]));
         break;
     default:
         break;
 8006726:	e008      	b.n	800673a <APPE_SysUserEvtRx+0x38>
         APPE_SysEvtReadyProcessing();
 8006728:	f000 f82a 	bl	8006780 <APPE_SysEvtReadyProcessing>
         break;
 800672c:	e005      	b.n	800673a <APPE_SysUserEvtRx+0x38>
         APPE_SysEvtError((SCHI_SystemErrCode_t) (p_sys_event->payload[0]));
 800672e:	68fb      	ldr	r3, [r7, #12]
 8006730:	789b      	ldrb	r3, [r3, #2]
 8006732:	4618      	mov	r0, r3
 8006734:	f000 f806 	bl	8006744 <APPE_SysEvtError>
         break;
 8006738:	bf00      	nop
  }
  return;
 800673a:	bf00      	nop
}
 800673c:	3710      	adds	r7, #16
 800673e:	46bd      	mov	sp, r7
 8006740:	bd80      	pop	{r7, pc}
	...

08006744 <APPE_SysEvtError>:
 * @param  ErrorCode  : errorCode detected by the M0 firmware
 *
 * @retval None
 */
static void APPE_SysEvtError( SCHI_SystemErrCode_t ErrorCode)
{
 8006744:	b580      	push	{r7, lr}
 8006746:	b082      	sub	sp, #8
 8006748:	af00      	add	r7, sp, #0
 800674a:	4603      	mov	r3, r0
 800674c:	71fb      	strb	r3, [r7, #7]
    switch (ErrorCode)
 800674e:	79fb      	ldrb	r3, [r7, #7]
 8006750:	2bc8      	cmp	r3, #200	; 0xc8
 8006752:	d105      	bne.n	8006760 <APPE_SysEvtError+0x1c>
	{
        case ERR_ZIGBEE_UNKNOWN_CMD:
            APP_DBG("** ERR_ZIGBEE : UNKNOWN_CMD \n");
 8006754:	4a08      	ldr	r2, [pc, #32]	; (8006778 <APPE_SysEvtError+0x34>)
 8006756:	2101      	movs	r1, #1
 8006758:	2000      	movs	r0, #0
 800675a:	f001 fcdb 	bl	8008114 <logApplication>
            break;
 800675e:	e006      	b.n	800676e <APPE_SysEvtError+0x2a>
        default:
            APP_DBG("** ERR_ZIGBEE : ErroCode=%d \n", ErrorCode);
 8006760:	79fb      	ldrb	r3, [r7, #7]
 8006762:	4a06      	ldr	r2, [pc, #24]	; (800677c <APPE_SysEvtError+0x38>)
 8006764:	2101      	movs	r1, #1
 8006766:	2000      	movs	r0, #0
 8006768:	f001 fcd4 	bl	8008114 <logApplication>
            break;
 800676c:	bf00      	nop
    }
    return;
 800676e:	bf00      	nop
}
 8006770:	3708      	adds	r7, #8
 8006772:	46bd      	mov	sp, r7
 8006774:	bd80      	pop	{r7, pc}
 8006776:	bf00      	nop
 8006778:	08019388 	.word	0x08019388
 800677c:	080193a8 	.word	0x080193a8

08006780 <APPE_SysEvtReadyProcessing>:

static void APPE_SysEvtReadyProcessing( void )
{
 8006780:	b580      	push	{r7, lr}
 8006782:	af00      	add	r7, sp, #0
    /* Traces channel initialization */
    TL_TRACES_Init();
 8006784:	f00d fa94 	bl	8013cb0 <TL_TRACES_Init>

    APP_ZIGBEE_Init();
 8006788:	f001 fe98 	bl	80084bc <APP_ZIGBEE_Init>
    UTIL_LPM_SetOffMode(1U << CFG_LPM_APP, UTIL_LPM_ENABLE);
 800678c:	2100      	movs	r1, #0
 800678e:	2001      	movs	r0, #1
 8006790:	f011 f9cc 	bl	8017b2c <UTIL_LPM_SetOffMode>
    return;
 8006794:	bf00      	nop
}
 8006796:	bd80      	pop	{r7, pc}

08006798 <Led_Init>:

/* USER CODE BEGIN FD_LOCAL_FUNCTIONS */
static void Led_Init( void )
{
 8006798:	b580      	push	{r7, lr}
 800679a:	af00      	add	r7, sp, #0
#if (CFG_LED_SUPPORTED == 1U)
  /**
   * Leds Initialization
   */

  BSP_LED_Init(LED_BLUE);
 800679c:	2000      	movs	r0, #0
 800679e:	f002 fd29 	bl	80091f4 <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
 80067a2:	2001      	movs	r0, #1
 80067a4:	f002 fd26 	bl	80091f4 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 80067a8:	2002      	movs	r0, #2
 80067aa:	f002 fd23 	bl	80091f4 <BSP_LED_Init>

#endif

  return;
 80067ae:	bf00      	nop
}
 80067b0:	bd80      	pop	{r7, pc}

080067b2 <Button_Init>:

static void Button_Init( void )
{
 80067b2:	b580      	push	{r7, lr}
 80067b4:	af00      	add	r7, sp, #0
#if (CFG_BUTTON_SUPPORTED == 1U)
  /**
   * Button Initialization
   */
    BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 80067b6:	2101      	movs	r1, #1
 80067b8:	2000      	movs	r0, #0
 80067ba:	f002 fdb3 	bl	8009324 <BSP_PB_Init>
#endif

    return;
 80067be:	bf00      	nop
}
 80067c0:	bd80      	pop	{r7, pc}

080067c2 <UTIL_SEQ_Idle>:
 * WRAP FUNCTIONS
 *
 *************************************************************/

void UTIL_SEQ_Idle( void )
{
 80067c2:	b480      	push	{r7}
 80067c4:	af00      	add	r7, sp, #0
#if ( CFG_LPM_SUPPORTED == 1)
  UTIL_LPM_EnterLowPower( );
#endif
  return;
 80067c6:	bf00      	nop
}
 80067c8:	46bd      	mov	sp, r7
 80067ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067ce:	4770      	bx	lr

080067d0 <UTIL_SEQ_EvtIdle>:
  *
  * @param  evt_waited_bm : Event pending.
  * @retval None
  */
void UTIL_SEQ_EvtIdle( UTIL_SEQ_bm_t task_id_bm, UTIL_SEQ_bm_t evt_waited_bm )
{
 80067d0:	b580      	push	{r7, lr}
 80067d2:	b082      	sub	sp, #8
 80067d4:	af00      	add	r7, sp, #0
 80067d6:	6078      	str	r0, [r7, #4]
 80067d8:	6039      	str	r1, [r7, #0]
  switch (evt_waited_bm) {
 80067da:	683b      	ldr	r3, [r7, #0]
 80067dc:	2b02      	cmp	r3, #2
 80067de:	d003      	beq.n	80067e8 <UTIL_SEQ_EvtIdle+0x18>
 80067e0:	683b      	ldr	r3, [r7, #0]
 80067e2:	2b04      	cmp	r3, #4
 80067e4:	d004      	beq.n	80067f0 <UTIL_SEQ_EvtIdle+0x20>
 80067e6:	e00a      	b.n	80067fe <UTIL_SEQ_EvtIdle+0x2e>
    case EVENT_ACK_FROM_M0_EVT:
      /* Run only the task CFG_TASK_REQUEST_FROM_M0_TO_M4 to process
      * direct requests from the M0 (e.g. ZbMalloc), but no stack notifications
      * until we're done the request to the M0. */
      UTIL_SEQ_Run((1U << CFG_TASK_REQUEST_FROM_M0_TO_M4));
 80067e8:	2002      	movs	r0, #2
 80067ea:	f011 f9cf 	bl	8017b8c <UTIL_SEQ_Run>
      break;
 80067ee:	e00b      	b.n	8006808 <UTIL_SEQ_EvtIdle+0x38>

    case EVENT_SYNCHRO_BYPASS_IDLE:
      UTIL_SEQ_SetEvt(EVENT_SYNCHRO_BYPASS_IDLE);
 80067f0:	2004      	movs	r0, #4
 80067f2:	f011 fb15 	bl	8017e20 <UTIL_SEQ_SetEvt>
      /* Process notifications and requests from the M0 */
      UTIL_SEQ_Run((1U << CFG_TASK_NOTIFY_FROM_M0_TO_M4) | (1U << CFG_TASK_REQUEST_FROM_M0_TO_M4));
 80067f6:	2003      	movs	r0, #3
 80067f8:	f011 f9c8 	bl	8017b8c <UTIL_SEQ_Run>
      break;
 80067fc:	e004      	b.n	8006808 <UTIL_SEQ_EvtIdle+0x38>

        default:
            /* default case */
            UTIL_SEQ_Run( UTIL_SEQ_DEFAULT );
 80067fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006802:	f011 f9c3 	bl	8017b8c <UTIL_SEQ_Run>
            break;
 8006806:	bf00      	nop
    }
}
 8006808:	bf00      	nop
 800680a:	3708      	adds	r7, #8
 800680c:	46bd      	mov	sp, r7
 800680e:	bd80      	pop	{r7, pc}

08006810 <shci_notify_asynch_evt>:

void shci_notify_asynch_evt(void* pdata)
{
 8006810:	b580      	push	{r7, lr}
 8006812:	b082      	sub	sp, #8
 8006814:	af00      	add	r7, sp, #0
 8006816:	6078      	str	r0, [r7, #4]
  UNUSED(pdata);
  UTIL_SEQ_SetTask(1U << CFG_TASK_SYSTEM_HCI_ASYNCH_EVT, CFG_SCH_PRIO_0);
 8006818:	2100      	movs	r1, #0
 800681a:	2004      	movs	r0, #4
 800681c:	f011 fad4 	bl	8017dc8 <UTIL_SEQ_SetTask>
  return;
 8006820:	bf00      	nop
}
 8006822:	3708      	adds	r7, #8
 8006824:	46bd      	mov	sp, r7
 8006826:	bd80      	pop	{r7, pc}

08006828 <shci_cmd_resp_release>:

void shci_cmd_resp_release(uint32_t flag)
{
 8006828:	b580      	push	{r7, lr}
 800682a:	b082      	sub	sp, #8
 800682c:	af00      	add	r7, sp, #0
 800682e:	6078      	str	r0, [r7, #4]
  UNUSED(flag);
  UTIL_SEQ_SetEvt(1U << CFG_EVT_SYSTEM_HCI_CMD_EVT_RESP);
 8006830:	2001      	movs	r0, #1
 8006832:	f011 faf5 	bl	8017e20 <UTIL_SEQ_SetEvt>
  return;
 8006836:	bf00      	nop
}
 8006838:	3708      	adds	r7, #8
 800683a:	46bd      	mov	sp, r7
 800683c:	bd80      	pop	{r7, pc}

0800683e <shci_cmd_resp_wait>:

void shci_cmd_resp_wait(uint32_t timeout)
{
 800683e:	b580      	push	{r7, lr}
 8006840:	b082      	sub	sp, #8
 8006842:	af00      	add	r7, sp, #0
 8006844:	6078      	str	r0, [r7, #4]
  UNUSED(timeout);
  UTIL_SEQ_WaitEvt(1U << CFG_EVT_SYSTEM_HCI_CMD_EVT_RESP);
 8006846:	2001      	movs	r0, #1
 8006848:	f011 fb0a 	bl	8017e60 <UTIL_SEQ_WaitEvt>
  return;
 800684c:	bf00      	nop
}
 800684e:	3708      	adds	r7, #8
 8006850:	46bd      	mov	sp, r7
 8006852:	bd80      	pop	{r7, pc}

08006854 <TL_TRACES_EvtReceived>:

/* Received trace buffer from M0 */
void TL_TRACES_EvtReceived( TL_EvtPacket_t * hcievt )
{
 8006854:	b580      	push	{r7, lr}
 8006856:	b082      	sub	sp, #8
 8006858:	af00      	add	r7, sp, #0
 800685a:	6078      	str	r0, [r7, #4]
#if(CFG_DEBUG_TRACE != 0)
  /* Call write/print function using DMA from dbg_trace */
  /* - Cast to TL_AsynchEvt_t* to get "real" payload (without Sub Evt code 2bytes),
     - (-2) to size to remove Sub Evt Code */
  DbgTraceWrite(1U, (const unsigned char *) ((TL_AsynchEvt_t *)(hcievt->evtserial.evt.payload))->payload, hcievt->evtserial.evt.plen - 2U);
 800685c:	687b      	ldr	r3, [r7, #4]
 800685e:	330b      	adds	r3, #11
 8006860:	1c99      	adds	r1, r3, #2
 8006862:	687b      	ldr	r3, [r7, #4]
 8006864:	7a9b      	ldrb	r3, [r3, #10]
 8006866:	3b02      	subs	r3, #2
 8006868:	461a      	mov	r2, r3
 800686a:	2001      	movs	r0, #1
 800686c:	f00d ff70 	bl	8014750 <DbgTraceWrite>
#endif /* CFG_DEBUG_TRACE */
  /* Release buffer */
  TL_MM_EvtDone( hcievt );
 8006870:	6878      	ldr	r0, [r7, #4]
 8006872:	f00d f9e5 	bl	8013c40 <TL_MM_EvtDone>
}
 8006876:	bf00      	nop
 8006878:	3708      	adds	r7, #8
 800687a:	46bd      	mov	sp, r7
 800687c:	bd80      	pop	{r7, pc}
	...

08006880 <DbgOutputInit>:
  * @param  None
  * @retval None
  */
#if(CFG_DEBUG_TRACE != 0)
void DbgOutputInit( void )
{
 8006880:	b580      	push	{r7, lr}
 8006882:	af00      	add	r7, sp, #0
#if (CFG_USB_INTERFACE_ENABLE == 0)
  MX_USART1_UART_Init(); 
#else
  VCP_Init(&VcpTxBuffer[0], &VcpRxBuffer[0]);
 8006884:	4902      	ldr	r1, [pc, #8]	; (8006890 <DbgOutputInit+0x10>)
 8006886:	4803      	ldr	r0, [pc, #12]	; (8006894 <DbgOutputInit+0x14>)
 8006888:	f00d fd62 	bl	8014350 <VCP_Init>
#endif
  return;
 800688c:	bf00      	nop
}
 800688e:	bd80      	pop	{r7, pc}
 8006890:	200005a0 	.word	0x200005a0
 8006894:	200001a0 	.word	0x200001a0

08006898 <DbgOutputTraces>:
  * @param  size : size
  * @param  call-back :
  * @retval None
  */
void DbgOutputTraces(  uint8_t *p_data, uint16_t size, void (*cb)(void) )
{
 8006898:	b580      	push	{r7, lr}
 800689a:	b084      	sub	sp, #16
 800689c:	af00      	add	r7, sp, #0
 800689e:	60f8      	str	r0, [r7, #12]
 80068a0:	460b      	mov	r3, r1
 80068a2:	607a      	str	r2, [r7, #4]
 80068a4:	817b      	strh	r3, [r7, #10]
#if (CFG_USB_INTERFACE_ENABLE == 0)
  HW_UART_Transmit_DMA(CFG_DEBUG_TRACE_UART, p_data, size, cb);
#else
  VCP_SendData ( p_data , size , cb );
 80068a6:	897b      	ldrh	r3, [r7, #10]
 80068a8:	687a      	ldr	r2, [r7, #4]
 80068aa:	4619      	mov	r1, r3
 80068ac:	68f8      	ldr	r0, [r7, #12]
 80068ae:	f00d fd85 	bl	80143bc <VCP_SendData>
#endif
  return;
 80068b2:	bf00      	nop
}
 80068b4:	3710      	adds	r7, #16
 80068b6:	46bd      	mov	sp, r7
 80068b8:	bd80      	pop	{r7, pc}

080068ba <HAL_GPIO_EXTI_Callback>:
  * @brief This function manage the Push button action
  * @param  GPIO_Pin : GPIO pin which has been activated
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 80068ba:	b580      	push	{r7, lr}
 80068bc:	b082      	sub	sp, #8
 80068be:	af00      	add	r7, sp, #0
 80068c0:	4603      	mov	r3, r0
 80068c2:	80fb      	strh	r3, [r7, #6]
  switch (GPIO_Pin) {
 80068c4:	88fb      	ldrh	r3, [r7, #6]
 80068c6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80068ca:	d104      	bne.n	80068d6 <HAL_GPIO_EXTI_Callback+0x1c>
  case BUTTON_SW1_PIN:
    UTIL_SEQ_SetTask(1U << CFG_TASK_BUTTON_SW1,CFG_SCH_PRIO_1);
 80068cc:	2101      	movs	r1, #1
 80068ce:	2020      	movs	r0, #32
 80068d0:	f011 fa7a 	bl	8017dc8 <UTIL_SEQ_SetTask>
    break;
 80068d4:	e000      	b.n	80068d8 <HAL_GPIO_EXTI_Callback+0x1e>

  default:
    break;
 80068d6:	bf00      	nop
  }
}
 80068d8:	bf00      	nop
 80068da:	3708      	adds	r7, #8
 80068dc:	46bd      	mov	sp, r7
 80068de:	bd80      	pop	{r7, pc}

080068e0 <RxUART_Init>:

static void RxUART_Init(void)
{
 80068e0:	b580      	push	{r7, lr}
 80068e2:	af00      	add	r7, sp, #0
  HW_UART_Receive_IT(CFG_DEBUG_TRACE_UART, aRxBuffer, 1U, RxCpltCallback);
 80068e4:	4b03      	ldr	r3, [pc, #12]	; (80068f4 <RxUART_Init+0x14>)
 80068e6:	2201      	movs	r2, #1
 80068e8:	4903      	ldr	r1, [pc, #12]	; (80068f8 <RxUART_Init+0x18>)
 80068ea:	2000      	movs	r0, #0
 80068ec:	f000 fe70 	bl	80075d0 <HW_UART_Receive_IT>
}
 80068f0:	bf00      	nop
 80068f2:	bd80      	pop	{r7, pc}
 80068f4:	080068fd 	.word	0x080068fd
 80068f8:	200009a0 	.word	0x200009a0

080068fc <RxCpltCallback>:

static void RxCpltCallback(void)
{
 80068fc:	b580      	push	{r7, lr}
 80068fe:	af00      	add	r7, sp, #0
  /* Filling buffer and wait for '\r' char */
  if (indexReceiveChar < C_SIZE_CMD_STRING)
 8006900:	4b16      	ldr	r3, [pc, #88]	; (800695c <RxCpltCallback+0x60>)
 8006902:	881b      	ldrh	r3, [r3, #0]
 8006904:	2bff      	cmp	r3, #255	; 0xff
 8006906:	d820      	bhi.n	800694a <RxCpltCallback+0x4e>
  {
    if (aRxBuffer[0] == '\r')
 8006908:	4b15      	ldr	r3, [pc, #84]	; (8006960 <RxCpltCallback+0x64>)
 800690a:	781b      	ldrb	r3, [r3, #0]
 800690c:	2b0d      	cmp	r3, #13
 800690e:	d111      	bne.n	8006934 <RxCpltCallback+0x38>
    {
      APP_DBG("received %s", CommandString);
 8006910:	4b14      	ldr	r3, [pc, #80]	; (8006964 <RxCpltCallback+0x68>)
 8006912:	4a15      	ldr	r2, [pc, #84]	; (8006968 <RxCpltCallback+0x6c>)
 8006914:	2101      	movs	r1, #1
 8006916:	2000      	movs	r0, #0
 8006918:	f001 fbfc 	bl	8008114 <logApplication>

      UartCmdExecute();
 800691c:	f000 f828 	bl	8006970 <UartCmdExecute>

      /* Clear receive buffer and character counter*/
      indexReceiveChar = 0;
 8006920:	4b0e      	ldr	r3, [pc, #56]	; (800695c <RxCpltCallback+0x60>)
 8006922:	2200      	movs	r2, #0
 8006924:	801a      	strh	r2, [r3, #0]
      memset(CommandString, 0, C_SIZE_CMD_STRING);
 8006926:	f44f 7280 	mov.w	r2, #256	; 0x100
 800692a:	2100      	movs	r1, #0
 800692c:	480d      	ldr	r0, [pc, #52]	; (8006964 <RxCpltCallback+0x68>)
 800692e:	f011 fd97 	bl	8018460 <memset>
 8006932:	e00a      	b.n	800694a <RxCpltCallback+0x4e>
    }
    else
    {
      CommandString[indexReceiveChar++] = aRxBuffer[0];
 8006934:	4b09      	ldr	r3, [pc, #36]	; (800695c <RxCpltCallback+0x60>)
 8006936:	881b      	ldrh	r3, [r3, #0]
 8006938:	1c5a      	adds	r2, r3, #1
 800693a:	b291      	uxth	r1, r2
 800693c:	4a07      	ldr	r2, [pc, #28]	; (800695c <RxCpltCallback+0x60>)
 800693e:	8011      	strh	r1, [r2, #0]
 8006940:	461a      	mov	r2, r3
 8006942:	4b07      	ldr	r3, [pc, #28]	; (8006960 <RxCpltCallback+0x64>)
 8006944:	7819      	ldrb	r1, [r3, #0]
 8006946:	4b07      	ldr	r3, [pc, #28]	; (8006964 <RxCpltCallback+0x68>)
 8006948:	5499      	strb	r1, [r3, r2]
    }
  }

  /* Once a character has been sent, put back the device in reception mode */
  HW_UART_Receive_IT(CFG_DEBUG_TRACE_UART, aRxBuffer, 1U, RxCpltCallback);
 800694a:	4b08      	ldr	r3, [pc, #32]	; (800696c <RxCpltCallback+0x70>)
 800694c:	2201      	movs	r2, #1
 800694e:	4904      	ldr	r1, [pc, #16]	; (8006960 <RxCpltCallback+0x64>)
 8006950:	2000      	movs	r0, #0
 8006952:	f000 fe3d 	bl	80075d0 <HW_UART_Receive_IT>
}
 8006956:	bf00      	nop
 8006958:	bd80      	pop	{r7, pc}
 800695a:	bf00      	nop
 800695c:	20000aa8 	.word	0x20000aa8
 8006960:	200009a0 	.word	0x200009a0
 8006964:	200009a8 	.word	0x200009a8
 8006968:	080193c8 	.word	0x080193c8
 800696c:	080068fd 	.word	0x080068fd

08006970 <UartCmdExecute>:

static void UartCmdExecute(void)
{
 8006970:	b580      	push	{r7, lr}
 8006972:	af00      	add	r7, sp, #0
  /* Parse received CommandString */
  if(strcmp((char const*)CommandString, "SW1") == 0)
 8006974:	490d      	ldr	r1, [pc, #52]	; (80069ac <UartCmdExecute+0x3c>)
 8006976:	480e      	ldr	r0, [pc, #56]	; (80069b0 <UartCmdExecute+0x40>)
 8006978:	f7ff f86b 	bl	8005a52 <strcmp>
 800697c:	4603      	mov	r3, r0
 800697e:	2b00      	cmp	r3, #0
 8006980:	d10b      	bne.n	800699a <UartCmdExecute+0x2a>
  {
    APP_DBG("SW1 OK");
 8006982:	4a0c      	ldr	r2, [pc, #48]	; (80069b4 <UartCmdExecute+0x44>)
 8006984:	2101      	movs	r1, #1
 8006986:	2000      	movs	r0, #0
 8006988:	f001 fbc4 	bl	8008114 <logApplication>
    exti_handle.Line = EXTI_LINE_10;
 800698c:	4b0a      	ldr	r3, [pc, #40]	; (80069b8 <UartCmdExecute+0x48>)
 800698e:	4a0b      	ldr	r2, [pc, #44]	; (80069bc <UartCmdExecute+0x4c>)
 8006990:	601a      	str	r2, [r3, #0]
    HAL_EXTI_GenerateSWI(&exti_handle);
 8006992:	4809      	ldr	r0, [pc, #36]	; (80069b8 <UartCmdExecute+0x48>)
 8006994:	f003 f90e 	bl	8009bb4 <HAL_EXTI_GenerateSWI>
  }
  else
  {
    APP_DBG("NOT RECOGNIZED COMMAND : %s", CommandString);
  }
}
 8006998:	e005      	b.n	80069a6 <UartCmdExecute+0x36>
    APP_DBG("NOT RECOGNIZED COMMAND : %s", CommandString);
 800699a:	4b05      	ldr	r3, [pc, #20]	; (80069b0 <UartCmdExecute+0x40>)
 800699c:	4a08      	ldr	r2, [pc, #32]	; (80069c0 <UartCmdExecute+0x50>)
 800699e:	2101      	movs	r1, #1
 80069a0:	2000      	movs	r0, #0
 80069a2:	f001 fbb7 	bl	8008114 <logApplication>
}
 80069a6:	bf00      	nop
 80069a8:	bd80      	pop	{r7, pc}
 80069aa:	bf00      	nop
 80069ac:	080193d4 	.word	0x080193d4
 80069b0:	200009a8 	.word	0x200009a8
 80069b4:	080193d8 	.word	0x080193d8
 80069b8:	20000aac 	.word	0x20000aac
 80069bc:	1600000a 	.word	0x1600000a
 80069c0:	080193e0 	.word	0x080193e0

080069c4 <LL_EXTI_EnableIT_0_31>:
{
 80069c4:	b480      	push	{r7}
 80069c6:	b083      	sub	sp, #12
 80069c8:	af00      	add	r7, sp, #0
 80069ca:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR1, ExtiLine);
 80069cc:	4b06      	ldr	r3, [pc, #24]	; (80069e8 <LL_EXTI_EnableIT_0_31+0x24>)
 80069ce:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80069d2:	4905      	ldr	r1, [pc, #20]	; (80069e8 <LL_EXTI_EnableIT_0_31+0x24>)
 80069d4:	687b      	ldr	r3, [r7, #4]
 80069d6:	4313      	orrs	r3, r2
 80069d8:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 80069dc:	bf00      	nop
 80069de:	370c      	adds	r7, #12
 80069e0:	46bd      	mov	sp, r7
 80069e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069e6:	4770      	bx	lr
 80069e8:	58000800 	.word	0x58000800

080069ec <LL_EXTI_EnableRisingTrig_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
{
 80069ec:	b480      	push	{r7}
 80069ee:	b083      	sub	sp, #12
 80069f0:	af00      	add	r7, sp, #0
 80069f2:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR1, ExtiLine);
 80069f4:	4b05      	ldr	r3, [pc, #20]	; (8006a0c <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 80069f6:	681a      	ldr	r2, [r3, #0]
 80069f8:	4904      	ldr	r1, [pc, #16]	; (8006a0c <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 80069fa:	687b      	ldr	r3, [r7, #4]
 80069fc:	4313      	orrs	r3, r2
 80069fe:	600b      	str	r3, [r1, #0]

}
 8006a00:	bf00      	nop
 8006a02:	370c      	adds	r7, #12
 8006a04:	46bd      	mov	sp, r7
 8006a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a0a:	4770      	bx	lr
 8006a0c:	58000800 	.word	0x58000800

08006a10 <ReadRtcSsrValue>:
 *         reliability of the value
 * @param  None
 * @retval SSR value read
 */
static uint32_t ReadRtcSsrValue(void)
{
 8006a10:	b480      	push	{r7}
 8006a12:	b083      	sub	sp, #12
 8006a14:	af00      	add	r7, sp, #0
  uint32_t first_read;
  uint32_t second_read;

  first_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 8006a16:	4b0d      	ldr	r3, [pc, #52]	; (8006a4c <ReadRtcSsrValue+0x3c>)
 8006a18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a1a:	b29b      	uxth	r3, r3
 8006a1c:	607b      	str	r3, [r7, #4]

  second_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 8006a1e:	4b0b      	ldr	r3, [pc, #44]	; (8006a4c <ReadRtcSsrValue+0x3c>)
 8006a20:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a22:	b29b      	uxth	r3, r3
 8006a24:	603b      	str	r3, [r7, #0]

  while(first_read != second_read)
 8006a26:	e005      	b.n	8006a34 <ReadRtcSsrValue+0x24>
  {
    first_read = second_read;
 8006a28:	683b      	ldr	r3, [r7, #0]
 8006a2a:	607b      	str	r3, [r7, #4]

    second_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 8006a2c:	4b07      	ldr	r3, [pc, #28]	; (8006a4c <ReadRtcSsrValue+0x3c>)
 8006a2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a30:	b29b      	uxth	r3, r3
 8006a32:	603b      	str	r3, [r7, #0]
  while(first_read != second_read)
 8006a34:	687a      	ldr	r2, [r7, #4]
 8006a36:	683b      	ldr	r3, [r7, #0]
 8006a38:	429a      	cmp	r2, r3
 8006a3a:	d1f5      	bne.n	8006a28 <ReadRtcSsrValue+0x18>
  }

  return second_read;
 8006a3c:	683b      	ldr	r3, [r7, #0]
}
 8006a3e:	4618      	mov	r0, r3
 8006a40:	370c      	adds	r7, #12
 8006a42:	46bd      	mov	sp, r7
 8006a44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a48:	4770      	bx	lr
 8006a4a:	bf00      	nop
 8006a4c:	40002800 	.word	0x40002800

08006a50 <LinkTimerAfter>:
 * @param  TimerID:   The ID of the Timer
 * @param  RefTimerID: The ID of the Timer to be linked after
 * @retval None
 */
static void LinkTimerAfter(uint8_t TimerID, uint8_t RefTimerID)
{
 8006a50:	b480      	push	{r7}
 8006a52:	b085      	sub	sp, #20
 8006a54:	af00      	add	r7, sp, #0
 8006a56:	4603      	mov	r3, r0
 8006a58:	460a      	mov	r2, r1
 8006a5a:	71fb      	strb	r3, [r7, #7]
 8006a5c:	4613      	mov	r3, r2
 8006a5e:	71bb      	strb	r3, [r7, #6]
  uint8_t next_id;

  next_id = aTimerContext[RefTimerID].NextID;
 8006a60:	79ba      	ldrb	r2, [r7, #6]
 8006a62:	491d      	ldr	r1, [pc, #116]	; (8006ad8 <LinkTimerAfter+0x88>)
 8006a64:	4613      	mov	r3, r2
 8006a66:	005b      	lsls	r3, r3, #1
 8006a68:	4413      	add	r3, r2
 8006a6a:	00db      	lsls	r3, r3, #3
 8006a6c:	440b      	add	r3, r1
 8006a6e:	3315      	adds	r3, #21
 8006a70:	781b      	ldrb	r3, [r3, #0]
 8006a72:	73fb      	strb	r3, [r7, #15]

  if(next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8006a74:	7bfb      	ldrb	r3, [r7, #15]
 8006a76:	2b06      	cmp	r3, #6
 8006a78:	d009      	beq.n	8006a8e <LinkTimerAfter+0x3e>
  {
    aTimerContext[next_id].PreviousID = TimerID;
 8006a7a:	7bfa      	ldrb	r2, [r7, #15]
 8006a7c:	4916      	ldr	r1, [pc, #88]	; (8006ad8 <LinkTimerAfter+0x88>)
 8006a7e:	4613      	mov	r3, r2
 8006a80:	005b      	lsls	r3, r3, #1
 8006a82:	4413      	add	r3, r2
 8006a84:	00db      	lsls	r3, r3, #3
 8006a86:	440b      	add	r3, r1
 8006a88:	3314      	adds	r3, #20
 8006a8a:	79fa      	ldrb	r2, [r7, #7]
 8006a8c:	701a      	strb	r2, [r3, #0]
  }
  aTimerContext[TimerID].NextID = next_id;
 8006a8e:	79fa      	ldrb	r2, [r7, #7]
 8006a90:	4911      	ldr	r1, [pc, #68]	; (8006ad8 <LinkTimerAfter+0x88>)
 8006a92:	4613      	mov	r3, r2
 8006a94:	005b      	lsls	r3, r3, #1
 8006a96:	4413      	add	r3, r2
 8006a98:	00db      	lsls	r3, r3, #3
 8006a9a:	440b      	add	r3, r1
 8006a9c:	3315      	adds	r3, #21
 8006a9e:	7bfa      	ldrb	r2, [r7, #15]
 8006aa0:	701a      	strb	r2, [r3, #0]
  aTimerContext[TimerID].PreviousID = RefTimerID ;
 8006aa2:	79fa      	ldrb	r2, [r7, #7]
 8006aa4:	490c      	ldr	r1, [pc, #48]	; (8006ad8 <LinkTimerAfter+0x88>)
 8006aa6:	4613      	mov	r3, r2
 8006aa8:	005b      	lsls	r3, r3, #1
 8006aaa:	4413      	add	r3, r2
 8006aac:	00db      	lsls	r3, r3, #3
 8006aae:	440b      	add	r3, r1
 8006ab0:	3314      	adds	r3, #20
 8006ab2:	79ba      	ldrb	r2, [r7, #6]
 8006ab4:	701a      	strb	r2, [r3, #0]
  aTimerContext[RefTimerID].NextID = TimerID;
 8006ab6:	79ba      	ldrb	r2, [r7, #6]
 8006ab8:	4907      	ldr	r1, [pc, #28]	; (8006ad8 <LinkTimerAfter+0x88>)
 8006aba:	4613      	mov	r3, r2
 8006abc:	005b      	lsls	r3, r3, #1
 8006abe:	4413      	add	r3, r2
 8006ac0:	00db      	lsls	r3, r3, #3
 8006ac2:	440b      	add	r3, r1
 8006ac4:	3315      	adds	r3, #21
 8006ac6:	79fa      	ldrb	r2, [r7, #7]
 8006ac8:	701a      	strb	r2, [r3, #0]

  return;
 8006aca:	bf00      	nop
}
 8006acc:	3714      	adds	r7, #20
 8006ace:	46bd      	mov	sp, r7
 8006ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ad4:	4770      	bx	lr
 8006ad6:	bf00      	nop
 8006ad8:	20000ab4 	.word	0x20000ab4

08006adc <LinkTimerBefore>:
 * @param  TimerID:   The ID of the Timer
 * @param  RefTimerID: The ID of the Timer to be linked before
 * @retval None
 */
static void LinkTimerBefore(uint8_t TimerID, uint8_t RefTimerID)
{
 8006adc:	b480      	push	{r7}
 8006ade:	b085      	sub	sp, #20
 8006ae0:	af00      	add	r7, sp, #0
 8006ae2:	4603      	mov	r3, r0
 8006ae4:	460a      	mov	r2, r1
 8006ae6:	71fb      	strb	r3, [r7, #7]
 8006ae8:	4613      	mov	r3, r2
 8006aea:	71bb      	strb	r3, [r7, #6]
  uint8_t previous_id;

  if(RefTimerID != CurrentRunningTimerID)
 8006aec:	4b29      	ldr	r3, [pc, #164]	; (8006b94 <LinkTimerBefore+0xb8>)
 8006aee:	781b      	ldrb	r3, [r3, #0]
 8006af0:	b2db      	uxtb	r3, r3
 8006af2:	79ba      	ldrb	r2, [r7, #6]
 8006af4:	429a      	cmp	r2, r3
 8006af6:	d032      	beq.n	8006b5e <LinkTimerBefore+0x82>
  {
    previous_id = aTimerContext[RefTimerID].PreviousID;
 8006af8:	79ba      	ldrb	r2, [r7, #6]
 8006afa:	4927      	ldr	r1, [pc, #156]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006afc:	4613      	mov	r3, r2
 8006afe:	005b      	lsls	r3, r3, #1
 8006b00:	4413      	add	r3, r2
 8006b02:	00db      	lsls	r3, r3, #3
 8006b04:	440b      	add	r3, r1
 8006b06:	3314      	adds	r3, #20
 8006b08:	781b      	ldrb	r3, [r3, #0]
 8006b0a:	73fb      	strb	r3, [r7, #15]

    aTimerContext[previous_id].NextID = TimerID;
 8006b0c:	7bfa      	ldrb	r2, [r7, #15]
 8006b0e:	4922      	ldr	r1, [pc, #136]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006b10:	4613      	mov	r3, r2
 8006b12:	005b      	lsls	r3, r3, #1
 8006b14:	4413      	add	r3, r2
 8006b16:	00db      	lsls	r3, r3, #3
 8006b18:	440b      	add	r3, r1
 8006b1a:	3315      	adds	r3, #21
 8006b1c:	79fa      	ldrb	r2, [r7, #7]
 8006b1e:	701a      	strb	r2, [r3, #0]
    aTimerContext[TimerID].NextID = RefTimerID;
 8006b20:	79fa      	ldrb	r2, [r7, #7]
 8006b22:	491d      	ldr	r1, [pc, #116]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006b24:	4613      	mov	r3, r2
 8006b26:	005b      	lsls	r3, r3, #1
 8006b28:	4413      	add	r3, r2
 8006b2a:	00db      	lsls	r3, r3, #3
 8006b2c:	440b      	add	r3, r1
 8006b2e:	3315      	adds	r3, #21
 8006b30:	79ba      	ldrb	r2, [r7, #6]
 8006b32:	701a      	strb	r2, [r3, #0]
    aTimerContext[TimerID].PreviousID = previous_id ;
 8006b34:	79fa      	ldrb	r2, [r7, #7]
 8006b36:	4918      	ldr	r1, [pc, #96]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006b38:	4613      	mov	r3, r2
 8006b3a:	005b      	lsls	r3, r3, #1
 8006b3c:	4413      	add	r3, r2
 8006b3e:	00db      	lsls	r3, r3, #3
 8006b40:	440b      	add	r3, r1
 8006b42:	3314      	adds	r3, #20
 8006b44:	7bfa      	ldrb	r2, [r7, #15]
 8006b46:	701a      	strb	r2, [r3, #0]
    aTimerContext[RefTimerID].PreviousID = TimerID;
 8006b48:	79ba      	ldrb	r2, [r7, #6]
 8006b4a:	4913      	ldr	r1, [pc, #76]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006b4c:	4613      	mov	r3, r2
 8006b4e:	005b      	lsls	r3, r3, #1
 8006b50:	4413      	add	r3, r2
 8006b52:	00db      	lsls	r3, r3, #3
 8006b54:	440b      	add	r3, r1
 8006b56:	3314      	adds	r3, #20
 8006b58:	79fa      	ldrb	r2, [r7, #7]
 8006b5a:	701a      	strb	r2, [r3, #0]
  {
    aTimerContext[TimerID].NextID = RefTimerID;
    aTimerContext[RefTimerID].PreviousID = TimerID;
  }

  return;
 8006b5c:	e014      	b.n	8006b88 <LinkTimerBefore+0xac>
    aTimerContext[TimerID].NextID = RefTimerID;
 8006b5e:	79fa      	ldrb	r2, [r7, #7]
 8006b60:	490d      	ldr	r1, [pc, #52]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006b62:	4613      	mov	r3, r2
 8006b64:	005b      	lsls	r3, r3, #1
 8006b66:	4413      	add	r3, r2
 8006b68:	00db      	lsls	r3, r3, #3
 8006b6a:	440b      	add	r3, r1
 8006b6c:	3315      	adds	r3, #21
 8006b6e:	79ba      	ldrb	r2, [r7, #6]
 8006b70:	701a      	strb	r2, [r3, #0]
    aTimerContext[RefTimerID].PreviousID = TimerID;
 8006b72:	79ba      	ldrb	r2, [r7, #6]
 8006b74:	4908      	ldr	r1, [pc, #32]	; (8006b98 <LinkTimerBefore+0xbc>)
 8006b76:	4613      	mov	r3, r2
 8006b78:	005b      	lsls	r3, r3, #1
 8006b7a:	4413      	add	r3, r2
 8006b7c:	00db      	lsls	r3, r3, #3
 8006b7e:	440b      	add	r3, r1
 8006b80:	3314      	adds	r3, #20
 8006b82:	79fa      	ldrb	r2, [r7, #7]
 8006b84:	701a      	strb	r2, [r3, #0]
  return;
 8006b86:	bf00      	nop
}
 8006b88:	3714      	adds	r7, #20
 8006b8a:	46bd      	mov	sp, r7
 8006b8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b90:	4770      	bx	lr
 8006b92:	bf00      	nop
 8006b94:	20000b44 	.word	0x20000b44
 8006b98:	20000ab4 	.word	0x20000ab4

08006b9c <linkTimer>:
 * @brief  Insert a Timer in the list
 * @param  TimerID:   The ID of the Timer
 * @retval None
 */
static uint16_t linkTimer(uint8_t TimerID)
{
 8006b9c:	b580      	push	{r7, lr}
 8006b9e:	b084      	sub	sp, #16
 8006ba0:	af00      	add	r7, sp, #0
 8006ba2:	4603      	mov	r3, r0
 8006ba4:	71fb      	strb	r3, [r7, #7]
  uint32_t time_left;
  uint16_t time_elapsed;
  uint8_t timer_id_lookup;
  uint8_t next_id;

  if(CurrentRunningTimerID == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8006ba6:	4b4e      	ldr	r3, [pc, #312]	; (8006ce0 <linkTimer+0x144>)
 8006ba8:	781b      	ldrb	r3, [r3, #0]
 8006baa:	b2db      	uxtb	r3, r3
 8006bac:	2b06      	cmp	r3, #6
 8006bae:	d118      	bne.n	8006be2 <linkTimer+0x46>
  {
    /**
     * No timer in the list
     */
    PreviousRunningTimerID = CurrentRunningTimerID;
 8006bb0:	4b4b      	ldr	r3, [pc, #300]	; (8006ce0 <linkTimer+0x144>)
 8006bb2:	781b      	ldrb	r3, [r3, #0]
 8006bb4:	b2da      	uxtb	r2, r3
 8006bb6:	4b4b      	ldr	r3, [pc, #300]	; (8006ce4 <linkTimer+0x148>)
 8006bb8:	701a      	strb	r2, [r3, #0]
    CurrentRunningTimerID = TimerID;
 8006bba:	4a49      	ldr	r2, [pc, #292]	; (8006ce0 <linkTimer+0x144>)
 8006bbc:	79fb      	ldrb	r3, [r7, #7]
 8006bbe:	7013      	strb	r3, [r2, #0]
    aTimerContext[TimerID].NextID = CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER;
 8006bc0:	79fa      	ldrb	r2, [r7, #7]
 8006bc2:	4949      	ldr	r1, [pc, #292]	; (8006ce8 <linkTimer+0x14c>)
 8006bc4:	4613      	mov	r3, r2
 8006bc6:	005b      	lsls	r3, r3, #1
 8006bc8:	4413      	add	r3, r2
 8006bca:	00db      	lsls	r3, r3, #3
 8006bcc:	440b      	add	r3, r1
 8006bce:	3315      	adds	r3, #21
 8006bd0:	2206      	movs	r2, #6
 8006bd2:	701a      	strb	r2, [r3, #0]

    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 8006bd4:	4b45      	ldr	r3, [pc, #276]	; (8006cec <linkTimer+0x150>)
 8006bd6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006bda:	601a      	str	r2, [r3, #0]
    time_elapsed = 0;
 8006bdc:	2300      	movs	r3, #0
 8006bde:	81fb      	strh	r3, [r7, #14]
 8006be0:	e078      	b.n	8006cd4 <linkTimer+0x138>
  }
  else
  {
    time_elapsed = ReturnTimeElapsed();
 8006be2:	f000 f909 	bl	8006df8 <ReturnTimeElapsed>
 8006be6:	4603      	mov	r3, r0
 8006be8:	81fb      	strh	r3, [r7, #14]

    /**
     * update count of the timer to be linked
     */
    aTimerContext[TimerID].CountLeft += time_elapsed;
 8006bea:	79fa      	ldrb	r2, [r7, #7]
 8006bec:	493e      	ldr	r1, [pc, #248]	; (8006ce8 <linkTimer+0x14c>)
 8006bee:	4613      	mov	r3, r2
 8006bf0:	005b      	lsls	r3, r3, #1
 8006bf2:	4413      	add	r3, r2
 8006bf4:	00db      	lsls	r3, r3, #3
 8006bf6:	440b      	add	r3, r1
 8006bf8:	3308      	adds	r3, #8
 8006bfa:	6819      	ldr	r1, [r3, #0]
 8006bfc:	89fb      	ldrh	r3, [r7, #14]
 8006bfe:	79fa      	ldrb	r2, [r7, #7]
 8006c00:	4419      	add	r1, r3
 8006c02:	4839      	ldr	r0, [pc, #228]	; (8006ce8 <linkTimer+0x14c>)
 8006c04:	4613      	mov	r3, r2
 8006c06:	005b      	lsls	r3, r3, #1
 8006c08:	4413      	add	r3, r2
 8006c0a:	00db      	lsls	r3, r3, #3
 8006c0c:	4403      	add	r3, r0
 8006c0e:	3308      	adds	r3, #8
 8006c10:	6019      	str	r1, [r3, #0]
    time_left = aTimerContext[TimerID].CountLeft;
 8006c12:	79fa      	ldrb	r2, [r7, #7]
 8006c14:	4934      	ldr	r1, [pc, #208]	; (8006ce8 <linkTimer+0x14c>)
 8006c16:	4613      	mov	r3, r2
 8006c18:	005b      	lsls	r3, r3, #1
 8006c1a:	4413      	add	r3, r2
 8006c1c:	00db      	lsls	r3, r3, #3
 8006c1e:	440b      	add	r3, r1
 8006c20:	3308      	adds	r3, #8
 8006c22:	681b      	ldr	r3, [r3, #0]
 8006c24:	60bb      	str	r3, [r7, #8]

    /**
     * Search for index where the new timer shall be linked
     */
    if(aTimerContext[CurrentRunningTimerID].CountLeft <= time_left)
 8006c26:	4b2e      	ldr	r3, [pc, #184]	; (8006ce0 <linkTimer+0x144>)
 8006c28:	781b      	ldrb	r3, [r3, #0]
 8006c2a:	b2db      	uxtb	r3, r3
 8006c2c:	4619      	mov	r1, r3
 8006c2e:	4a2e      	ldr	r2, [pc, #184]	; (8006ce8 <linkTimer+0x14c>)
 8006c30:	460b      	mov	r3, r1
 8006c32:	005b      	lsls	r3, r3, #1
 8006c34:	440b      	add	r3, r1
 8006c36:	00db      	lsls	r3, r3, #3
 8006c38:	4413      	add	r3, r2
 8006c3a:	3308      	adds	r3, #8
 8006c3c:	681b      	ldr	r3, [r3, #0]
 8006c3e:	68ba      	ldr	r2, [r7, #8]
 8006c40:	429a      	cmp	r2, r3
 8006c42:	d337      	bcc.n	8006cb4 <linkTimer+0x118>
    {
      /**
       * Search for the ID after the first one
       */
      timer_id_lookup = CurrentRunningTimerID;
 8006c44:	4b26      	ldr	r3, [pc, #152]	; (8006ce0 <linkTimer+0x144>)
 8006c46:	781b      	ldrb	r3, [r3, #0]
 8006c48:	737b      	strb	r3, [r7, #13]
      next_id = aTimerContext[timer_id_lookup].NextID;
 8006c4a:	7b7a      	ldrb	r2, [r7, #13]
 8006c4c:	4926      	ldr	r1, [pc, #152]	; (8006ce8 <linkTimer+0x14c>)
 8006c4e:	4613      	mov	r3, r2
 8006c50:	005b      	lsls	r3, r3, #1
 8006c52:	4413      	add	r3, r2
 8006c54:	00db      	lsls	r3, r3, #3
 8006c56:	440b      	add	r3, r1
 8006c58:	3315      	adds	r3, #21
 8006c5a:	781b      	ldrb	r3, [r3, #0]
 8006c5c:	733b      	strb	r3, [r7, #12]
      while((next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[next_id].CountLeft <= time_left))
 8006c5e:	e013      	b.n	8006c88 <linkTimer+0xec>
      {
        timer_id_lookup = aTimerContext[timer_id_lookup].NextID;
 8006c60:	7b7a      	ldrb	r2, [r7, #13]
 8006c62:	4921      	ldr	r1, [pc, #132]	; (8006ce8 <linkTimer+0x14c>)
 8006c64:	4613      	mov	r3, r2
 8006c66:	005b      	lsls	r3, r3, #1
 8006c68:	4413      	add	r3, r2
 8006c6a:	00db      	lsls	r3, r3, #3
 8006c6c:	440b      	add	r3, r1
 8006c6e:	3315      	adds	r3, #21
 8006c70:	781b      	ldrb	r3, [r3, #0]
 8006c72:	737b      	strb	r3, [r7, #13]
        next_id = aTimerContext[timer_id_lookup].NextID;
 8006c74:	7b7a      	ldrb	r2, [r7, #13]
 8006c76:	491c      	ldr	r1, [pc, #112]	; (8006ce8 <linkTimer+0x14c>)
 8006c78:	4613      	mov	r3, r2
 8006c7a:	005b      	lsls	r3, r3, #1
 8006c7c:	4413      	add	r3, r2
 8006c7e:	00db      	lsls	r3, r3, #3
 8006c80:	440b      	add	r3, r1
 8006c82:	3315      	adds	r3, #21
 8006c84:	781b      	ldrb	r3, [r3, #0]
 8006c86:	733b      	strb	r3, [r7, #12]
      while((next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[next_id].CountLeft <= time_left))
 8006c88:	7b3b      	ldrb	r3, [r7, #12]
 8006c8a:	2b06      	cmp	r3, #6
 8006c8c:	d00b      	beq.n	8006ca6 <linkTimer+0x10a>
 8006c8e:	7b3a      	ldrb	r2, [r7, #12]
 8006c90:	4915      	ldr	r1, [pc, #84]	; (8006ce8 <linkTimer+0x14c>)
 8006c92:	4613      	mov	r3, r2
 8006c94:	005b      	lsls	r3, r3, #1
 8006c96:	4413      	add	r3, r2
 8006c98:	00db      	lsls	r3, r3, #3
 8006c9a:	440b      	add	r3, r1
 8006c9c:	3308      	adds	r3, #8
 8006c9e:	681b      	ldr	r3, [r3, #0]
 8006ca0:	68ba      	ldr	r2, [r7, #8]
 8006ca2:	429a      	cmp	r2, r3
 8006ca4:	d2dc      	bcs.n	8006c60 <linkTimer+0xc4>
      }

      /**
       * Link after the ID
       */
      LinkTimerAfter(TimerID, timer_id_lookup);
 8006ca6:	7b7a      	ldrb	r2, [r7, #13]
 8006ca8:	79fb      	ldrb	r3, [r7, #7]
 8006caa:	4611      	mov	r1, r2
 8006cac:	4618      	mov	r0, r3
 8006cae:	f7ff fecf 	bl	8006a50 <LinkTimerAfter>
 8006cb2:	e00f      	b.n	8006cd4 <linkTimer+0x138>
    else
    {
      /**
       * Link before the first ID
       */
      LinkTimerBefore(TimerID, CurrentRunningTimerID);
 8006cb4:	4b0a      	ldr	r3, [pc, #40]	; (8006ce0 <linkTimer+0x144>)
 8006cb6:	781b      	ldrb	r3, [r3, #0]
 8006cb8:	b2da      	uxtb	r2, r3
 8006cba:	79fb      	ldrb	r3, [r7, #7]
 8006cbc:	4611      	mov	r1, r2
 8006cbe:	4618      	mov	r0, r3
 8006cc0:	f7ff ff0c 	bl	8006adc <LinkTimerBefore>
      PreviousRunningTimerID = CurrentRunningTimerID;
 8006cc4:	4b06      	ldr	r3, [pc, #24]	; (8006ce0 <linkTimer+0x144>)
 8006cc6:	781b      	ldrb	r3, [r3, #0]
 8006cc8:	b2da      	uxtb	r2, r3
 8006cca:	4b06      	ldr	r3, [pc, #24]	; (8006ce4 <linkTimer+0x148>)
 8006ccc:	701a      	strb	r2, [r3, #0]
      CurrentRunningTimerID = TimerID;
 8006cce:	4a04      	ldr	r2, [pc, #16]	; (8006ce0 <linkTimer+0x144>)
 8006cd0:	79fb      	ldrb	r3, [r7, #7]
 8006cd2:	7013      	strb	r3, [r2, #0]
    }
  }

  return time_elapsed;
 8006cd4:	89fb      	ldrh	r3, [r7, #14]
}
 8006cd6:	4618      	mov	r0, r3
 8006cd8:	3710      	adds	r7, #16
 8006cda:	46bd      	mov	sp, r7
 8006cdc:	bd80      	pop	{r7, pc}
 8006cde:	bf00      	nop
 8006ce0:	20000b44 	.word	0x20000b44
 8006ce4:	20000b45 	.word	0x20000b45
 8006ce8:	20000ab4 	.word	0x20000ab4
 8006cec:	20000b48 	.word	0x20000b48

08006cf0 <UnlinkTimer>:
 * @param  TimerID:   The ID of the Timer
 * @param  RequestReadSSR: Request to read the SSR register or not
 * @retval None
 */
static void UnlinkTimer(uint8_t TimerID, RequestReadSSR_t RequestReadSSR)
{
 8006cf0:	b480      	push	{r7}
 8006cf2:	b085      	sub	sp, #20
 8006cf4:	af00      	add	r7, sp, #0
 8006cf6:	4603      	mov	r3, r0
 8006cf8:	460a      	mov	r2, r1
 8006cfa:	71fb      	strb	r3, [r7, #7]
 8006cfc:	4613      	mov	r3, r2
 8006cfe:	71bb      	strb	r3, [r7, #6]
  uint8_t previous_id;
  uint8_t next_id;

  if(TimerID == CurrentRunningTimerID)
 8006d00:	4b39      	ldr	r3, [pc, #228]	; (8006de8 <UnlinkTimer+0xf8>)
 8006d02:	781b      	ldrb	r3, [r3, #0]
 8006d04:	b2db      	uxtb	r3, r3
 8006d06:	79fa      	ldrb	r2, [r7, #7]
 8006d08:	429a      	cmp	r2, r3
 8006d0a:	d111      	bne.n	8006d30 <UnlinkTimer+0x40>
  {
    PreviousRunningTimerID = CurrentRunningTimerID;
 8006d0c:	4b36      	ldr	r3, [pc, #216]	; (8006de8 <UnlinkTimer+0xf8>)
 8006d0e:	781b      	ldrb	r3, [r3, #0]
 8006d10:	b2da      	uxtb	r2, r3
 8006d12:	4b36      	ldr	r3, [pc, #216]	; (8006dec <UnlinkTimer+0xfc>)
 8006d14:	701a      	strb	r2, [r3, #0]
    CurrentRunningTimerID = aTimerContext[TimerID].NextID;
 8006d16:	79fa      	ldrb	r2, [r7, #7]
 8006d18:	4935      	ldr	r1, [pc, #212]	; (8006df0 <UnlinkTimer+0x100>)
 8006d1a:	4613      	mov	r3, r2
 8006d1c:	005b      	lsls	r3, r3, #1
 8006d1e:	4413      	add	r3, r2
 8006d20:	00db      	lsls	r3, r3, #3
 8006d22:	440b      	add	r3, r1
 8006d24:	3315      	adds	r3, #21
 8006d26:	781b      	ldrb	r3, [r3, #0]
 8006d28:	b2da      	uxtb	r2, r3
 8006d2a:	4b2f      	ldr	r3, [pc, #188]	; (8006de8 <UnlinkTimer+0xf8>)
 8006d2c:	701a      	strb	r2, [r3, #0]
 8006d2e:	e03e      	b.n	8006dae <UnlinkTimer+0xbe>
  }
  else
  {
    previous_id = aTimerContext[TimerID].PreviousID;
 8006d30:	79fa      	ldrb	r2, [r7, #7]
 8006d32:	492f      	ldr	r1, [pc, #188]	; (8006df0 <UnlinkTimer+0x100>)
 8006d34:	4613      	mov	r3, r2
 8006d36:	005b      	lsls	r3, r3, #1
 8006d38:	4413      	add	r3, r2
 8006d3a:	00db      	lsls	r3, r3, #3
 8006d3c:	440b      	add	r3, r1
 8006d3e:	3314      	adds	r3, #20
 8006d40:	781b      	ldrb	r3, [r3, #0]
 8006d42:	73fb      	strb	r3, [r7, #15]
    next_id = aTimerContext[TimerID].NextID;
 8006d44:	79fa      	ldrb	r2, [r7, #7]
 8006d46:	492a      	ldr	r1, [pc, #168]	; (8006df0 <UnlinkTimer+0x100>)
 8006d48:	4613      	mov	r3, r2
 8006d4a:	005b      	lsls	r3, r3, #1
 8006d4c:	4413      	add	r3, r2
 8006d4e:	00db      	lsls	r3, r3, #3
 8006d50:	440b      	add	r3, r1
 8006d52:	3315      	adds	r3, #21
 8006d54:	781b      	ldrb	r3, [r3, #0]
 8006d56:	73bb      	strb	r3, [r7, #14]

    aTimerContext[previous_id].NextID = aTimerContext[TimerID].NextID;
 8006d58:	79f9      	ldrb	r1, [r7, #7]
 8006d5a:	7bfa      	ldrb	r2, [r7, #15]
 8006d5c:	4824      	ldr	r0, [pc, #144]	; (8006df0 <UnlinkTimer+0x100>)
 8006d5e:	460b      	mov	r3, r1
 8006d60:	005b      	lsls	r3, r3, #1
 8006d62:	440b      	add	r3, r1
 8006d64:	00db      	lsls	r3, r3, #3
 8006d66:	4403      	add	r3, r0
 8006d68:	3315      	adds	r3, #21
 8006d6a:	781b      	ldrb	r3, [r3, #0]
 8006d6c:	b2d8      	uxtb	r0, r3
 8006d6e:	4920      	ldr	r1, [pc, #128]	; (8006df0 <UnlinkTimer+0x100>)
 8006d70:	4613      	mov	r3, r2
 8006d72:	005b      	lsls	r3, r3, #1
 8006d74:	4413      	add	r3, r2
 8006d76:	00db      	lsls	r3, r3, #3
 8006d78:	440b      	add	r3, r1
 8006d7a:	3315      	adds	r3, #21
 8006d7c:	4602      	mov	r2, r0
 8006d7e:	701a      	strb	r2, [r3, #0]
    if(next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8006d80:	7bbb      	ldrb	r3, [r7, #14]
 8006d82:	2b06      	cmp	r3, #6
 8006d84:	d013      	beq.n	8006dae <UnlinkTimer+0xbe>
    {
      aTimerContext[next_id].PreviousID = aTimerContext[TimerID].PreviousID;
 8006d86:	79f9      	ldrb	r1, [r7, #7]
 8006d88:	7bba      	ldrb	r2, [r7, #14]
 8006d8a:	4819      	ldr	r0, [pc, #100]	; (8006df0 <UnlinkTimer+0x100>)
 8006d8c:	460b      	mov	r3, r1
 8006d8e:	005b      	lsls	r3, r3, #1
 8006d90:	440b      	add	r3, r1
 8006d92:	00db      	lsls	r3, r3, #3
 8006d94:	4403      	add	r3, r0
 8006d96:	3314      	adds	r3, #20
 8006d98:	781b      	ldrb	r3, [r3, #0]
 8006d9a:	b2d8      	uxtb	r0, r3
 8006d9c:	4914      	ldr	r1, [pc, #80]	; (8006df0 <UnlinkTimer+0x100>)
 8006d9e:	4613      	mov	r3, r2
 8006da0:	005b      	lsls	r3, r3, #1
 8006da2:	4413      	add	r3, r2
 8006da4:	00db      	lsls	r3, r3, #3
 8006da6:	440b      	add	r3, r1
 8006da8:	3314      	adds	r3, #20
 8006daa:	4602      	mov	r2, r0
 8006dac:	701a      	strb	r2, [r3, #0]
  }

  /**
   * Timer is out of the list
   */
  aTimerContext[TimerID].TimerIDStatus = TimerID_Created;
 8006dae:	79fa      	ldrb	r2, [r7, #7]
 8006db0:	490f      	ldr	r1, [pc, #60]	; (8006df0 <UnlinkTimer+0x100>)
 8006db2:	4613      	mov	r3, r2
 8006db4:	005b      	lsls	r3, r3, #1
 8006db6:	4413      	add	r3, r2
 8006db8:	00db      	lsls	r3, r3, #3
 8006dba:	440b      	add	r3, r1
 8006dbc:	330c      	adds	r3, #12
 8006dbe:	2201      	movs	r2, #1
 8006dc0:	701a      	strb	r2, [r3, #0]

  if((CurrentRunningTimerID == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (RequestReadSSR == SSR_Read_Requested))
 8006dc2:	4b09      	ldr	r3, [pc, #36]	; (8006de8 <UnlinkTimer+0xf8>)
 8006dc4:	781b      	ldrb	r3, [r3, #0]
 8006dc6:	b2db      	uxtb	r3, r3
 8006dc8:	2b06      	cmp	r3, #6
 8006dca:	d107      	bne.n	8006ddc <UnlinkTimer+0xec>
 8006dcc:	79bb      	ldrb	r3, [r7, #6]
 8006dce:	2b00      	cmp	r3, #0
 8006dd0:	d104      	bne.n	8006ddc <UnlinkTimer+0xec>
  {
    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 8006dd2:	4b08      	ldr	r3, [pc, #32]	; (8006df4 <UnlinkTimer+0x104>)
 8006dd4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006dd8:	601a      	str	r2, [r3, #0]
  }

  return;
 8006dda:	bf00      	nop
 8006ddc:	bf00      	nop
}
 8006dde:	3714      	adds	r7, #20
 8006de0:	46bd      	mov	sp, r7
 8006de2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006de6:	4770      	bx	lr
 8006de8:	20000b44 	.word	0x20000b44
 8006dec:	20000b45 	.word	0x20000b45
 8006df0:	20000ab4 	.word	0x20000ab4
 8006df4:	20000b48 	.word	0x20000b48

08006df8 <ReturnTimeElapsed>:
 *        since the time the timer has been started
 * @param  None
 * @retval Time expired in Ticks
 */
static uint16_t ReturnTimeElapsed(void)
{
 8006df8:	b580      	push	{r7, lr}
 8006dfa:	b082      	sub	sp, #8
 8006dfc:	af00      	add	r7, sp, #0
  uint32_t  return_value;
  uint32_t  wrap_counter;

  if(SSRValueOnLastSetup != SSR_FORBIDDEN_VALUE)
 8006dfe:	4b1a      	ldr	r3, [pc, #104]	; (8006e68 <ReturnTimeElapsed+0x70>)
 8006e00:	681b      	ldr	r3, [r3, #0]
 8006e02:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8006e06:	d026      	beq.n	8006e56 <ReturnTimeElapsed+0x5e>
  {
    return_value = ReadRtcSsrValue(); /**< Read SSR register first */
 8006e08:	f7ff fe02 	bl	8006a10 <ReadRtcSsrValue>
 8006e0c:	6078      	str	r0, [r7, #4]

    if (SSRValueOnLastSetup >= return_value)
 8006e0e:	4b16      	ldr	r3, [pc, #88]	; (8006e68 <ReturnTimeElapsed+0x70>)
 8006e10:	681b      	ldr	r3, [r3, #0]
 8006e12:	687a      	ldr	r2, [r7, #4]
 8006e14:	429a      	cmp	r2, r3
 8006e16:	d805      	bhi.n	8006e24 <ReturnTimeElapsed+0x2c>
    {
      return_value = SSRValueOnLastSetup - return_value;
 8006e18:	4b13      	ldr	r3, [pc, #76]	; (8006e68 <ReturnTimeElapsed+0x70>)
 8006e1a:	681a      	ldr	r2, [r3, #0]
 8006e1c:	687b      	ldr	r3, [r7, #4]
 8006e1e:	1ad3      	subs	r3, r2, r3
 8006e20:	607b      	str	r3, [r7, #4]
 8006e22:	e00a      	b.n	8006e3a <ReturnTimeElapsed+0x42>
    }
    else
    {
      wrap_counter = SynchPrescalerUserConfig - return_value;
 8006e24:	4b11      	ldr	r3, [pc, #68]	; (8006e6c <ReturnTimeElapsed+0x74>)
 8006e26:	881b      	ldrh	r3, [r3, #0]
 8006e28:	461a      	mov	r2, r3
 8006e2a:	687b      	ldr	r3, [r7, #4]
 8006e2c:	1ad3      	subs	r3, r2, r3
 8006e2e:	603b      	str	r3, [r7, #0]
      return_value = SSRValueOnLastSetup + wrap_counter;
 8006e30:	4b0d      	ldr	r3, [pc, #52]	; (8006e68 <ReturnTimeElapsed+0x70>)
 8006e32:	681b      	ldr	r3, [r3, #0]
 8006e34:	683a      	ldr	r2, [r7, #0]
 8006e36:	4413      	add	r3, r2
 8006e38:	607b      	str	r3, [r7, #4]

    /**
     * At this stage, ReturnValue holds the number of ticks counted by SSR
     * Need to translate in number of ticks counted by the Wakeuptimer
     */
    return_value = return_value*AsynchPrescalerUserConfig;
 8006e3a:	4b0d      	ldr	r3, [pc, #52]	; (8006e70 <ReturnTimeElapsed+0x78>)
 8006e3c:	781b      	ldrb	r3, [r3, #0]
 8006e3e:	461a      	mov	r2, r3
 8006e40:	687b      	ldr	r3, [r7, #4]
 8006e42:	fb02 f303 	mul.w	r3, r2, r3
 8006e46:	607b      	str	r3, [r7, #4]
    return_value = return_value >> WakeupTimerDivider;
 8006e48:	4b0a      	ldr	r3, [pc, #40]	; (8006e74 <ReturnTimeElapsed+0x7c>)
 8006e4a:	781b      	ldrb	r3, [r3, #0]
 8006e4c:	461a      	mov	r2, r3
 8006e4e:	687b      	ldr	r3, [r7, #4]
 8006e50:	40d3      	lsrs	r3, r2
 8006e52:	607b      	str	r3, [r7, #4]
 8006e54:	e001      	b.n	8006e5a <ReturnTimeElapsed+0x62>
  }
  else
  {
    return_value = 0;
 8006e56:	2300      	movs	r3, #0
 8006e58:	607b      	str	r3, [r7, #4]
  }

  return (uint16_t)return_value;
 8006e5a:	687b      	ldr	r3, [r7, #4]
 8006e5c:	b29b      	uxth	r3, r3
}
 8006e5e:	4618      	mov	r0, r3
 8006e60:	3708      	adds	r7, #8
 8006e62:	46bd      	mov	sp, r7
 8006e64:	bd80      	pop	{r7, pc}
 8006e66:	bf00      	nop
 8006e68:	20000b48 	.word	0x20000b48
 8006e6c:	20000b50 	.word	0x20000b50
 8006e70:	20000b4e 	.word	0x20000b4e
 8006e74:	20000b4d 	.word	0x20000b4d

08006e78 <RestartWakeupCounter>:
 *    It assumes all condition are met to be allowed to write the wakeup counter
 * @param  Value: Value to be written in the counter
 * @retval None
 */
static void RestartWakeupCounter(uint16_t Value)
{
 8006e78:	b580      	push	{r7, lr}
 8006e7a:	b082      	sub	sp, #8
 8006e7c:	af00      	add	r7, sp, #0
 8006e7e:	4603      	mov	r3, r0
 8006e80:	80fb      	strh	r3, [r7, #6]
   * The wakeuptimer has been disabled in the calling function to reduce the time to poll the WUTWF
   * FLAG when the new value will have to be written
   *  __HAL_RTC_WAKEUPTIMER_DISABLE(&hrtc);
   */

  if(Value == 0)
 8006e82:	88fb      	ldrh	r3, [r7, #6]
 8006e84:	2b00      	cmp	r3, #0
 8006e86:	d108      	bne.n	8006e9a <RestartWakeupCounter+0x22>
  {
    SSRValueOnLastSetup = ReadRtcSsrValue();
 8006e88:	f7ff fdc2 	bl	8006a10 <ReadRtcSsrValue>
 8006e8c:	4603      	mov	r3, r0
 8006e8e:	4a21      	ldr	r2, [pc, #132]	; (8006f14 <RestartWakeupCounter+0x9c>)
 8006e90:	6013      	str	r3, [r2, #0]

    /**
     * Simulate that the Timer expired
     */
    HAL_NVIC_SetPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);
 8006e92:	2003      	movs	r0, #3
 8006e94:	f002 fd05 	bl	80098a2 <HAL_NVIC_SetPendingIRQ>
    __HAL_RTC_WAKEUPTIMER_ENABLE(&hrtc);    /**<  Enable the Wakeup Timer */

    HW_TS_RTC_CountUpdated_AppNot();
  }

  return ;
 8006e98:	e039      	b.n	8006f0e <RestartWakeupCounter+0x96>
    if((Value > 1) ||(WakeupTimerDivider != 1))
 8006e9a:	88fb      	ldrh	r3, [r7, #6]
 8006e9c:	2b01      	cmp	r3, #1
 8006e9e:	d803      	bhi.n	8006ea8 <RestartWakeupCounter+0x30>
 8006ea0:	4b1d      	ldr	r3, [pc, #116]	; (8006f18 <RestartWakeupCounter+0xa0>)
 8006ea2:	781b      	ldrb	r3, [r3, #0]
 8006ea4:	2b01      	cmp	r3, #1
 8006ea6:	d002      	beq.n	8006eae <RestartWakeupCounter+0x36>
      Value -= 1;
 8006ea8:	88fb      	ldrh	r3, [r7, #6]
 8006eaa:	3b01      	subs	r3, #1
 8006eac:	80fb      	strh	r3, [r7, #6]
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc, RTC_FLAG_WUTWF) == RESET);
 8006eae:	bf00      	nop
 8006eb0:	4b1a      	ldr	r3, [pc, #104]	; (8006f1c <RestartWakeupCounter+0xa4>)
 8006eb2:	681b      	ldr	r3, [r3, #0]
 8006eb4:	68db      	ldr	r3, [r3, #12]
 8006eb6:	f003 0304 	and.w	r3, r3, #4
 8006eba:	2b00      	cmp	r3, #0
 8006ebc:	d0f8      	beq.n	8006eb0 <RestartWakeupCounter+0x38>
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 8006ebe:	4b17      	ldr	r3, [pc, #92]	; (8006f1c <RestartWakeupCounter+0xa4>)
 8006ec0:	681b      	ldr	r3, [r3, #0]
 8006ec2:	68db      	ldr	r3, [r3, #12]
 8006ec4:	b2da      	uxtb	r2, r3
 8006ec6:	4b15      	ldr	r3, [pc, #84]	; (8006f1c <RestartWakeupCounter+0xa4>)
 8006ec8:	681b      	ldr	r3, [r3, #0]
 8006eca:	f462 6290 	orn	r2, r2, #1152	; 0x480
 8006ece:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 8006ed0:	4b13      	ldr	r3, [pc, #76]	; (8006f20 <RestartWakeupCounter+0xa8>)
 8006ed2:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8006ed6:	60da      	str	r2, [r3, #12]
    HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);   /**<  Clear pending bit in NVIC */
 8006ed8:	2003      	movs	r0, #3
 8006eda:	f002 fcf0 	bl	80098be <HAL_NVIC_ClearPendingIRQ>
    MODIFY_REG(RTC->WUTR, RTC_WUTR_WUT, Value);
 8006ede:	4b11      	ldr	r3, [pc, #68]	; (8006f24 <RestartWakeupCounter+0xac>)
 8006ee0:	695b      	ldr	r3, [r3, #20]
 8006ee2:	0c1b      	lsrs	r3, r3, #16
 8006ee4:	041b      	lsls	r3, r3, #16
 8006ee6:	88fa      	ldrh	r2, [r7, #6]
 8006ee8:	490e      	ldr	r1, [pc, #56]	; (8006f24 <RestartWakeupCounter+0xac>)
 8006eea:	4313      	orrs	r3, r2
 8006eec:	614b      	str	r3, [r1, #20]
    SSRValueOnLastSetup = ReadRtcSsrValue();
 8006eee:	f7ff fd8f 	bl	8006a10 <ReadRtcSsrValue>
 8006ef2:	4603      	mov	r3, r0
 8006ef4:	4a07      	ldr	r2, [pc, #28]	; (8006f14 <RestartWakeupCounter+0x9c>)
 8006ef6:	6013      	str	r3, [r2, #0]
    __HAL_RTC_WAKEUPTIMER_ENABLE(&hrtc);    /**<  Enable the Wakeup Timer */
 8006ef8:	4b08      	ldr	r3, [pc, #32]	; (8006f1c <RestartWakeupCounter+0xa4>)
 8006efa:	681b      	ldr	r3, [r3, #0]
 8006efc:	689a      	ldr	r2, [r3, #8]
 8006efe:	4b07      	ldr	r3, [pc, #28]	; (8006f1c <RestartWakeupCounter+0xa4>)
 8006f00:	681b      	ldr	r3, [r3, #0]
 8006f02:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006f06:	609a      	str	r2, [r3, #8]
    HW_TS_RTC_CountUpdated_AppNot();
 8006f08:	f3af 8000 	nop.w
  return ;
 8006f0c:	bf00      	nop
}
 8006f0e:	3708      	adds	r7, #8
 8006f10:	46bd      	mov	sp, r7
 8006f12:	bd80      	pop	{r7, pc}
 8006f14:	20000b48 	.word	0x20000b48
 8006f18:	20000b4d 	.word	0x20000b4d
 8006f1c:	20000d4c 	.word	0x20000d4c
 8006f20:	58000800 	.word	0x58000800
 8006f24:	40002800 	.word	0x40002800

08006f28 <RescheduleTimerList>:
 *    2) Setup the wakeuptimer
 * @param  None
 * @retval None
 */
static void RescheduleTimerList(void)
{
 8006f28:	b580      	push	{r7, lr}
 8006f2a:	b084      	sub	sp, #16
 8006f2c:	af00      	add	r7, sp, #0

  /**
   * The wakeuptimer is disabled now to reduce the time to poll the WUTWF
   * FLAG when the new value will have to be written
   */
  if((READ_BIT(RTC->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) == SET)
 8006f2e:	4b45      	ldr	r3, [pc, #276]	; (8007044 <RescheduleTimerList+0x11c>)
 8006f30:	689b      	ldr	r3, [r3, #8]
 8006f32:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006f36:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006f3a:	d107      	bne.n	8006f4c <RescheduleTimerList+0x24>
  {
    /**
     * Wait for the flag to be back to 0 when the wakeup timer is enabled
     */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc, RTC_FLAG_WUTWF) == SET);
 8006f3c:	bf00      	nop
 8006f3e:	4b42      	ldr	r3, [pc, #264]	; (8007048 <RescheduleTimerList+0x120>)
 8006f40:	681b      	ldr	r3, [r3, #0]
 8006f42:	68db      	ldr	r3, [r3, #12]
 8006f44:	f003 0304 	and.w	r3, r3, #4
 8006f48:	2b00      	cmp	r3, #0
 8006f4a:	d1f8      	bne.n	8006f3e <RescheduleTimerList+0x16>
  }
  __HAL_RTC_WAKEUPTIMER_DISABLE(&hrtc);   /**<  Disable the Wakeup Timer */
 8006f4c:	4b3e      	ldr	r3, [pc, #248]	; (8007048 <RescheduleTimerList+0x120>)
 8006f4e:	681b      	ldr	r3, [r3, #0]
 8006f50:	689a      	ldr	r2, [r3, #8]
 8006f52:	4b3d      	ldr	r3, [pc, #244]	; (8007048 <RescheduleTimerList+0x120>)
 8006f54:	681b      	ldr	r3, [r3, #0]
 8006f56:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8006f5a:	609a      	str	r2, [r3, #8]

  localTimerID = CurrentRunningTimerID;
 8006f5c:	4b3b      	ldr	r3, [pc, #236]	; (800704c <RescheduleTimerList+0x124>)
 8006f5e:	781b      	ldrb	r3, [r3, #0]
 8006f60:	73fb      	strb	r3, [r7, #15]

  /**
   * Calculate what will be the value to write in the wakeuptimer
   */
  timecountleft = aTimerContext[localTimerID].CountLeft;
 8006f62:	7bfa      	ldrb	r2, [r7, #15]
 8006f64:	493a      	ldr	r1, [pc, #232]	; (8007050 <RescheduleTimerList+0x128>)
 8006f66:	4613      	mov	r3, r2
 8006f68:	005b      	lsls	r3, r3, #1
 8006f6a:	4413      	add	r3, r2
 8006f6c:	00db      	lsls	r3, r3, #3
 8006f6e:	440b      	add	r3, r1
 8006f70:	3308      	adds	r3, #8
 8006f72:	681b      	ldr	r3, [r3, #0]
 8006f74:	60bb      	str	r3, [r7, #8]

  /**
   * Read how much has been counted
   */
  time_elapsed = ReturnTimeElapsed();
 8006f76:	f7ff ff3f 	bl	8006df8 <ReturnTimeElapsed>
 8006f7a:	4603      	mov	r3, r0
 8006f7c:	80fb      	strh	r3, [r7, #6]

  if(timecountleft < time_elapsed )
 8006f7e:	88fb      	ldrh	r3, [r7, #6]
 8006f80:	68ba      	ldr	r2, [r7, #8]
 8006f82:	429a      	cmp	r2, r3
 8006f84:	d205      	bcs.n	8006f92 <RescheduleTimerList+0x6a>
  {
    /**
     * There is no tick left to count
     */
    wakeup_timer_value = 0;
 8006f86:	2300      	movs	r3, #0
 8006f88:	81bb      	strh	r3, [r7, #12]
    WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 8006f8a:	4b32      	ldr	r3, [pc, #200]	; (8007054 <RescheduleTimerList+0x12c>)
 8006f8c:	2201      	movs	r2, #1
 8006f8e:	701a      	strb	r2, [r3, #0]
 8006f90:	e04d      	b.n	800702e <RescheduleTimerList+0x106>
  }
  else
  {
    if(timecountleft > (time_elapsed + MaxWakeupTimerSetup))
 8006f92:	88fb      	ldrh	r3, [r7, #6]
 8006f94:	4a30      	ldr	r2, [pc, #192]	; (8007058 <RescheduleTimerList+0x130>)
 8006f96:	8812      	ldrh	r2, [r2, #0]
 8006f98:	b292      	uxth	r2, r2
 8006f9a:	4413      	add	r3, r2
 8006f9c:	461a      	mov	r2, r3
 8006f9e:	68bb      	ldr	r3, [r7, #8]
 8006fa0:	4293      	cmp	r3, r2
 8006fa2:	d906      	bls.n	8006fb2 <RescheduleTimerList+0x8a>
    {
      /**
       * The number of tick left is greater than the Wakeuptimer maximum value
       */
      wakeup_timer_value = MaxWakeupTimerSetup;
 8006fa4:	4b2c      	ldr	r3, [pc, #176]	; (8007058 <RescheduleTimerList+0x130>)
 8006fa6:	881b      	ldrh	r3, [r3, #0]
 8006fa8:	81bb      	strh	r3, [r7, #12]

      WakeupTimerLimitation = WakeupTimerValue_Overpassed;
 8006faa:	4b2a      	ldr	r3, [pc, #168]	; (8007054 <RescheduleTimerList+0x12c>)
 8006fac:	2200      	movs	r2, #0
 8006fae:	701a      	strb	r2, [r3, #0]
 8006fb0:	e03d      	b.n	800702e <RescheduleTimerList+0x106>
    }
    else
    {
      wakeup_timer_value = timecountleft - time_elapsed;
 8006fb2:	68bb      	ldr	r3, [r7, #8]
 8006fb4:	b29a      	uxth	r2, r3
 8006fb6:	88fb      	ldrh	r3, [r7, #6]
 8006fb8:	1ad3      	subs	r3, r2, r3
 8006fba:	81bb      	strh	r3, [r7, #12]
      WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 8006fbc:	4b25      	ldr	r3, [pc, #148]	; (8007054 <RescheduleTimerList+0x12c>)
 8006fbe:	2201      	movs	r2, #1
 8006fc0:	701a      	strb	r2, [r3, #0]
  }

  /**
   * update ticks left to be counted for each timer
   */
  while(localTimerID != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8006fc2:	e034      	b.n	800702e <RescheduleTimerList+0x106>
  {
    if (aTimerContext[localTimerID].CountLeft < time_elapsed)
 8006fc4:	7bfa      	ldrb	r2, [r7, #15]
 8006fc6:	4922      	ldr	r1, [pc, #136]	; (8007050 <RescheduleTimerList+0x128>)
 8006fc8:	4613      	mov	r3, r2
 8006fca:	005b      	lsls	r3, r3, #1
 8006fcc:	4413      	add	r3, r2
 8006fce:	00db      	lsls	r3, r3, #3
 8006fd0:	440b      	add	r3, r1
 8006fd2:	3308      	adds	r3, #8
 8006fd4:	681a      	ldr	r2, [r3, #0]
 8006fd6:	88fb      	ldrh	r3, [r7, #6]
 8006fd8:	429a      	cmp	r2, r3
 8006fda:	d20a      	bcs.n	8006ff2 <RescheduleTimerList+0xca>
    {
      aTimerContext[localTimerID].CountLeft = 0;
 8006fdc:	7bfa      	ldrb	r2, [r7, #15]
 8006fde:	491c      	ldr	r1, [pc, #112]	; (8007050 <RescheduleTimerList+0x128>)
 8006fe0:	4613      	mov	r3, r2
 8006fe2:	005b      	lsls	r3, r3, #1
 8006fe4:	4413      	add	r3, r2
 8006fe6:	00db      	lsls	r3, r3, #3
 8006fe8:	440b      	add	r3, r1
 8006fea:	3308      	adds	r3, #8
 8006fec:	2200      	movs	r2, #0
 8006fee:	601a      	str	r2, [r3, #0]
 8006ff0:	e013      	b.n	800701a <RescheduleTimerList+0xf2>
    }
    else
    {
      aTimerContext[localTimerID].CountLeft -= time_elapsed;
 8006ff2:	7bfa      	ldrb	r2, [r7, #15]
 8006ff4:	4916      	ldr	r1, [pc, #88]	; (8007050 <RescheduleTimerList+0x128>)
 8006ff6:	4613      	mov	r3, r2
 8006ff8:	005b      	lsls	r3, r3, #1
 8006ffa:	4413      	add	r3, r2
 8006ffc:	00db      	lsls	r3, r3, #3
 8006ffe:	440b      	add	r3, r1
 8007000:	3308      	adds	r3, #8
 8007002:	6819      	ldr	r1, [r3, #0]
 8007004:	88fb      	ldrh	r3, [r7, #6]
 8007006:	7bfa      	ldrb	r2, [r7, #15]
 8007008:	1ac9      	subs	r1, r1, r3
 800700a:	4811      	ldr	r0, [pc, #68]	; (8007050 <RescheduleTimerList+0x128>)
 800700c:	4613      	mov	r3, r2
 800700e:	005b      	lsls	r3, r3, #1
 8007010:	4413      	add	r3, r2
 8007012:	00db      	lsls	r3, r3, #3
 8007014:	4403      	add	r3, r0
 8007016:	3308      	adds	r3, #8
 8007018:	6019      	str	r1, [r3, #0]
    }
    localTimerID = aTimerContext[localTimerID].NextID;
 800701a:	7bfa      	ldrb	r2, [r7, #15]
 800701c:	490c      	ldr	r1, [pc, #48]	; (8007050 <RescheduleTimerList+0x128>)
 800701e:	4613      	mov	r3, r2
 8007020:	005b      	lsls	r3, r3, #1
 8007022:	4413      	add	r3, r2
 8007024:	00db      	lsls	r3, r3, #3
 8007026:	440b      	add	r3, r1
 8007028:	3315      	adds	r3, #21
 800702a:	781b      	ldrb	r3, [r3, #0]
 800702c:	73fb      	strb	r3, [r7, #15]
  while(localTimerID != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800702e:	7bfb      	ldrb	r3, [r7, #15]
 8007030:	2b06      	cmp	r3, #6
 8007032:	d1c7      	bne.n	8006fc4 <RescheduleTimerList+0x9c>
  }

  /**
   * Write next count
   */
  RestartWakeupCounter(wakeup_timer_value);
 8007034:	89bb      	ldrh	r3, [r7, #12]
 8007036:	4618      	mov	r0, r3
 8007038:	f7ff ff1e 	bl	8006e78 <RestartWakeupCounter>

  return ;
 800703c:	bf00      	nop
}
 800703e:	3710      	adds	r7, #16
 8007040:	46bd      	mov	sp, r7
 8007042:	bd80      	pop	{r7, pc}
 8007044:	40002800 	.word	0x40002800
 8007048:	20000d4c 	.word	0x20000d4c
 800704c:	20000b44 	.word	0x20000b44
 8007050:	20000ab4 	.word	0x20000ab4
 8007054:	20000b4c 	.word	0x20000b4c
 8007058:	20000b52 	.word	0x20000b52

0800705c <HW_TS_RTC_Wakeup_Handler>:
 * In order to ease maintainability, the unlock is done at the top and the lock at then end
 * in case some new implementation is coming in the future
 */

void HW_TS_RTC_Wakeup_Handler(void)
{
 800705c:	b580      	push	{r7, lr}
 800705e:	b08a      	sub	sp, #40	; 0x28
 8007060:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8007062:	f3ef 8310 	mrs	r3, PRIMASK
 8007066:	617b      	str	r3, [r7, #20]
  return(result);
 8007068:	697b      	ldr	r3, [r7, #20]
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800706a:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("cpsid i" : : : "memory");
 800706c:	b672      	cpsid	i
}
 800706e:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

/* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( &hrtc );
 8007070:	4b59      	ldr	r3, [pc, #356]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 8007072:	681b      	ldr	r3, [r3, #0]
 8007074:	22ca      	movs	r2, #202	; 0xca
 8007076:	625a      	str	r2, [r3, #36]	; 0x24
 8007078:	4b57      	ldr	r3, [pc, #348]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 800707a:	681b      	ldr	r3, [r3, #0]
 800707c:	2253      	movs	r2, #83	; 0x53
 800707e:	625a      	str	r2, [r3, #36]	; 0x24
  /**
   * Disable the Wakeup Timer
   * This may speed up a bit the processing to wait the timer to be disabled
   * The timer is still counting 2 RTCCLK
   */
  __HAL_RTC_WAKEUPTIMER_DISABLE(&hrtc);
 8007080:	4b55      	ldr	r3, [pc, #340]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 8007082:	681b      	ldr	r3, [r3, #0]
 8007084:	689a      	ldr	r2, [r3, #8]
 8007086:	4b54      	ldr	r3, [pc, #336]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 8007088:	681b      	ldr	r3, [r3, #0]
 800708a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800708e:	609a      	str	r2, [r3, #8]

  local_current_running_timer_id = CurrentRunningTimerID;
 8007090:	4b52      	ldr	r3, [pc, #328]	; (80071dc <HW_TS_RTC_Wakeup_Handler+0x180>)
 8007092:	781b      	ldrb	r3, [r3, #0]
 8007094:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  if(aTimerContext[local_current_running_timer_id].TimerIDStatus == TimerID_Running)
 8007098:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800709c:	4950      	ldr	r1, [pc, #320]	; (80071e0 <HW_TS_RTC_Wakeup_Handler+0x184>)
 800709e:	4613      	mov	r3, r2
 80070a0:	005b      	lsls	r3, r3, #1
 80070a2:	4413      	add	r3, r2
 80070a4:	00db      	lsls	r3, r3, #3
 80070a6:	440b      	add	r3, r1
 80070a8:	330c      	adds	r3, #12
 80070aa:	781b      	ldrb	r3, [r3, #0]
 80070ac:	b2db      	uxtb	r3, r3
 80070ae:	2b02      	cmp	r3, #2
 80070b0:	d16e      	bne.n	8007190 <HW_TS_RTC_Wakeup_Handler+0x134>
  {
    ptimer_callback = aTimerContext[local_current_running_timer_id].pTimerCallBack;
 80070b2:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 80070b6:	494a      	ldr	r1, [pc, #296]	; (80071e0 <HW_TS_RTC_Wakeup_Handler+0x184>)
 80070b8:	4613      	mov	r3, r2
 80070ba:	005b      	lsls	r3, r3, #1
 80070bc:	4413      	add	r3, r2
 80070be:	00db      	lsls	r3, r3, #3
 80070c0:	440b      	add	r3, r1
 80070c2:	681b      	ldr	r3, [r3, #0]
 80070c4:	61fb      	str	r3, [r7, #28]
    timer_process_id = aTimerContext[local_current_running_timer_id].TimerProcessID;
 80070c6:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 80070ca:	4945      	ldr	r1, [pc, #276]	; (80071e0 <HW_TS_RTC_Wakeup_Handler+0x184>)
 80070cc:	4613      	mov	r3, r2
 80070ce:	005b      	lsls	r3, r3, #1
 80070d0:	4413      	add	r3, r2
 80070d2:	00db      	lsls	r3, r3, #3
 80070d4:	440b      	add	r3, r1
 80070d6:	3310      	adds	r3, #16
 80070d8:	681b      	ldr	r3, [r3, #0]
 80070da:	61bb      	str	r3, [r7, #24]
     * However, due to the inaccuracy of the reading of the time elapsed, it may return there is 1 tick
     * to be left whereas the count is over
     * A more secure implementation has been done with a flag to state whereas the full count has been written
     * in the wakeuptimer or not
     */
    if(WakeupTimerLimitation != WakeupTimerValue_Overpassed)
 80070dc:	4b41      	ldr	r3, [pc, #260]	; (80071e4 <HW_TS_RTC_Wakeup_Handler+0x188>)
 80070de:	781b      	ldrb	r3, [r3, #0]
 80070e0:	b2db      	uxtb	r3, r3
 80070e2:	2b00      	cmp	r3, #0
 80070e4:	d04c      	beq.n	8007180 <HW_TS_RTC_Wakeup_Handler+0x124>
    {
      if(aTimerContext[local_current_running_timer_id].TimerMode == hw_ts_Repeated)
 80070e6:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 80070ea:	493d      	ldr	r1, [pc, #244]	; (80071e0 <HW_TS_RTC_Wakeup_Handler+0x184>)
 80070ec:	4613      	mov	r3, r2
 80070ee:	005b      	lsls	r3, r3, #1
 80070f0:	4413      	add	r3, r2
 80070f2:	00db      	lsls	r3, r3, #3
 80070f4:	440b      	add	r3, r1
 80070f6:	330d      	adds	r3, #13
 80070f8:	781b      	ldrb	r3, [r3, #0]
 80070fa:	b2db      	uxtb	r3, r3
 80070fc:	2b01      	cmp	r3, #1
 80070fe:	d124      	bne.n	800714a <HW_TS_RTC_Wakeup_Handler+0xee>
      {
        UnlinkTimer(local_current_running_timer_id, SSR_Read_Not_Requested);
 8007100:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8007104:	2101      	movs	r1, #1
 8007106:	4618      	mov	r0, r3
 8007108:	f7ff fdf2 	bl	8006cf0 <UnlinkTimer>
 800710c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800710e:	613b      	str	r3, [r7, #16]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8007110:	693b      	ldr	r3, [r7, #16]
 8007112:	f383 8810 	msr	PRIMASK, r3
}
 8007116:	bf00      	nop
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
        __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif
        HW_TS_Start(local_current_running_timer_id, aTimerContext[local_current_running_timer_id].CounterInit);
 8007118:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800711c:	4930      	ldr	r1, [pc, #192]	; (80071e0 <HW_TS_RTC_Wakeup_Handler+0x184>)
 800711e:	4613      	mov	r3, r2
 8007120:	005b      	lsls	r3, r3, #1
 8007122:	4413      	add	r3, r2
 8007124:	00db      	lsls	r3, r3, #3
 8007126:	440b      	add	r3, r1
 8007128:	3304      	adds	r3, #4
 800712a:	681a      	ldr	r2, [r3, #0]
 800712c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8007130:	4611      	mov	r1, r2
 8007132:	4618      	mov	r0, r3
 8007134:	f000 f9b8 	bl	80074a8 <HW_TS_Start>

        /* Disable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_DISABLE( &hrtc );
 8007138:	4b27      	ldr	r3, [pc, #156]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 800713a:	681b      	ldr	r3, [r3, #0]
 800713c:	22ca      	movs	r2, #202	; 0xca
 800713e:	625a      	str	r2, [r3, #36]	; 0x24
 8007140:	4b25      	ldr	r3, [pc, #148]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 8007142:	681b      	ldr	r3, [r3, #0]
 8007144:	2253      	movs	r2, #83	; 0x53
 8007146:	625a      	str	r2, [r3, #36]	; 0x24
 8007148:	e012      	b.n	8007170 <HW_TS_RTC_Wakeup_Handler+0x114>
 800714a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800714c:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800714e:	68fb      	ldr	r3, [r7, #12]
 8007150:	f383 8810 	msr	PRIMASK, r3
}
 8007154:	bf00      	nop
      else
      {
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
        __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif
        HW_TS_Stop(local_current_running_timer_id);
 8007156:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800715a:	4618      	mov	r0, r3
 800715c:	f000 f920 	bl	80073a0 <HW_TS_Stop>

        /* Disable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_DISABLE( &hrtc );
 8007160:	4b1d      	ldr	r3, [pc, #116]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 8007162:	681b      	ldr	r3, [r3, #0]
 8007164:	22ca      	movs	r2, #202	; 0xca
 8007166:	625a      	str	r2, [r3, #36]	; 0x24
 8007168:	4b1b      	ldr	r3, [pc, #108]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 800716a:	681b      	ldr	r3, [r3, #0]
 800716c:	2253      	movs	r2, #83	; 0x53
 800716e:	625a      	str	r2, [r3, #36]	; 0x24
        }

      HW_TS_RTC_Int_AppNot(timer_process_id, local_current_running_timer_id, ptimer_callback);
 8007170:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8007174:	69fa      	ldr	r2, [r7, #28]
 8007176:	4619      	mov	r1, r3
 8007178:	69b8      	ldr	r0, [r7, #24]
 800717a:	f000 fa1b 	bl	80075b4 <HW_TS_RTC_Int_AppNot>
 800717e:	e022      	b.n	80071c6 <HW_TS_RTC_Wakeup_Handler+0x16a>
    }
    else
    {
      RescheduleTimerList();
 8007180:	f7ff fed2 	bl	8006f28 <RescheduleTimerList>
 8007184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007186:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8007188:	68bb      	ldr	r3, [r7, #8]
 800718a:	f383 8810 	msr	PRIMASK, r3
}
 800718e:	e01a      	b.n	80071c6 <HW_TS_RTC_Wakeup_Handler+0x16a>
    /**
     * We should never end up in this case
     * However, if due to any bug in the timer server this is the case, the mistake may not impact the user.
     * We could just clean the interrupt flag and get out from this unexpected interrupt
     */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc, RTC_FLAG_WUTWF) == RESET);
 8007190:	bf00      	nop
 8007192:	4b11      	ldr	r3, [pc, #68]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 8007194:	681b      	ldr	r3, [r3, #0]
 8007196:	68db      	ldr	r3, [r3, #12]
 8007198:	f003 0304 	and.w	r3, r3, #4
 800719c:	2b00      	cmp	r3, #0
 800719e:	d0f8      	beq.n	8007192 <HW_TS_RTC_Wakeup_Handler+0x136>
     * It takes 2 RTCCLK between the time the WUTE bit is disabled and the
     * time the timer is disabled. The WUTWF bit somehow guarantee the system is stable
     * Otherwise, when the timer is periodic with 1 Tick, it may generate an extra interrupt in between
     * due to the autoreload feature
     */
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 80071a0:	4b0d      	ldr	r3, [pc, #52]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 80071a2:	681b      	ldr	r3, [r3, #0]
 80071a4:	68db      	ldr	r3, [r3, #12]
 80071a6:	b2da      	uxtb	r2, r3
 80071a8:	4b0b      	ldr	r3, [pc, #44]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 80071aa:	681b      	ldr	r3, [r3, #0]
 80071ac:	f462 6290 	orn	r2, r2, #1152	; 0x480
 80071b0:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 80071b2:	4b0d      	ldr	r3, [pc, #52]	; (80071e8 <HW_TS_RTC_Wakeup_Handler+0x18c>)
 80071b4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80071b8:	60da      	str	r2, [r3, #12]
 80071ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80071bc:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80071be:	687b      	ldr	r3, [r7, #4]
 80071c0:	f383 8810 	msr	PRIMASK, r3
}
 80071c4:	bf00      	nop
    __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( &hrtc );
 80071c6:	4b04      	ldr	r3, [pc, #16]	; (80071d8 <HW_TS_RTC_Wakeup_Handler+0x17c>)
 80071c8:	681b      	ldr	r3, [r3, #0]
 80071ca:	22ff      	movs	r2, #255	; 0xff
 80071cc:	625a      	str	r2, [r3, #36]	; 0x24

  return;
 80071ce:	bf00      	nop
}
 80071d0:	3728      	adds	r7, #40	; 0x28
 80071d2:	46bd      	mov	sp, r7
 80071d4:	bd80      	pop	{r7, pc}
 80071d6:	bf00      	nop
 80071d8:	20000d4c 	.word	0x20000d4c
 80071dc:	20000b44 	.word	0x20000b44
 80071e0:	20000ab4 	.word	0x20000ab4
 80071e4:	20000b4c 	.word	0x20000b4c
 80071e8:	58000800 	.word	0x58000800

080071ec <HW_TS_Init>:

void HW_TS_Init(HW_TS_InitMode_t TimerInitMode, RTC_HandleTypeDef *phrtc)
{
 80071ec:	b580      	push	{r7, lr}
 80071ee:	b088      	sub	sp, #32
 80071f0:	af00      	add	r7, sp, #0
 80071f2:	4603      	mov	r3, r0
 80071f4:	6039      	str	r1, [r7, #0]
 80071f6:	71fb      	strb	r3, [r7, #7]
  uint8_t loop;
  uint32_t localmaxwakeuptimersetup;

 /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( &hrtc );
 80071f8:	4b5e      	ldr	r3, [pc, #376]	; (8007374 <HW_TS_Init+0x188>)
 80071fa:	681b      	ldr	r3, [r3, #0]
 80071fc:	22ca      	movs	r2, #202	; 0xca
 80071fe:	625a      	str	r2, [r3, #36]	; 0x24
 8007200:	4b5c      	ldr	r3, [pc, #368]	; (8007374 <HW_TS_Init+0x188>)
 8007202:	681b      	ldr	r3, [r3, #0]
 8007204:	2253      	movs	r2, #83	; 0x53
 8007206:	625a      	str	r2, [r3, #36]	; 0x24

  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8007208:	4b5b      	ldr	r3, [pc, #364]	; (8007378 <HW_TS_Init+0x18c>)
 800720a:	689b      	ldr	r3, [r3, #8]
 800720c:	4a5a      	ldr	r2, [pc, #360]	; (8007378 <HW_TS_Init+0x18c>)
 800720e:	f043 0320 	orr.w	r3, r3, #32
 8007212:	6093      	str	r3, [r2, #8]

  /**
   * Readout the user config
   */
  WakeupTimerDivider = (4 - ((uint32_t)(READ_BIT(RTC->CR, RTC_CR_WUCKSEL))));
 8007214:	4b58      	ldr	r3, [pc, #352]	; (8007378 <HW_TS_Init+0x18c>)
 8007216:	689b      	ldr	r3, [r3, #8]
 8007218:	b2db      	uxtb	r3, r3
 800721a:	f003 0307 	and.w	r3, r3, #7
 800721e:	b2db      	uxtb	r3, r3
 8007220:	f1c3 0304 	rsb	r3, r3, #4
 8007224:	b2da      	uxtb	r2, r3
 8007226:	4b55      	ldr	r3, [pc, #340]	; (800737c <HW_TS_Init+0x190>)
 8007228:	701a      	strb	r2, [r3, #0]

  AsynchPrescalerUserConfig = (uint8_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_A) >> (uint32_t)POSITION_VAL(RTC_PRER_PREDIV_A)) + 1;
 800722a:	4b53      	ldr	r3, [pc, #332]	; (8007378 <HW_TS_Init+0x18c>)
 800722c:	691b      	ldr	r3, [r3, #16]
 800722e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 8007232:	f44f 02fe 	mov.w	r2, #8323072	; 0x7f0000
 8007236:	613a      	str	r2, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007238:	693a      	ldr	r2, [r7, #16]
 800723a:	fa92 f2a2 	rbit	r2, r2
 800723e:	60fa      	str	r2, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8007240:	68fa      	ldr	r2, [r7, #12]
 8007242:	617a      	str	r2, [r7, #20]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8007244:	697a      	ldr	r2, [r7, #20]
 8007246:	2a00      	cmp	r2, #0
 8007248:	d101      	bne.n	800724e <HW_TS_Init+0x62>
  {
    return 32U;
 800724a:	2220      	movs	r2, #32
 800724c:	e003      	b.n	8007256 <HW_TS_Init+0x6a>
  }
  return __builtin_clz(value);
 800724e:	697a      	ldr	r2, [r7, #20]
 8007250:	fab2 f282 	clz	r2, r2
 8007254:	b2d2      	uxtb	r2, r2
 8007256:	40d3      	lsrs	r3, r2
 8007258:	b2db      	uxtb	r3, r3
 800725a:	3301      	adds	r3, #1
 800725c:	b2da      	uxtb	r2, r3
 800725e:	4b48      	ldr	r3, [pc, #288]	; (8007380 <HW_TS_Init+0x194>)
 8007260:	701a      	strb	r2, [r3, #0]

  SynchPrescalerUserConfig = (uint16_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_S)) + 1;
 8007262:	4b45      	ldr	r3, [pc, #276]	; (8007378 <HW_TS_Init+0x18c>)
 8007264:	691b      	ldr	r3, [r3, #16]
 8007266:	b29b      	uxth	r3, r3
 8007268:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800726c:	b29b      	uxth	r3, r3
 800726e:	3301      	adds	r3, #1
 8007270:	b29a      	uxth	r2, r3
 8007272:	4b44      	ldr	r3, [pc, #272]	; (8007384 <HW_TS_Init+0x198>)
 8007274:	801a      	strh	r2, [r3, #0]

  /**
   *  Margin is taken to avoid wrong calculation when the wrap around is there and some
   *  application interrupts may have delayed the reading
   */
  localmaxwakeuptimersetup = ((((SynchPrescalerUserConfig - 1)*AsynchPrescalerUserConfig) - CFG_HW_TS_RTC_HANDLER_MAX_DELAY) >> WakeupTimerDivider);
 8007276:	4b43      	ldr	r3, [pc, #268]	; (8007384 <HW_TS_Init+0x198>)
 8007278:	881b      	ldrh	r3, [r3, #0]
 800727a:	3b01      	subs	r3, #1
 800727c:	4a40      	ldr	r2, [pc, #256]	; (8007380 <HW_TS_Init+0x194>)
 800727e:	7812      	ldrb	r2, [r2, #0]
 8007280:	fb02 f303 	mul.w	r3, r2, r3
 8007284:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 8007288:	4a3c      	ldr	r2, [pc, #240]	; (800737c <HW_TS_Init+0x190>)
 800728a:	7812      	ldrb	r2, [r2, #0]
 800728c:	40d3      	lsrs	r3, r2
 800728e:	61bb      	str	r3, [r7, #24]

  if(localmaxwakeuptimersetup >= 0xFFFF)
 8007290:	69bb      	ldr	r3, [r7, #24]
 8007292:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8007296:	4293      	cmp	r3, r2
 8007298:	d904      	bls.n	80072a4 <HW_TS_Init+0xb8>
  {
    MaxWakeupTimerSetup = 0xFFFF;
 800729a:	4b3b      	ldr	r3, [pc, #236]	; (8007388 <HW_TS_Init+0x19c>)
 800729c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80072a0:	801a      	strh	r2, [r3, #0]
 80072a2:	e003      	b.n	80072ac <HW_TS_Init+0xc0>
  }
  else
  {
    MaxWakeupTimerSetup = (uint16_t)localmaxwakeuptimersetup;
 80072a4:	69bb      	ldr	r3, [r7, #24]
 80072a6:	b29a      	uxth	r2, r3
 80072a8:	4b37      	ldr	r3, [pc, #220]	; (8007388 <HW_TS_Init+0x19c>)
 80072aa:	801a      	strh	r2, [r3, #0]
  }

  /**
   * Configure EXTI module
   */
  LL_EXTI_EnableRisingTrig_0_31(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 80072ac:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80072b0:	f7ff fb9c 	bl	80069ec <LL_EXTI_EnableRisingTrig_0_31>
  LL_EXTI_EnableIT_0_31(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 80072b4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80072b8:	f7ff fb84 	bl	80069c4 <LL_EXTI_EnableIT_0_31>

  if(TimerInitMode == hw_ts_InitMode_Full)
 80072bc:	79fb      	ldrb	r3, [r7, #7]
 80072be:	2b00      	cmp	r3, #0
 80072c0:	d13d      	bne.n	800733e <HW_TS_Init+0x152>
  {
    WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 80072c2:	4b32      	ldr	r3, [pc, #200]	; (800738c <HW_TS_Init+0x1a0>)
 80072c4:	2201      	movs	r2, #1
 80072c6:	701a      	strb	r2, [r3, #0]
    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 80072c8:	4b31      	ldr	r3, [pc, #196]	; (8007390 <HW_TS_Init+0x1a4>)
 80072ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80072ce:	601a      	str	r2, [r3, #0]

    /**
     * Initialize the timer server
     */
    for(loop = 0; loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER; loop++)
 80072d0:	2300      	movs	r3, #0
 80072d2:	77fb      	strb	r3, [r7, #31]
 80072d4:	e00c      	b.n	80072f0 <HW_TS_Init+0x104>
    {
      aTimerContext[loop].TimerIDStatus = TimerID_Free;
 80072d6:	7ffa      	ldrb	r2, [r7, #31]
 80072d8:	492e      	ldr	r1, [pc, #184]	; (8007394 <HW_TS_Init+0x1a8>)
 80072da:	4613      	mov	r3, r2
 80072dc:	005b      	lsls	r3, r3, #1
 80072de:	4413      	add	r3, r2
 80072e0:	00db      	lsls	r3, r3, #3
 80072e2:	440b      	add	r3, r1
 80072e4:	330c      	adds	r3, #12
 80072e6:	2200      	movs	r2, #0
 80072e8:	701a      	strb	r2, [r3, #0]
    for(loop = 0; loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER; loop++)
 80072ea:	7ffb      	ldrb	r3, [r7, #31]
 80072ec:	3301      	adds	r3, #1
 80072ee:	77fb      	strb	r3, [r7, #31]
 80072f0:	7ffb      	ldrb	r3, [r7, #31]
 80072f2:	2b05      	cmp	r3, #5
 80072f4:	d9ef      	bls.n	80072d6 <HW_TS_Init+0xea>
    }

    CurrentRunningTimerID = CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER;   /**<  Set ID to non valid value */
 80072f6:	4b28      	ldr	r3, [pc, #160]	; (8007398 <HW_TS_Init+0x1ac>)
 80072f8:	2206      	movs	r2, #6
 80072fa:	701a      	strb	r2, [r3, #0]

    __HAL_RTC_WAKEUPTIMER_DISABLE(&hrtc);                       /**<  Disable the Wakeup Timer */
 80072fc:	4b1d      	ldr	r3, [pc, #116]	; (8007374 <HW_TS_Init+0x188>)
 80072fe:	681b      	ldr	r3, [r3, #0]
 8007300:	689a      	ldr	r2, [r3, #8]
 8007302:	4b1c      	ldr	r3, [pc, #112]	; (8007374 <HW_TS_Init+0x188>)
 8007304:	681b      	ldr	r3, [r3, #0]
 8007306:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800730a:	609a      	str	r2, [r3, #8]
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);     /**<  Clear flag in RTC module */
 800730c:	4b19      	ldr	r3, [pc, #100]	; (8007374 <HW_TS_Init+0x188>)
 800730e:	681b      	ldr	r3, [r3, #0]
 8007310:	68db      	ldr	r3, [r3, #12]
 8007312:	b2da      	uxtb	r2, r3
 8007314:	4b17      	ldr	r3, [pc, #92]	; (8007374 <HW_TS_Init+0x188>)
 8007316:	681b      	ldr	r3, [r3, #0]
 8007318:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800731c:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module  */
 800731e:	4b1f      	ldr	r3, [pc, #124]	; (800739c <HW_TS_Init+0x1b0>)
 8007320:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8007324:	60da      	str	r2, [r3, #12]
    HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);       /**<  Clear pending bit in NVIC  */
 8007326:	2003      	movs	r0, #3
 8007328:	f002 fac9 	bl	80098be <HAL_NVIC_ClearPendingIRQ>
    __HAL_RTC_WAKEUPTIMER_ENABLE_IT(&hrtc, RTC_IT_WUT);         /**<  Enable interrupt in RTC module  */
 800732c:	4b11      	ldr	r3, [pc, #68]	; (8007374 <HW_TS_Init+0x188>)
 800732e:	681b      	ldr	r3, [r3, #0]
 8007330:	689a      	ldr	r2, [r3, #8]
 8007332:	4b10      	ldr	r3, [pc, #64]	; (8007374 <HW_TS_Init+0x188>)
 8007334:	681b      	ldr	r3, [r3, #0]
 8007336:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800733a:	609a      	str	r2, [r3, #8]
 800733c:	e009      	b.n	8007352 <HW_TS_Init+0x166>
  }
  else
  {
    if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc, RTC_FLAG_WUTF) != RESET)
 800733e:	4b0d      	ldr	r3, [pc, #52]	; (8007374 <HW_TS_Init+0x188>)
 8007340:	681b      	ldr	r3, [r3, #0]
 8007342:	68db      	ldr	r3, [r3, #12]
 8007344:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007348:	2b00      	cmp	r3, #0
 800734a:	d002      	beq.n	8007352 <HW_TS_Init+0x166>
    {
      /**
       * Simulate that the Timer expired
       */
      HAL_NVIC_SetPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);
 800734c:	2003      	movs	r0, #3
 800734e:	f002 faa8 	bl	80098a2 <HAL_NVIC_SetPendingIRQ>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( &hrtc );
 8007352:	4b08      	ldr	r3, [pc, #32]	; (8007374 <HW_TS_Init+0x188>)
 8007354:	681b      	ldr	r3, [r3, #0]
 8007356:	22ff      	movs	r2, #255	; 0xff
 8007358:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_SetPriority(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID, CFG_HW_TS_NVIC_RTC_WAKEUP_IT_PREEMPTPRIO, CFG_HW_TS_NVIC_RTC_WAKEUP_IT_SUBPRIO);   /**<  Set NVIC priority */
 800735a:	2200      	movs	r2, #0
 800735c:	2103      	movs	r1, #3
 800735e:	2003      	movs	r0, #3
 8007360:	f002 fa5d 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 8007364:	2003      	movs	r0, #3
 8007366:	f002 fa74 	bl	8009852 <HAL_NVIC_EnableIRQ>

  return;
 800736a:	bf00      	nop
}
 800736c:	3720      	adds	r7, #32
 800736e:	46bd      	mov	sp, r7
 8007370:	bd80      	pop	{r7, pc}
 8007372:	bf00      	nop
 8007374:	20000d4c 	.word	0x20000d4c
 8007378:	40002800 	.word	0x40002800
 800737c:	20000b4d 	.word	0x20000b4d
 8007380:	20000b4e 	.word	0x20000b4e
 8007384:	20000b50 	.word	0x20000b50
 8007388:	20000b52 	.word	0x20000b52
 800738c:	20000b4c 	.word	0x20000b4c
 8007390:	20000b48 	.word	0x20000b48
 8007394:	20000ab4 	.word	0x20000ab4
 8007398:	20000b44 	.word	0x20000b44
 800739c:	58000800 	.word	0x58000800

080073a0 <HW_TS_Stop>:

  return;
}

void HW_TS_Stop(uint8_t timer_id)
{
 80073a0:	b580      	push	{r7, lr}
 80073a2:	b086      	sub	sp, #24
 80073a4:	af00      	add	r7, sp, #0
 80073a6:	4603      	mov	r3, r0
 80073a8:	71fb      	strb	r3, [r7, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80073aa:	f3ef 8310 	mrs	r3, PRIMASK
 80073ae:	60fb      	str	r3, [r7, #12]
  return(result);
 80073b0:	68fb      	ldr	r3, [r7, #12]
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80073b2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80073b4:	b672      	cpsid	i
}
 80073b6:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  HAL_NVIC_DisableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);    /**<  Disable NVIC */
 80073b8:	2003      	movs	r0, #3
 80073ba:	f002 fa58 	bl	800986e <HAL_NVIC_DisableIRQ>

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( &hrtc );
 80073be:	4b34      	ldr	r3, [pc, #208]	; (8007490 <HW_TS_Stop+0xf0>)
 80073c0:	681b      	ldr	r3, [r3, #0]
 80073c2:	22ca      	movs	r2, #202	; 0xca
 80073c4:	625a      	str	r2, [r3, #36]	; 0x24
 80073c6:	4b32      	ldr	r3, [pc, #200]	; (8007490 <HW_TS_Stop+0xf0>)
 80073c8:	681b      	ldr	r3, [r3, #0]
 80073ca:	2253      	movs	r2, #83	; 0x53
 80073cc:	625a      	str	r2, [r3, #36]	; 0x24

  if(aTimerContext[timer_id].TimerIDStatus == TimerID_Running)
 80073ce:	79fa      	ldrb	r2, [r7, #7]
 80073d0:	4930      	ldr	r1, [pc, #192]	; (8007494 <HW_TS_Stop+0xf4>)
 80073d2:	4613      	mov	r3, r2
 80073d4:	005b      	lsls	r3, r3, #1
 80073d6:	4413      	add	r3, r2
 80073d8:	00db      	lsls	r3, r3, #3
 80073da:	440b      	add	r3, r1
 80073dc:	330c      	adds	r3, #12
 80073de:	781b      	ldrb	r3, [r3, #0]
 80073e0:	b2db      	uxtb	r3, r3
 80073e2:	2b02      	cmp	r3, #2
 80073e4:	d142      	bne.n	800746c <HW_TS_Stop+0xcc>
  {
    UnlinkTimer(timer_id, SSR_Read_Requested);
 80073e6:	79fb      	ldrb	r3, [r7, #7]
 80073e8:	2100      	movs	r1, #0
 80073ea:	4618      	mov	r0, r3
 80073ec:	f7ff fc80 	bl	8006cf0 <UnlinkTimer>
    localcurrentrunningtimerid = CurrentRunningTimerID;
 80073f0:	4b29      	ldr	r3, [pc, #164]	; (8007498 <HW_TS_Stop+0xf8>)
 80073f2:	781b      	ldrb	r3, [r3, #0]
 80073f4:	74fb      	strb	r3, [r7, #19]

    if(localcurrentrunningtimerid == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 80073f6:	7cfb      	ldrb	r3, [r7, #19]
 80073f8:	2b06      	cmp	r3, #6
 80073fa:	d12f      	bne.n	800745c <HW_TS_Stop+0xbc>
       */

      /**
       * Disable the timer
       */
      if((READ_BIT(RTC->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) == SET)
 80073fc:	4b27      	ldr	r3, [pc, #156]	; (800749c <HW_TS_Stop+0xfc>)
 80073fe:	689b      	ldr	r3, [r3, #8]
 8007400:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007404:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8007408:	d107      	bne.n	800741a <HW_TS_Stop+0x7a>
      {
        /**
         * Wait for the flag to be back to 0 when the wakeup timer is enabled
         */
        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc, RTC_FLAG_WUTWF) == SET);
 800740a:	bf00      	nop
 800740c:	4b20      	ldr	r3, [pc, #128]	; (8007490 <HW_TS_Stop+0xf0>)
 800740e:	681b      	ldr	r3, [r3, #0]
 8007410:	68db      	ldr	r3, [r3, #12]
 8007412:	f003 0304 	and.w	r3, r3, #4
 8007416:	2b00      	cmp	r3, #0
 8007418:	d1f8      	bne.n	800740c <HW_TS_Stop+0x6c>
      }
      __HAL_RTC_WAKEUPTIMER_DISABLE(&hrtc);   /**<  Disable the Wakeup Timer */
 800741a:	4b1d      	ldr	r3, [pc, #116]	; (8007490 <HW_TS_Stop+0xf0>)
 800741c:	681b      	ldr	r3, [r3, #0]
 800741e:	689a      	ldr	r2, [r3, #8]
 8007420:	4b1b      	ldr	r3, [pc, #108]	; (8007490 <HW_TS_Stop+0xf0>)
 8007422:	681b      	ldr	r3, [r3, #0]
 8007424:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8007428:	609a      	str	r2, [r3, #8]

      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(&hrtc, RTC_FLAG_WUTWF) == RESET);
 800742a:	bf00      	nop
 800742c:	4b18      	ldr	r3, [pc, #96]	; (8007490 <HW_TS_Stop+0xf0>)
 800742e:	681b      	ldr	r3, [r3, #0]
 8007430:	68db      	ldr	r3, [r3, #12]
 8007432:	f003 0304 	and.w	r3, r3, #4
 8007436:	2b00      	cmp	r3, #0
 8007438:	d0f8      	beq.n	800742c <HW_TS_Stop+0x8c>
       * It takes 2 RTCCLK between the time the WUTE bit is disabled and the
       * time the timer is disabled. The WUTWF bit somehow guarantee the system is stable
       * Otherwise, when the timer is periodic with 1 Tick, it may generate an extra interrupt in between
       * due to the autoreload feature
       */
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 800743a:	4b15      	ldr	r3, [pc, #84]	; (8007490 <HW_TS_Stop+0xf0>)
 800743c:	681b      	ldr	r3, [r3, #0]
 800743e:	68db      	ldr	r3, [r3, #12]
 8007440:	b2da      	uxtb	r2, r3
 8007442:	4b13      	ldr	r3, [pc, #76]	; (8007490 <HW_TS_Stop+0xf0>)
 8007444:	681b      	ldr	r3, [r3, #0]
 8007446:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800744a:	60da      	str	r2, [r3, #12]
      __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 800744c:	4b14      	ldr	r3, [pc, #80]	; (80074a0 <HW_TS_Stop+0x100>)
 800744e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8007452:	60da      	str	r2, [r3, #12]
      HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);   /**<  Clear pending bit in NVIC */
 8007454:	2003      	movs	r0, #3
 8007456:	f002 fa32 	bl	80098be <HAL_NVIC_ClearPendingIRQ>
 800745a:	e007      	b.n	800746c <HW_TS_Stop+0xcc>
    }
    else if(PreviousRunningTimerID != localcurrentrunningtimerid)
 800745c:	4b11      	ldr	r3, [pc, #68]	; (80074a4 <HW_TS_Stop+0x104>)
 800745e:	781b      	ldrb	r3, [r3, #0]
 8007460:	b2db      	uxtb	r3, r3
 8007462:	7cfa      	ldrb	r2, [r7, #19]
 8007464:	429a      	cmp	r2, r3
 8007466:	d001      	beq.n	800746c <HW_TS_Stop+0xcc>
    {
      RescheduleTimerList();
 8007468:	f7ff fd5e 	bl	8006f28 <RescheduleTimerList>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( &hrtc );
 800746c:	4b08      	ldr	r3, [pc, #32]	; (8007490 <HW_TS_Stop+0xf0>)
 800746e:	681b      	ldr	r3, [r3, #0]
 8007470:	22ff      	movs	r2, #255	; 0xff
 8007472:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 8007474:	2003      	movs	r0, #3
 8007476:	f002 f9ec 	bl	8009852 <HAL_NVIC_EnableIRQ>
 800747a:	697b      	ldr	r3, [r7, #20]
 800747c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800747e:	68bb      	ldr	r3, [r7, #8]
 8007480:	f383 8810 	msr	PRIMASK, r3
}
 8007484:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

  return;
 8007486:	bf00      	nop
}
 8007488:	3718      	adds	r7, #24
 800748a:	46bd      	mov	sp, r7
 800748c:	bd80      	pop	{r7, pc}
 800748e:	bf00      	nop
 8007490:	20000d4c 	.word	0x20000d4c
 8007494:	20000ab4 	.word	0x20000ab4
 8007498:	20000b44 	.word	0x20000b44
 800749c:	40002800 	.word	0x40002800
 80074a0:	58000800 	.word	0x58000800
 80074a4:	20000b45 	.word	0x20000b45

080074a8 <HW_TS_Start>:

void HW_TS_Start(uint8_t timer_id, uint32_t timeout_ticks)
{
 80074a8:	b580      	push	{r7, lr}
 80074aa:	b086      	sub	sp, #24
 80074ac:	af00      	add	r7, sp, #0
 80074ae:	4603      	mov	r3, r0
 80074b0:	6039      	str	r1, [r7, #0]
 80074b2:	71fb      	strb	r3, [r7, #7]

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

  if(aTimerContext[timer_id].TimerIDStatus == TimerID_Running)
 80074b4:	79fa      	ldrb	r2, [r7, #7]
 80074b6:	493b      	ldr	r1, [pc, #236]	; (80075a4 <HW_TS_Start+0xfc>)
 80074b8:	4613      	mov	r3, r2
 80074ba:	005b      	lsls	r3, r3, #1
 80074bc:	4413      	add	r3, r2
 80074be:	00db      	lsls	r3, r3, #3
 80074c0:	440b      	add	r3, r1
 80074c2:	330c      	adds	r3, #12
 80074c4:	781b      	ldrb	r3, [r3, #0]
 80074c6:	b2db      	uxtb	r3, r3
 80074c8:	2b02      	cmp	r3, #2
 80074ca:	d103      	bne.n	80074d4 <HW_TS_Start+0x2c>
  {
    HW_TS_Stop( timer_id );
 80074cc:	79fb      	ldrb	r3, [r7, #7]
 80074ce:	4618      	mov	r0, r3
 80074d0:	f7ff ff66 	bl	80073a0 <HW_TS_Stop>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80074d4:	f3ef 8310 	mrs	r3, PRIMASK
 80074d8:	60fb      	str	r3, [r7, #12]
  return(result);
 80074da:	68fb      	ldr	r3, [r7, #12]
  }

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80074dc:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80074de:	b672      	cpsid	i
}
 80074e0:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  HAL_NVIC_DisableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);    /**<  Disable NVIC */
 80074e2:	2003      	movs	r0, #3
 80074e4:	f002 f9c3 	bl	800986e <HAL_NVIC_DisableIRQ>

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( &hrtc );
 80074e8:	4b2f      	ldr	r3, [pc, #188]	; (80075a8 <HW_TS_Start+0x100>)
 80074ea:	681b      	ldr	r3, [r3, #0]
 80074ec:	22ca      	movs	r2, #202	; 0xca
 80074ee:	625a      	str	r2, [r3, #36]	; 0x24
 80074f0:	4b2d      	ldr	r3, [pc, #180]	; (80075a8 <HW_TS_Start+0x100>)
 80074f2:	681b      	ldr	r3, [r3, #0]
 80074f4:	2253      	movs	r2, #83	; 0x53
 80074f6:	625a      	str	r2, [r3, #36]	; 0x24

  aTimerContext[timer_id].TimerIDStatus = TimerID_Running;
 80074f8:	79fa      	ldrb	r2, [r7, #7]
 80074fa:	492a      	ldr	r1, [pc, #168]	; (80075a4 <HW_TS_Start+0xfc>)
 80074fc:	4613      	mov	r3, r2
 80074fe:	005b      	lsls	r3, r3, #1
 8007500:	4413      	add	r3, r2
 8007502:	00db      	lsls	r3, r3, #3
 8007504:	440b      	add	r3, r1
 8007506:	330c      	adds	r3, #12
 8007508:	2202      	movs	r2, #2
 800750a:	701a      	strb	r2, [r3, #0]

  aTimerContext[timer_id].CountLeft = timeout_ticks;
 800750c:	79fa      	ldrb	r2, [r7, #7]
 800750e:	4925      	ldr	r1, [pc, #148]	; (80075a4 <HW_TS_Start+0xfc>)
 8007510:	4613      	mov	r3, r2
 8007512:	005b      	lsls	r3, r3, #1
 8007514:	4413      	add	r3, r2
 8007516:	00db      	lsls	r3, r3, #3
 8007518:	440b      	add	r3, r1
 800751a:	3308      	adds	r3, #8
 800751c:	683a      	ldr	r2, [r7, #0]
 800751e:	601a      	str	r2, [r3, #0]
  aTimerContext[timer_id].CounterInit = timeout_ticks;
 8007520:	79fa      	ldrb	r2, [r7, #7]
 8007522:	4920      	ldr	r1, [pc, #128]	; (80075a4 <HW_TS_Start+0xfc>)
 8007524:	4613      	mov	r3, r2
 8007526:	005b      	lsls	r3, r3, #1
 8007528:	4413      	add	r3, r2
 800752a:	00db      	lsls	r3, r3, #3
 800752c:	440b      	add	r3, r1
 800752e:	3304      	adds	r3, #4
 8007530:	683a      	ldr	r2, [r7, #0]
 8007532:	601a      	str	r2, [r3, #0]

  time_elapsed =  linkTimer(timer_id);
 8007534:	79fb      	ldrb	r3, [r7, #7]
 8007536:	4618      	mov	r0, r3
 8007538:	f7ff fb30 	bl	8006b9c <linkTimer>
 800753c:	4603      	mov	r3, r0
 800753e:	827b      	strh	r3, [r7, #18]

  localcurrentrunningtimerid = CurrentRunningTimerID;
 8007540:	4b1a      	ldr	r3, [pc, #104]	; (80075ac <HW_TS_Start+0x104>)
 8007542:	781b      	ldrb	r3, [r3, #0]
 8007544:	747b      	strb	r3, [r7, #17]

  if(PreviousRunningTimerID != localcurrentrunningtimerid)
 8007546:	4b1a      	ldr	r3, [pc, #104]	; (80075b0 <HW_TS_Start+0x108>)
 8007548:	781b      	ldrb	r3, [r3, #0]
 800754a:	b2db      	uxtb	r3, r3
 800754c:	7c7a      	ldrb	r2, [r7, #17]
 800754e:	429a      	cmp	r2, r3
 8007550:	d002      	beq.n	8007558 <HW_TS_Start+0xb0>
  {
    RescheduleTimerList();
 8007552:	f7ff fce9 	bl	8006f28 <RescheduleTimerList>
 8007556:	e013      	b.n	8007580 <HW_TS_Start+0xd8>
  }
  else
  {
    aTimerContext[timer_id].CountLeft -= time_elapsed;
 8007558:	79fa      	ldrb	r2, [r7, #7]
 800755a:	4912      	ldr	r1, [pc, #72]	; (80075a4 <HW_TS_Start+0xfc>)
 800755c:	4613      	mov	r3, r2
 800755e:	005b      	lsls	r3, r3, #1
 8007560:	4413      	add	r3, r2
 8007562:	00db      	lsls	r3, r3, #3
 8007564:	440b      	add	r3, r1
 8007566:	3308      	adds	r3, #8
 8007568:	6819      	ldr	r1, [r3, #0]
 800756a:	8a7b      	ldrh	r3, [r7, #18]
 800756c:	79fa      	ldrb	r2, [r7, #7]
 800756e:	1ac9      	subs	r1, r1, r3
 8007570:	480c      	ldr	r0, [pc, #48]	; (80075a4 <HW_TS_Start+0xfc>)
 8007572:	4613      	mov	r3, r2
 8007574:	005b      	lsls	r3, r3, #1
 8007576:	4413      	add	r3, r2
 8007578:	00db      	lsls	r3, r3, #3
 800757a:	4403      	add	r3, r0
 800757c:	3308      	adds	r3, #8
 800757e:	6019      	str	r1, [r3, #0]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( &hrtc );
 8007580:	4b09      	ldr	r3, [pc, #36]	; (80075a8 <HW_TS_Start+0x100>)
 8007582:	681b      	ldr	r3, [r3, #0]
 8007584:	22ff      	movs	r2, #255	; 0xff
 8007586:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 8007588:	2003      	movs	r0, #3
 800758a:	f002 f962 	bl	8009852 <HAL_NVIC_EnableIRQ>
 800758e:	697b      	ldr	r3, [r7, #20]
 8007590:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8007592:	68bb      	ldr	r3, [r7, #8]
 8007594:	f383 8810 	msr	PRIMASK, r3
}
 8007598:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

  return;
 800759a:	bf00      	nop
}
 800759c:	3718      	adds	r7, #24
 800759e:	46bd      	mov	sp, r7
 80075a0:	bd80      	pop	{r7, pc}
 80075a2:	bf00      	nop
 80075a4:	20000ab4 	.word	0x20000ab4
 80075a8:	20000d4c 	.word	0x20000d4c
 80075ac:	20000b44 	.word	0x20000b44
 80075b0:	20000b45 	.word	0x20000b45

080075b4 <HW_TS_RTC_Int_AppNot>:

  return (return_value);
}

__weak void HW_TS_RTC_Int_AppNot(uint32_t TimerProcessID, uint8_t TimerID, HW_TS_pTimerCb_t pTimerCallBack)
{
 80075b4:	b580      	push	{r7, lr}
 80075b6:	b084      	sub	sp, #16
 80075b8:	af00      	add	r7, sp, #0
 80075ba:	60f8      	str	r0, [r7, #12]
 80075bc:	460b      	mov	r3, r1
 80075be:	607a      	str	r2, [r7, #4]
 80075c0:	72fb      	strb	r3, [r7, #11]
  pTimerCallBack();
 80075c2:	687b      	ldr	r3, [r7, #4]
 80075c4:	4798      	blx	r3

  return;
 80075c6:	bf00      	nop
}
 80075c8:	3710      	adds	r7, #16
 80075ca:	46bd      	mov	sp, r7
 80075cc:	bd80      	pop	{r7, pc}
	...

080075d0 <HW_UART_Receive_IT>:
    void (*HW_hlpuart1RxCb)(void);
    void (*HW_hlpuart1TxCb)(void);
#endif

void HW_UART_Receive_IT(hw_uart_id_t hw_uart_id, uint8_t *p_data, uint16_t size, void (*cb)(void))
{
 80075d0:	b580      	push	{r7, lr}
 80075d2:	b084      	sub	sp, #16
 80075d4:	af00      	add	r7, sp, #0
 80075d6:	60b9      	str	r1, [r7, #8]
 80075d8:	607b      	str	r3, [r7, #4]
 80075da:	4603      	mov	r3, r0
 80075dc:	73fb      	strb	r3, [r7, #15]
 80075de:	4613      	mov	r3, r2
 80075e0:	81bb      	strh	r3, [r7, #12]
    switch (hw_uart_id)
 80075e2:	7bfb      	ldrb	r3, [r7, #15]
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	d002      	beq.n	80075ee <HW_UART_Receive_IT+0x1e>
 80075e8:	2b02      	cmp	r3, #2
 80075ea:	d00d      	beq.n	8007608 <HW_UART_Receive_IT+0x38>
            HW_UART_RX_IT(hlpuart1, LPUART1);
            break;
#endif

        default:
            break;
 80075ec:	e019      	b.n	8007622 <HW_UART_Receive_IT+0x52>
            HW_UART_RX_IT(huart1, USART1);
 80075ee:	4a0f      	ldr	r2, [pc, #60]	; (800762c <HW_UART_Receive_IT+0x5c>)
 80075f0:	687b      	ldr	r3, [r7, #4]
 80075f2:	6013      	str	r3, [r2, #0]
 80075f4:	4b0e      	ldr	r3, [pc, #56]	; (8007630 <HW_UART_Receive_IT+0x60>)
 80075f6:	4a0f      	ldr	r2, [pc, #60]	; (8007634 <HW_UART_Receive_IT+0x64>)
 80075f8:	601a      	str	r2, [r3, #0]
 80075fa:	89bb      	ldrh	r3, [r7, #12]
 80075fc:	461a      	mov	r2, r3
 80075fe:	68b9      	ldr	r1, [r7, #8]
 8007600:	480b      	ldr	r0, [pc, #44]	; (8007630 <HW_UART_Receive_IT+0x60>)
 8007602:	f006 fa4b 	bl	800da9c <HAL_UART_Receive_IT>
            break;
 8007606:	e00c      	b.n	8007622 <HW_UART_Receive_IT+0x52>
            HW_UART_RX_IT(hlpuart1, LPUART1);
 8007608:	4a0b      	ldr	r2, [pc, #44]	; (8007638 <HW_UART_Receive_IT+0x68>)
 800760a:	687b      	ldr	r3, [r7, #4]
 800760c:	6013      	str	r3, [r2, #0]
 800760e:	4b0b      	ldr	r3, [pc, #44]	; (800763c <HW_UART_Receive_IT+0x6c>)
 8007610:	4a0b      	ldr	r2, [pc, #44]	; (8007640 <HW_UART_Receive_IT+0x70>)
 8007612:	601a      	str	r2, [r3, #0]
 8007614:	89bb      	ldrh	r3, [r7, #12]
 8007616:	461a      	mov	r2, r3
 8007618:	68b9      	ldr	r1, [r7, #8]
 800761a:	4808      	ldr	r0, [pc, #32]	; (800763c <HW_UART_Receive_IT+0x6c>)
 800761c:	f006 fa3e 	bl	800da9c <HAL_UART_Receive_IT>
            break;
 8007620:	bf00      	nop
    }

    return;
 8007622:	bf00      	nop
}
 8007624:	3710      	adds	r7, #16
 8007626:	46bd      	mov	sp, r7
 8007628:	bd80      	pop	{r7, pc}
 800762a:	bf00      	nop
 800762c:	20000b54 	.word	0x20000b54
 8007630:	20000bf8 	.word	0x20000bf8
 8007634:	40013800 	.word	0x40013800
 8007638:	20000b5c 	.word	0x20000b5c
 800763c:	20000b64 	.word	0x20000b64
 8007640:	40008000 	.word	0x40008000

08007644 <HAL_UART_RxCpltCallback>:

    return;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 8007644:	b580      	push	{r7, lr}
 8007646:	b082      	sub	sp, #8
 8007648:	af00      	add	r7, sp, #0
 800764a:	6078      	str	r0, [r7, #4]
    switch ((uint32_t)huart->Instance)
 800764c:	687b      	ldr	r3, [r7, #4]
 800764e:	681b      	ldr	r3, [r3, #0]
 8007650:	4a0f      	ldr	r2, [pc, #60]	; (8007690 <HAL_UART_RxCpltCallback+0x4c>)
 8007652:	4293      	cmp	r3, r2
 8007654:	d00a      	beq.n	800766c <HAL_UART_RxCpltCallback+0x28>
 8007656:	4a0f      	ldr	r2, [pc, #60]	; (8007694 <HAL_UART_RxCpltCallback+0x50>)
 8007658:	4293      	cmp	r3, r2
 800765a:	d10f      	bne.n	800767c <HAL_UART_RxCpltCallback+0x38>
    {
#if (CFG_HW_USART1_ENABLED == 1)
        case (uint32_t)USART1:
            if(HW_huart1RxCb)
 800765c:	4b0e      	ldr	r3, [pc, #56]	; (8007698 <HAL_UART_RxCpltCallback+0x54>)
 800765e:	681b      	ldr	r3, [r3, #0]
 8007660:	2b00      	cmp	r3, #0
 8007662:	d00d      	beq.n	8007680 <HAL_UART_RxCpltCallback+0x3c>
            {
                HW_huart1RxCb();
 8007664:	4b0c      	ldr	r3, [pc, #48]	; (8007698 <HAL_UART_RxCpltCallback+0x54>)
 8007666:	681b      	ldr	r3, [r3, #0]
 8007668:	4798      	blx	r3
            }
            break;
 800766a:	e009      	b.n	8007680 <HAL_UART_RxCpltCallback+0x3c>
#endif

#if (CFG_HW_LPUART1_ENABLED == 1)
        case (uint32_t)LPUART1:
            if(HW_hlpuart1RxCb)
 800766c:	4b0b      	ldr	r3, [pc, #44]	; (800769c <HAL_UART_RxCpltCallback+0x58>)
 800766e:	681b      	ldr	r3, [r3, #0]
 8007670:	2b00      	cmp	r3, #0
 8007672:	d007      	beq.n	8007684 <HAL_UART_RxCpltCallback+0x40>
            {
                HW_hlpuart1RxCb();
 8007674:	4b09      	ldr	r3, [pc, #36]	; (800769c <HAL_UART_RxCpltCallback+0x58>)
 8007676:	681b      	ldr	r3, [r3, #0]
 8007678:	4798      	blx	r3
            }
            break;
 800767a:	e003      	b.n	8007684 <HAL_UART_RxCpltCallback+0x40>
#endif

        default:
            break;
 800767c:	bf00      	nop
 800767e:	e002      	b.n	8007686 <HAL_UART_RxCpltCallback+0x42>
            break;
 8007680:	bf00      	nop
 8007682:	e000      	b.n	8007686 <HAL_UART_RxCpltCallback+0x42>
            break;
 8007684:	bf00      	nop
    }

    return;
 8007686:	bf00      	nop
}
 8007688:	3708      	adds	r7, #8
 800768a:	46bd      	mov	sp, r7
 800768c:	bd80      	pop	{r7, pc}
 800768e:	bf00      	nop
 8007690:	40008000 	.word	0x40008000
 8007694:	40013800 	.word	0x40013800
 8007698:	20000b54 	.word	0x20000b54
 800769c:	20000b5c 	.word	0x20000b5c

080076a0 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 80076a0:	b580      	push	{r7, lr}
 80076a2:	b082      	sub	sp, #8
 80076a4:	af00      	add	r7, sp, #0
 80076a6:	6078      	str	r0, [r7, #4]
    switch ((uint32_t)huart->Instance)
 80076a8:	687b      	ldr	r3, [r7, #4]
 80076aa:	681b      	ldr	r3, [r3, #0]
 80076ac:	4a0f      	ldr	r2, [pc, #60]	; (80076ec <HAL_UART_TxCpltCallback+0x4c>)
 80076ae:	4293      	cmp	r3, r2
 80076b0:	d00a      	beq.n	80076c8 <HAL_UART_TxCpltCallback+0x28>
 80076b2:	4a0f      	ldr	r2, [pc, #60]	; (80076f0 <HAL_UART_TxCpltCallback+0x50>)
 80076b4:	4293      	cmp	r3, r2
 80076b6:	d10f      	bne.n	80076d8 <HAL_UART_TxCpltCallback+0x38>
    {
#if (CFG_HW_USART1_ENABLED == 1)
        case (uint32_t)USART1:
            if(HW_huart1TxCb)
 80076b8:	4b0e      	ldr	r3, [pc, #56]	; (80076f4 <HAL_UART_TxCpltCallback+0x54>)
 80076ba:	681b      	ldr	r3, [r3, #0]
 80076bc:	2b00      	cmp	r3, #0
 80076be:	d00d      	beq.n	80076dc <HAL_UART_TxCpltCallback+0x3c>
            {
                HW_huart1TxCb();
 80076c0:	4b0c      	ldr	r3, [pc, #48]	; (80076f4 <HAL_UART_TxCpltCallback+0x54>)
 80076c2:	681b      	ldr	r3, [r3, #0]
 80076c4:	4798      	blx	r3
            }
            break;
 80076c6:	e009      	b.n	80076dc <HAL_UART_TxCpltCallback+0x3c>
#endif

#if (CFG_HW_LPUART1_ENABLED == 1)
        case (uint32_t)LPUART1:
            if(HW_hlpuart1TxCb)
 80076c8:	4b0b      	ldr	r3, [pc, #44]	; (80076f8 <HAL_UART_TxCpltCallback+0x58>)
 80076ca:	681b      	ldr	r3, [r3, #0]
 80076cc:	2b00      	cmp	r3, #0
 80076ce:	d007      	beq.n	80076e0 <HAL_UART_TxCpltCallback+0x40>
            {
                HW_hlpuart1TxCb();
 80076d0:	4b09      	ldr	r3, [pc, #36]	; (80076f8 <HAL_UART_TxCpltCallback+0x58>)
 80076d2:	681b      	ldr	r3, [r3, #0]
 80076d4:	4798      	blx	r3
            }
            break;
 80076d6:	e003      	b.n	80076e0 <HAL_UART_TxCpltCallback+0x40>
#endif

        default:
            break;
 80076d8:	bf00      	nop
 80076da:	e002      	b.n	80076e2 <HAL_UART_TxCpltCallback+0x42>
            break;
 80076dc:	bf00      	nop
 80076de:	e000      	b.n	80076e2 <HAL_UART_TxCpltCallback+0x42>
            break;
 80076e0:	bf00      	nop
    }

    return;
 80076e2:	bf00      	nop
}
 80076e4:	3708      	adds	r7, #8
 80076e6:	46bd      	mov	sp, r7
 80076e8:	bd80      	pop	{r7, pc}
 80076ea:	bf00      	nop
 80076ec:	40008000 	.word	0x40008000
 80076f0:	40013800 	.word	0x40013800
 80076f4:	20000b58 	.word	0x20000b58
 80076f8:	20000b60 	.word	0x20000b60

080076fc <LL_EXTI_EnableIT_32_63>:
{
 80076fc:	b480      	push	{r7}
 80076fe:	b083      	sub	sp, #12
 8007700:	af00      	add	r7, sp, #0
 8007702:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR2, ExtiLine);
 8007704:	4b06      	ldr	r3, [pc, #24]	; (8007720 <LL_EXTI_EnableIT_32_63+0x24>)
 8007706:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800770a:	4905      	ldr	r1, [pc, #20]	; (8007720 <LL_EXTI_EnableIT_32_63+0x24>)
 800770c:	687b      	ldr	r3, [r7, #4]
 800770e:	4313      	orrs	r3, r2
 8007710:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 8007714:	bf00      	nop
 8007716:	370c      	adds	r7, #12
 8007718:	46bd      	mov	sp, r7
 800771a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800771e:	4770      	bx	lr
 8007720:	58000800 	.word	0x58000800

08007724 <LL_RCC_HSE_SetCapacitorTuning>:
{
 8007724:	b480      	push	{r7}
 8007726:	b083      	sub	sp, #12
 8007728:	af00      	add	r7, sp, #0
 800772a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->HSECR, HSE_CONTROL_UNLOCK_KEY);
 800772c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007730:	4a0a      	ldr	r2, [pc, #40]	; (800775c <LL_RCC_HSE_SetCapacitorTuning+0x38>)
 8007732:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  MODIFY_REG(RCC->HSECR, RCC_HSECR_HSETUNE, Value << RCC_HSECR_HSETUNE_Pos);
 8007736:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800773a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800773e:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
 8007742:	687b      	ldr	r3, [r7, #4]
 8007744:	021b      	lsls	r3, r3, #8
 8007746:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800774a:	4313      	orrs	r3, r2
 800774c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
}
 8007750:	bf00      	nop
 8007752:	370c      	adds	r7, #12
 8007754:	46bd      	mov	sp, r7
 8007756:	f85d 7b04 	ldr.w	r7, [sp], #4
 800775a:	4770      	bx	lr
 800775c:	cafecafe 	.word	0xcafecafe

08007760 <LL_RCC_HSI48_Enable>:
{
 8007760:	b480      	push	{r7}
 8007762:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8007764:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007768:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800776c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8007770:	f043 0301 	orr.w	r3, r3, #1
 8007774:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 8007778:	bf00      	nop
 800777a:	46bd      	mov	sp, r7
 800777c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007780:	4770      	bx	lr

08007782 <LL_RCC_HSI48_IsReady>:
{
 8007782:	b480      	push	{r7}
 8007784:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 8007786:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800778a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800778e:	f003 0302 	and.w	r3, r3, #2
 8007792:	2b02      	cmp	r3, #2
 8007794:	d101      	bne.n	800779a <LL_RCC_HSI48_IsReady+0x18>
 8007796:	2301      	movs	r3, #1
 8007798:	e000      	b.n	800779c <LL_RCC_HSI48_IsReady+0x1a>
 800779a:	2300      	movs	r3, #0
}
 800779c:	4618      	mov	r0, r3
 800779e:	46bd      	mov	sp, r7
 80077a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077a4:	4770      	bx	lr

080077a6 <LL_RCC_LSE_SetDriveCapability>:
{
 80077a6:	b480      	push	{r7}
 80077a8:	b083      	sub	sp, #12
 80077aa:	af00      	add	r7, sp, #0
 80077ac:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 80077ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80077b2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80077b6:	f023 0218 	bic.w	r2, r3, #24
 80077ba:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80077be:	687b      	ldr	r3, [r7, #4]
 80077c0:	4313      	orrs	r3, r2
 80077c2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 80077c6:	bf00      	nop
 80077c8:	370c      	adds	r7, #12
 80077ca:	46bd      	mov	sp, r7
 80077cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077d0:	4770      	bx	lr

080077d2 <LL_RCC_ForceBackupDomainReset>:
  * @brief  Force the Backup domain reset
  * @rmtoll BDCR         BDRST         LL_RCC_ForceBackupDomainReset
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ForceBackupDomainReset(void)
{
 80077d2:	b480      	push	{r7}
 80077d4:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 80077d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80077da:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80077de:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80077e2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80077e6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 80077ea:	bf00      	nop
 80077ec:	46bd      	mov	sp, r7
 80077ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80077f2:	4770      	bx	lr

080077f4 <LL_RCC_ReleaseBackupDomainReset>:
  * @brief  Release the Backup domain reset
  * @rmtoll BDCR         BDRST         LL_RCC_ReleaseBackupDomainReset
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ReleaseBackupDomainReset(void)
{
 80077f4:	b480      	push	{r7}
 80077f6:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 80077f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80077fc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007800:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8007804:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8007808:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800780c:	bf00      	nop
 800780e:	46bd      	mov	sp, r7
 8007810:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007814:	4770      	bx	lr

08007816 <LL_RCC_IsActiveFlag_PINRST>:
  * @brief  Check if RCC flag Pin reset is set or not.
  * @rmtoll CSR          PINRSTF       LL_RCC_IsActiveFlag_PINRST
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PINRST(void)
{
 8007816:	b480      	push	{r7}
 8007818:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_PINRSTF) == (RCC_CSR_PINRSTF)) ? 1UL : 0UL);
 800781a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800781e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8007822:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8007826:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800782a:	d101      	bne.n	8007830 <LL_RCC_IsActiveFlag_PINRST+0x1a>
 800782c:	2301      	movs	r3, #1
 800782e:	e000      	b.n	8007832 <LL_RCC_IsActiveFlag_PINRST+0x1c>
 8007830:	2300      	movs	r3, #0
}
 8007832:	4618      	mov	r0, r3
 8007834:	46bd      	mov	sp, r7
 8007836:	f85d 7b04 	ldr.w	r7, [sp], #4
 800783a:	4770      	bx	lr

0800783c <LL_RCC_IsActiveFlag_SFTRST>:
  * @brief  Check if RCC flag Software reset is set or not.
  * @rmtoll CSR          SFTRSTF       LL_RCC_IsActiveFlag_SFTRST
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SFTRST(void)
{
 800783c:	b480      	push	{r7}
 800783e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_SFTRSTF) == (RCC_CSR_SFTRSTF)) ? 1UL : 0UL);
 8007840:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007844:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8007848:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800784c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8007850:	d101      	bne.n	8007856 <LL_RCC_IsActiveFlag_SFTRST+0x1a>
 8007852:	2301      	movs	r3, #1
 8007854:	e000      	b.n	8007858 <LL_RCC_IsActiveFlag_SFTRST+0x1c>
 8007856:	2300      	movs	r3, #0
}
 8007858:	4618      	mov	r0, r3
 800785a:	46bd      	mov	sp, r7
 800785c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007860:	4770      	bx	lr

08007862 <LL_AHB1_GRP1_EnableClock>:
  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
 8007862:	b480      	push	{r7}
 8007864:	b085      	sub	sp, #20
 8007866:	af00      	add	r7, sp, #0
 8007868:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 800786a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800786e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8007870:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8007874:	687b      	ldr	r3, [r7, #4]
 8007876:	4313      	orrs	r3, r2
 8007878:	648b      	str	r3, [r1, #72]	; 0x48
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800787a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800787e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8007880:	687b      	ldr	r3, [r7, #4]
 8007882:	4013      	ands	r3, r2
 8007884:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8007886:	68fb      	ldr	r3, [r7, #12]
}
 8007888:	bf00      	nop
 800788a:	3714      	adds	r7, #20
 800788c:	46bd      	mov	sp, r7
 800788e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007892:	4770      	bx	lr

08007894 <LL_AHB2_GRP1_EnableClock>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
 8007894:	b480      	push	{r7}
 8007896:	b085      	sub	sp, #20
 8007898:	af00      	add	r7, sp, #0
 800789a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 800789c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80078a0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80078a2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80078a6:	687b      	ldr	r3, [r7, #4]
 80078a8:	4313      	orrs	r3, r2
 80078aa:	64cb      	str	r3, [r1, #76]	; 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80078ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80078b0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80078b2:	687b      	ldr	r3, [r7, #4]
 80078b4:	4013      	ands	r3, r2
 80078b6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80078b8:	68fb      	ldr	r3, [r7, #12]
}
 80078ba:	bf00      	nop
 80078bc:	3714      	adds	r7, #20
 80078be:	46bd      	mov	sp, r7
 80078c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078c4:	4770      	bx	lr

080078c6 <LL_AHB3_GRP1_EnableClock>:
  *         @arg @ref LL_AHB3_GRP1_PERIPH_FLASH
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
 80078c6:	b480      	push	{r7}
 80078c8:	b085      	sub	sp, #20
 80078ca:	af00      	add	r7, sp, #0
 80078cc:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB3ENR, Periphs);
 80078ce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80078d2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80078d4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80078d8:	687b      	ldr	r3, [r7, #4]
 80078da:	4313      	orrs	r3, r2
 80078dc:	650b      	str	r3, [r1, #80]	; 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 80078de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80078e2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80078e4:	687b      	ldr	r3, [r7, #4]
 80078e6:	4013      	ands	r3, r2
 80078e8:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80078ea:	68fb      	ldr	r3, [r7, #12]
}
 80078ec:	bf00      	nop
 80078ee:	3714      	adds	r7, #20
 80078f0:	46bd      	mov	sp, r7
 80078f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078f6:	4770      	bx	lr

080078f8 <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 80078f8:	b480      	push	{r7}
 80078fa:	b085      	sub	sp, #20
 80078fc:	af00      	add	r7, sp, #0
 80078fe:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 8007900:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007904:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007906:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800790a:	687b      	ldr	r3, [r7, #4]
 800790c:	4313      	orrs	r3, r2
 800790e:	658b      	str	r3, [r1, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8007910:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007914:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007916:	687b      	ldr	r3, [r7, #4]
 8007918:	4013      	ands	r3, r2
 800791a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800791c:	68fb      	ldr	r3, [r7, #12]
}
 800791e:	bf00      	nop
 8007920:	3714      	adds	r7, #20
 8007922:	46bd      	mov	sp, r7
 8007924:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007928:	4770      	bx	lr

0800792a <LL_C1_IPCC_DisableTransmitChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_DisableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 800792a:	b480      	push	{r7}
 800792c:	b083      	sub	sp, #12
 800792e:	af00      	add	r7, sp, #0
 8007930:	6078      	str	r0, [r7, #4]
 8007932:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8007934:	687b      	ldr	r3, [r7, #4]
 8007936:	685a      	ldr	r2, [r3, #4]
 8007938:	683b      	ldr	r3, [r7, #0]
 800793a:	041b      	lsls	r3, r3, #16
 800793c:	431a      	orrs	r2, r3
 800793e:	687b      	ldr	r3, [r7, #4]
 8007940:	605a      	str	r2, [r3, #4]
}
 8007942:	bf00      	nop
 8007944:	370c      	adds	r7, #12
 8007946:	46bd      	mov	sp, r7
 8007948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800794c:	4770      	bx	lr

0800794e <LL_C1_IPCC_DisableReceiveChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_DisableReceiveChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 800794e:	b480      	push	{r7}
 8007950:	b083      	sub	sp, #12
 8007952:	af00      	add	r7, sp, #0
 8007954:	6078      	str	r0, [r7, #4]
 8007956:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel);
 8007958:	687b      	ldr	r3, [r7, #4]
 800795a:	685a      	ldr	r2, [r3, #4]
 800795c:	683b      	ldr	r3, [r7, #0]
 800795e:	431a      	orrs	r2, r3
 8007960:	687b      	ldr	r3, [r7, #4]
 8007962:	605a      	str	r2, [r3, #4]
}
 8007964:	bf00      	nop
 8007966:	370c      	adds	r7, #12
 8007968:	46bd      	mov	sp, r7
 800796a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800796e:	4770      	bx	lr

08007970 <LL_C2_IPCC_DisableTransmitChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C2_IPCC_DisableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8007970:	b480      	push	{r7}
 8007972:	b083      	sub	sp, #12
 8007974:	af00      	add	r7, sp, #0
 8007976:	6078      	str	r0, [r7, #4]
 8007978:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C2MR, Channel << (IPCC_C2MR_CH1FM_Pos));
 800797a:	687b      	ldr	r3, [r7, #4]
 800797c:	695a      	ldr	r2, [r3, #20]
 800797e:	683b      	ldr	r3, [r7, #0]
 8007980:	041b      	lsls	r3, r3, #16
 8007982:	431a      	orrs	r2, r3
 8007984:	687b      	ldr	r3, [r7, #4]
 8007986:	615a      	str	r2, [r3, #20]
}
 8007988:	bf00      	nop
 800798a:	370c      	adds	r7, #12
 800798c:	46bd      	mov	sp, r7
 800798e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007992:	4770      	bx	lr

08007994 <LL_C2_IPCC_DisableReceiveChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C2_IPCC_DisableReceiveChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8007994:	b480      	push	{r7}
 8007996:	b083      	sub	sp, #12
 8007998:	af00      	add	r7, sp, #0
 800799a:	6078      	str	r0, [r7, #4]
 800799c:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C2MR, Channel);
 800799e:	687b      	ldr	r3, [r7, #4]
 80079a0:	695a      	ldr	r2, [r3, #20]
 80079a2:	683b      	ldr	r3, [r7, #0]
 80079a4:	431a      	orrs	r2, r3
 80079a6:	687b      	ldr	r3, [r7, #4]
 80079a8:	615a      	str	r2, [r3, #20]
}
 80079aa:	bf00      	nop
 80079ac:	370c      	adds	r7, #12
 80079ae:	46bd      	mov	sp, r7
 80079b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079b4:	4770      	bx	lr

080079b6 <LL_C1_IPCC_ClearFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_ClearFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 80079b6:	b480      	push	{r7}
 80079b8:	b083      	sub	sp, #12
 80079ba:	af00      	add	r7, sp, #0
 80079bc:	6078      	str	r0, [r7, #4]
 80079be:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel);
 80079c0:	687b      	ldr	r3, [r7, #4]
 80079c2:	683a      	ldr	r2, [r7, #0]
 80079c4:	609a      	str	r2, [r3, #8]
}
 80079c6:	bf00      	nop
 80079c8:	370c      	adds	r7, #12
 80079ca:	46bd      	mov	sp, r7
 80079cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079d0:	4770      	bx	lr

080079d2 <LL_C2_IPCC_ClearFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C2_IPCC_ClearFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 80079d2:	b480      	push	{r7}
 80079d4:	b083      	sub	sp, #12
 80079d6:	af00      	add	r7, sp, #0
 80079d8:	6078      	str	r0, [r7, #4]
 80079da:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C2SCR, Channel);
 80079dc:	687b      	ldr	r3, [r7, #4]
 80079de:	683a      	ldr	r2, [r7, #0]
 80079e0:	619a      	str	r2, [r3, #24]
}
 80079e2:	bf00      	nop
 80079e4:	370c      	adds	r7, #12
 80079e6:	46bd      	mov	sp, r7
 80079e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079ec:	4770      	bx	lr
	...

080079f0 <LL_HSEM_1StepLock>:
  * @param  HSEMx HSEM Instance.
  * @param  Semaphore Semaphore number. Value between Min_Data=0 and Max_Data=31
  * @retval 1 lock fail, 0 lock successful or already locked by same core
  */
__STATIC_INLINE uint32_t LL_HSEM_1StepLock(HSEM_TypeDef *HSEMx, uint32_t Semaphore)
{
 80079f0:	b480      	push	{r7}
 80079f2:	b083      	sub	sp, #12
 80079f4:	af00      	add	r7, sp, #0
 80079f6:	6078      	str	r0, [r7, #4]
 80079f8:	6039      	str	r1, [r7, #0]
  return ((HSEMx->RLR[Semaphore] != (HSEM_R_LOCK | LL_HSEM_COREID)) ? 1UL : 0UL);
 80079fa:	687b      	ldr	r3, [r7, #4]
 80079fc:	683a      	ldr	r2, [r7, #0]
 80079fe:	3220      	adds	r2, #32
 8007a00:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8007a04:	4a05      	ldr	r2, [pc, #20]	; (8007a1c <LL_HSEM_1StepLock+0x2c>)
 8007a06:	4293      	cmp	r3, r2
 8007a08:	d001      	beq.n	8007a0e <LL_HSEM_1StepLock+0x1e>
 8007a0a:	2301      	movs	r3, #1
 8007a0c:	e000      	b.n	8007a10 <LL_HSEM_1StepLock+0x20>
 8007a0e:	2300      	movs	r3, #0
}
 8007a10:	4618      	mov	r0, r3
 8007a12:	370c      	adds	r7, #12
 8007a14:	46bd      	mov	sp, r7
 8007a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a1a:	4770      	bx	lr
 8007a1c:	80000400 	.word	0x80000400

08007a20 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8007a20:	b580      	push	{r7, lr}
 8007a22:	af00      	add	r7, sp, #0
    /**
     * The OPTVERR flag is wrongly set at power on
     * It shall be cleared before using any HAL_FLASH_xxx() api
     */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8007a24:	4b11      	ldr	r3, [pc, #68]	; (8007a6c <main+0x4c>)
 8007a26:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8007a2a:	611a      	str	r2, [r3, #16]

    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    HAL_Init();
 8007a2c:	f001 fd30 	bl	8009490 <HAL_Init>

    Reset_Device();
 8007a30:	f000 f94c 	bl	8007ccc <Reset_Device>
    Config_HSE();
 8007a34:	f000 f936 	bl	8007ca4 <Config_HSE>

    /* Configure the system clock */
    SystemClock_Config();
 8007a38:	f000 f81c 	bl	8007a74 <SystemClock_Config>

    PeriphClock_Config();
 8007a3c:	f000 f8ee 	bl	8007c1c <PeriphClock_Config>
    Init_Exti(); /**< Configure the system Power Mode */
 8007a40:	f000 f985 	bl	8007d4e <Init_Exti>

    /* Initialize all configured peripherals */
    MX_GPIO_Init();
 8007a44:	f000 f8dc 	bl	8007c00 <MX_GPIO_Init>
    MX_DMA_Init();
 8007a48:	f000 f8c0 	bl	8007bcc <MX_DMA_Init>
    MX_RF_Init();
 8007a4c:	f000 f890 	bl	8007b70 <MX_RF_Init>
    MX_RTC_Init();
 8007a50:	f000 f896 	bl	8007b80 <MX_RTC_Init>

    /* Init the full application */

    UTIL_SEQ_RegTask(1U << CFG_TASK_READ_TEMP, UTIL_SEQ_RFU, readTemp);
 8007a54:	4a06      	ldr	r2, [pc, #24]	; (8007a70 <main+0x50>)
 8007a56:	2100      	movs	r1, #0
 8007a58:	2010      	movs	r0, #16
 8007a5a:	f010 f993 	bl	8017d84 <UTIL_SEQ_RegTask>

    APPE_Init();
 8007a5e:	f7fe fdd1 	bl	8006604 <APPE_Init>

    /* Infinite loop */
    //int i = 0;

    while (1) {
        UTIL_SEQ_Run( UTIL_SEQ_DEFAULT );
 8007a62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007a66:	f010 f891 	bl	8017b8c <UTIL_SEQ_Run>
 8007a6a:	e7fa      	b.n	8007a62 <main+0x42>
 8007a6c:	58004000 	.word	0x58004000
 8007a70:	08008429 	.word	0x08008429

08007a74 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8007a74:	b580      	push	{r7, lr}
 8007a76:	b0ae      	sub	sp, #184	; 0xb8
 8007a78:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8007a7a:	f107 0370 	add.w	r3, r7, #112	; 0x70
 8007a7e:	2248      	movs	r2, #72	; 0x48
 8007a80:	2100      	movs	r1, #0
 8007a82:	4618      	mov	r0, r3
 8007a84:	f010 fcec 	bl	8018460 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8007a88:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8007a8c:	2200      	movs	r2, #0
 8007a8e:	601a      	str	r2, [r3, #0]
 8007a90:	605a      	str	r2, [r3, #4]
 8007a92:	609a      	str	r2, [r3, #8]
 8007a94:	60da      	str	r2, [r3, #12]
 8007a96:	611a      	str	r2, [r3, #16]
 8007a98:	615a      	str	r2, [r3, #20]
 8007a9a:	619a      	str	r2, [r3, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8007a9c:	1d3b      	adds	r3, r7, #4
 8007a9e:	2250      	movs	r2, #80	; 0x50
 8007aa0:	2100      	movs	r1, #0
 8007aa2:	4618      	mov	r0, r3
 8007aa4:	f010 fcdc 	bl	8018460 <memset>

  /** Configure LSE Drive Capability 
  */
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8007aa8:	2000      	movs	r0, #0
 8007aaa:	f7ff fe7c 	bl	80077a6 <LL_RCC_LSE_SetDriveCapability>
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8007aae:	4b2f      	ldr	r3, [pc, #188]	; (8007b6c <SystemClock_Config+0xf8>)
 8007ab0:	681b      	ldr	r3, [r3, #0]
 8007ab2:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8007ab6:	4a2d      	ldr	r2, [pc, #180]	; (8007b6c <SystemClock_Config+0xf8>)
 8007ab8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007abc:	6013      	str	r3, [r2, #0]
 8007abe:	4b2b      	ldr	r3, [pc, #172]	; (8007b6c <SystemClock_Config+0xf8>)
 8007ac0:	681b      	ldr	r3, [r3, #0]
 8007ac2:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8007ac6:	603b      	str	r3, [r7, #0]
 8007ac8:	683b      	ldr	r3, [r7, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE
 8007aca:	2307      	movs	r3, #7
 8007acc:	673b      	str	r3, [r7, #112]	; 0x70
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8007ace:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8007ad2:	677b      	str	r3, [r7, #116]	; 0x74
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8007ad4:	2301      	movs	r3, #1
 8007ad6:	67bb      	str	r3, [r7, #120]	; 0x78
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8007ad8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007adc:	67fb      	str	r3, [r7, #124]	; 0x7c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8007ade:	2340      	movs	r3, #64	; 0x40
 8007ae0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8007ae4:	2300      	movs	r3, #0
 8007ae6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8007aea:	f107 0370 	add.w	r3, r7, #112	; 0x70
 8007aee:	4618      	mov	r0, r3
 8007af0:	f004 fc68 	bl	800c3c4 <HAL_RCC_OscConfig>
 8007af4:	4603      	mov	r3, r0
 8007af6:	2b00      	cmp	r3, #0
 8007af8:	d001      	beq.n	8007afe <SystemClock_Config+0x8a>
  {
    Error_Handler();
 8007afa:	f000 f92f 	bl	8007d5c <Error_Handler>
  }
  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
 8007afe:	236f      	movs	r3, #111	; 0x6f
 8007b00:	657b      	str	r3, [r7, #84]	; 0x54
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
 8007b02:	2302      	movs	r3, #2
 8007b04:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8007b06:	2300      	movs	r3, #0
 8007b08:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8007b0a:	2300      	movs	r3, #0
 8007b0c:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8007b0e:	2300      	movs	r3, #0
 8007b10:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV1;
 8007b12:	2300      	movs	r3, #0
 8007b14:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;
 8007b16:	2300      	movs	r3, #0
 8007b18:	66fb      	str	r3, [r7, #108]	; 0x6c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8007b1a:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8007b1e:	2101      	movs	r1, #1
 8007b20:	4618      	mov	r0, r3
 8007b22:	f004 ffc3 	bl	800caac <HAL_RCC_ClockConfig>
 8007b26:	4603      	mov	r3, r0
 8007b28:	2b00      	cmp	r3, #0
 8007b2a:	d001      	beq.n	8007b30 <SystemClock_Config+0xbc>
  {
    Error_Handler();
 8007b2c:	f000 f916 	bl	8007d5c <Error_Handler>
  }
  /** Initializes the peripherals clocks
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS|RCC_PERIPHCLK_RFWAKEUP
 8007b30:	f643 0303 	movw	r3, #14339	; 0x3803
 8007b34:	607b      	str	r3, [r7, #4]
                              |RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART1
                              |RCC_PERIPHCLK_LPUART1;
  PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8007b36:	2300      	movs	r3, #0
 8007b38:	61fb      	str	r3, [r7, #28]
  PeriphClkInitStruct.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
 8007b3a:	2300      	movs	r3, #0
 8007b3c:	623b      	str	r3, [r7, #32]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8007b3e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007b42:	647b      	str	r3, [r7, #68]	; 0x44
  PeriphClkInitStruct.RFWakeUpClockSelection = RCC_RFWKPCLKSOURCE_LSE;
 8007b44:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8007b48:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSE;
 8007b4a:	2302      	movs	r3, #2
 8007b4c:	64fb      	str	r3, [r7, #76]	; 0x4c
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE0;
 8007b4e:	2300      	movs	r3, #0
 8007b50:	653b      	str	r3, [r7, #80]	; 0x50

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8007b52:	1d3b      	adds	r3, r7, #4
 8007b54:	4618      	mov	r0, r3
 8007b56:	f005 fbdf 	bl	800d318 <HAL_RCCEx_PeriphCLKConfig>
 8007b5a:	4603      	mov	r3, r0
 8007b5c:	2b00      	cmp	r3, #0
 8007b5e:	d001      	beq.n	8007b64 <SystemClock_Config+0xf0>
  {
    Error_Handler();
 8007b60:	f000 f8fc 	bl	8007d5c <Error_Handler>
  }
}
 8007b64:	bf00      	nop
 8007b66:	37b8      	adds	r7, #184	; 0xb8
 8007b68:	46bd      	mov	sp, r7
 8007b6a:	bd80      	pop	{r7, pc}
 8007b6c:	58000400 	.word	0x58000400

08007b70 <MX_RF_Init>:
  * @brief RF Initialization Function
  * @param None
  * @retval None
  */
static void MX_RF_Init(void)
{
 8007b70:	b480      	push	{r7}
 8007b72:	af00      	add	r7, sp, #0

}
 8007b74:	bf00      	nop
 8007b76:	46bd      	mov	sp, r7
 8007b78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b7c:	4770      	bx	lr
	...

08007b80 <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 8007b80:	b580      	push	{r7, lr}
 8007b82:	af00      	add	r7, sp, #0


  /** Initialize RTC Only 
  */
  hrtc.Instance = RTC;
 8007b84:	4b0f      	ldr	r3, [pc, #60]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007b86:	4a10      	ldr	r2, [pc, #64]	; (8007bc8 <MX_RTC_Init+0x48>)
 8007b88:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8007b8a:	4b0e      	ldr	r3, [pc, #56]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007b8c:	2200      	movs	r2, #0
 8007b8e:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = CFG_RTC_ASYNCH_PRESCALER;
 8007b90:	4b0c      	ldr	r3, [pc, #48]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007b92:	220f      	movs	r2, #15
 8007b94:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = CFG_RTC_SYNCH_PRESCALER;
 8007b96:	4b0b      	ldr	r3, [pc, #44]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007b98:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8007b9c:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8007b9e:	4b09      	ldr	r3, [pc, #36]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007ba0:	2200      	movs	r2, #0
 8007ba2:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8007ba4:	4b07      	ldr	r3, [pc, #28]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007ba6:	2200      	movs	r2, #0
 8007ba8:	619a      	str	r2, [r3, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8007baa:	4b06      	ldr	r3, [pc, #24]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007bac:	2200      	movs	r2, #0
 8007bae:	61da      	str	r2, [r3, #28]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8007bb0:	4804      	ldr	r0, [pc, #16]	; (8007bc4 <MX_RTC_Init+0x44>)
 8007bb2:	f005 fe73 	bl	800d89c <HAL_RTC_Init>
 8007bb6:	4603      	mov	r3, r0
 8007bb8:	2b00      	cmp	r3, #0
 8007bba:	d001      	beq.n	8007bc0 <MX_RTC_Init+0x40>
  {
    Error_Handler();
 8007bbc:	f000 f8ce 	bl	8007d5c <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 8007bc0:	bf00      	nop
 8007bc2:	bd80      	pop	{r7, pc}
 8007bc4:	20000d4c 	.word	0x20000d4c
 8007bc8:	40002800 	.word	0x40002800

08007bcc <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 8007bcc:	b580      	push	{r7, lr}
 8007bce:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8007bd0:	2004      	movs	r0, #4
 8007bd2:	f7ff fe46 	bl	8007862 <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_DMA1_CLK_ENABLE();
 8007bd6:	2001      	movs	r0, #1
 8007bd8:	f7ff fe43 	bl	8007862 <LL_AHB1_GRP1_EnableClock>

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 8007bdc:	2200      	movs	r2, #0
 8007bde:	2100      	movs	r1, #0
 8007be0:	200b      	movs	r0, #11
 8007be2:	f001 fe1c 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8007be6:	200b      	movs	r0, #11
 8007be8:	f001 fe33 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 8007bec:	2200      	movs	r2, #0
 8007bee:	2100      	movs	r1, #0
 8007bf0:	200c      	movs	r0, #12
 8007bf2:	f001 fe14 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
 8007bf6:	200c      	movs	r0, #12
 8007bf8:	f001 fe2b 	bl	8009852 <HAL_NVIC_EnableIRQ>

}
 8007bfc:	bf00      	nop
 8007bfe:	bd80      	pop	{r7, pc}

08007c00 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8007c00:	b580      	push	{r7, lr}
 8007c02:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8007c04:	2004      	movs	r0, #4
 8007c06:	f7ff fe45 	bl	8007894 <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8007c0a:	2001      	movs	r0, #1
 8007c0c:	f7ff fe42 	bl	8007894 <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c10:	2002      	movs	r0, #2
 8007c12:	f7ff fe3f 	bl	8007894 <LL_AHB2_GRP1_EnableClock>

}
 8007c16:	bf00      	nop
 8007c18:	bd80      	pop	{r7, pc}
	...

08007c1c <PeriphClock_Config>:

/* USER CODE BEGIN 4 */
void PeriphClock_Config(void)
{
 8007c1c:	b580      	push	{r7, lr}
 8007c1e:	b09a      	sub	sp, #104	; 0x68
 8007c20:	af00      	add	r7, sp, #0
  #if (CFG_USB_INTERFACE_ENABLE != 0)
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = { 0 };
 8007c22:	f107 0318 	add.w	r3, r7, #24
 8007c26:	2250      	movs	r2, #80	; 0x50
 8007c28:	2100      	movs	r1, #0
 8007c2a:	4618      	mov	r0, r3
 8007c2c:	f010 fc18 	bl	8018460 <memset>
  RCC_CRSInitTypeDef RCC_CRSInitStruct = { 0 };
 8007c30:	463b      	mov	r3, r7
 8007c32:	2200      	movs	r2, #0
 8007c34:	601a      	str	r2, [r3, #0]
 8007c36:	605a      	str	r2, [r3, #4]
 8007c38:	609a      	str	r2, [r3, #8]
 8007c3a:	60da      	str	r2, [r3, #12]
 8007c3c:	611a      	str	r2, [r3, #16]
 8007c3e:	615a      	str	r2, [r3, #20]

  /**
   * This prevents the CPU2 to disable the HSI48 oscillator when
   * it does not use anymore the RNG IP
   */
  LL_HSEM_1StepLock( HSEM, 5 );
 8007c40:	2105      	movs	r1, #5
 8007c42:	4817      	ldr	r0, [pc, #92]	; (8007ca0 <PeriphClock_Config+0x84>)
 8007c44:	f7ff fed4 	bl	80079f0 <LL_HSEM_1StepLock>

  LL_RCC_HSI48_Enable();
 8007c48:	f7ff fd8a 	bl	8007760 <LL_RCC_HSI48_Enable>

  while(!LL_RCC_HSI48_IsReady());
 8007c4c:	bf00      	nop
 8007c4e:	f7ff fd98 	bl	8007782 <LL_RCC_HSI48_IsReady>
 8007c52:	4603      	mov	r3, r0
 8007c54:	2b00      	cmp	r3, #0
 8007c56:	d0fa      	beq.n	8007c4e <PeriphClock_Config+0x32>

  /* Select HSI48 as USB clock source */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8007c58:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007c5c:	61bb      	str	r3, [r7, #24]
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 8007c5e:	2300      	movs	r3, #0
 8007c60:	64fb      	str	r3, [r7, #76]	; 0x4c
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8007c62:	f107 0318 	add.w	r3, r7, #24
 8007c66:	4618      	mov	r0, r3
 8007c68:	f005 fb56 	bl	800d318 <HAL_RCCEx_PeriphCLKConfig>

  /*Configure the clock recovery system (CRS)**********************************/

  /* Enable CRS Clock */
  __HAL_RCC_CRS_CLK_ENABLE();
 8007c6c:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8007c70:	f7ff fe42 	bl	80078f8 <LL_APB1_GRP1_EnableClock>

  /* Default Synchro Signal division factor (not divided) */
  RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
 8007c74:	2300      	movs	r3, #0
 8007c76:	603b      	str	r3, [r7, #0]

  /* Set the SYNCSRC[1:0] bits according to CRS_Source value */
  RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
 8007c78:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8007c7c:	607b      	str	r3, [r7, #4]

  /* HSI48 is synchronized with USB SOF at 1KHz rate */
  RCC_CRSInitStruct.ReloadValue = RCC_CRS_RELOADVALUE_DEFAULT;
 8007c7e:	f64b 337f 	movw	r3, #47999	; 0xbb7f
 8007c82:	60fb      	str	r3, [r7, #12]
  RCC_CRSInitStruct.ErrorLimitValue = RCC_CRS_ERRORLIMIT_DEFAULT;
 8007c84:	2322      	movs	r3, #34	; 0x22
 8007c86:	613b      	str	r3, [r7, #16]

  RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
 8007c88:	2300      	movs	r3, #0
 8007c8a:	60bb      	str	r3, [r7, #8]

  /* Set the TRIM[5:0] to the default value*/
  RCC_CRSInitStruct.HSI48CalibrationValue = RCC_CRS_HSI48CALIBRATION_DEFAULT;
 8007c8c:	2320      	movs	r3, #32
 8007c8e:	617b      	str	r3, [r7, #20]

  /* Start automatic synchronization */
  HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
 8007c90:	463b      	mov	r3, r7
 8007c92:	4618      	mov	r0, r3
 8007c94:	f005 fcb6 	bl	800d604 <HAL_RCCEx_CRSConfig>
#endif

  return;
 8007c98:	bf00      	nop
}
 8007c9a:	3768      	adds	r7, #104	; 0x68
 8007c9c:	46bd      	mov	sp, r7
 8007c9e:	bd80      	pop	{r7, pc}
 8007ca0:	58001400 	.word	0x58001400

08007ca4 <Config_HSE>:
 * LOCAL FUNCTIONS
 *
 *************************************************************/

static void Config_HSE(void)
{
 8007ca4:	b580      	push	{r7, lr}
 8007ca6:	b082      	sub	sp, #8
 8007ca8:	af00      	add	r7, sp, #0
    OTP_ID0_t * p_otp;

  /**
   * Read HSE_Tuning from OTP
   */
  p_otp = (OTP_ID0_t *) OTP_Read(0);
 8007caa:	2000      	movs	r0, #0
 8007cac:	f00c fda8 	bl	8014800 <OTP_Read>
 8007cb0:	6078      	str	r0, [r7, #4]
  if (p_otp)
 8007cb2:	687b      	ldr	r3, [r7, #4]
 8007cb4:	2b00      	cmp	r3, #0
 8007cb6:	d005      	beq.n	8007cc4 <Config_HSE+0x20>
  {
    LL_RCC_HSE_SetCapacitorTuning(p_otp->hse_tuning);
 8007cb8:	687b      	ldr	r3, [r7, #4]
 8007cba:	799b      	ldrb	r3, [r3, #6]
 8007cbc:	4618      	mov	r0, r3
 8007cbe:	f7ff fd31 	bl	8007724 <LL_RCC_HSE_SetCapacitorTuning>
  }

  return;
 8007cc2:	bf00      	nop
 8007cc4:	bf00      	nop
}
 8007cc6:	3708      	adds	r7, #8
 8007cc8:	46bd      	mov	sp, r7
 8007cca:	bd80      	pop	{r7, pc}

08007ccc <Reset_Device>:


static void Reset_Device( void )
{
 8007ccc:	b580      	push	{r7, lr}
 8007cce:	af00      	add	r7, sp, #0
#if ( CFG_HW_RESET_BY_FW == 1 )
  Reset_BackupDomain();
 8007cd0:	f000 f826 	bl	8007d20 <Reset_BackupDomain>

  Reset_IPCC();
 8007cd4:	f000 f802 	bl	8007cdc <Reset_IPCC>
#endif

  return;
 8007cd8:	bf00      	nop
}
 8007cda:	bd80      	pop	{r7, pc}

08007cdc <Reset_IPCC>:

static void Reset_IPCC( void )
{
 8007cdc:	b580      	push	{r7, lr}
 8007cde:	af00      	add	r7, sp, #0
  LL_AHB3_GRP1_EnableClock(LL_AHB3_GRP1_PERIPH_IPCC);
 8007ce0:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8007ce4:	f7ff fdef 	bl	80078c6 <LL_AHB3_GRP1_EnableClock>

  LL_C1_IPCC_ClearFlag_CHx(
 8007ce8:	213f      	movs	r1, #63	; 0x3f
 8007cea:	480c      	ldr	r0, [pc, #48]	; (8007d1c <Reset_IPCC+0x40>)
 8007cec:	f7ff fe63 	bl	80079b6 <LL_C1_IPCC_ClearFlag_CHx>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C2_IPCC_ClearFlag_CHx(
 8007cf0:	213f      	movs	r1, #63	; 0x3f
 8007cf2:	480a      	ldr	r0, [pc, #40]	; (8007d1c <Reset_IPCC+0x40>)
 8007cf4:	f7ff fe6d 	bl	80079d2 <LL_C2_IPCC_ClearFlag_CHx>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C1_IPCC_DisableTransmitChannel(
 8007cf8:	213f      	movs	r1, #63	; 0x3f
 8007cfa:	4808      	ldr	r0, [pc, #32]	; (8007d1c <Reset_IPCC+0x40>)
 8007cfc:	f7ff fe15 	bl	800792a <LL_C1_IPCC_DisableTransmitChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C2_IPCC_DisableTransmitChannel(
 8007d00:	213f      	movs	r1, #63	; 0x3f
 8007d02:	4806      	ldr	r0, [pc, #24]	; (8007d1c <Reset_IPCC+0x40>)
 8007d04:	f7ff fe34 	bl	8007970 <LL_C2_IPCC_DisableTransmitChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C1_IPCC_DisableReceiveChannel(
 8007d08:	213f      	movs	r1, #63	; 0x3f
 8007d0a:	4804      	ldr	r0, [pc, #16]	; (8007d1c <Reset_IPCC+0x40>)
 8007d0c:	f7ff fe1f 	bl	800794e <LL_C1_IPCC_DisableReceiveChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C2_IPCC_DisableReceiveChannel(
 8007d10:	213f      	movs	r1, #63	; 0x3f
 8007d12:	4802      	ldr	r0, [pc, #8]	; (8007d1c <Reset_IPCC+0x40>)
 8007d14:	f7ff fe3e 	bl	8007994 <LL_C2_IPCC_DisableReceiveChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  return;
 8007d18:	bf00      	nop
}
 8007d1a:	bd80      	pop	{r7, pc}
 8007d1c:	58000c00 	.word	0x58000c00

08007d20 <Reset_BackupDomain>:

static void Reset_BackupDomain( void )
{
 8007d20:	b580      	push	{r7, lr}
 8007d22:	af00      	add	r7, sp, #0
  if ((LL_RCC_IsActiveFlag_PINRST() != FALSE) && (LL_RCC_IsActiveFlag_SFTRST() == FALSE))
 8007d24:	f7ff fd77 	bl	8007816 <LL_RCC_IsActiveFlag_PINRST>
 8007d28:	4603      	mov	r3, r0
 8007d2a:	2b00      	cmp	r3, #0
 8007d2c:	d00d      	beq.n	8007d4a <Reset_BackupDomain+0x2a>
 8007d2e:	f7ff fd85 	bl	800783c <LL_RCC_IsActiveFlag_SFTRST>
 8007d32:	4603      	mov	r3, r0
 8007d34:	2b00      	cmp	r3, #0
 8007d36:	d108      	bne.n	8007d4a <Reset_BackupDomain+0x2a>
  {
    HAL_PWR_EnableBkUpAccess(); /**< Enable access to the RTC registers */
 8007d38:	f003 ff3a 	bl	800bbb0 <HAL_PWR_EnableBkUpAccess>

    /**
     *  Write twice the value to flush the APB-AHB bridge
     *  This bit shall be written in the register before writing the next one
     */
    HAL_PWR_EnableBkUpAccess();
 8007d3c:	f003 ff38 	bl	800bbb0 <HAL_PWR_EnableBkUpAccess>

    __HAL_RCC_BACKUPRESET_FORCE();
 8007d40:	f7ff fd47 	bl	80077d2 <LL_RCC_ForceBackupDomainReset>
    __HAL_RCC_BACKUPRESET_RELEASE();
 8007d44:	f7ff fd56 	bl	80077f4 <LL_RCC_ReleaseBackupDomainReset>
  }

  return;
 8007d48:	bf00      	nop
 8007d4a:	bf00      	nop
}
 8007d4c:	bd80      	pop	{r7, pc}

08007d4e <Init_Exti>:

static void Init_Exti( void )
{
 8007d4e:	b580      	push	{r7, lr}
 8007d50:	af00      	add	r7, sp, #0
  /* Enable IPCC(36), HSEM(38) wakeup interrupts on CPU1 */
  LL_EXTI_EnableIT_32_63(LL_EXTI_LINE_36 | LL_EXTI_LINE_38);
 8007d52:	2050      	movs	r0, #80	; 0x50
 8007d54:	f7ff fcd2 	bl	80076fc <LL_EXTI_EnableIT_32_63>

  return;
 8007d58:	bf00      	nop
}
 8007d5a:	bd80      	pop	{r7, pc}

08007d5c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8007d5c:	b480      	push	{r7}
 8007d5e:	af00      	add	r7, sp, #0

}
 8007d60:	bf00      	nop
 8007d62:	46bd      	mov	sp, r7
 8007d64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d68:	4770      	bx	lr

08007d6a <LL_RCC_SetRTCClockSource>:
{
 8007d6a:	b480      	push	{r7}
 8007d6c:	b083      	sub	sp, #12
 8007d6e:	af00      	add	r7, sp, #0
 8007d70:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8007d72:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007d76:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007d7a:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8007d7e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8007d82:	687b      	ldr	r3, [r7, #4]
 8007d84:	4313      	orrs	r3, r2
 8007d86:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 8007d8a:	bf00      	nop
 8007d8c:	370c      	adds	r7, #12
 8007d8e:	46bd      	mov	sp, r7
 8007d90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d94:	4770      	bx	lr

08007d96 <LL_RCC_EnableRTC>:
{
 8007d96:	b480      	push	{r7}
 8007d98:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 8007d9a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007d9e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007da2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8007da6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007daa:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8007dae:	bf00      	nop
 8007db0:	46bd      	mov	sp, r7
 8007db2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007db6:	4770      	bx	lr

08007db8 <LL_AHB3_GRP1_EnableClock>:
{
 8007db8:	b480      	push	{r7}
 8007dba:	b085      	sub	sp, #20
 8007dbc:	af00      	add	r7, sp, #0
 8007dbe:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 8007dc0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007dc4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007dc6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8007dca:	687b      	ldr	r3, [r7, #4]
 8007dcc:	4313      	orrs	r3, r2
 8007dce:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 8007dd0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8007dd4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007dd6:	687b      	ldr	r3, [r7, #4]
 8007dd8:	4013      	ands	r3, r2
 8007dda:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8007ddc:	68fb      	ldr	r3, [r7, #12]
}
 8007dde:	bf00      	nop
 8007de0:	3714      	adds	r7, #20
 8007de2:	46bd      	mov	sp, r7
 8007de4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007de8:	4770      	bx	lr

08007dea <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8007dea:	b580      	push	{r7, lr}
 8007dec:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_HSEM_CLK_ENABLE();
 8007dee:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8007df2:	f7ff ffe1 	bl	8007db8 <LL_AHB3_GRP1_EnableClock>

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* PVD_PVM_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PVD_PVM_IRQn, 0, 0);
 8007df6:	2200      	movs	r2, #0
 8007df8:	2100      	movs	r1, #0
 8007dfa:	2001      	movs	r0, #1
 8007dfc:	f001 fd0f 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(PVD_PVM_IRQn);
 8007e00:	2001      	movs	r0, #1
 8007e02:	f001 fd26 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* FLASH_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(FLASH_IRQn, 0, 0);
 8007e06:	2200      	movs	r2, #0
 8007e08:	2100      	movs	r1, #0
 8007e0a:	2004      	movs	r0, #4
 8007e0c:	f001 fd07 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(FLASH_IRQn);
 8007e10:	2004      	movs	r0, #4
 8007e12:	f001 fd1e 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* RCC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_IRQn, 0, 0);
 8007e16:	2200      	movs	r2, #0
 8007e18:	2100      	movs	r1, #0
 8007e1a:	2005      	movs	r0, #5
 8007e1c:	f001 fcff 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_IRQn);
 8007e20:	2005      	movs	r0, #5
 8007e22:	f001 fd16 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* C2SEV_PWR_C2H_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(C2SEV_PWR_C2H_IRQn, 0, 0);
 8007e26:	2200      	movs	r2, #0
 8007e28:	2100      	movs	r1, #0
 8007e2a:	2015      	movs	r0, #21
 8007e2c:	f001 fcf7 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(C2SEV_PWR_C2H_IRQn);
 8007e30:	2015      	movs	r0, #21
 8007e32:	f001 fd0e 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn, 0, 0);
 8007e36:	2200      	movs	r2, #0
 8007e38:	2100      	movs	r1, #0
 8007e3a:	202b      	movs	r0, #43	; 0x2b
 8007e3c:	f001 fcef 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn);
 8007e40:	202b      	movs	r0, #43	; 0x2b
 8007e42:	f001 fd06 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* HSEM_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(HSEM_IRQn, 0, 0);
 8007e46:	2200      	movs	r2, #0
 8007e48:	2100      	movs	r1, #0
 8007e4a:	202e      	movs	r0, #46	; 0x2e
 8007e4c:	f001 fce7 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(HSEM_IRQn);
 8007e50:	202e      	movs	r0, #46	; 0x2e
 8007e52:	f001 fcfe 	bl	8009852 <HAL_NVIC_EnableIRQ>
  /* FPU_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(FPU_IRQn, 0, 0);
 8007e56:	2200      	movs	r2, #0
 8007e58:	2100      	movs	r1, #0
 8007e5a:	2036      	movs	r0, #54	; 0x36
 8007e5c:	f001 fcdf 	bl	800981e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(FPU_IRQn);
 8007e60:	2036      	movs	r0, #54	; 0x36
 8007e62:	f001 fcf6 	bl	8009852 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8007e66:	bf00      	nop
 8007e68:	bd80      	pop	{r7, pc}
	...

08007e6c <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 8007e6c:	b580      	push	{r7, lr}
 8007e6e:	b082      	sub	sp, #8
 8007e70:	af00      	add	r7, sp, #0
 8007e72:	6078      	str	r0, [r7, #4]
  if(hrtc->Instance==RTC)
 8007e74:	687b      	ldr	r3, [r7, #4]
 8007e76:	681b      	ldr	r3, [r3, #0]
 8007e78:	4a0b      	ldr	r2, [pc, #44]	; (8007ea8 <HAL_RTC_MspInit+0x3c>)
 8007e7a:	4293      	cmp	r3, r2
 8007e7c:	d10f      	bne.n	8007e9e <HAL_RTC_MspInit+0x32>
  {
  /* USER CODE BEGIN RTC_MspInit 0 */
    HAL_PWR_EnableBkUpAccess(); /**< Enable access to the RTC registers */
 8007e7e:	f003 fe97 	bl	800bbb0 <HAL_PWR_EnableBkUpAccess>

    /**
     *  Write twice the value to flush the APB-AHB bridge
     *  This bit shall be written in the register before writing the next one
     */
    HAL_PWR_EnableBkUpAccess();
 8007e82:	f003 fe95 	bl	800bbb0 <HAL_PWR_EnableBkUpAccess>

    __HAL_RCC_RTC_CONFIG(RCC_RTCCLKSOURCE_LSE); /**< Select LSE as RTC Input */
 8007e86:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007e8a:	f7ff ff6e 	bl	8007d6a <LL_RCC_SetRTCClockSource>

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 8007e8e:	f7ff ff82 	bl	8007d96 <LL_RCC_EnableRTC>
  /* USER CODE BEGIN RTC_MspInit 1 */
    
    MODIFY_REG(RTC->CR, RTC_CR_WUCKSEL, CFG_RTC_WUCKSEL_DIVIDER);
 8007e92:	4b05      	ldr	r3, [pc, #20]	; (8007ea8 <HAL_RTC_MspInit+0x3c>)
 8007e94:	689b      	ldr	r3, [r3, #8]
 8007e96:	4a04      	ldr	r2, [pc, #16]	; (8007ea8 <HAL_RTC_MspInit+0x3c>)
 8007e98:	f023 0307 	bic.w	r3, r3, #7
 8007e9c:	6093      	str	r3, [r2, #8]
  /* USER CODE END RTC_MspInit 1 */
  }

}
 8007e9e:	bf00      	nop
 8007ea0:	3708      	adds	r7, #8
 8007ea2:	46bd      	mov	sp, r7
 8007ea4:	bd80      	pop	{r7, pc}
 8007ea6:	bf00      	nop
 8007ea8:	40002800 	.word	0x40002800

08007eac <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8007eac:	b480      	push	{r7}
 8007eae:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8007eb0:	bf00      	nop
 8007eb2:	46bd      	mov	sp, r7
 8007eb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007eb8:	4770      	bx	lr

08007eba <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8007eba:	b480      	push	{r7}
 8007ebc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8007ebe:	e7fe      	b.n	8007ebe <HardFault_Handler+0x4>

08007ec0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8007ec0:	b480      	push	{r7}
 8007ec2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8007ec4:	e7fe      	b.n	8007ec4 <MemManage_Handler+0x4>

08007ec6 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8007ec6:	b480      	push	{r7}
 8007ec8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8007eca:	e7fe      	b.n	8007eca <BusFault_Handler+0x4>

08007ecc <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8007ecc:	b480      	push	{r7}
 8007ece:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8007ed0:	e7fe      	b.n	8007ed0 <UsageFault_Handler+0x4>

08007ed2 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8007ed2:	b480      	push	{r7}
 8007ed4:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8007ed6:	bf00      	nop
 8007ed8:	46bd      	mov	sp, r7
 8007eda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ede:	4770      	bx	lr

08007ee0 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8007ee0:	b480      	push	{r7}
 8007ee2:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8007ee4:	bf00      	nop
 8007ee6:	46bd      	mov	sp, r7
 8007ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007eec:	4770      	bx	lr

08007eee <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8007eee:	b480      	push	{r7}
 8007ef0:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8007ef2:	bf00      	nop
 8007ef4:	46bd      	mov	sp, r7
 8007ef6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007efa:	4770      	bx	lr

08007efc <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8007efc:	b580      	push	{r7, lr}
 8007efe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8007f00:	f001 fb20 	bl	8009544 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8007f04:	bf00      	nop
 8007f06:	bd80      	pop	{r7, pc}

08007f08 <PVD_PVM_IRQHandler>:

/**
  * @brief This function handles PVD/PVM0/PVM2 interrupts through EXTI lines 16/31/33.
  */
void PVD_PVM_IRQHandler(void)
{
 8007f08:	b580      	push	{r7, lr}
 8007f0a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN PVD_PVM_IRQn 0 */

  /* USER CODE END PVD_PVM_IRQn 0 */
  HAL_PWREx_PVD_PVM_IRQHandler();
 8007f0c:	f003 fec6 	bl	800bc9c <HAL_PWREx_PVD_PVM_IRQHandler>
  /* USER CODE BEGIN PVD_PVM_IRQn 1 */

  /* USER CODE END PVD_PVM_IRQn 1 */
}
 8007f10:	bf00      	nop
 8007f12:	bd80      	pop	{r7, pc}

08007f14 <FLASH_IRQHandler>:

/**
  * @brief This function handles Flash global interrupt.
  */
void FLASH_IRQHandler(void)
{
 8007f14:	b580      	push	{r7, lr}
 8007f16:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FLASH_IRQn 0 */

  /* USER CODE END FLASH_IRQn 0 */
  HAL_FLASH_IRQHandler();
 8007f18:	f001 fe6e 	bl	8009bf8 <HAL_FLASH_IRQHandler>
  /* USER CODE BEGIN FLASH_IRQn 1 */

  /* USER CODE END FLASH_IRQn 1 */
}
 8007f1c:	bf00      	nop
 8007f1e:	bd80      	pop	{r7, pc}

08007f20 <RCC_IRQHandler>:

/**
  * @brief This function handles RCC global interrupt.
  */
void RCC_IRQHandler(void)
{
 8007f20:	b480      	push	{r7}
 8007f22:	af00      	add	r7, sp, #0

  /* USER CODE END RCC_IRQn 0 */
  /* USER CODE BEGIN RCC_IRQn 1 */

  /* USER CODE END RCC_IRQn 1 */
}
 8007f24:	bf00      	nop
 8007f26:	46bd      	mov	sp, r7
 8007f28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f2c:	4770      	bx	lr
	...

08007f30 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 8007f30:	b580      	push	{r7, lr}
 8007f32:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_lpuart1_tx);
 8007f34:	4802      	ldr	r0, [pc, #8]	; (8007f40 <DMA1_Channel1_IRQHandler+0x10>)
 8007f36:	f001 fd8e 	bl	8009a56 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 8007f3a:	bf00      	nop
 8007f3c:	bd80      	pop	{r7, pc}
 8007f3e:	bf00      	nop
 8007f40:	20000c8c 	.word	0x20000c8c

08007f44 <DMA1_Channel2_IRQHandler>:

/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
 8007f44:	b580      	push	{r7, lr}
 8007f46:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 8007f48:	4802      	ldr	r0, [pc, #8]	; (8007f54 <DMA1_Channel2_IRQHandler+0x10>)
 8007f4a:	f001 fd84 	bl	8009a56 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}
 8007f4e:	bf00      	nop
 8007f50:	bd80      	pop	{r7, pc}
 8007f52:	bf00      	nop
 8007f54:	20000cec 	.word	0x20000cec

08007f58 <C2SEV_PWR_C2H_IRQHandler>:

/**
  * @brief This function handles CPU2 SEV interrupt through EXTI line 40 and PWR CPU2 HOLD wake-up interrupt.
  */
void C2SEV_PWR_C2H_IRQHandler(void)
{
 8007f58:	b480      	push	{r7}
 8007f5a:	af00      	add	r7, sp, #0

  /* USER CODE END C2SEV_PWR_C2H_IRQn 0 */
  /* USER CODE BEGIN C2SEV_PWR_C2H_IRQn 1 */

  /* USER CODE END C2SEV_PWR_C2H_IRQn 1 */
}
 8007f5c:	bf00      	nop
 8007f5e:	46bd      	mov	sp, r7
 8007f60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f64:	4770      	bx	lr
	...

08007f68 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8007f68:	b580      	push	{r7, lr}
 8007f6a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8007f6c:	4802      	ldr	r0, [pc, #8]	; (8007f78 <USART1_IRQHandler+0x10>)
 8007f6e:	f005 fde1 	bl	800db34 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8007f72:	bf00      	nop
 8007f74:	bd80      	pop	{r7, pc}
 8007f76:	bf00      	nop
 8007f78:	20000bf8 	.word	0x20000bf8

08007f7c <LPUART1_IRQHandler>:

/**
  * @brief This function handles LPUART1 global interrupt.
  */
void LPUART1_IRQHandler(void)
{
 8007f7c:	b580      	push	{r7, lr}
 8007f7e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN LPUART1_IRQn 0 */

  /* USER CODE END LPUART1_IRQn 0 */
  HAL_UART_IRQHandler(&hlpuart1);
 8007f80:	4802      	ldr	r0, [pc, #8]	; (8007f8c <LPUART1_IRQHandler+0x10>)
 8007f82:	f005 fdd7 	bl	800db34 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN LPUART1_IRQn 1 */

  /* USER CODE END LPUART1_IRQn 1 */
}
 8007f86:	bf00      	nop
 8007f88:	bd80      	pop	{r7, pc}
 8007f8a:	bf00      	nop
 8007f8c:	20000b64 	.word	0x20000b64

08007f90 <PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQHandler>:

/**
  * @brief This function handles PWR switching on the fly, end of BLE activity, end of 802.15.4 activity, end of critical radio phase interrupt.
  */
void PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQHandler(void)
{
 8007f90:	b480      	push	{r7}
 8007f92:	af00      	add	r7, sp, #0

  /* USER CODE END PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn 0 */
  /* USER CODE BEGIN PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn 1 */

  /* USER CODE END PWR_SOTF_BLEACT_802ACT_RFPHASE_IRQn 1 */
}
 8007f94:	bf00      	nop
 8007f96:	46bd      	mov	sp, r7
 8007f98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f9c:	4770      	bx	lr

08007f9e <HSEM_IRQHandler>:

/**
  * @brief This function handles HSEM global interrupt.
  */
void HSEM_IRQHandler(void)
{
 8007f9e:	b580      	push	{r7, lr}
 8007fa0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HSEM_IRQn 0 */

  /* USER CODE END HSEM_IRQn 0 */
  HAL_HSEM_IRQHandler();
 8007fa2:	f002 f8a1 	bl	800a0e8 <HAL_HSEM_IRQHandler>
  /* USER CODE BEGIN HSEM_IRQn 1 */

  /* USER CODE END HSEM_IRQn 1 */
}
 8007fa6:	bf00      	nop
 8007fa8:	bd80      	pop	{r7, pc}

08007faa <FPU_IRQHandler>:

/**
  * @brief This function handles FPU global interrupt.
  */
void FPU_IRQHandler(void)
{
 8007faa:	b480      	push	{r7}
 8007fac:	af00      	add	r7, sp, #0

  /* USER CODE END FPU_IRQn 0 */
  /* USER CODE BEGIN FPU_IRQn 1 */

  /* USER CODE END FPU_IRQn 1 */
}
 8007fae:	bf00      	nop
 8007fb0:	46bd      	mov	sp, r7
 8007fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fb6:	4770      	bx	lr

08007fb8 <USB_LP_IRQHandler>:
  * @brief  This function handles USB FS global interrupt request.
  * @param  None
  * @retval None
  */
void USB_LP_IRQHandler(void)
{
 8007fb8:	b580      	push	{r7, lr}
 8007fba:	af00      	add	r7, sp, #0
  HAL_PCD_IRQHandler(&hpcd);
 8007fbc:	4802      	ldr	r0, [pc, #8]	; (8007fc8 <USB_LP_IRQHandler+0x10>)
 8007fbe:	f002 f9a7 	bl	800a310 <HAL_PCD_IRQHandler>
}
 8007fc2:	bf00      	nop
 8007fc4:	bd80      	pop	{r7, pc}
 8007fc6:	bf00      	nop
 8007fc8:	20000e10 	.word	0x20000e10

08007fcc <USB_HP_IRQHandler>:
  * @brief  This function handles USB FS global interrupt request.
  * @param  None
  * @retval None
  */
void USB_HP_IRQHandler(void)
{
 8007fcc:	b580      	push	{r7, lr}
 8007fce:	af00      	add	r7, sp, #0
  HAL_PCD_IRQHandler(&hpcd);
 8007fd0:	4802      	ldr	r0, [pc, #8]	; (8007fdc <USB_HP_IRQHandler+0x10>)
 8007fd2:	f002 f99d 	bl	800a310 <HAL_PCD_IRQHandler>
}
 8007fd6:	bf00      	nop
 8007fd8:	bd80      	pop	{r7, pc}
 8007fda:	bf00      	nop
 8007fdc:	20000e10 	.word	0x20000e10

08007fe0 <RTC_WKUP_IRQHandler>:
}
#endif /* (CFG_USB_INTERFACE_ENABLE != 0) */

/* USER CODE BEGIN 1 */
void RTC_WKUP_IRQHandler(void)
{
 8007fe0:	b580      	push	{r7, lr}
 8007fe2:	af00      	add	r7, sp, #0
  HW_TS_RTC_Wakeup_Handler();
 8007fe4:	f7ff f83a 	bl	800705c <HW_TS_RTC_Wakeup_Handler>
}
 8007fe8:	bf00      	nop
 8007fea:	bd80      	pop	{r7, pc}

08007fec <EXTI15_10_IRQHandler>:
  * @brief  This function handles EXTI15_10_IRQ Handler.
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler(void)
{
 8007fec:	b580      	push	{r7, lr}
 8007fee:	af00      	add	r7, sp, #0
  HAL_GPIO_EXTI_IRQHandler(BUTTON_SW1_PIN);
 8007ff0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8007ff4:	f002 f860 	bl	800a0b8 <HAL_GPIO_EXTI_IRQHandler>
}
 8007ff8:	bf00      	nop
 8007ffa:	bd80      	pop	{r7, pc}

08007ffc <IPCC_C1_TX_IRQHandler>:

void
IPCC_C1_TX_IRQHandler(void)
{
 8007ffc:	b580      	push	{r7, lr}
 8007ffe:	af00      	add	r7, sp, #0
    HW_IPCC_Tx_Handler();
 8008000:	f000 ff48 	bl	8008e94 <HW_IPCC_Tx_Handler>

    return;
 8008004:	bf00      	nop
}
 8008006:	bd80      	pop	{r7, pc}

08008008 <IPCC_C1_RX_IRQHandler>:

void
IPCC_C1_RX_IRQHandler(void)
{
 8008008:	b580      	push	{r7, lr}
 800800a:	af00      	add	r7, sp, #0
    HW_IPCC_Rx_Handler();
 800800c:	f000 feec 	bl	8008de8 <HW_IPCC_Rx_Handler>
    return;
 8008010:	bf00      	nop
}
 8008012:	bd80      	pop	{r7, pc}

08008014 <logRegion>:
 * @returns  String with a log level color value.
 */
static inline uint16_t
logRegion(char *aLogString, uint16_t aMaxSize,
    appliLogRegion_t aLogRegion)
{
 8008014:	b5b0      	push	{r4, r5, r7, lr}
 8008016:	b08a      	sub	sp, #40	; 0x28
 8008018:	af00      	add	r7, sp, #0
 800801a:	6078      	str	r0, [r7, #4]
 800801c:	460b      	mov	r3, r1
 800801e:	807b      	strh	r3, [r7, #2]
 8008020:	4613      	mov	r3, r2
 8008022:	707b      	strb	r3, [r7, #1]
    char logRegionString[30U];

    switch (aLogRegion) {
 8008024:	787b      	ldrb	r3, [r7, #1]
 8008026:	2b01      	cmp	r3, #1
 8008028:	d002      	beq.n	8008030 <logRegion+0x1c>
 800802a:	2b02      	cmp	r3, #2
 800802c:	d00a      	beq.n	8008044 <logRegion+0x30>
 800802e:	e012      	b.n	8008056 <logRegion+0x42>
        case APPLI_LOG_REGION_GENERAL:
            strcpy(logRegionString, "[M4 APPLICATION]");
 8008030:	f107 0308 	add.w	r3, r7, #8
 8008034:	4a13      	ldr	r2, [pc, #76]	; (8008084 <logRegion+0x70>)
 8008036:	461c      	mov	r4, r3
 8008038:	4615      	mov	r5, r2
 800803a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800803c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800803e:	682b      	ldr	r3, [r5, #0]
 8008040:	7023      	strb	r3, [r4, #0]
            break;
 8008042:	e011      	b.n	8008068 <logRegion+0x54>
        case APPLI_LOG_REGION_ZIGBEE_API:
            strcpy(logRegionString, "[M4 ZIGBEE API]");
 8008044:	f107 0308 	add.w	r3, r7, #8
 8008048:	4a0f      	ldr	r2, [pc, #60]	; (8008088 <logRegion+0x74>)
 800804a:	461c      	mov	r4, r3
 800804c:	4613      	mov	r3, r2
 800804e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8008050:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            break;
 8008054:	e008      	b.n	8008068 <logRegion+0x54>
        default:
            strcpy(logRegionString, "[M4]");
 8008056:	f107 0308 	add.w	r3, r7, #8
 800805a:	4a0c      	ldr	r2, [pc, #48]	; (800808c <logRegion+0x78>)
 800805c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008060:	6018      	str	r0, [r3, #0]
 8008062:	3304      	adds	r3, #4
 8008064:	7019      	strb	r1, [r3, #0]
            break;
 8008066:	bf00      	nop
    }

    return snprintf(aLogString, aMaxSize, "%s ", logRegionString);
 8008068:	8879      	ldrh	r1, [r7, #2]
 800806a:	f107 0308 	add.w	r3, r7, #8
 800806e:	4a08      	ldr	r2, [pc, #32]	; (8008090 <logRegion+0x7c>)
 8008070:	6878      	ldr	r0, [r7, #4]
 8008072:	f010 f925 	bl	80182c0 <sniprintf>
 8008076:	4603      	mov	r3, r0
 8008078:	b29b      	uxth	r3, r3
}
 800807a:	4618      	mov	r0, r3
 800807c:	3728      	adds	r7, #40	; 0x28
 800807e:	46bd      	mov	sp, r7
 8008080:	bdb0      	pop	{r4, r5, r7, pc}
 8008082:	bf00      	nop
 8008084:	080193fc 	.word	0x080193fc
 8008088:	08019410 	.word	0x08019410
 800808c:	08019420 	.word	0x08019420
 8008090:	08019428 	.word	0x08019428

08008094 <levelToString>:
 * @param[in]  aLogLevel The log level.
 *
 * @returns  String with a log level color value.
 */
static inline const char *levelToString(appliLogLevel_t aLogLevel)
{
 8008094:	b480      	push	{r7}
 8008096:	b083      	sub	sp, #12
 8008098:	af00      	add	r7, sp, #0
 800809a:	4603      	mov	r3, r0
 800809c:	71fb      	strb	r3, [r7, #7]
  switch (aLogLevel)
 800809e:	79fb      	ldrb	r3, [r7, #7]
 80080a0:	2b03      	cmp	r3, #3
 80080a2:	d00a      	beq.n	80080ba <levelToString+0x26>
 80080a4:	2b03      	cmp	r3, #3
 80080a6:	dc0a      	bgt.n	80080be <levelToString+0x2a>
 80080a8:	2b01      	cmp	r3, #1
 80080aa:	d002      	beq.n	80080b2 <levelToString+0x1e>
 80080ac:	2b02      	cmp	r3, #2
 80080ae:	d002      	beq.n	80080b6 <levelToString+0x22>
 80080b0:	e005      	b.n	80080be <levelToString+0x2a>
  {
  case LOG_LEVEL_CRIT:
    return RTT_COLOR_CODE_RED;
 80080b2:	4b06      	ldr	r3, [pc, #24]	; (80080cc <levelToString+0x38>)
 80080b4:	e004      	b.n	80080c0 <levelToString+0x2c>

  case LOG_LEVEL_WARN:
    return RTT_COLOR_CODE_YELLOW;
 80080b6:	4b06      	ldr	r3, [pc, #24]	; (80080d0 <levelToString+0x3c>)
 80080b8:	e002      	b.n	80080c0 <levelToString+0x2c>

  case LOG_LEVEL_INFO:
    return RTT_COLOR_CODE_GREEN;
 80080ba:	4b06      	ldr	r3, [pc, #24]	; (80080d4 <levelToString+0x40>)
 80080bc:	e000      	b.n	80080c0 <levelToString+0x2c>

  case LOG_LEVEL_DEBG:
  default:
    return RTT_COLOR_CODE_DEFAULT;
 80080be:	4b06      	ldr	r3, [pc, #24]	; (80080d8 <levelToString+0x44>)
  }
}
 80080c0:	4618      	mov	r0, r3
 80080c2:	370c      	adds	r7, #12
 80080c4:	46bd      	mov	sp, r7
 80080c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080ca:	4770      	bx	lr
 80080cc:	0801942c 	.word	0x0801942c
 80080d0:	08019434 	.word	0x08019434
 80080d4:	0801943c 	.word	0x0801943c
 80080d8:	08019444 	.word	0x08019444

080080dc <logLevel>:
 *
 * @returns  Number of bytes successfully written to the log buffer.
 */
static inline uint16_t logLevel(char *aLogString, uint16_t aMaxSize,
                                appliLogLevel_t aLogLevel)
{
 80080dc:	b590      	push	{r4, r7, lr}
 80080de:	b083      	sub	sp, #12
 80080e0:	af00      	add	r7, sp, #0
 80080e2:	6078      	str	r0, [r7, #4]
 80080e4:	460b      	mov	r3, r1
 80080e6:	807b      	strh	r3, [r7, #2]
 80080e8:	4613      	mov	r3, r2
 80080ea:	707b      	strb	r3, [r7, #1]
  return snprintf(aLogString, aMaxSize, "%s", levelToString(aLogLevel));
 80080ec:	887c      	ldrh	r4, [r7, #2]
 80080ee:	787b      	ldrb	r3, [r7, #1]
 80080f0:	4618      	mov	r0, r3
 80080f2:	f7ff ffcf 	bl	8008094 <levelToString>
 80080f6:	4603      	mov	r3, r0
 80080f8:	4a05      	ldr	r2, [pc, #20]	; (8008110 <logLevel+0x34>)
 80080fa:	4621      	mov	r1, r4
 80080fc:	6878      	ldr	r0, [r7, #4]
 80080fe:	f010 f8df 	bl	80182c0 <sniprintf>
 8008102:	4603      	mov	r3, r0
 8008104:	b29b      	uxth	r3, r3
}
 8008106:	4618      	mov	r0, r3
 8008108:	370c      	adds	r7, #12
 800810a:	46bd      	mov	sp, r7
 800810c:	bd90      	pop	{r4, r7, pc}
 800810e:	bf00      	nop
 8008110:	0801944c 	.word	0x0801944c

08008114 <logApplication>:
 * @param[in]     aFormat     User string format.
 *
 * @returns  Number of bytes successfully written to the log buffer.
 */
void logApplication(appliLogLevel_t aLogLevel, appliLogRegion_t aLogRegion, const char *aFormat, ...)
{
 8008114:	b40c      	push	{r2, r3}
 8008116:	b580      	push	{r7, lr}
 8008118:	b0c4      	sub	sp, #272	; 0x110
 800811a:	af00      	add	r7, sp, #0
 800811c:	4602      	mov	r2, r0
 800811e:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8008122:	f2a3 1309 	subw	r3, r3, #265	; 0x109
 8008126:	701a      	strb	r2, [r3, #0]
 8008128:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800812c:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 8008130:	460a      	mov	r2, r1
 8008132:	701a      	strb	r2, [r3, #0]
#if (CFG_DEBUG_TRACE != 0) /* Since the traces are disabled, there is nothing to print */
  uint16_t length = 0;
 8008134:	2300      	movs	r3, #0
 8008136:	f8a7 310e 	strh.w	r3, [r7, #270]	; 0x10e
  length += logTimestamp(logString, LOG_PARSE_BUFFER_SIZE);
#endif

#if (LOG_RTT_COLOR_ENABLE == 1U)
  /* Add level information */
  length += logLevel(&logString[length], (LOG_PARSE_BUFFER_SIZE - length),
 800813a:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 800813e:	f107 020c 	add.w	r2, r7, #12
 8008142:	18d0      	adds	r0, r2, r3
 8008144:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 8008148:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 800814c:	b299      	uxth	r1, r3
 800814e:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8008152:	f2a3 1309 	subw	r3, r3, #265	; 0x109
 8008156:	781b      	ldrb	r3, [r3, #0]
 8008158:	461a      	mov	r2, r3
 800815a:	f7ff ffbf 	bl	80080dc <logLevel>
 800815e:	4603      	mov	r3, r0
 8008160:	461a      	mov	r2, r3
 8008162:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 8008166:	4413      	add	r3, r2
 8008168:	f8a7 310e 	strh.w	r3, [r7, #270]	; 0x10e
      aLogLevel);
#endif

#if (LOG_REGION_ENABLE == 1U)
  /* Add Region information */
  length += logRegion(&logString[length], (LOG_PARSE_BUFFER_SIZE - length),
 800816c:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 8008170:	f107 020c 	add.w	r2, r7, #12
 8008174:	18d0      	adds	r0, r2, r3
 8008176:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 800817a:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 800817e:	b299      	uxth	r1, r3
 8008180:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8008184:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 8008188:	781b      	ldrb	r3, [r3, #0]
 800818a:	461a      	mov	r2, r3
 800818c:	f7ff ff42 	bl	8008014 <logRegion>
 8008190:	4603      	mov	r3, r0
 8008192:	461a      	mov	r2, r3
 8008194:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 8008198:	4413      	add	r3, r2
 800819a:	f8a7 310e 	strh.w	r3, [r7, #270]	; 0x10e
      aLogRegion);
#endif

    /* Parse user string */
    va_list paramList;
    va_start(paramList, aFormat);
 800819e:	f507 728e 	add.w	r2, r7, #284	; 0x11c
 80081a2:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80081a6:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80081aa:	601a      	str	r2, [r3, #0]
    length += vsnprintf(&logString[length], (LOG_PARSE_BUFFER_SIZE - length),
 80081ac:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 80081b0:	f107 020c 	add.w	r2, r7, #12
 80081b4:	18d0      	adds	r0, r2, r3
 80081b6:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 80081ba:	f5c3 7180 	rsb	r1, r3, #256	; 0x100
 80081be:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80081c2:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80081c6:	681b      	ldr	r3, [r3, #0]
 80081c8:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 80081cc:	f010 f93a 	bl	8018444 <vsniprintf>
 80081d0:	4603      	mov	r3, r0
 80081d2:	b29a      	uxth	r2, r3
 80081d4:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 80081d8:	4413      	add	r3, r2
 80081da:	f8a7 310e 	strh.w	r3, [r7, #270]	; 0x10e
            aFormat, paramList);
    logString[length++] = '\r';
 80081de:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 80081e2:	1c5a      	adds	r2, r3, #1
 80081e4:	f8a7 210e 	strh.w	r2, [r7, #270]	; 0x10e
 80081e8:	461a      	mov	r2, r3
 80081ea:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80081ee:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80081f2:	210d      	movs	r1, #13
 80081f4:	5499      	strb	r1, [r3, r2]
    logString[length++] = '\n';
 80081f6:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 80081fa:	1c5a      	adds	r2, r3, #1
 80081fc:	f8a7 210e 	strh.w	r2, [r7, #270]	; 0x10e
 8008200:	461a      	mov	r2, r3
 8008202:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8008206:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800820a:	210a      	movs	r1, #10
 800820c:	5499      	strb	r1, [r3, r2]
    logString[length++] = 0;
 800820e:	f8b7 310e 	ldrh.w	r3, [r7, #270]	; 0x10e
 8008212:	1c5a      	adds	r2, r3, #1
 8008214:	f8a7 210e 	strh.w	r2, [r7, #270]	; 0x10e
 8008218:	461a      	mov	r2, r3
 800821a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800821e:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8008222:	2100      	movs	r1, #0
 8008224:	5499      	strb	r1, [r3, r2]
    va_end(paramList);

  if (aLogLevel <= APPLI_CONFIG_LOG_LEVEL)
 8008226:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800822a:	f2a3 1309 	subw	r3, r3, #265	; 0x109
 800822e:	781b      	ldrb	r3, [r3, #0]
 8008230:	2b03      	cmp	r3, #3
 8008232:	d805      	bhi.n	8008240 <logApplication+0x12c>
  {
    printf("%s", logString);
 8008234:	f107 030c 	add.w	r3, r7, #12
 8008238:	4619      	mov	r1, r3
 800823a:	4805      	ldr	r0, [pc, #20]	; (8008250 <logApplication+0x13c>)
 800823c:	f010 f82e 	bl	801829c <iprintf>
  }else
  {
    /* Print nothing */
  }
#endif /* CFG_DEBUG_TRACE */
}
 8008240:	bf00      	nop
 8008242:	f507 7788 	add.w	r7, r7, #272	; 0x110
 8008246:	46bd      	mov	sp, r7
 8008248:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800824c:	b002      	add	sp, #8
 800824e:	4770      	bx	lr
 8008250:	0801944c 	.word	0x0801944c

08008254 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 8008254:	b480      	push	{r7}
 8008256:	af00      	add	r7, sp, #0
  return 1;
 8008258:	2301      	movs	r3, #1
}
 800825a:	4618      	mov	r0, r3
 800825c:	46bd      	mov	sp, r7
 800825e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008262:	4770      	bx	lr

08008264 <_kill>:

int _kill(int pid, int sig)
{
 8008264:	b580      	push	{r7, lr}
 8008266:	b082      	sub	sp, #8
 8008268:	af00      	add	r7, sp, #0
 800826a:	6078      	str	r0, [r7, #4]
 800826c:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 800826e:	f010 f963 	bl	8018538 <__errno>
 8008272:	4603      	mov	r3, r0
 8008274:	2216      	movs	r2, #22
 8008276:	601a      	str	r2, [r3, #0]
  return -1;
 8008278:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 800827c:	4618      	mov	r0, r3
 800827e:	3708      	adds	r7, #8
 8008280:	46bd      	mov	sp, r7
 8008282:	bd80      	pop	{r7, pc}

08008284 <_exit>:

void _exit (int status)
{
 8008284:	b580      	push	{r7, lr}
 8008286:	b082      	sub	sp, #8
 8008288:	af00      	add	r7, sp, #0
 800828a:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 800828c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008290:	6878      	ldr	r0, [r7, #4]
 8008292:	f7ff ffe7 	bl	8008264 <_kill>
  while (1) {}    /* Make sure we hang here */
 8008296:	e7fe      	b.n	8008296 <_exit+0x12>

08008298 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8008298:	b580      	push	{r7, lr}
 800829a:	b086      	sub	sp, #24
 800829c:	af00      	add	r7, sp, #0
 800829e:	60f8      	str	r0, [r7, #12]
 80082a0:	60b9      	str	r1, [r7, #8]
 80082a2:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80082a4:	2300      	movs	r3, #0
 80082a6:	617b      	str	r3, [r7, #20]
 80082a8:	e00a      	b.n	80082c0 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 80082aa:	f3af 8000 	nop.w
 80082ae:	4601      	mov	r1, r0
 80082b0:	68bb      	ldr	r3, [r7, #8]
 80082b2:	1c5a      	adds	r2, r3, #1
 80082b4:	60ba      	str	r2, [r7, #8]
 80082b6:	b2ca      	uxtb	r2, r1
 80082b8:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80082ba:	697b      	ldr	r3, [r7, #20]
 80082bc:	3301      	adds	r3, #1
 80082be:	617b      	str	r3, [r7, #20]
 80082c0:	697a      	ldr	r2, [r7, #20]
 80082c2:	687b      	ldr	r3, [r7, #4]
 80082c4:	429a      	cmp	r2, r3
 80082c6:	dbf0      	blt.n	80082aa <_read+0x12>
  }

  return len;
 80082c8:	687b      	ldr	r3, [r7, #4]
}
 80082ca:	4618      	mov	r0, r3
 80082cc:	3718      	adds	r7, #24
 80082ce:	46bd      	mov	sp, r7
 80082d0:	bd80      	pop	{r7, pc}

080082d2 <_close>:
  }
  return len;
}

int _close(int file)
{
 80082d2:	b480      	push	{r7}
 80082d4:	b083      	sub	sp, #12
 80082d6:	af00      	add	r7, sp, #0
 80082d8:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 80082da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 80082de:	4618      	mov	r0, r3
 80082e0:	370c      	adds	r7, #12
 80082e2:	46bd      	mov	sp, r7
 80082e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082e8:	4770      	bx	lr

080082ea <_fstat>:


int _fstat(int file, struct stat *st)
{
 80082ea:	b480      	push	{r7}
 80082ec:	b083      	sub	sp, #12
 80082ee:	af00      	add	r7, sp, #0
 80082f0:	6078      	str	r0, [r7, #4]
 80082f2:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 80082f4:	683b      	ldr	r3, [r7, #0]
 80082f6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80082fa:	605a      	str	r2, [r3, #4]
  return 0;
 80082fc:	2300      	movs	r3, #0
}
 80082fe:	4618      	mov	r0, r3
 8008300:	370c      	adds	r7, #12
 8008302:	46bd      	mov	sp, r7
 8008304:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008308:	4770      	bx	lr

0800830a <_isatty>:

int _isatty(int file)
{
 800830a:	b480      	push	{r7}
 800830c:	b083      	sub	sp, #12
 800830e:	af00      	add	r7, sp, #0
 8008310:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8008312:	2301      	movs	r3, #1
}
 8008314:	4618      	mov	r0, r3
 8008316:	370c      	adds	r7, #12
 8008318:	46bd      	mov	sp, r7
 800831a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800831e:	4770      	bx	lr

08008320 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8008320:	b480      	push	{r7}
 8008322:	b085      	sub	sp, #20
 8008324:	af00      	add	r7, sp, #0
 8008326:	60f8      	str	r0, [r7, #12]
 8008328:	60b9      	str	r1, [r7, #8]
 800832a:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 800832c:	2300      	movs	r3, #0
}
 800832e:	4618      	mov	r0, r3
 8008330:	3714      	adds	r7, #20
 8008332:	46bd      	mov	sp, r7
 8008334:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008338:	4770      	bx	lr
	...

0800833c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800833c:	b580      	push	{r7, lr}
 800833e:	b086      	sub	sp, #24
 8008340:	af00      	add	r7, sp, #0
 8008342:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8008344:	4a14      	ldr	r2, [pc, #80]	; (8008398 <_sbrk+0x5c>)
 8008346:	4b15      	ldr	r3, [pc, #84]	; (800839c <_sbrk+0x60>)
 8008348:	1ad3      	subs	r3, r2, r3
 800834a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800834c:	697b      	ldr	r3, [r7, #20]
 800834e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8008350:	4b13      	ldr	r3, [pc, #76]	; (80083a0 <_sbrk+0x64>)
 8008352:	681b      	ldr	r3, [r3, #0]
 8008354:	2b00      	cmp	r3, #0
 8008356:	d102      	bne.n	800835e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8008358:	4b11      	ldr	r3, [pc, #68]	; (80083a0 <_sbrk+0x64>)
 800835a:	4a12      	ldr	r2, [pc, #72]	; (80083a4 <_sbrk+0x68>)
 800835c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800835e:	4b10      	ldr	r3, [pc, #64]	; (80083a0 <_sbrk+0x64>)
 8008360:	681a      	ldr	r2, [r3, #0]
 8008362:	687b      	ldr	r3, [r7, #4]
 8008364:	4413      	add	r3, r2
 8008366:	693a      	ldr	r2, [r7, #16]
 8008368:	429a      	cmp	r2, r3
 800836a:	d207      	bcs.n	800837c <_sbrk+0x40>
  {
    errno = ENOMEM;
 800836c:	f010 f8e4 	bl	8018538 <__errno>
 8008370:	4603      	mov	r3, r0
 8008372:	220c      	movs	r2, #12
 8008374:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8008376:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800837a:	e009      	b.n	8008390 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800837c:	4b08      	ldr	r3, [pc, #32]	; (80083a0 <_sbrk+0x64>)
 800837e:	681b      	ldr	r3, [r3, #0]
 8008380:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8008382:	4b07      	ldr	r3, [pc, #28]	; (80083a0 <_sbrk+0x64>)
 8008384:	681a      	ldr	r2, [r3, #0]
 8008386:	687b      	ldr	r3, [r7, #4]
 8008388:	4413      	add	r3, r2
 800838a:	4a05      	ldr	r2, [pc, #20]	; (80083a0 <_sbrk+0x64>)
 800838c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800838e:	68fb      	ldr	r3, [r7, #12]
}
 8008390:	4618      	mov	r0, r3
 8008392:	3718      	adds	r7, #24
 8008394:	46bd      	mov	sp, r7
 8008396:	bd80      	pop	{r7, pc}
 8008398:	20030000 	.word	0x20030000
 800839c:	00001000 	.word	0x00001000
 80083a0:	20000d70 	.word	0x20000d70
 80083a4:	200028f8 	.word	0x200028f8

080083a8 <readTemp_cb>:

int i = 0;
char ready_to_send = 0;

void readTemp_cb(const struct ZbZclReadRspT *rsp, void *cbarg)
{
 80083a8:	b580      	push	{r7, lr}
 80083aa:	b084      	sub	sp, #16
 80083ac:	af00      	add	r7, sp, #0
 80083ae:	6078      	str	r0, [r7, #4]
 80083b0:	6039      	str	r1, [r7, #0]
	uint16_t temp = -2;
 80083b2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80083b6:	81fb      	strh	r3, [r7, #14]
	if(rsp->attr[0].status == ZCL_STATUS_SUCCESS)
 80083b8:	687b      	ldr	r3, [r7, #4]
 80083ba:	f893 3020 	ldrb.w	r3, [r3, #32]
 80083be:	2b00      	cmp	r3, #0
 80083c0:	d107      	bne.n	80083d2 <readTemp_cb+0x2a>
	{
		temp = pletoh16(rsp->attr[0].value);
 80083c2:	687b      	ldr	r3, [r7, #4]
 80083c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80083c6:	4618      	mov	r0, r3
 80083c8:	f7f7 fee8 	bl	800019c <pletoh16>
 80083cc:	4603      	mov	r3, r0
 80083ce:	81fb      	strh	r3, [r7, #14]
 80083d0:	e005      	b.n	80083de <readTemp_cb+0x36>
	}
	else
	{
		BSP_LED_Toggle(LED_RED);
 80083d2:	2002      	movs	r0, #2
 80083d4:	f000 ff8c 	bl	80092f0 <BSP_LED_Toggle>
		temp = -1;
 80083d8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80083dc:	81fb      	strh	r3, [r7, #14]
	}
	if(temp == 0)
 80083de:	89fb      	ldrh	r3, [r7, #14]
 80083e0:	2b00      	cmp	r3, #0
 80083e2:	d102      	bne.n	80083ea <readTemp_cb+0x42>
		BSP_LED_Toggle(LED_GREEN);
 80083e4:	2001      	movs	r0, #1
 80083e6:	f000 ff83 	bl	80092f0 <BSP_LED_Toggle>

	printf("Temp: %d.%d\n", temp/100,temp%100);
 80083ea:	89fb      	ldrh	r3, [r7, #14]
 80083ec:	4a0c      	ldr	r2, [pc, #48]	; (8008420 <readTemp_cb+0x78>)
 80083ee:	fba2 2303 	umull	r2, r3, r2, r3
 80083f2:	095b      	lsrs	r3, r3, #5
 80083f4:	b29b      	uxth	r3, r3
 80083f6:	4618      	mov	r0, r3
 80083f8:	89fb      	ldrh	r3, [r7, #14]
 80083fa:	4a09      	ldr	r2, [pc, #36]	; (8008420 <readTemp_cb+0x78>)
 80083fc:	fba2 1203 	umull	r1, r2, r2, r3
 8008400:	0952      	lsrs	r2, r2, #5
 8008402:	2164      	movs	r1, #100	; 0x64
 8008404:	fb01 f202 	mul.w	r2, r1, r2
 8008408:	1a9b      	subs	r3, r3, r2
 800840a:	b29b      	uxth	r3, r3
 800840c:	461a      	mov	r2, r3
 800840e:	4601      	mov	r1, r0
 8008410:	4804      	ldr	r0, [pc, #16]	; (8008424 <readTemp_cb+0x7c>)
 8008412:	f00f ff43 	bl	801829c <iprintf>
}
 8008416:	bf00      	nop
 8008418:	3710      	adds	r7, #16
 800841a:	46bd      	mov	sp, r7
 800841c:	bd80      	pop	{r7, pc}
 800841e:	bf00      	nop
 8008420:	51eb851f 	.word	0x51eb851f
 8008424:	08019450 	.word	0x08019450

08008428 <readTemp>:

void readTemp() {
 8008428:	b580      	push	{r7, lr}
 800842a:	b08c      	sub	sp, #48	; 0x30
 800842c:	af00      	add	r7, sp, #0
	if(i++ == 100000) {
 800842e:	4b1e      	ldr	r3, [pc, #120]	; (80084a8 <readTemp+0x80>)
 8008430:	681b      	ldr	r3, [r3, #0]
 8008432:	1c5a      	adds	r2, r3, #1
 8008434:	491c      	ldr	r1, [pc, #112]	; (80084a8 <readTemp+0x80>)
 8008436:	600a      	str	r2, [r1, #0]
 8008438:	4a1c      	ldr	r2, [pc, #112]	; (80084ac <readTemp+0x84>)
 800843a:	4293      	cmp	r3, r2
 800843c:	d12b      	bne.n	8008496 <readTemp+0x6e>
		i = 0;
 800843e:	4b1a      	ldr	r3, [pc, #104]	; (80084a8 <readTemp+0x80>)
 8008440:	2200      	movs	r2, #0
 8008442:	601a      	str	r2, [r3, #0]
		ZbZclReadReqT req;
		//uint32_t adc_result;

		//adc_result = HAL_ADC_GetValue();

		memset(&req, 0, sizeof(req));
 8008444:	463b      	mov	r3, r7
 8008446:	2228      	movs	r2, #40	; 0x28
 8008448:	2100      	movs	r1, #0
 800844a:	4618      	mov	r0, r3
 800844c:	f010 f808 	bl	8018460 <memset>
		req.dst.mode = ZB_APSDE_ADDRMODE_SHORT;
 8008450:	2302      	movs	r3, #2
 8008452:	703b      	strb	r3, [r7, #0]
		req.dst.endpoint = SW1_ENDPOINT;
 8008454:	2301      	movs	r3, #1
 8008456:	807b      	strh	r3, [r7, #2]
		req.dst.nwkAddr = 0x0000;
 8008458:	2300      	movs	r3, #0
 800845a:	80fb      	strh	r3, [r7, #6]

		req.count = 1U;
 800845c:	2301      	movs	r3, #1
 800845e:	613b      	str	r3, [r7, #16]
		req.attr[0] = ZCL_TEMP_MEAS_ATTR_MEAS_VAL;
 8008460:	2300      	movs	r3, #0
 8008462:	82bb      	strh	r3, [r7, #20]

		if(ready_to_send) {
 8008464:	4b12      	ldr	r3, [pc, #72]	; (80084b0 <readTemp+0x88>)
 8008466:	781b      	ldrb	r3, [r3, #0]
 8008468:	2b00      	cmp	r3, #0
 800846a:	d014      	beq.n	8008496 <readTemp+0x6e>
			status = ZbZclReadReq(zigbee_app_info.temperature_meas_client_1, &req, readTemp_cb, NULL);
 800846c:	4b11      	ldr	r3, [pc, #68]	; (80084b4 <readTemp+0x8c>)
 800846e:	6958      	ldr	r0, [r3, #20]
 8008470:	4639      	mov	r1, r7
 8008472:	2300      	movs	r3, #0
 8008474:	4a10      	ldr	r2, [pc, #64]	; (80084b8 <readTemp+0x90>)
 8008476:	f00d fcae 	bl	8015dd6 <ZbZclReadReq>
 800847a:	4603      	mov	r3, r0
 800847c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			if (status != ZCL_STATUS_SUCCESS) {
 8008480:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8008484:	2b00      	cmp	r3, #0
 8008486:	d003      	beq.n	8008490 <readTemp+0x68>
				BSP_LED_On(LED_GREEN);
 8008488:	2001      	movs	r0, #1
 800848a:	f000 fefd 	bl	8009288 <BSP_LED_On>
 800848e:	e002      	b.n	8008496 <readTemp+0x6e>
			} else {
				BSP_LED_Off(LED_GREEN);
 8008490:	2001      	movs	r0, #1
 8008492:	f000 ff13 	bl	80092bc <BSP_LED_Off>
			}
		}
	}
    UTIL_SEQ_SetTask(1U << CFG_TASK_READ_TEMP,CFG_SCH_PRIO_1);
 8008496:	2101      	movs	r1, #1
 8008498:	2010      	movs	r0, #16
 800849a:	f00f fc95 	bl	8017dc8 <UTIL_SEQ_SetTask>
}
 800849e:	bf00      	nop
 80084a0:	3730      	adds	r7, #48	; 0x30
 80084a2:	46bd      	mov	sp, r7
 80084a4:	bd80      	pop	{r7, pc}
 80084a6:	bf00      	nop
 80084a8:	20000da0 	.word	0x20000da0
 80084ac:	000186a0 	.word	0x000186a0
 80084b0:	20000da4 	.word	0x20000da4
 80084b4:	20000d88 	.word	0x20000d88
 80084b8:	080083a9 	.word	0x080083a9

080084bc <APP_ZIGBEE_Init>:
 * @brief  Zigbee application initialization
 * @param  None
 * @retval None
 */
void APP_ZIGBEE_Init(void)
{
 80084bc:	b580      	push	{r7, lr}
 80084be:	b082      	sub	sp, #8
 80084c0:	af00      	add	r7, sp, #0
  SHCI_CmdStatus_t ZigbeeInitStatus;

  APP_DBG("APP_ZIGBEE_Init");
 80084c2:	4a12      	ldr	r2, [pc, #72]	; (800850c <APP_ZIGBEE_Init+0x50>)
 80084c4:	2101      	movs	r1, #1
 80084c6:	2000      	movs	r0, #0
 80084c8:	f7ff fe24 	bl	8008114 <logApplication>

  /* Check the compatibility with the Coprocessor Wireless Firmware loaded */
  APP_ZIGBEE_CheckWirelessFirmwareInfo();
 80084cc:	f000 f9c8 	bl	8008860 <APP_ZIGBEE_CheckWirelessFirmwareInfo>

  /* Register cmdbuffer */
  APP_ZIGBEE_RegisterCmdBuffer(&ZigbeeOtCmdBuffer);
 80084d0:	480f      	ldr	r0, [pc, #60]	; (8008510 <APP_ZIGBEE_Init+0x54>)
 80084d2:	f000 fa7b 	bl	80089cc <APP_ZIGBEE_RegisterCmdBuffer>

  /* Init config buffer and call TL_ZIGBEE_Init */
  APP_ZIGBEE_TL_INIT();
 80084d6:	f000 fb35 	bl	8008b44 <APP_ZIGBEE_TL_INIT>

  /* Register task */
  /* Create the different tasks */
  UTIL_SEQ_RegTask(1U << (uint32_t)CFG_TASK_NOTIFY_FROM_M0_TO_M4, UTIL_SEQ_RFU, APP_ZIGBEE_ProcessNotifyM0ToM4);
 80084da:	4a0e      	ldr	r2, [pc, #56]	; (8008514 <APP_ZIGBEE_Init+0x58>)
 80084dc:	2100      	movs	r1, #0
 80084de:	2001      	movs	r0, #1
 80084e0:	f00f fc50 	bl	8017d84 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask(1U << (uint32_t)CFG_TASK_REQUEST_FROM_M0_TO_M4, UTIL_SEQ_RFU, APP_ZIGBEE_ProcessRequestM0ToM4);
 80084e4:	4a0c      	ldr	r2, [pc, #48]	; (8008518 <APP_ZIGBEE_Init+0x5c>)
 80084e6:	2100      	movs	r1, #0
 80084e8:	2002      	movs	r0, #2
 80084ea:	f00f fc4b 	bl	8017d84 <UTIL_SEQ_RegTask>

  /* Task associated with network creation process */
  UTIL_SEQ_RegTask(1U << CFG_TASK_ZIGBEE_NETWORK_FORM, UTIL_SEQ_RFU, APP_ZIGBEE_NwkForm);
 80084ee:	4a0b      	ldr	r2, [pc, #44]	; (800851c <APP_ZIGBEE_Init+0x60>)
 80084f0:	2100      	movs	r1, #0
 80084f2:	2008      	movs	r0, #8
 80084f4:	f00f fc46 	bl	8017d84 <UTIL_SEQ_RegTask>

  /* USER CODE BEGIN APP_ZIGBEE_INIT */
  /* USER CODE END APP_ZIGBEE_INIT */

  /* Start the Zigbee on the CPU2 side */
  ZigbeeInitStatus = SHCI_C2_ZIGBEE_Init();
 80084f8:	f00b f80a 	bl	8013510 <SHCI_C2_ZIGBEE_Init>
 80084fc:	4603      	mov	r3, r0
 80084fe:	71fb      	strb	r3, [r7, #7]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(ZigbeeInitStatus);

  /* Initialize Zigbee stack layers */
  APP_ZIGBEE_StackLayersInit();
 8008500:	f000 f80e 	bl	8008520 <APP_ZIGBEE_StackLayersInit>

}
 8008504:	bf00      	nop
 8008506:	3708      	adds	r7, #8
 8008508:	46bd      	mov	sp, r7
 800850a:	bd80      	pop	{r7, pc}
 800850c:	08019460 	.word	0x08019460
 8008510:	20030838 	.word	0x20030838
 8008514:	08008b75 	.word	0x08008b75
 8008518:	08008b95 	.word	0x08008b95
 800851c:	0800862d 	.word	0x0800862d

08008520 <APP_ZIGBEE_StackLayersInit>:
 * @brief  Initialize Zigbee stack layers
 * @param  None
 * @retval None
 */
static void APP_ZIGBEE_StackLayersInit(void)
{
 8008520:	b580      	push	{r7, lr}
 8008522:	af00      	add	r7, sp, #0
  APP_DBG("APP_ZIGBEE_StackLayersInit");
 8008524:	4a17      	ldr	r2, [pc, #92]	; (8008584 <APP_ZIGBEE_StackLayersInit+0x64>)
 8008526:	2101      	movs	r1, #1
 8008528:	2000      	movs	r0, #0
 800852a:	f7ff fdf3 	bl	8008114 <logApplication>

  zigbee_app_info.zb = ZbInit(0U, NULL, NULL);
 800852e:	2300      	movs	r3, #0
 8008530:	2200      	movs	r2, #0
 8008532:	f04f 0000 	mov.w	r0, #0
 8008536:	f04f 0100 	mov.w	r1, #0
 800853a:	f00c feb3 	bl	80152a4 <ZbInit>
 800853e:	4603      	mov	r3, r0
 8008540:	4a11      	ldr	r2, [pc, #68]	; (8008588 <APP_ZIGBEE_StackLayersInit+0x68>)
 8008542:	6053      	str	r3, [r2, #4]
  assert(zigbee_app_info.zb != NULL);
 8008544:	4b10      	ldr	r3, [pc, #64]	; (8008588 <APP_ZIGBEE_StackLayersInit+0x68>)
 8008546:	685b      	ldr	r3, [r3, #4]
 8008548:	2b00      	cmp	r3, #0
 800854a:	d105      	bne.n	8008558 <APP_ZIGBEE_StackLayersInit+0x38>
 800854c:	4b0f      	ldr	r3, [pc, #60]	; (800858c <APP_ZIGBEE_StackLayersInit+0x6c>)
 800854e:	4a10      	ldr	r2, [pc, #64]	; (8008590 <APP_ZIGBEE_StackLayersInit+0x70>)
 8008550:	21d8      	movs	r1, #216	; 0xd8
 8008552:	4810      	ldr	r0, [pc, #64]	; (8008594 <APP_ZIGBEE_StackLayersInit+0x74>)
 8008554:	f00f fcf4 	bl	8017f40 <__assert_func>

  /* Create the endpoint and cluster(s) */
  APP_ZIGBEE_ConfigEndpoints();
 8008558:	f000 f81e 	bl	8008598 <APP_ZIGBEE_ConfigEndpoints>

  /* USER CODE BEGIN APP_ZIGBEE_StackLayersInit */
  /* USER CODE END APP_ZIGBEE_StackLayersInit */

  /* Configure the joining parameters */
  zigbee_app_info.join_status = (enum ZbStatusCodeT) 0x01; /* init to error status */
 800855c:	4b0a      	ldr	r3, [pc, #40]	; (8008588 <APP_ZIGBEE_StackLayersInit+0x68>)
 800855e:	2201      	movs	r2, #1
 8008560:	725a      	strb	r2, [r3, #9]
  zigbee_app_info.join_delay = HAL_GetTick(); /* now */
 8008562:	f001 f803 	bl	800956c <HAL_GetTick>
 8008566:	4603      	mov	r3, r0
 8008568:	4a07      	ldr	r2, [pc, #28]	; (8008588 <APP_ZIGBEE_StackLayersInit+0x68>)
 800856a:	60d3      	str	r3, [r2, #12]
  zigbee_app_info.startupControl = ZbStartTypeJoin;
 800856c:	4b06      	ldr	r3, [pc, #24]	; (8008588 <APP_ZIGBEE_StackLayersInit+0x68>)
 800856e:	2203      	movs	r2, #3
 8008570:	721a      	strb	r2, [r3, #8]
  //ziggbee_app_info.startupControl = ZbStartTypeForm;

  /* Initialization Complete */
  zigbee_app_info.has_init = true;
 8008572:	4b05      	ldr	r3, [pc, #20]	; (8008588 <APP_ZIGBEE_StackLayersInit+0x68>)
 8008574:	2201      	movs	r2, #1
 8008576:	701a      	strb	r2, [r3, #0]

  /* run the task */
  UTIL_SEQ_SetTask(1U << CFG_TASK_ZIGBEE_NETWORK_FORM, CFG_SCH_PRIO_0);
 8008578:	2100      	movs	r1, #0
 800857a:	2008      	movs	r0, #8
 800857c:	f00f fc24 	bl	8017dc8 <UTIL_SEQ_SetTask>
}
 8008580:	bf00      	nop
 8008582:	bd80      	pop	{r7, pc}
 8008584:	08019470 	.word	0x08019470
 8008588:	20000d88 	.word	0x20000d88
 800858c:	0801948c 	.word	0x0801948c
 8008590:	080199c8 	.word	0x080199c8
 8008594:	080194a8 	.word	0x080194a8

08008598 <APP_ZIGBEE_ConfigEndpoints>:
 * @brief  Configure Zigbee application endpoints
 * @param  None
 * @retval None
 */
static void APP_ZIGBEE_ConfigEndpoints(void)
{
 8008598:	b580      	push	{r7, lr}
 800859a:	b088      	sub	sp, #32
 800859c:	af00      	add	r7, sp, #0
  struct ZbApsmeAddEndpointReqT req;
  struct ZbApsmeAddEndpointConfT conf;

  memset(&req, 0, sizeof(req));
 800859e:	f107 0308 	add.w	r3, r7, #8
 80085a2:	2218      	movs	r2, #24
 80085a4:	2100      	movs	r1, #0
 80085a6:	4618      	mov	r0, r3
 80085a8:	f00f ff5a 	bl	8018460 <memset>

  /* Endpoint: SW1_ENDPOINT */
  req.profileId = ZCL_PROFILE_HOME_AUTOMATION;
 80085ac:	f44f 7382 	mov.w	r3, #260	; 0x104
 80085b0:	817b      	strh	r3, [r7, #10]
  req.deviceId = ZCL_DEVICE_ONOFF_LIGHT_SENSOR;
 80085b2:	f44f 7383 	mov.w	r3, #262	; 0x106
 80085b6:	81bb      	strh	r3, [r7, #12]
  req.endpoint = SW1_ENDPOINT;
 80085b8:	2301      	movs	r3, #1
 80085ba:	723b      	strb	r3, [r7, #8]
  ZbZclAddEndpoint(zigbee_app_info.zb, &req, &conf);
 80085bc:	4b16      	ldr	r3, [pc, #88]	; (8008618 <APP_ZIGBEE_ConfigEndpoints+0x80>)
 80085be:	685b      	ldr	r3, [r3, #4]
 80085c0:	1d3a      	adds	r2, r7, #4
 80085c2:	f107 0108 	add.w	r1, r7, #8
 80085c6:	4618      	mov	r0, r3
 80085c8:	f00d fbd6 	bl	8015d78 <ZbZclAddEndpoint>
  assert(conf.status == ZB_STATUS_SUCCESS);
 80085cc:	793b      	ldrb	r3, [r7, #4]
 80085ce:	2b00      	cmp	r3, #0
 80085d0:	d005      	beq.n	80085de <APP_ZIGBEE_ConfigEndpoints+0x46>
 80085d2:	4b12      	ldr	r3, [pc, #72]	; (800861c <APP_ZIGBEE_ConfigEndpoints+0x84>)
 80085d4:	4a12      	ldr	r2, [pc, #72]	; (8008620 <APP_ZIGBEE_ConfigEndpoints+0x88>)
 80085d6:	21fe      	movs	r1, #254	; 0xfe
 80085d8:	4812      	ldr	r0, [pc, #72]	; (8008624 <APP_ZIGBEE_ConfigEndpoints+0x8c>)
 80085da:	f00f fcb1 	bl	8017f40 <__assert_func>

  /* Temperature meas client */
  zigbee_app_info.temperature_meas_client_1 = ZbZclTempMeasClientAlloc(zigbee_app_info.zb, SW1_ENDPOINT);
 80085de:	4b0e      	ldr	r3, [pc, #56]	; (8008618 <APP_ZIGBEE_ConfigEndpoints+0x80>)
 80085e0:	685b      	ldr	r3, [r3, #4]
 80085e2:	2101      	movs	r1, #1
 80085e4:	4618      	mov	r0, r3
 80085e6:	f7f8 fd73 	bl	80010d0 <ZbZclTempMeasClientAlloc>
 80085ea:	4603      	mov	r3, r0
 80085ec:	4a0a      	ldr	r2, [pc, #40]	; (8008618 <APP_ZIGBEE_ConfigEndpoints+0x80>)
 80085ee:	6153      	str	r3, [r2, #20]
  assert(zigbee_app_info.temperature_meas_client_1 != NULL);
 80085f0:	4b09      	ldr	r3, [pc, #36]	; (8008618 <APP_ZIGBEE_ConfigEndpoints+0x80>)
 80085f2:	695b      	ldr	r3, [r3, #20]
 80085f4:	2b00      	cmp	r3, #0
 80085f6:	d106      	bne.n	8008606 <APP_ZIGBEE_ConfigEndpoints+0x6e>
 80085f8:	4b0b      	ldr	r3, [pc, #44]	; (8008628 <APP_ZIGBEE_ConfigEndpoints+0x90>)
 80085fa:	4a09      	ldr	r2, [pc, #36]	; (8008620 <APP_ZIGBEE_ConfigEndpoints+0x88>)
 80085fc:	f44f 7181 	mov.w	r1, #258	; 0x102
 8008600:	4808      	ldr	r0, [pc, #32]	; (8008624 <APP_ZIGBEE_ConfigEndpoints+0x8c>)
 8008602:	f00f fc9d 	bl	8017f40 <__assert_func>
  ZbZclClusterEndpointRegister(zigbee_app_info.temperature_meas_client_1);
 8008606:	4b04      	ldr	r3, [pc, #16]	; (8008618 <APP_ZIGBEE_ConfigEndpoints+0x80>)
 8008608:	695b      	ldr	r3, [r3, #20]
 800860a:	4618      	mov	r0, r3
 800860c:	f00d fce9 	bl	8015fe2 <ZbZclClusterEndpointRegister>

  /* USER CODE BEGIN CONFIG_ENDPOINT */
  /* USER CODE END CONFIG_ENDPOINT */
}
 8008610:	bf00      	nop
 8008612:	3720      	adds	r7, #32
 8008614:	46bd      	mov	sp, r7
 8008616:	bd80      	pop	{r7, pc}
 8008618:	20000d88 	.word	0x20000d88
 800861c:	08019550 	.word	0x08019550
 8008620:	080199e4 	.word	0x080199e4
 8008624:	080194a8 	.word	0x080194a8
 8008628:	08019574 	.word	0x08019574

0800862c <APP_ZIGBEE_NwkForm>:
 * @brief  Handle Zigbee network forming and joining
 * @param  None
 * @retval None
 */
static void APP_ZIGBEE_NwkForm(void)
{
 800862c:	b590      	push	{r4, r7, lr}
 800862e:	b0f9      	sub	sp, #484	; 0x1e4
 8008630:	af00      	add	r7, sp, #0
  if ((zigbee_app_info.join_status != ZB_STATUS_SUCCESS) && (HAL_GetTick() >= zigbee_app_info.join_delay))
 8008632:	4b4b      	ldr	r3, [pc, #300]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 8008634:	7a5b      	ldrb	r3, [r3, #9]
 8008636:	2b00      	cmp	r3, #0
 8008638:	f000 8085 	beq.w	8008746 <APP_ZIGBEE_NwkForm+0x11a>
 800863c:	f000 ff96 	bl	800956c <HAL_GetTick>
 8008640:	4602      	mov	r2, r0
 8008642:	4b47      	ldr	r3, [pc, #284]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 8008644:	68db      	ldr	r3, [r3, #12]
 8008646:	429a      	cmp	r2, r3
 8008648:	d37d      	bcc.n	8008746 <APP_ZIGBEE_NwkForm+0x11a>
  {
    struct ZbStartupT config;
    enum ZbStatusCodeT status;

    /* Configure Zigbee Logging */
    ZbSetLogging(zigbee_app_info.zb, ZB_LOG_MASK_LEVEL_5, NULL);
 800864a:	4b45      	ldr	r3, [pc, #276]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 800864c:	685b      	ldr	r3, [r3, #4]
 800864e:	2200      	movs	r2, #0
 8008650:	211f      	movs	r1, #31
 8008652:	4618      	mov	r0, r3
 8008654:	f00c fe7a 	bl	801534c <ZbSetLogging>

    /* Attempt to join a zigbee network */
    ZbStartupConfigGetProDefaults(&config);
 8008658:	463b      	mov	r3, r7
 800865a:	4618      	mov	r0, r3
 800865c:	f00c ff14 	bl	8015488 <ZbStartupConfigGetProDefaults>

    /* Set the centralized network */
    APP_DBG("Network config : APP_STARTUP_CENTRALIZED_ROUTER");
 8008660:	4a40      	ldr	r2, [pc, #256]	; (8008764 <APP_ZIGBEE_NwkForm+0x138>)
 8008662:	2101      	movs	r1, #1
 8008664:	2000      	movs	r0, #0
 8008666:	f7ff fd55 	bl	8008114 <logApplication>
    zigbee_app_info.startupControl = ZbStartTypeJoin;
 800866a:	4b3d      	ldr	r3, [pc, #244]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 800866c:	2203      	movs	r2, #3
 800866e:	721a      	strb	r2, [r3, #8]
    //APP_DBG("Network config : APP_STARTUP_CENTRALIZED_COORDINATOR");
    config.startupControl = zigbee_app_info.startupControl;
 8008670:	4b3b      	ldr	r3, [pc, #236]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 8008672:	7a1a      	ldrb	r2, [r3, #8]
 8008674:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
 8008678:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 800867c:	f883 206e 	strb.w	r2, [r3, #110]	; 0x6e

    /* Using the default HA preconfigured Link Key */
    memcpy(config.security.preconfiguredLinkKey, sec_key_ha, ZB_SEC_KEYSIZE);
 8008680:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
 8008684:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 8008688:	4a37      	ldr	r2, [pc, #220]	; (8008768 <APP_ZIGBEE_NwkForm+0x13c>)
 800868a:	f103 0480 	add.w	r4, r3, #128	; 0x80
 800868e:	4613      	mov	r3, r2
 8008690:	6818      	ldr	r0, [r3, #0]
 8008692:	6859      	ldr	r1, [r3, #4]
 8008694:	689a      	ldr	r2, [r3, #8]
 8008696:	68db      	ldr	r3, [r3, #12]
 8008698:	c40f      	stmia	r4!, {r0, r1, r2, r3}

    config.channelList.count = 1;
 800869a:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
 800869e:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 80086a2:	2201      	movs	r2, #1
 80086a4:	741a      	strb	r2, [r3, #16]
    config.channelList.list[0].page = 0;
 80086a6:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
 80086aa:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 80086ae:	2200      	movs	r2, #0
 80086b0:	751a      	strb	r2, [r3, #20]
    config.channelList.list[0].channelMask = 1 << CHANNEL; /*Channel in use */
 80086b2:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
 80086b6:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 80086ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80086be:	619a      	str	r2, [r3, #24]

    /* Using ZbStartupWait (blocking) */
    status = ZbStartupWait(zigbee_app_info.zb, &config);
 80086c0:	4b27      	ldr	r3, [pc, #156]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 80086c2:	685b      	ldr	r3, [r3, #4]
 80086c4:	463a      	mov	r2, r7
 80086c6:	4611      	mov	r1, r2
 80086c8:	4618      	mov	r0, r3
 80086ca:	f000 f86d 	bl	80087a8 <ZbStartupWait>
 80086ce:	4603      	mov	r3, r0
 80086d0:	f887 31df 	strb.w	r3, [r7, #479]	; 0x1df

    APP_DBG("ZbStartup Callback (status = 0x%02x)", status);
 80086d4:	f897 31df 	ldrb.w	r3, [r7, #479]	; 0x1df
 80086d8:	4a24      	ldr	r2, [pc, #144]	; (800876c <APP_ZIGBEE_NwkForm+0x140>)
 80086da:	2101      	movs	r1, #1
 80086dc:	2000      	movs	r0, #0
 80086de:	f7ff fd19 	bl	8008114 <logApplication>
    zigbee_app_info.join_status = status;
 80086e2:	4a1f      	ldr	r2, [pc, #124]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 80086e4:	f897 31df 	ldrb.w	r3, [r7, #479]	; 0x1df
 80086e8:	7253      	strb	r3, [r2, #9]

    if (status == ZB_STATUS_SUCCESS)
 80086ea:	f897 31df 	ldrb.w	r3, [r7, #479]	; 0x1df
 80086ee:	2b00      	cmp	r3, #0
 80086f0:	d118      	bne.n	8008724 <APP_ZIGBEE_NwkForm+0xf8>
    {
      zigbee_app_info.join_delay = 0U;
 80086f2:	4b1b      	ldr	r3, [pc, #108]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 80086f4:	2200      	movs	r2, #0
 80086f6:	60da      	str	r2, [r3, #12]
      zigbee_app_info.init_after_join = true;
 80086f8:	4b19      	ldr	r3, [pc, #100]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 80086fa:	2201      	movs	r2, #1
 80086fc:	741a      	strb	r2, [r3, #16]
      APP_DBG("Startup done !\n");
 80086fe:	4a1c      	ldr	r2, [pc, #112]	; (8008770 <APP_ZIGBEE_NwkForm+0x144>)
 8008700:	2101      	movs	r1, #1
 8008702:	2000      	movs	r0, #0
 8008704:	f7ff fd06 	bl	8008114 <logApplication>
      /* USER CODE BEGIN 0 */
      BSP_LED_On(LED_BLUE);
 8008708:	2000      	movs	r0, #0
 800870a:	f000 fdbd 	bl	8009288 <BSP_LED_On>
      BSP_LED_Off(LED_RED);
 800870e:	2002      	movs	r0, #2
 8008710:	f000 fdd4 	bl	80092bc <BSP_LED_Off>
      ready_to_send = 1;
 8008714:	4b17      	ldr	r3, [pc, #92]	; (8008774 <APP_ZIGBEE_NwkForm+0x148>)
 8008716:	2201      	movs	r2, #1
 8008718:	701a      	strb	r2, [r3, #0]
      UTIL_SEQ_SetTask(1U << CFG_TASK_READ_TEMP,CFG_SCH_PRIO_1);
 800871a:	2101      	movs	r1, #1
 800871c:	2010      	movs	r0, #16
 800871e:	f00f fb53 	bl	8017dc8 <UTIL_SEQ_SetTask>
 8008722:	e010      	b.n	8008746 <APP_ZIGBEE_NwkForm+0x11a>
      /* USER CODE END 0 */
    }
    else
    {
      APP_DBG("Startup failed, attempting again after a short delay (%d ms)", APP_ZIGBEE_STARTUP_FAIL_DELAY);
 8008724:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8008728:	4a13      	ldr	r2, [pc, #76]	; (8008778 <APP_ZIGBEE_NwkForm+0x14c>)
 800872a:	2101      	movs	r1, #1
 800872c:	2000      	movs	r0, #0
 800872e:	f7ff fcf1 	bl	8008114 <logApplication>
      zigbee_app_info.join_delay = HAL_GetTick() + APP_ZIGBEE_STARTUP_FAIL_DELAY;
 8008732:	f000 ff1b 	bl	800956c <HAL_GetTick>
 8008736:	4603      	mov	r3, r0
 8008738:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800873c:	4a08      	ldr	r2, [pc, #32]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 800873e:	60d3      	str	r3, [r2, #12]
      /* USER CODE BEGIN 1 */
      BSP_LED_On(LED_RED);
 8008740:	2002      	movs	r0, #2
 8008742:	f000 fda1 	bl	8009288 <BSP_LED_On>
      /* USER CODE END 1 */
    }
  }

  /* If Network forming/joining was not successful reschedule the current task to retry the process */
  if (zigbee_app_info.join_status != ZB_STATUS_SUCCESS)
 8008746:	4b06      	ldr	r3, [pc, #24]	; (8008760 <APP_ZIGBEE_NwkForm+0x134>)
 8008748:	7a5b      	ldrb	r3, [r3, #9]
 800874a:	2b00      	cmp	r3, #0
 800874c:	d003      	beq.n	8008756 <APP_ZIGBEE_NwkForm+0x12a>
  {
    UTIL_SEQ_SetTask(1U << CFG_TASK_ZIGBEE_NETWORK_FORM, CFG_SCH_PRIO_0);
 800874e:	2100      	movs	r1, #0
 8008750:	2008      	movs	r0, #8
 8008752:	f00f fb39 	bl	8017dc8 <UTIL_SEQ_SetTask>
  }
  /* USER CODE BEGIN NW_FORM */
  /* USER CODE END NW_FORM */
}
 8008756:	bf00      	nop
 8008758:	f507 77f2 	add.w	r7, r7, #484	; 0x1e4
 800875c:	46bd      	mov	sp, r7
 800875e:	bd90      	pop	{r4, r7, pc}
 8008760:	20000d88 	.word	0x20000d88
 8008764:	080195a8 	.word	0x080195a8
 8008768:	08019aa0 	.word	0x08019aa0
 800876c:	080195d8 	.word	0x080195d8
 8008770:	08019600 	.word	0x08019600
 8008774:	20000da4 	.word	0x20000da4
 8008778:	08019610 	.word	0x08019610

0800877c <ZbStartupWaitCb>:
  bool active;
  enum ZbStatusCodeT status;
};

static void ZbStartupWaitCb(enum ZbStatusCodeT status, void *cb_arg)
{
 800877c:	b580      	push	{r7, lr}
 800877e:	b084      	sub	sp, #16
 8008780:	af00      	add	r7, sp, #0
 8008782:	4603      	mov	r3, r0
 8008784:	6039      	str	r1, [r7, #0]
 8008786:	71fb      	strb	r3, [r7, #7]
  struct ZbStartupWaitInfo *info = cb_arg;
 8008788:	683b      	ldr	r3, [r7, #0]
 800878a:	60fb      	str	r3, [r7, #12]

  info->status = status;
 800878c:	68fb      	ldr	r3, [r7, #12]
 800878e:	79fa      	ldrb	r2, [r7, #7]
 8008790:	705a      	strb	r2, [r3, #1]
  info->active = false;
 8008792:	68fb      	ldr	r3, [r7, #12]
 8008794:	2200      	movs	r2, #0
 8008796:	701a      	strb	r2, [r3, #0]
  UTIL_SEQ_SetEvt(EVENT_ZIGBEE_STARTUP_ENDED);
 8008798:	2008      	movs	r0, #8
 800879a:	f00f fb41 	bl	8017e20 <UTIL_SEQ_SetEvt>
}
 800879e:	bf00      	nop
 80087a0:	3710      	adds	r7, #16
 80087a2:	46bd      	mov	sp, r7
 80087a4:	bd80      	pop	{r7, pc}
	...

080087a8 <ZbStartupWait>:

enum ZbStatusCodeT ZbStartupWait(struct ZigBeeT *zb, struct ZbStartupT *config)
{
 80087a8:	b580      	push	{r7, lr}
 80087aa:	b084      	sub	sp, #16
 80087ac:	af00      	add	r7, sp, #0
 80087ae:	6078      	str	r0, [r7, #4]
 80087b0:	6039      	str	r1, [r7, #0]
  struct ZbStartupWaitInfo *info;
  enum ZbStatusCodeT status;

  info = malloc(sizeof(struct ZbStartupWaitInfo));
 80087b2:	2002      	movs	r0, #2
 80087b4:	f00f fbe2 	bl	8017f7c <malloc>
 80087b8:	4603      	mov	r3, r0
 80087ba:	60fb      	str	r3, [r7, #12]
  if (info == NULL)
 80087bc:	68fb      	ldr	r3, [r7, #12]
 80087be:	2b00      	cmp	r3, #0
 80087c0:	d101      	bne.n	80087c6 <ZbStartupWait+0x1e>
  {
    return ZB_STATUS_ALLOC_FAIL;
 80087c2:	2370      	movs	r3, #112	; 0x70
 80087c4:	e021      	b.n	800880a <ZbStartupWait+0x62>
  }
  memset(info, 0, sizeof(struct ZbStartupWaitInfo));
 80087c6:	2202      	movs	r2, #2
 80087c8:	2100      	movs	r1, #0
 80087ca:	68f8      	ldr	r0, [r7, #12]
 80087cc:	f00f fe48 	bl	8018460 <memset>

  info->active = true;
 80087d0:	68fb      	ldr	r3, [r7, #12]
 80087d2:	2201      	movs	r2, #1
 80087d4:	701a      	strb	r2, [r3, #0]
  status = ZbStartup(zb, config, ZbStartupWaitCb, info);
 80087d6:	68fb      	ldr	r3, [r7, #12]
 80087d8:	4a0e      	ldr	r2, [pc, #56]	; (8008814 <ZbStartupWait+0x6c>)
 80087da:	6839      	ldr	r1, [r7, #0]
 80087dc:	6878      	ldr	r0, [r7, #4]
 80087de:	f00c fe7d 	bl	80154dc <ZbStartup>
 80087e2:	4603      	mov	r3, r0
 80087e4:	72fb      	strb	r3, [r7, #11]
  if (status != ZB_STATUS_SUCCESS)
 80087e6:	7afb      	ldrb	r3, [r7, #11]
 80087e8:	2b00      	cmp	r3, #0
 80087ea:	d004      	beq.n	80087f6 <ZbStartupWait+0x4e>
  {
    free(info);
 80087ec:	68f8      	ldr	r0, [r7, #12]
 80087ee:	f00f fbcd 	bl	8017f8c <free>
    return status;
 80087f2:	7afb      	ldrb	r3, [r7, #11]
 80087f4:	e009      	b.n	800880a <ZbStartupWait+0x62>
  }

  UTIL_SEQ_WaitEvt(EVENT_ZIGBEE_STARTUP_ENDED);
 80087f6:	2008      	movs	r0, #8
 80087f8:	f00f fb32 	bl	8017e60 <UTIL_SEQ_WaitEvt>
  status = info->status;
 80087fc:	68fb      	ldr	r3, [r7, #12]
 80087fe:	785b      	ldrb	r3, [r3, #1]
 8008800:	72fb      	strb	r3, [r7, #11]
  free(info);
 8008802:	68f8      	ldr	r0, [r7, #12]
 8008804:	f00f fbc2 	bl	8017f8c <free>
  return status;
 8008808:	7afb      	ldrb	r3, [r7, #11]
}
 800880a:	4618      	mov	r0, r3
 800880c:	3710      	adds	r7, #16
 800880e:	46bd      	mov	sp, r7
 8008810:	bd80      	pop	{r7, pc}
 8008812:	bf00      	nop
 8008814:	0800877d 	.word	0x0800877d

08008818 <APP_ZIGBEE_Error>:
 * @param  ErrId :
 * @param  ErrCode
 * @retval None
 */
void APP_ZIGBEE_Error(uint32_t ErrId, uint32_t ErrCode)
{
 8008818:	b580      	push	{r7, lr}
 800881a:	b082      	sub	sp, #8
 800881c:	af00      	add	r7, sp, #0
 800881e:	6078      	str	r0, [r7, #4]
 8008820:	6039      	str	r1, [r7, #0]
  switch (ErrId)
  {
    default:
      APP_ZIGBEE_TraceError("ERROR Unknown ", 0);
 8008822:	2100      	movs	r1, #0
 8008824:	4803      	ldr	r0, [pc, #12]	; (8008834 <APP_ZIGBEE_Error+0x1c>)
 8008826:	f000 f807 	bl	8008838 <APP_ZIGBEE_TraceError>
      break;
 800882a:	bf00      	nop
  }
}
 800882c:	bf00      	nop
 800882e:	3708      	adds	r7, #8
 8008830:	46bd      	mov	sp, r7
 8008832:	bd80      	pop	{r7, pc}
 8008834:	08019650 	.word	0x08019650

08008838 <APP_ZIGBEE_TraceError>:
 * @param  pMess  : Message associated to the error.
 * @param  ErrCode: Error code associated to the module (Zigbee or other module if any)
 * @retval None
 */
static void APP_ZIGBEE_TraceError(const char *pMess, uint32_t ErrCode)
{
 8008838:	b580      	push	{r7, lr}
 800883a:	b084      	sub	sp, #16
 800883c:	af02      	add	r7, sp, #8
 800883e:	6078      	str	r0, [r7, #4]
 8008840:	6039      	str	r1, [r7, #0]
  APP_DBG("**** Fatal error = %s (Err = %d)", pMess, ErrCode);
 8008842:	683b      	ldr	r3, [r7, #0]
 8008844:	9300      	str	r3, [sp, #0]
 8008846:	687b      	ldr	r3, [r7, #4]
 8008848:	4a04      	ldr	r2, [pc, #16]	; (800885c <APP_ZIGBEE_TraceError+0x24>)
 800884a:	2101      	movs	r1, #1
 800884c:	2000      	movs	r0, #0
 800884e:	f7ff fc61 	bl	8008114 <logApplication>
  /* USER CODE BEGIN TRACE_ERROR */
  /* USER CODE END TRACE_ERROR */

}
 8008852:	bf00      	nop
 8008854:	3708      	adds	r7, #8
 8008856:	46bd      	mov	sp, r7
 8008858:	bd80      	pop	{r7, pc}
 800885a:	bf00      	nop
 800885c:	08019660 	.word	0x08019660

08008860 <APP_ZIGBEE_CheckWirelessFirmwareInfo>:
 *        and display associated information
 * @param  None
 * @retval None
 */
static void APP_ZIGBEE_CheckWirelessFirmwareInfo(void)
{
 8008860:	b580      	push	{r7, lr}
 8008862:	b098      	sub	sp, #96	; 0x60
 8008864:	af02      	add	r7, sp, #8
  WirelessFwInfo_t wireless_info_instance;
  WirelessFwInfo_t *p_wireless_info = &wireless_info_instance;
 8008866:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800886a:	657b      	str	r3, [r7, #84]	; 0x54

  if (SHCI_GetWirelessFwInfo(p_wireless_info) != SHCI_Success)
 800886c:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800886e:	f00a fe63 	bl	8013538 <SHCI_GetWirelessFwInfo>
 8008872:	4603      	mov	r3, r0
 8008874:	2b00      	cmp	r3, #0
 8008876:	d004      	beq.n	8008882 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x22>
  {
    APP_ZIGBEE_Error((uint32_t)ERR_ZIGBEE_CHECK_WIRELESS, (uint32_t)ERR_INTERFACE_FATAL);
 8008878:	2101      	movs	r1, #1
 800887a:	2001      	movs	r0, #1
 800887c:	f7ff ffcc 	bl	8008818 <APP_ZIGBEE_Error>
    /* print clusters allocated */
    APP_DBG("Clusters allocated are:");
    APP_DBG("temperature_meas Client on Endpoint %d", SW1_ENDPOINT);
    APP_DBG("**********************************************************");
  }
}
 8008880:	e083      	b.n	800898a <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x12a>
    APP_DBG("**********************************************************");
 8008882:	4a44      	ldr	r2, [pc, #272]	; (8008994 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x134>)
 8008884:	2101      	movs	r1, #1
 8008886:	2000      	movs	r0, #0
 8008888:	f7ff fc44 	bl	8008114 <logApplication>
    APP_DBG("WIRELESS COPROCESSOR FW:");
 800888c:	4a42      	ldr	r2, [pc, #264]	; (8008998 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x138>)
 800888e:	2101      	movs	r1, #1
 8008890:	2000      	movs	r0, #0
 8008892:	f7ff fc3f 	bl	8008114 <logApplication>
    APP_DBG("VERSION ID = %d.%d.%d", p_wireless_info->VersionMajor, p_wireless_info->VersionMinor, p_wireless_info->VersionSub);
 8008896:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008898:	781b      	ldrb	r3, [r3, #0]
 800889a:	4619      	mov	r1, r3
 800889c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800889e:	785b      	ldrb	r3, [r3, #1]
 80088a0:	461a      	mov	r2, r3
 80088a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80088a4:	789b      	ldrb	r3, [r3, #2]
 80088a6:	9301      	str	r3, [sp, #4]
 80088a8:	9200      	str	r2, [sp, #0]
 80088aa:	460b      	mov	r3, r1
 80088ac:	4a3b      	ldr	r2, [pc, #236]	; (800899c <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x13c>)
 80088ae:	2101      	movs	r1, #1
 80088b0:	2000      	movs	r0, #0
 80088b2:	f7ff fc2f 	bl	8008114 <logApplication>
    switch (p_wireless_info->StackType)
 80088b6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80088b8:	7a5b      	ldrb	r3, [r3, #9]
 80088ba:	2b30      	cmp	r3, #48	; 0x30
 80088bc:	d002      	beq.n	80088c4 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x64>
 80088be:	2b31      	cmp	r3, #49	; 0x31
 80088c0:	d006      	beq.n	80088d0 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x70>
 80088c2:	e00b      	b.n	80088dc <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x7c>
        APP_DBG("FW Type : FFD Zigbee stack");
 80088c4:	4a36      	ldr	r2, [pc, #216]	; (80089a0 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x140>)
 80088c6:	2101      	movs	r1, #1
 80088c8:	2000      	movs	r0, #0
 80088ca:	f7ff fc23 	bl	8008114 <logApplication>
        break;
 80088ce:	e00a      	b.n	80088e6 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x86>
        APP_DBG("FW Type : RFD Zigbee stack");
 80088d0:	4a34      	ldr	r2, [pc, #208]	; (80089a4 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x144>)
 80088d2:	2101      	movs	r1, #1
 80088d4:	2000      	movs	r0, #0
 80088d6:	f7ff fc1d 	bl	8008114 <logApplication>
        break;
 80088da:	e004      	b.n	80088e6 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x86>
        APP_ZIGBEE_Error((uint32_t)ERR_ZIGBEE_CHECK_WIRELESS, (uint32_t)ERR_INTERFACE_FATAL);
 80088dc:	2101      	movs	r1, #1
 80088de:	2001      	movs	r0, #1
 80088e0:	f7ff ff9a 	bl	8008818 <APP_ZIGBEE_Error>
        break;
 80088e4:	bf00      	nop
    char *__PathProject__ = (strstr(__FILE__, "Zigbee") ? strstr(__FILE__, "Zigbee") + 7 : __FILE__);
 80088e6:	4b30      	ldr	r3, [pc, #192]	; (80089a8 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x148>)
 80088e8:	64fb      	str	r3, [r7, #76]	; 0x4c
    char *pdel = NULL;
 80088ea:	2300      	movs	r3, #0
 80088ec:	64bb      	str	r3, [r7, #72]	; 0x48
      pdel = strchr(__PathProject__, '/');
 80088ee:	212f      	movs	r1, #47	; 0x2f
 80088f0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80088f2:	f00f fdbd 	bl	8018470 <strchr>
 80088f6:	64b8      	str	r0, [r7, #72]	; 0x48
    int index = (int)(pdel - __PathProject__);
 80088f8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80088fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80088fc:	1ad3      	subs	r3, r2, r3
 80088fe:	647b      	str	r3, [r7, #68]	; 0x44
    APP_DBG("Application flashed: %*.*s", index, index, __PathProject__);
 8008900:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008902:	9301      	str	r3, [sp, #4]
 8008904:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008906:	9300      	str	r3, [sp, #0]
 8008908:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800890a:	4a28      	ldr	r2, [pc, #160]	; (80089ac <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x14c>)
 800890c:	2101      	movs	r1, #1
 800890e:	2000      	movs	r0, #0
 8008910:	f7ff fc00 	bl	8008114 <logApplication>
    APP_DBG("Channel used: %d", CHANNEL);
 8008914:	230b      	movs	r3, #11
 8008916:	4a26      	ldr	r2, [pc, #152]	; (80089b0 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x150>)
 8008918:	2101      	movs	r1, #1
 800891a:	2000      	movs	r0, #0
 800891c:	f7ff fbfa 	bl	8008114 <logApplication>
    APP_DBG("Link Key: %.16s", sec_key_ha);
 8008920:	4b24      	ldr	r3, [pc, #144]	; (80089b4 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x154>)
 8008922:	4a25      	ldr	r2, [pc, #148]	; (80089b8 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x158>)
 8008924:	2101      	movs	r1, #1
 8008926:	2000      	movs	r0, #0
 8008928:	f7ff fbf4 	bl	8008114 <logApplication>
    Z09_LL_string[0] = 0;
 800892c:	2300      	movs	r3, #0
 800892e:	703b      	strb	r3, [r7, #0]
    for (int str_index = 0; str_index < ZB_SEC_KEYSIZE; str_index++)
 8008930:	2300      	movs	r3, #0
 8008932:	653b      	str	r3, [r7, #80]	; 0x50
 8008934:	e010      	b.n	8008958 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0xf8>
      sprintf(&Z09_LL_string[str_index*3], "%02x ", sec_key_ha[str_index]);
 8008936:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8008938:	4613      	mov	r3, r2
 800893a:	005b      	lsls	r3, r3, #1
 800893c:	4413      	add	r3, r2
 800893e:	463a      	mov	r2, r7
 8008940:	18d0      	adds	r0, r2, r3
 8008942:	4a1c      	ldr	r2, [pc, #112]	; (80089b4 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x154>)
 8008944:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008946:	4413      	add	r3, r2
 8008948:	781b      	ldrb	r3, [r3, #0]
 800894a:	461a      	mov	r2, r3
 800894c:	491b      	ldr	r1, [pc, #108]	; (80089bc <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x15c>)
 800894e:	f00f fceb 	bl	8018328 <siprintf>
    for (int str_index = 0; str_index < ZB_SEC_KEYSIZE; str_index++)
 8008952:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008954:	3301      	adds	r3, #1
 8008956:	653b      	str	r3, [r7, #80]	; 0x50
 8008958:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800895a:	2b0f      	cmp	r3, #15
 800895c:	d9eb      	bls.n	8008936 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0xd6>
    APP_DBG("Link Key value: %s", Z09_LL_string);
 800895e:	463b      	mov	r3, r7
 8008960:	4a17      	ldr	r2, [pc, #92]	; (80089c0 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x160>)
 8008962:	2101      	movs	r1, #1
 8008964:	2000      	movs	r0, #0
 8008966:	f7ff fbd5 	bl	8008114 <logApplication>
    APP_DBG("Clusters allocated are:");
 800896a:	4a16      	ldr	r2, [pc, #88]	; (80089c4 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x164>)
 800896c:	2101      	movs	r1, #1
 800896e:	2000      	movs	r0, #0
 8008970:	f7ff fbd0 	bl	8008114 <logApplication>
    APP_DBG("temperature_meas Client on Endpoint %d", SW1_ENDPOINT);
 8008974:	2301      	movs	r3, #1
 8008976:	4a14      	ldr	r2, [pc, #80]	; (80089c8 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x168>)
 8008978:	2101      	movs	r1, #1
 800897a:	2000      	movs	r0, #0
 800897c:	f7ff fbca 	bl	8008114 <logApplication>
    APP_DBG("**********************************************************");
 8008980:	4a04      	ldr	r2, [pc, #16]	; (8008994 <APP_ZIGBEE_CheckWirelessFirmwareInfo+0x134>)
 8008982:	2101      	movs	r1, #1
 8008984:	2000      	movs	r0, #0
 8008986:	f7ff fbc5 	bl	8008114 <logApplication>
}
 800898a:	bf00      	nop
 800898c:	3758      	adds	r7, #88	; 0x58
 800898e:	46bd      	mov	sp, r7
 8008990:	bd80      	pop	{r7, pc}
 8008992:	bf00      	nop
 8008994:	08019684 	.word	0x08019684
 8008998:	080196c0 	.word	0x080196c0
 800899c:	080196dc 	.word	0x080196dc
 80089a0:	080196f4 	.word	0x080196f4
 80089a4:	08019710 	.word	0x08019710
 80089a8:	08019518 	.word	0x08019518
 80089ac:	0801972c 	.word	0x0801972c
 80089b0:	08019748 	.word	0x08019748
 80089b4:	08019aa0 	.word	0x08019aa0
 80089b8:	0801975c 	.word	0x0801975c
 80089bc:	0801976c 	.word	0x0801976c
 80089c0:	08019774 	.word	0x08019774
 80089c4:	08019788 	.word	0x08019788
 80089c8:	080197a0 	.word	0x080197a0

080089cc <APP_ZIGBEE_RegisterCmdBuffer>:
 * WRAP FUNCTIONS
 *
 *************************************************************/

void APP_ZIGBEE_RegisterCmdBuffer(TL_CmdPacket_t *p_buffer)
{
 80089cc:	b480      	push	{r7}
 80089ce:	b083      	sub	sp, #12
 80089d0:	af00      	add	r7, sp, #0
 80089d2:	6078      	str	r0, [r7, #4]
  p_ZIGBEE_otcmdbuffer = p_buffer;
 80089d4:	4a04      	ldr	r2, [pc, #16]	; (80089e8 <APP_ZIGBEE_RegisterCmdBuffer+0x1c>)
 80089d6:	687b      	ldr	r3, [r7, #4]
 80089d8:	6013      	str	r3, [r2, #0]
}
 80089da:	bf00      	nop
 80089dc:	370c      	adds	r7, #12
 80089de:	46bd      	mov	sp, r7
 80089e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089e4:	4770      	bx	lr
 80089e6:	bf00      	nop
 80089e8:	20000d74 	.word	0x20000d74

080089ec <ZIGBEE_Get_OTCmdPayloadBuffer>:

Zigbee_Cmd_Request_t * ZIGBEE_Get_OTCmdPayloadBuffer(void)
{
 80089ec:	b480      	push	{r7}
 80089ee:	af00      	add	r7, sp, #0
  return (Zigbee_Cmd_Request_t *)p_ZIGBEE_otcmdbuffer->cmdserial.cmd.payload;
 80089f0:	4b03      	ldr	r3, [pc, #12]	; (8008a00 <ZIGBEE_Get_OTCmdPayloadBuffer+0x14>)
 80089f2:	681b      	ldr	r3, [r3, #0]
 80089f4:	330c      	adds	r3, #12
}
 80089f6:	4618      	mov	r0, r3
 80089f8:	46bd      	mov	sp, r7
 80089fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089fe:	4770      	bx	lr
 8008a00:	20000d74 	.word	0x20000d74

08008a04 <ZIGBEE_Get_OTCmdRspPayloadBuffer>:

Zigbee_Cmd_Request_t * ZIGBEE_Get_OTCmdRspPayloadBuffer(void)
{
 8008a04:	b480      	push	{r7}
 8008a06:	af00      	add	r7, sp, #0
  return (Zigbee_Cmd_Request_t *)((TL_EvtPacket_t *)p_ZIGBEE_otcmdbuffer)->evtserial.evt.payload;
 8008a08:	4b03      	ldr	r3, [pc, #12]	; (8008a18 <ZIGBEE_Get_OTCmdRspPayloadBuffer+0x14>)
 8008a0a:	681b      	ldr	r3, [r3, #0]
 8008a0c:	330b      	adds	r3, #11
}
 8008a0e:	4618      	mov	r0, r3
 8008a10:	46bd      	mov	sp, r7
 8008a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a16:	4770      	bx	lr
 8008a18:	20000d74 	.word	0x20000d74

08008a1c <ZIGBEE_Get_NotificationPayloadBuffer>:

Zigbee_Cmd_Request_t * ZIGBEE_Get_NotificationPayloadBuffer(void)
{
 8008a1c:	b480      	push	{r7}
 8008a1e:	af00      	add	r7, sp, #0
  return (Zigbee_Cmd_Request_t *)(p_ZIGBEE_notif_M0_to_M4)->evtserial.evt.payload;
 8008a20:	4b03      	ldr	r3, [pc, #12]	; (8008a30 <ZIGBEE_Get_NotificationPayloadBuffer+0x14>)
 8008a22:	681b      	ldr	r3, [r3, #0]
 8008a24:	330b      	adds	r3, #11
}
 8008a26:	4618      	mov	r0, r3
 8008a28:	46bd      	mov	sp, r7
 8008a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a2e:	4770      	bx	lr
 8008a30:	20000d78 	.word	0x20000d78

08008a34 <ZIGBEE_Get_M0RequestPayloadBuffer>:

Zigbee_Cmd_Request_t * ZIGBEE_Get_M0RequestPayloadBuffer(void)
{
 8008a34:	b480      	push	{r7}
 8008a36:	af00      	add	r7, sp, #0
  return (Zigbee_Cmd_Request_t *)(p_ZIGBEE_request_M0_to_M4)->evtserial.evt.payload;
 8008a38:	4b03      	ldr	r3, [pc, #12]	; (8008a48 <ZIGBEE_Get_M0RequestPayloadBuffer+0x14>)
 8008a3a:	681b      	ldr	r3, [r3, #0]
 8008a3c:	330b      	adds	r3, #11
}
 8008a3e:	4618      	mov	r0, r3
 8008a40:	46bd      	mov	sp, r7
 8008a42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a46:	4770      	bx	lr
 8008a48:	20000d7c 	.word	0x20000d7c

08008a4c <ZIGBEE_CmdTransfer>:
 *
 * @param   None
 * @return  None
 */
void ZIGBEE_CmdTransfer(void)
{
 8008a4c:	b580      	push	{r7, lr}
 8008a4e:	b082      	sub	sp, #8
 8008a50:	af00      	add	r7, sp, #0
  Zigbee_Cmd_Request_t *cmd_req = (Zigbee_Cmd_Request_t *)p_ZIGBEE_otcmdbuffer->cmdserial.cmd.payload;
 8008a52:	4b0f      	ldr	r3, [pc, #60]	; (8008a90 <ZIGBEE_CmdTransfer+0x44>)
 8008a54:	681b      	ldr	r3, [r3, #0]
 8008a56:	330c      	adds	r3, #12
 8008a58:	607b      	str	r3, [r7, #4]

  /* Zigbee OT command cmdcode range 0x280 .. 0x3DF = 352 */
  p_ZIGBEE_otcmdbuffer->cmdserial.cmd.cmdcode = 0x280U;
 8008a5a:	4b0d      	ldr	r3, [pc, #52]	; (8008a90 <ZIGBEE_CmdTransfer+0x44>)
 8008a5c:	681b      	ldr	r3, [r3, #0]
 8008a5e:	2200      	movs	r2, #0
 8008a60:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8008a64:	725a      	strb	r2, [r3, #9]
 8008a66:	2200      	movs	r2, #0
 8008a68:	f042 0202 	orr.w	r2, r2, #2
 8008a6c:	729a      	strb	r2, [r3, #10]
  /* Size = otCmdBuffer->Size (Number of OT cmd arguments : 1 arg = 32bits so multiply by 4 to get size in bytes)
   * + ID (4 bytes) + Size (4 bytes) */
  p_ZIGBEE_otcmdbuffer->cmdserial.cmd.plen = 8U + (cmd_req->Size * 4U);
 8008a6e:	687b      	ldr	r3, [r7, #4]
 8008a70:	685b      	ldr	r3, [r3, #4]
 8008a72:	3302      	adds	r3, #2
 8008a74:	b2da      	uxtb	r2, r3
 8008a76:	4b06      	ldr	r3, [pc, #24]	; (8008a90 <ZIGBEE_CmdTransfer+0x44>)
 8008a78:	681b      	ldr	r3, [r3, #0]
 8008a7a:	0092      	lsls	r2, r2, #2
 8008a7c:	b2d2      	uxtb	r2, r2
 8008a7e:	72da      	strb	r2, [r3, #11]

  TL_ZIGBEE_SendM4RequestToM0();
 8008a80:	f00b f854 	bl	8013b2c <TL_ZIGBEE_SendM4RequestToM0>

  /* Wait completion of cmd */
  Wait_Getting_Ack_From_M0();
 8008a84:	f000 f827 	bl	8008ad6 <Wait_Getting_Ack_From_M0>
}
 8008a88:	bf00      	nop
 8008a8a:	3708      	adds	r7, #8
 8008a8c:	46bd      	mov	sp, r7
 8008a8e:	bd80      	pop	{r7, pc}
 8008a90:	20000d74 	.word	0x20000d74

08008a94 <TL_ZIGBEE_CmdEvtReceived>:
 *
 * @param   Otbuffer : a pointer to TL_EvtPacket_t
 * @return  None
 */
void TL_ZIGBEE_CmdEvtReceived(TL_EvtPacket_t *Otbuffer)
{
 8008a94:	b580      	push	{r7, lr}
 8008a96:	b082      	sub	sp, #8
 8008a98:	af00      	add	r7, sp, #0
 8008a9a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Otbuffer);

  Receive_Ack_From_M0();
 8008a9c:	f000 f822 	bl	8008ae4 <Receive_Ack_From_M0>
}
 8008aa0:	bf00      	nop
 8008aa2:	3708      	adds	r7, #8
 8008aa4:	46bd      	mov	sp, r7
 8008aa6:	bd80      	pop	{r7, pc}

08008aa8 <TL_ZIGBEE_NotReceived>:
 *
 * @param   Notbuffer : a pointer to TL_EvtPacket_t
 * @return  None
 */
void TL_ZIGBEE_NotReceived(TL_EvtPacket_t *Notbuffer)
{
 8008aa8:	b580      	push	{r7, lr}
 8008aaa:	b082      	sub	sp, #8
 8008aac:	af00      	add	r7, sp, #0
 8008aae:	6078      	str	r0, [r7, #4]
  p_ZIGBEE_notif_M0_to_M4 = Notbuffer;
 8008ab0:	4a04      	ldr	r2, [pc, #16]	; (8008ac4 <TL_ZIGBEE_NotReceived+0x1c>)
 8008ab2:	687b      	ldr	r3, [r7, #4]
 8008ab4:	6013      	str	r3, [r2, #0]

  Receive_Notification_From_M0();
 8008ab6:	f000 f81d 	bl	8008af4 <Receive_Notification_From_M0>
}
 8008aba:	bf00      	nop
 8008abc:	3708      	adds	r7, #8
 8008abe:	46bd      	mov	sp, r7
 8008ac0:	bd80      	pop	{r7, pc}
 8008ac2:	bf00      	nop
 8008ac4:	20000d78 	.word	0x20000d78

08008ac8 <Pre_ZigbeeCmdProcessing>:
 *         pending before sending a new ot command.
 * @param  None
 * @retval None
 */
void Pre_ZigbeeCmdProcessing(void)
{
 8008ac8:	b580      	push	{r7, lr}
 8008aca:	af00      	add	r7, sp, #0
  UTIL_SEQ_WaitEvt(EVENT_SYNCHRO_BYPASS_IDLE);
 8008acc:	2004      	movs	r0, #4
 8008ace:	f00f f9c7 	bl	8017e60 <UTIL_SEQ_WaitEvt>
}
 8008ad2:	bf00      	nop
 8008ad4:	bd80      	pop	{r7, pc}

08008ad6 <Wait_Getting_Ack_From_M0>:
 *
 * @param  None
 * @retval None
 */
static void Wait_Getting_Ack_From_M0(void)
{
 8008ad6:	b580      	push	{r7, lr}
 8008ad8:	af00      	add	r7, sp, #0
  UTIL_SEQ_WaitEvt(EVENT_ACK_FROM_M0_EVT);
 8008ada:	2002      	movs	r0, #2
 8008adc:	f00f f9c0 	bl	8017e60 <UTIL_SEQ_WaitEvt>
}
 8008ae0:	bf00      	nop
 8008ae2:	bd80      	pop	{r7, pc}

08008ae4 <Receive_Ack_From_M0>:
 *         This function is called under interrupt.
 * @param  None
 * @retval None
 */
static void Receive_Ack_From_M0(void)
{
 8008ae4:	b580      	push	{r7, lr}
 8008ae6:	af00      	add	r7, sp, #0
  UTIL_SEQ_SetEvt(EVENT_ACK_FROM_M0_EVT);
 8008ae8:	2002      	movs	r0, #2
 8008aea:	f00f f999 	bl	8017e20 <UTIL_SEQ_SetEvt>
}
 8008aee:	bf00      	nop
 8008af0:	bd80      	pop	{r7, pc}
	...

08008af4 <Receive_Notification_From_M0>:
 *         This function is called under interrupt.
 * @param  None
 * @retval None
 */
static void Receive_Notification_From_M0(void)
{
 8008af4:	b580      	push	{r7, lr}
 8008af6:	af00      	add	r7, sp, #0
  CptReceiveNotifyFromM0++;
 8008af8:	4b05      	ldr	r3, [pc, #20]	; (8008b10 <Receive_Notification_From_M0+0x1c>)
 8008afa:	681b      	ldr	r3, [r3, #0]
 8008afc:	3301      	adds	r3, #1
 8008afe:	4a04      	ldr	r2, [pc, #16]	; (8008b10 <Receive_Notification_From_M0+0x1c>)
 8008b00:	6013      	str	r3, [r2, #0]
  UTIL_SEQ_SetTask(1U << (uint32_t)CFG_TASK_NOTIFY_FROM_M0_TO_M4, CFG_SCH_PRIO_0);
 8008b02:	2100      	movs	r1, #0
 8008b04:	2001      	movs	r0, #1
 8008b06:	f00f f95f 	bl	8017dc8 <UTIL_SEQ_SetTask>
}
 8008b0a:	bf00      	nop
 8008b0c:	bd80      	pop	{r7, pc}
 8008b0e:	bf00      	nop
 8008b10:	20000d80 	.word	0x20000d80

08008b14 <TL_ZIGBEE_M0RequestReceived>:
 *
 * @param   Notbuffer : a pointer to TL_EvtPacket_t
 * @return  None
 */
void TL_ZIGBEE_M0RequestReceived(TL_EvtPacket_t *Reqbuffer)
{
 8008b14:	b580      	push	{r7, lr}
 8008b16:	b082      	sub	sp, #8
 8008b18:	af00      	add	r7, sp, #0
 8008b1a:	6078      	str	r0, [r7, #4]
  p_ZIGBEE_request_M0_to_M4 = Reqbuffer;
 8008b1c:	4a07      	ldr	r2, [pc, #28]	; (8008b3c <TL_ZIGBEE_M0RequestReceived+0x28>)
 8008b1e:	687b      	ldr	r3, [r7, #4]
 8008b20:	6013      	str	r3, [r2, #0]

  CptReceiveRequestFromM0++;
 8008b22:	4b07      	ldr	r3, [pc, #28]	; (8008b40 <TL_ZIGBEE_M0RequestReceived+0x2c>)
 8008b24:	681b      	ldr	r3, [r3, #0]
 8008b26:	3301      	adds	r3, #1
 8008b28:	4a05      	ldr	r2, [pc, #20]	; (8008b40 <TL_ZIGBEE_M0RequestReceived+0x2c>)
 8008b2a:	6013      	str	r3, [r2, #0]
  UTIL_SEQ_SetTask(1U << (uint32_t)CFG_TASK_REQUEST_FROM_M0_TO_M4, CFG_SCH_PRIO_0);
 8008b2c:	2100      	movs	r1, #0
 8008b2e:	2002      	movs	r0, #2
 8008b30:	f00f f94a 	bl	8017dc8 <UTIL_SEQ_SetTask>
}
 8008b34:	bf00      	nop
 8008b36:	3708      	adds	r7, #8
 8008b38:	46bd      	mov	sp, r7
 8008b3a:	bd80      	pop	{r7, pc}
 8008b3c:	20000d7c 	.word	0x20000d7c
 8008b40:	20000d84 	.word	0x20000d84

08008b44 <APP_ZIGBEE_TL_INIT>:
 * @brief Perform initialization of TL for Zigbee.
 * @param  None
 * @retval None
 */
void APP_ZIGBEE_TL_INIT(void)
{
 8008b44:	b580      	push	{r7, lr}
 8008b46:	af00      	add	r7, sp, #0
  ZigbeeConfigBuffer.p_ZigbeeOtCmdRspBuffer = (uint8_t *)&ZigbeeOtCmdBuffer;
 8008b48:	4b06      	ldr	r3, [pc, #24]	; (8008b64 <APP_ZIGBEE_TL_INIT+0x20>)
 8008b4a:	4a07      	ldr	r2, [pc, #28]	; (8008b68 <APP_ZIGBEE_TL_INIT+0x24>)
 8008b4c:	601a      	str	r2, [r3, #0]
  ZigbeeConfigBuffer.p_ZigbeeNotAckBuffer = (uint8_t *)ZigbeeNotifRspEvtBuffer;
 8008b4e:	4b05      	ldr	r3, [pc, #20]	; (8008b64 <APP_ZIGBEE_TL_INIT+0x20>)
 8008b50:	4a06      	ldr	r2, [pc, #24]	; (8008b6c <APP_ZIGBEE_TL_INIT+0x28>)
 8008b52:	605a      	str	r2, [r3, #4]
  ZigbeeConfigBuffer.p_ZigbeeNotifRequestBuffer = (uint8_t *)ZigbeeNotifRequestBuffer;
 8008b54:	4b03      	ldr	r3, [pc, #12]	; (8008b64 <APP_ZIGBEE_TL_INIT+0x20>)
 8008b56:	4a06      	ldr	r2, [pc, #24]	; (8008b70 <APP_ZIGBEE_TL_INIT+0x2c>)
 8008b58:	609a      	str	r2, [r3, #8]
  TL_ZIGBEE_Init(&ZigbeeConfigBuffer);
 8008b5a:	4802      	ldr	r0, [pc, #8]	; (8008b64 <APP_ZIGBEE_TL_INIT+0x20>)
 8008b5c:	f00a ffca 	bl	8013af4 <TL_ZIGBEE_Init>
}
 8008b60:	bf00      	nop
 8008b62:	bd80      	pop	{r7, pc}
 8008b64:	20030028 	.word	0x20030028
 8008b68:	20030838 	.word	0x20030838
 8008b6c:	20030944 	.word	0x20030944
 8008b70:	20030a50 	.word	0x20030a50

08008b74 <APP_ZIGBEE_ProcessNotifyM0ToM4>:
 * @brief Process the messages coming from the M0.
 * @param  None
 * @retval None
 */
static void APP_ZIGBEE_ProcessNotifyM0ToM4(void)
{
 8008b74:	b580      	push	{r7, lr}
 8008b76:	af00      	add	r7, sp, #0
  if (CptReceiveNotifyFromM0 != 0)
 8008b78:	4b05      	ldr	r3, [pc, #20]	; (8008b90 <APP_ZIGBEE_ProcessNotifyM0ToM4+0x1c>)
 8008b7a:	681b      	ldr	r3, [r3, #0]
 8008b7c:	2b00      	cmp	r3, #0
 8008b7e:	d004      	beq.n	8008b8a <APP_ZIGBEE_ProcessNotifyM0ToM4+0x16>
  {
    /* Reset counter */
    CptReceiveNotifyFromM0 = 0;
 8008b80:	4b03      	ldr	r3, [pc, #12]	; (8008b90 <APP_ZIGBEE_ProcessNotifyM0ToM4+0x1c>)
 8008b82:	2200      	movs	r2, #0
 8008b84:	601a      	str	r2, [r3, #0]
    Zigbee_CallBackProcessing();
 8008b86:	f00d fb77 	bl	8016278 <Zigbee_CallBackProcessing>
  }
}
 8008b8a:	bf00      	nop
 8008b8c:	bd80      	pop	{r7, pc}
 8008b8e:	bf00      	nop
 8008b90:	20000d80 	.word	0x20000d80

08008b94 <APP_ZIGBEE_ProcessRequestM0ToM4>:
 * @brief Process the requests coming from the M0.
 * @param  None
 * @retval None
 */
static void APP_ZIGBEE_ProcessRequestM0ToM4(void)
{
 8008b94:	b580      	push	{r7, lr}
 8008b96:	af00      	add	r7, sp, #0
  if (CptReceiveRequestFromM0 != 0)
 8008b98:	4b05      	ldr	r3, [pc, #20]	; (8008bb0 <APP_ZIGBEE_ProcessRequestM0ToM4+0x1c>)
 8008b9a:	681b      	ldr	r3, [r3, #0]
 8008b9c:	2b00      	cmp	r3, #0
 8008b9e:	d004      	beq.n	8008baa <APP_ZIGBEE_ProcessRequestM0ToM4+0x16>
  {
    CptReceiveRequestFromM0 = 0;
 8008ba0:	4b03      	ldr	r3, [pc, #12]	; (8008bb0 <APP_ZIGBEE_ProcessRequestM0ToM4+0x1c>)
 8008ba2:	2200      	movs	r2, #0
 8008ba4:	601a      	str	r2, [r3, #0]
    Zigbee_M0RequestProcessing();
 8008ba6:	f00e feed 	bl	8017984 <Zigbee_M0RequestProcessing>
  }
}
 8008baa:	bf00      	nop
 8008bac:	bd80      	pop	{r7, pc}
 8008bae:	bf00      	nop
 8008bb0:	20000d84 	.word	0x20000d84

08008bb4 <LL_PWR_EnableBootC2>:
{
 8008bb4:	b480      	push	{r7}
 8008bb6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR4, PWR_CR4_C2BOOT);
 8008bb8:	4b05      	ldr	r3, [pc, #20]	; (8008bd0 <LL_PWR_EnableBootC2+0x1c>)
 8008bba:	68db      	ldr	r3, [r3, #12]
 8008bbc:	4a04      	ldr	r2, [pc, #16]	; (8008bd0 <LL_PWR_EnableBootC2+0x1c>)
 8008bbe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008bc2:	60d3      	str	r3, [r2, #12]
}
 8008bc4:	bf00      	nop
 8008bc6:	46bd      	mov	sp, r7
 8008bc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bcc:	4770      	bx	lr
 8008bce:	bf00      	nop
 8008bd0:	58000400 	.word	0x58000400

08008bd4 <LL_C2_EXTI_EnableEvent_32_63>:
{
 8008bd4:	b480      	push	{r7}
 8008bd6:	b083      	sub	sp, #12
 8008bd8:	af00      	add	r7, sp, #0
 8008bda:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->C2EMR2, ExtiLine);
 8008bdc:	4b06      	ldr	r3, [pc, #24]	; (8008bf8 <LL_C2_EXTI_EnableEvent_32_63+0x24>)
 8008bde:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 8008be2:	4905      	ldr	r1, [pc, #20]	; (8008bf8 <LL_C2_EXTI_EnableEvent_32_63+0x24>)
 8008be4:	687b      	ldr	r3, [r7, #4]
 8008be6:	4313      	orrs	r3, r2
 8008be8:	f8c1 30d4 	str.w	r3, [r1, #212]	; 0xd4
}
 8008bec:	bf00      	nop
 8008bee:	370c      	adds	r7, #12
 8008bf0:	46bd      	mov	sp, r7
 8008bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bf6:	4770      	bx	lr
 8008bf8:	58000800 	.word	0x58000800

08008bfc <LL_EXTI_EnableRisingTrig_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
 8008bfc:	b480      	push	{r7}
 8008bfe:	b083      	sub	sp, #12
 8008c00:	af00      	add	r7, sp, #0
 8008c02:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR2, ExtiLine);
 8008c04:	4b05      	ldr	r3, [pc, #20]	; (8008c1c <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 8008c06:	6a1a      	ldr	r2, [r3, #32]
 8008c08:	4904      	ldr	r1, [pc, #16]	; (8008c1c <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 8008c0a:	687b      	ldr	r3, [r7, #4]
 8008c0c:	4313      	orrs	r3, r2
 8008c0e:	620b      	str	r3, [r1, #32]
}
 8008c10:	bf00      	nop
 8008c12:	370c      	adds	r7, #12
 8008c14:	46bd      	mov	sp, r7
 8008c16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c1a:	4770      	bx	lr
 8008c1c:	58000800 	.word	0x58000800

08008c20 <LL_AHB3_GRP1_EnableClock>:
{
 8008c20:	b480      	push	{r7}
 8008c22:	b085      	sub	sp, #20
 8008c24:	af00      	add	r7, sp, #0
 8008c26:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 8008c28:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008c2c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008c2e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8008c32:	687b      	ldr	r3, [r7, #4]
 8008c34:	4313      	orrs	r3, r2
 8008c36:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 8008c38:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008c3c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008c3e:	687b      	ldr	r3, [r7, #4]
 8008c40:	4013      	ands	r3, r2
 8008c42:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8008c44:	68fb      	ldr	r3, [r7, #12]
}
 8008c46:	bf00      	nop
 8008c48:	3714      	adds	r7, #20
 8008c4a:	46bd      	mov	sp, r7
 8008c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c50:	4770      	bx	lr

08008c52 <LL_C2_AHB3_GRP1_EnableClock>:
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_IPCC
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_FLASH
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
 8008c52:	b480      	push	{r7}
 8008c54:	b085      	sub	sp, #20
 8008c56:	af00      	add	r7, sp, #0
 8008c58:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 8008c5a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008c5e:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 8008c62:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8008c66:	687b      	ldr	r3, [r7, #4]
 8008c68:	4313      	orrs	r3, r2
 8008c6a:	f8c1 3150 	str.w	r3, [r1, #336]	; 0x150
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 8008c6e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008c72:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 8008c76:	687b      	ldr	r3, [r7, #4]
 8008c78:	4013      	ands	r3, r2
 8008c7a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8008c7c:	68fb      	ldr	r3, [r7, #12]
}
 8008c7e:	bf00      	nop
 8008c80:	3714      	adds	r7, #20
 8008c82:	46bd      	mov	sp, r7
 8008c84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c88:	4770      	bx	lr

08008c8a <LL_C1_IPCC_EnableIT_TXF>:
{
 8008c8a:	b480      	push	{r7}
 8008c8c:	b083      	sub	sp, #12
 8008c8e:	af00      	add	r7, sp, #0
 8008c90:	6078      	str	r0, [r7, #4]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_TXFIE);
 8008c92:	687b      	ldr	r3, [r7, #4]
 8008c94:	681b      	ldr	r3, [r3, #0]
 8008c96:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8008c9a:	687b      	ldr	r3, [r7, #4]
 8008c9c:	601a      	str	r2, [r3, #0]
}
 8008c9e:	bf00      	nop
 8008ca0:	370c      	adds	r7, #12
 8008ca2:	46bd      	mov	sp, r7
 8008ca4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ca8:	4770      	bx	lr

08008caa <LL_C1_IPCC_EnableIT_RXO>:
{
 8008caa:	b480      	push	{r7}
 8008cac:	b083      	sub	sp, #12
 8008cae:	af00      	add	r7, sp, #0
 8008cb0:	6078      	str	r0, [r7, #4]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_RXOIE);
 8008cb2:	687b      	ldr	r3, [r7, #4]
 8008cb4:	681b      	ldr	r3, [r3, #0]
 8008cb6:	f043 0201 	orr.w	r2, r3, #1
 8008cba:	687b      	ldr	r3, [r7, #4]
 8008cbc:	601a      	str	r2, [r3, #0]
}
 8008cbe:	bf00      	nop
 8008cc0:	370c      	adds	r7, #12
 8008cc2:	46bd      	mov	sp, r7
 8008cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008cc8:	4770      	bx	lr

08008cca <LL_C1_IPCC_EnableTransmitChannel>:
{
 8008cca:	b480      	push	{r7}
 8008ccc:	b083      	sub	sp, #12
 8008cce:	af00      	add	r7, sp, #0
 8008cd0:	6078      	str	r0, [r7, #4]
 8008cd2:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8008cd4:	687b      	ldr	r3, [r7, #4]
 8008cd6:	685a      	ldr	r2, [r3, #4]
 8008cd8:	683b      	ldr	r3, [r7, #0]
 8008cda:	041b      	lsls	r3, r3, #16
 8008cdc:	43db      	mvns	r3, r3
 8008cde:	401a      	ands	r2, r3
 8008ce0:	687b      	ldr	r3, [r7, #4]
 8008ce2:	605a      	str	r2, [r3, #4]
}
 8008ce4:	bf00      	nop
 8008ce6:	370c      	adds	r7, #12
 8008ce8:	46bd      	mov	sp, r7
 8008cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008cee:	4770      	bx	lr

08008cf0 <LL_C1_IPCC_DisableTransmitChannel>:
{
 8008cf0:	b480      	push	{r7}
 8008cf2:	b083      	sub	sp, #12
 8008cf4:	af00      	add	r7, sp, #0
 8008cf6:	6078      	str	r0, [r7, #4]
 8008cf8:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8008cfa:	687b      	ldr	r3, [r7, #4]
 8008cfc:	685a      	ldr	r2, [r3, #4]
 8008cfe:	683b      	ldr	r3, [r7, #0]
 8008d00:	041b      	lsls	r3, r3, #16
 8008d02:	431a      	orrs	r2, r3
 8008d04:	687b      	ldr	r3, [r7, #4]
 8008d06:	605a      	str	r2, [r3, #4]
}
 8008d08:	bf00      	nop
 8008d0a:	370c      	adds	r7, #12
 8008d0c:	46bd      	mov	sp, r7
 8008d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d12:	4770      	bx	lr

08008d14 <LL_C1_IPCC_EnableReceiveChannel>:
{
 8008d14:	b480      	push	{r7}
 8008d16:	b083      	sub	sp, #12
 8008d18:	af00      	add	r7, sp, #0
 8008d1a:	6078      	str	r0, [r7, #4]
 8008d1c:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel);
 8008d1e:	687b      	ldr	r3, [r7, #4]
 8008d20:	685a      	ldr	r2, [r3, #4]
 8008d22:	683b      	ldr	r3, [r7, #0]
 8008d24:	43db      	mvns	r3, r3
 8008d26:	401a      	ands	r2, r3
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	605a      	str	r2, [r3, #4]
}
 8008d2c:	bf00      	nop
 8008d2e:	370c      	adds	r7, #12
 8008d30:	46bd      	mov	sp, r7
 8008d32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d36:	4770      	bx	lr

08008d38 <LL_C1_IPCC_DisableReceiveChannel>:
{
 8008d38:	b480      	push	{r7}
 8008d3a:	b083      	sub	sp, #12
 8008d3c:	af00      	add	r7, sp, #0
 8008d3e:	6078      	str	r0, [r7, #4]
 8008d40:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel);
 8008d42:	687b      	ldr	r3, [r7, #4]
 8008d44:	685a      	ldr	r2, [r3, #4]
 8008d46:	683b      	ldr	r3, [r7, #0]
 8008d48:	431a      	orrs	r2, r3
 8008d4a:	687b      	ldr	r3, [r7, #4]
 8008d4c:	605a      	str	r2, [r3, #4]
}
 8008d4e:	bf00      	nop
 8008d50:	370c      	adds	r7, #12
 8008d52:	46bd      	mov	sp, r7
 8008d54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d58:	4770      	bx	lr

08008d5a <LL_C1_IPCC_ClearFlag_CHx>:
{
 8008d5a:	b480      	push	{r7}
 8008d5c:	b083      	sub	sp, #12
 8008d5e:	af00      	add	r7, sp, #0
 8008d60:	6078      	str	r0, [r7, #4]
 8008d62:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel);
 8008d64:	687b      	ldr	r3, [r7, #4]
 8008d66:	683a      	ldr	r2, [r7, #0]
 8008d68:	609a      	str	r2, [r3, #8]
}
 8008d6a:	bf00      	nop
 8008d6c:	370c      	adds	r7, #12
 8008d6e:	46bd      	mov	sp, r7
 8008d70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d74:	4770      	bx	lr

08008d76 <LL_C1_IPCC_SetFlag_CHx>:
{
 8008d76:	b480      	push	{r7}
 8008d78:	b083      	sub	sp, #12
 8008d7a:	af00      	add	r7, sp, #0
 8008d7c:	6078      	str	r0, [r7, #4]
 8008d7e:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 8008d80:	683b      	ldr	r3, [r7, #0]
 8008d82:	041a      	lsls	r2, r3, #16
 8008d84:	687b      	ldr	r3, [r7, #4]
 8008d86:	609a      	str	r2, [r3, #8]
}
 8008d88:	bf00      	nop
 8008d8a:	370c      	adds	r7, #12
 8008d8c:	46bd      	mov	sp, r7
 8008d8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d92:	4770      	bx	lr

08008d94 <LL_C1_IPCC_IsActiveFlag_CHx>:
{
 8008d94:	b480      	push	{r7}
 8008d96:	b083      	sub	sp, #12
 8008d98:	af00      	add	r7, sp, #0
 8008d9a:	6078      	str	r0, [r7, #4]
 8008d9c:	6039      	str	r1, [r7, #0]
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 8008d9e:	687b      	ldr	r3, [r7, #4]
 8008da0:	68da      	ldr	r2, [r3, #12]
 8008da2:	683b      	ldr	r3, [r7, #0]
 8008da4:	4013      	ands	r3, r2
 8008da6:	683a      	ldr	r2, [r7, #0]
 8008da8:	429a      	cmp	r2, r3
 8008daa:	d101      	bne.n	8008db0 <LL_C1_IPCC_IsActiveFlag_CHx+0x1c>
 8008dac:	2301      	movs	r3, #1
 8008dae:	e000      	b.n	8008db2 <LL_C1_IPCC_IsActiveFlag_CHx+0x1e>
 8008db0:	2300      	movs	r3, #0
}
 8008db2:	4618      	mov	r0, r3
 8008db4:	370c      	adds	r7, #12
 8008db6:	46bd      	mov	sp, r7
 8008db8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008dbc:	4770      	bx	lr

08008dbe <LL_C2_IPCC_IsActiveFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C2_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
 8008dbe:	b480      	push	{r7}
 8008dc0:	b083      	sub	sp, #12
 8008dc2:	af00      	add	r7, sp, #0
 8008dc4:	6078      	str	r0, [r7, #4]
 8008dc6:	6039      	str	r1, [r7, #0]
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 8008dc8:	687b      	ldr	r3, [r7, #4]
 8008dca:	69da      	ldr	r2, [r3, #28]
 8008dcc:	683b      	ldr	r3, [r7, #0]
 8008dce:	4013      	ands	r3, r2
 8008dd0:	683a      	ldr	r2, [r7, #0]
 8008dd2:	429a      	cmp	r2, r3
 8008dd4:	d101      	bne.n	8008dda <LL_C2_IPCC_IsActiveFlag_CHx+0x1c>
 8008dd6:	2301      	movs	r3, #1
 8008dd8:	e000      	b.n	8008ddc <LL_C2_IPCC_IsActiveFlag_CHx+0x1e>
 8008dda:	2300      	movs	r3, #0
}
 8008ddc:	4618      	mov	r0, r3
 8008dde:	370c      	adds	r7, #12
 8008de0:	46bd      	mov	sp, r7
 8008de2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008de6:	4770      	bx	lr

08008de8 <HW_IPCC_Rx_Handler>:

/******************************************************************************
 * INTERRUPT HANDLER
 ******************************************************************************/
void HW_IPCC_Rx_Handler( void )
{
 8008de8:	b580      	push	{r7, lr}
 8008dea:	af00      	add	r7, sp, #0
  if (HW_IPCC_RX_PENDING( HW_IPCC_SYSTEM_EVENT_CHANNEL ))
 8008dec:	2102      	movs	r1, #2
 8008dee:	4828      	ldr	r0, [pc, #160]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008df0:	f7ff ffe5 	bl	8008dbe <LL_C2_IPCC_IsActiveFlag_CHx>
 8008df4:	4603      	mov	r3, r0
 8008df6:	2b00      	cmp	r3, #0
 8008df8:	d008      	beq.n	8008e0c <HW_IPCC_Rx_Handler+0x24>
 8008dfa:	4b25      	ldr	r3, [pc, #148]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008dfc:	685b      	ldr	r3, [r3, #4]
 8008dfe:	f003 0302 	and.w	r3, r3, #2
 8008e02:	2b00      	cmp	r3, #0
 8008e04:	d102      	bne.n	8008e0c <HW_IPCC_Rx_Handler+0x24>
  {
      HW_IPCC_SYS_EvtHandler();
 8008e06:	f000 f8f1 	bl	8008fec <HW_IPCC_SYS_EvtHandler>
 8008e0a:	e03e      	b.n	8008e8a <HW_IPCC_Rx_Handler+0xa2>
  {
    HW_IPCC_LLD_BLE_ReceiveM0CmdHandler();
  }
#endif /* LLD_TESTS_WB */
#ifdef ZIGBEE_WB
  else if (HW_IPCC_RX_PENDING( HW_IPCC_ZIGBEE_APPLI_NOTIF_ACK_CHANNEL ))
 8008e0c:	2104      	movs	r1, #4
 8008e0e:	4820      	ldr	r0, [pc, #128]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e10:	f7ff ffd5 	bl	8008dbe <LL_C2_IPCC_IsActiveFlag_CHx>
 8008e14:	4603      	mov	r3, r0
 8008e16:	2b00      	cmp	r3, #0
 8008e18:	d008      	beq.n	8008e2c <HW_IPCC_Rx_Handler+0x44>
 8008e1a:	4b1d      	ldr	r3, [pc, #116]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e1c:	685b      	ldr	r3, [r3, #4]
 8008e1e:	f003 0304 	and.w	r3, r3, #4
 8008e22:	2b00      	cmp	r3, #0
 8008e24:	d102      	bne.n	8008e2c <HW_IPCC_Rx_Handler+0x44>
  {
    HW_IPCC_ZIGBEE_StackNotifEvtHandler();
 8008e26:	f000 f923 	bl	8009070 <HW_IPCC_ZIGBEE_StackNotifEvtHandler>
 8008e2a:	e02e      	b.n	8008e8a <HW_IPCC_Rx_Handler+0xa2>
  }
  else if (HW_IPCC_RX_PENDING( HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL ))
 8008e2c:	2110      	movs	r1, #16
 8008e2e:	4818      	ldr	r0, [pc, #96]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e30:	f7ff ffc5 	bl	8008dbe <LL_C2_IPCC_IsActiveFlag_CHx>
 8008e34:	4603      	mov	r3, r0
 8008e36:	2b00      	cmp	r3, #0
 8008e38:	d008      	beq.n	8008e4c <HW_IPCC_Rx_Handler+0x64>
 8008e3a:	4b15      	ldr	r3, [pc, #84]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e3c:	685b      	ldr	r3, [r3, #4]
 8008e3e:	f003 0310 	and.w	r3, r3, #16
 8008e42:	2b00      	cmp	r3, #0
 8008e44:	d102      	bne.n	8008e4c <HW_IPCC_Rx_Handler+0x64>
  {
    HW_IPCC_ZIGBEE_StackM0RequestHandler();
 8008e46:	f000 f91f 	bl	8009088 <HW_IPCC_ZIGBEE_StackM0RequestHandler>
 8008e4a:	e01e      	b.n	8008e8a <HW_IPCC_Rx_Handler+0xa2>
  }
#endif /* ZIGBEE_WB */
  else if (HW_IPCC_RX_PENDING( HW_IPCC_BLE_EVENT_CHANNEL ))
 8008e4c:	2101      	movs	r1, #1
 8008e4e:	4810      	ldr	r0, [pc, #64]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e50:	f7ff ffb5 	bl	8008dbe <LL_C2_IPCC_IsActiveFlag_CHx>
 8008e54:	4603      	mov	r3, r0
 8008e56:	2b00      	cmp	r3, #0
 8008e58:	d008      	beq.n	8008e6c <HW_IPCC_Rx_Handler+0x84>
 8008e5a:	4b0d      	ldr	r3, [pc, #52]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e5c:	685b      	ldr	r3, [r3, #4]
 8008e5e:	f003 0301 	and.w	r3, r3, #1
 8008e62:	2b00      	cmp	r3, #0
 8008e64:	d102      	bne.n	8008e6c <HW_IPCC_Rx_Handler+0x84>
  {
    HW_IPCC_BLE_EvtHandler();
 8008e66:	f000 f885 	bl	8008f74 <HW_IPCC_BLE_EvtHandler>
 8008e6a:	e00e      	b.n	8008e8a <HW_IPCC_Rx_Handler+0xa2>
  }
  else if (HW_IPCC_RX_PENDING( HW_IPCC_TRACES_CHANNEL ))
 8008e6c:	2108      	movs	r1, #8
 8008e6e:	4808      	ldr	r0, [pc, #32]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e70:	f7ff ffa5 	bl	8008dbe <LL_C2_IPCC_IsActiveFlag_CHx>
 8008e74:	4603      	mov	r3, r0
 8008e76:	2b00      	cmp	r3, #0
 8008e78:	d008      	beq.n	8008e8c <HW_IPCC_Rx_Handler+0xa4>
 8008e7a:	4b05      	ldr	r3, [pc, #20]	; (8008e90 <HW_IPCC_Rx_Handler+0xa8>)
 8008e7c:	685b      	ldr	r3, [r3, #4]
 8008e7e:	f003 0308 	and.w	r3, r3, #8
 8008e82:	2b00      	cmp	r3, #0
 8008e84:	d102      	bne.n	8008e8c <HW_IPCC_Rx_Handler+0xa4>
  {
    HW_IPCC_TRACES_EvtHandler();
 8008e86:	f000 f959 	bl	800913c <HW_IPCC_TRACES_EvtHandler>
  }

  return;
 8008e8a:	bf00      	nop
 8008e8c:	bf00      	nop
}
 8008e8e:	bd80      	pop	{r7, pc}
 8008e90:	58000c00 	.word	0x58000c00

08008e94 <HW_IPCC_Tx_Handler>:

void HW_IPCC_Tx_Handler( void )
{
 8008e94:	b580      	push	{r7, lr}
 8008e96:	af00      	add	r7, sp, #0
  if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 8008e98:	2102      	movs	r1, #2
 8008e9a:	4820      	ldr	r0, [pc, #128]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008e9c:	f7ff ff7a 	bl	8008d94 <LL_C1_IPCC_IsActiveFlag_CHx>
 8008ea0:	4603      	mov	r3, r0
 8008ea2:	2b00      	cmp	r3, #0
 8008ea4:	d107      	bne.n	8008eb6 <HW_IPCC_Tx_Handler+0x22>
 8008ea6:	4b1d      	ldr	r3, [pc, #116]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008ea8:	685b      	ldr	r3, [r3, #4]
 8008eaa:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008eae:	2b00      	cmp	r3, #0
 8008eb0:	d101      	bne.n	8008eb6 <HW_IPCC_Tx_Handler+0x22>
  {
    HW_IPCC_SYS_CmdEvtHandler();
 8008eb2:	f000 f88f 	bl	8008fd4 <HW_IPCC_SYS_CmdEvtHandler>
#endif /* THREAD_WB */
#ifdef LLD_TESTS_WB
// No TX handler for LLD tests
#endif /* LLD_TESTS_WB */
#ifdef ZIGBEE_WB
  if (HW_IPCC_TX_PENDING( HW_IPCC_ZIGBEE_CMD_APPLI_CHANNEL ))
 8008eb6:	2104      	movs	r1, #4
 8008eb8:	4818      	ldr	r0, [pc, #96]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008eba:	f7ff ff6b 	bl	8008d94 <LL_C1_IPCC_IsActiveFlag_CHx>
 8008ebe:	4603      	mov	r3, r0
 8008ec0:	2b00      	cmp	r3, #0
 8008ec2:	d108      	bne.n	8008ed6 <HW_IPCC_Tx_Handler+0x42>
 8008ec4:	4b15      	ldr	r3, [pc, #84]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008ec6:	685b      	ldr	r3, [r3, #4]
 8008ec8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008ecc:	2b00      	cmp	r3, #0
 8008ece:	d102      	bne.n	8008ed6 <HW_IPCC_Tx_Handler+0x42>
  {
      HW_IPCC_ZIGBEE_CmdEvtHandler();
 8008ed0:	f000 f8c2 	bl	8009058 <HW_IPCC_ZIGBEE_CmdEvtHandler>
 8008ed4:	e01e      	b.n	8008f14 <HW_IPCC_Tx_Handler+0x80>
  }
#endif /* ZIGBEE_WB */

  else if (HW_IPCC_TX_PENDING( HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ))
 8008ed6:	2108      	movs	r1, #8
 8008ed8:	4810      	ldr	r0, [pc, #64]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008eda:	f7ff ff5b 	bl	8008d94 <LL_C1_IPCC_IsActiveFlag_CHx>
 8008ede:	4603      	mov	r3, r0
 8008ee0:	2b00      	cmp	r3, #0
 8008ee2:	d108      	bne.n	8008ef6 <HW_IPCC_Tx_Handler+0x62>
 8008ee4:	4b0d      	ldr	r3, [pc, #52]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008ee6:	685b      	ldr	r3, [r3, #4]
 8008ee8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008eec:	2b00      	cmp	r3, #0
 8008eee:	d102      	bne.n	8008ef6 <HW_IPCC_Tx_Handler+0x62>
  {
    HW_IPCC_MM_FreeBufHandler();
 8008ef0:	f000 f906 	bl	8009100 <HW_IPCC_MM_FreeBufHandler>
 8008ef4:	e00e      	b.n	8008f14 <HW_IPCC_Tx_Handler+0x80>
  }
  else if (HW_IPCC_TX_PENDING( HW_IPCC_HCI_ACL_DATA_CHANNEL ))
 8008ef6:	2120      	movs	r1, #32
 8008ef8:	4808      	ldr	r0, [pc, #32]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008efa:	f7ff ff4b 	bl	8008d94 <LL_C1_IPCC_IsActiveFlag_CHx>
 8008efe:	4603      	mov	r3, r0
 8008f00:	2b00      	cmp	r3, #0
 8008f02:	d108      	bne.n	8008f16 <HW_IPCC_Tx_Handler+0x82>
 8008f04:	4b05      	ldr	r3, [pc, #20]	; (8008f1c <HW_IPCC_Tx_Handler+0x88>)
 8008f06:	685b      	ldr	r3, [r3, #4]
 8008f08:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8008f0c:	2b00      	cmp	r3, #0
 8008f0e:	d102      	bne.n	8008f16 <HW_IPCC_Tx_Handler+0x82>
  {
    HW_IPCC_BLE_AclDataEvtHandler();
 8008f10:	f000 f83c 	bl	8008f8c <HW_IPCC_BLE_AclDataEvtHandler>
  }

  return;
 8008f14:	bf00      	nop
 8008f16:	bf00      	nop
}
 8008f18:	bd80      	pop	{r7, pc}
 8008f1a:	bf00      	nop
 8008f1c:	58000c00 	.word	0x58000c00

08008f20 <HW_IPCC_Enable>:
/******************************************************************************
 * GENERAL
 ******************************************************************************/
void HW_IPCC_Enable( void )
{
 8008f20:	b580      	push	{r7, lr}
 8008f22:	af00      	add	r7, sp, #0
  /**
  * Such as IPCC IP available to the CPU2, it is required to keep the IPCC clock running
    when FUS is running on CPU2 and CPU1 enters deep sleep mode
  */
  LL_C2_AHB3_GRP1_EnableClock(LL_C2_AHB3_GRP1_PERIPH_IPCC);
 8008f24:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8008f28:	f7ff fe93 	bl	8008c52 <LL_C2_AHB3_GRP1_EnableClock>

   /**
   * When the device is out of standby, it is required to use the EXTI mechanism to wakeup CPU2
   */
  LL_C2_EXTI_EnableEvent_32_63( LL_EXTI_LINE_41 );
 8008f2c:	f44f 7000 	mov.w	r0, #512	; 0x200
 8008f30:	f7ff fe50 	bl	8008bd4 <LL_C2_EXTI_EnableEvent_32_63>
  LL_EXTI_EnableRisingTrig_32_63( LL_EXTI_LINE_41 );
 8008f34:	f44f 7000 	mov.w	r0, #512	; 0x200
 8008f38:	f7ff fe60 	bl	8008bfc <LL_EXTI_EnableRisingTrig_32_63>
   * When the CPU2 receives that command, it waits for its event input to be set to restart the CPU2 firmware.
   * This is required because once C2BOOT has been set once, a clear/set on C2BOOT has no effect.
   * When SHCI_C2_Reinit( ) is not called, generating an event to the CPU2 does not have any effect
   * So, by default, the application shall both set the event flag and set the C2BOOT bit.
   */
  __SEV( );       /* Set the internal event flag and send an event to the CPU2 */
 8008f3c:	bf40      	sev
  __WFE( );       /* Clear the internal event flag */
 8008f3e:	bf20      	wfe
  LL_PWR_EnableBootC2( );
 8008f40:	f7ff fe38 	bl	8008bb4 <LL_PWR_EnableBootC2>

  return;
 8008f44:	bf00      	nop
}
 8008f46:	bd80      	pop	{r7, pc}

08008f48 <HW_IPCC_Init>:

void HW_IPCC_Init( void )
{
 8008f48:	b580      	push	{r7, lr}
 8008f4a:	af00      	add	r7, sp, #0
  LL_AHB3_GRP1_EnableClock( LL_AHB3_GRP1_PERIPH_IPCC );
 8008f4c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8008f50:	f7ff fe66 	bl	8008c20 <LL_AHB3_GRP1_EnableClock>

  LL_C1_IPCC_EnableIT_RXO( IPCC );
 8008f54:	4806      	ldr	r0, [pc, #24]	; (8008f70 <HW_IPCC_Init+0x28>)
 8008f56:	f7ff fea8 	bl	8008caa <LL_C1_IPCC_EnableIT_RXO>
  LL_C1_IPCC_EnableIT_TXF( IPCC );
 8008f5a:	4805      	ldr	r0, [pc, #20]	; (8008f70 <HW_IPCC_Init+0x28>)
 8008f5c:	f7ff fe95 	bl	8008c8a <LL_C1_IPCC_EnableIT_TXF>

  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 8008f60:	202c      	movs	r0, #44	; 0x2c
 8008f62:	f000 fc76 	bl	8009852 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 8008f66:	202d      	movs	r0, #45	; 0x2d
 8008f68:	f000 fc73 	bl	8009852 <HAL_NVIC_EnableIRQ>

  return;
 8008f6c:	bf00      	nop
}
 8008f6e:	bd80      	pop	{r7, pc}
 8008f70:	58000c00 	.word	0x58000c00

08008f74 <HW_IPCC_BLE_EvtHandler>:

  return;
}

static void HW_IPCC_BLE_EvtHandler( void )
{
 8008f74:	b580      	push	{r7, lr}
 8008f76:	af00      	add	r7, sp, #0
  HW_IPCC_BLE_RxEvtNot();
 8008f78:	f00a fd04 	bl	8013984 <HW_IPCC_BLE_RxEvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_BLE_EVENT_CHANNEL );
 8008f7c:	2101      	movs	r1, #1
 8008f7e:	4802      	ldr	r0, [pc, #8]	; (8008f88 <HW_IPCC_BLE_EvtHandler+0x14>)
 8008f80:	f7ff feeb 	bl	8008d5a <LL_C1_IPCC_ClearFlag_CHx>

  return;
 8008f84:	bf00      	nop
}
 8008f86:	bd80      	pop	{r7, pc}
 8008f88:	58000c00 	.word	0x58000c00

08008f8c <HW_IPCC_BLE_AclDataEvtHandler>:

  return;
}

static void HW_IPCC_BLE_AclDataEvtHandler( void )
{
 8008f8c:	b580      	push	{r7, lr}
 8008f8e:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_HCI_ACL_DATA_CHANNEL );
 8008f90:	2120      	movs	r1, #32
 8008f92:	4803      	ldr	r0, [pc, #12]	; (8008fa0 <HW_IPCC_BLE_AclDataEvtHandler+0x14>)
 8008f94:	f7ff feac 	bl	8008cf0 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_BLE_AclDataAckNot();
 8008f98:	f00a fd24 	bl	80139e4 <HW_IPCC_BLE_AclDataAckNot>

  return;
 8008f9c:	bf00      	nop
}
 8008f9e:	bd80      	pop	{r7, pc}
 8008fa0:	58000c00 	.word	0x58000c00

08008fa4 <HW_IPCC_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
void HW_IPCC_SYS_Init( void )
{
 8008fa4:	b580      	push	{r7, lr}
 8008fa6:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );
 8008fa8:	2102      	movs	r1, #2
 8008faa:	4802      	ldr	r0, [pc, #8]	; (8008fb4 <HW_IPCC_SYS_Init+0x10>)
 8008fac:	f7ff feb2 	bl	8008d14 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8008fb0:	bf00      	nop
}
 8008fb2:	bd80      	pop	{r7, pc}
 8008fb4:	58000c00 	.word	0x58000c00

08008fb8 <HW_IPCC_SYS_SendCmd>:

void HW_IPCC_SYS_SendCmd( void )
{
 8008fb8:	b580      	push	{r7, lr}
 8008fba:	af00      	add	r7, sp, #0
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 8008fbc:	2102      	movs	r1, #2
 8008fbe:	4804      	ldr	r0, [pc, #16]	; (8008fd0 <HW_IPCC_SYS_SendCmd+0x18>)
 8008fc0:	f7ff fed9 	bl	8008d76 <LL_C1_IPCC_SetFlag_CHx>
  LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 8008fc4:	2102      	movs	r1, #2
 8008fc6:	4802      	ldr	r0, [pc, #8]	; (8008fd0 <HW_IPCC_SYS_SendCmd+0x18>)
 8008fc8:	f7ff fe7f 	bl	8008cca <LL_C1_IPCC_EnableTransmitChannel>

  return;
 8008fcc:	bf00      	nop
}
 8008fce:	bd80      	pop	{r7, pc}
 8008fd0:	58000c00 	.word	0x58000c00

08008fd4 <HW_IPCC_SYS_CmdEvtHandler>:

static void HW_IPCC_SYS_CmdEvtHandler( void )
{
 8008fd4:	b580      	push	{r7, lr}
 8008fd6:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 8008fd8:	2102      	movs	r1, #2
 8008fda:	4803      	ldr	r0, [pc, #12]	; (8008fe8 <HW_IPCC_SYS_CmdEvtHandler+0x14>)
 8008fdc:	f7ff fe88 	bl	8008cf0 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_SYS_CmdEvtNot();
 8008fe0:	f00a fd50 	bl	8013a84 <HW_IPCC_SYS_CmdEvtNot>

  return;
 8008fe4:	bf00      	nop
}
 8008fe6:	bd80      	pop	{r7, pc}
 8008fe8:	58000c00 	.word	0x58000c00

08008fec <HW_IPCC_SYS_EvtHandler>:

static void HW_IPCC_SYS_EvtHandler( void )
{
 8008fec:	b580      	push	{r7, lr}
 8008fee:	af00      	add	r7, sp, #0
  HW_IPCC_SYS_EvtNot();
 8008ff0:	f00a fd5e 	bl	8013ab0 <HW_IPCC_SYS_EvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );
 8008ff4:	2102      	movs	r1, #2
 8008ff6:	4802      	ldr	r0, [pc, #8]	; (8009000 <HW_IPCC_SYS_EvtHandler+0x14>)
 8008ff8:	f7ff feaf 	bl	8008d5a <LL_C1_IPCC_ClearFlag_CHx>

  return;
 8008ffc:	bf00      	nop
}
 8008ffe:	bd80      	pop	{r7, pc}
 8009000:	58000c00 	.word	0x58000c00

08009004 <HW_IPCC_ZIGBEE_Init>:
/******************************************************************************
 * ZIGBEE
 ******************************************************************************/
#ifdef ZIGBEE_WB
void HW_IPCC_ZIGBEE_Init( void )
{
 8009004:	b580      	push	{r7, lr}
 8009006:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_ZIGBEE_APPLI_NOTIF_ACK_CHANNEL );
 8009008:	2104      	movs	r1, #4
 800900a:	4804      	ldr	r0, [pc, #16]	; (800901c <HW_IPCC_ZIGBEE_Init+0x18>)
 800900c:	f7ff fe82 	bl	8008d14 <LL_C1_IPCC_EnableReceiveChannel>
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL );
 8009010:	2110      	movs	r1, #16
 8009012:	4802      	ldr	r0, [pc, #8]	; (800901c <HW_IPCC_ZIGBEE_Init+0x18>)
 8009014:	f7ff fe7e 	bl	8008d14 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8009018:	bf00      	nop
}
 800901a:	bd80      	pop	{r7, pc}
 800901c:	58000c00 	.word	0x58000c00

08009020 <HW_IPCC_ZIGBEE_SendM4RequestToM0>:

void HW_IPCC_ZIGBEE_SendM4RequestToM0( void )
{
 8009020:	b580      	push	{r7, lr}
 8009022:	af00      	add	r7, sp, #0
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_ZIGBEE_CMD_APPLI_CHANNEL );
 8009024:	2104      	movs	r1, #4
 8009026:	4804      	ldr	r0, [pc, #16]	; (8009038 <HW_IPCC_ZIGBEE_SendM4RequestToM0+0x18>)
 8009028:	f7ff fea5 	bl	8008d76 <LL_C1_IPCC_SetFlag_CHx>
  LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_ZIGBEE_CMD_APPLI_CHANNEL );
 800902c:	2104      	movs	r1, #4
 800902e:	4802      	ldr	r0, [pc, #8]	; (8009038 <HW_IPCC_ZIGBEE_SendM4RequestToM0+0x18>)
 8009030:	f7ff fe4b 	bl	8008cca <LL_C1_IPCC_EnableTransmitChannel>

  return;
 8009034:	bf00      	nop
}
 8009036:	bd80      	pop	{r7, pc}
 8009038:	58000c00 	.word	0x58000c00

0800903c <HW_IPCC_ZIGBEE_SendM4AckToM0Notify>:

void HW_IPCC_ZIGBEE_SendM4AckToM0Notify( void )
{
 800903c:	b580      	push	{r7, lr}
 800903e:	af00      	add	r7, sp, #0
  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_ZIGBEE_APPLI_NOTIF_ACK_CHANNEL );
 8009040:	2104      	movs	r1, #4
 8009042:	4804      	ldr	r0, [pc, #16]	; (8009054 <HW_IPCC_ZIGBEE_SendM4AckToM0Notify+0x18>)
 8009044:	f7ff fe89 	bl	8008d5a <LL_C1_IPCC_ClearFlag_CHx>
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_ZIGBEE_APPLI_NOTIF_ACK_CHANNEL );
 8009048:	2104      	movs	r1, #4
 800904a:	4802      	ldr	r0, [pc, #8]	; (8009054 <HW_IPCC_ZIGBEE_SendM4AckToM0Notify+0x18>)
 800904c:	f7ff fe62 	bl	8008d14 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8009050:	bf00      	nop
}
 8009052:	bd80      	pop	{r7, pc}
 8009054:	58000c00 	.word	0x58000c00

08009058 <HW_IPCC_ZIGBEE_CmdEvtHandler>:

static void HW_IPCC_ZIGBEE_CmdEvtHandler( void )
{
 8009058:	b580      	push	{r7, lr}
 800905a:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_ZIGBEE_CMD_APPLI_CHANNEL );
 800905c:	2104      	movs	r1, #4
 800905e:	4803      	ldr	r0, [pc, #12]	; (800906c <HW_IPCC_ZIGBEE_CmdEvtHandler+0x14>)
 8009060:	f7ff fe46 	bl	8008cf0 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_ZIGBEE_RecvAppliAckFromM0();
 8009064:	f00a fd70 	bl	8013b48 <HW_IPCC_ZIGBEE_RecvAppliAckFromM0>

  return;
 8009068:	bf00      	nop
}
 800906a:	bd80      	pop	{r7, pc}
 800906c:	58000c00 	.word	0x58000c00

08009070 <HW_IPCC_ZIGBEE_StackNotifEvtHandler>:

static void HW_IPCC_ZIGBEE_StackNotifEvtHandler( void )
{
 8009070:	b580      	push	{r7, lr}
 8009072:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableReceiveChannel( IPCC, HW_IPCC_ZIGBEE_APPLI_NOTIF_ACK_CHANNEL );
 8009074:	2104      	movs	r1, #4
 8009076:	4803      	ldr	r0, [pc, #12]	; (8009084 <HW_IPCC_ZIGBEE_StackNotifEvtHandler+0x14>)
 8009078:	f7ff fe5e 	bl	8008d38 <LL_C1_IPCC_DisableReceiveChannel>

  HW_IPCC_ZIGBEE_RecvM0NotifyToM4();
 800907c:	f00a fd70 	bl	8013b60 <HW_IPCC_ZIGBEE_RecvM0NotifyToM4>

  return;
 8009080:	bf00      	nop
}
 8009082:	bd80      	pop	{r7, pc}
 8009084:	58000c00 	.word	0x58000c00

08009088 <HW_IPCC_ZIGBEE_StackM0RequestHandler>:

static void HW_IPCC_ZIGBEE_StackM0RequestHandler( void )
{
 8009088:	b580      	push	{r7, lr}
 800908a:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableReceiveChannel( IPCC, HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL );
 800908c:	2110      	movs	r1, #16
 800908e:	4803      	ldr	r0, [pc, #12]	; (800909c <HW_IPCC_ZIGBEE_StackM0RequestHandler+0x14>)
 8009090:	f7ff fe52 	bl	8008d38 <LL_C1_IPCC_DisableReceiveChannel>

  HW_IPCC_ZIGBEE_RecvM0RequestToM4();
 8009094:	f00a fd7e 	bl	8013b94 <HW_IPCC_ZIGBEE_RecvM0RequestToM4>

  return;
 8009098:	bf00      	nop
}
 800909a:	bd80      	pop	{r7, pc}
 800909c:	58000c00 	.word	0x58000c00

080090a0 <HW_IPCC_ZIGBEE_SendM4AckToM0Request>:

void HW_IPCC_ZIGBEE_SendM4AckToM0Request( void )
{
 80090a0:	b580      	push	{r7, lr}
 80090a2:	af00      	add	r7, sp, #0
  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL );
 80090a4:	2110      	movs	r1, #16
 80090a6:	4804      	ldr	r0, [pc, #16]	; (80090b8 <HW_IPCC_ZIGBEE_SendM4AckToM0Request+0x18>)
 80090a8:	f7ff fe57 	bl	8008d5a <LL_C1_IPCC_ClearFlag_CHx>
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL );
 80090ac:	2110      	movs	r1, #16
 80090ae:	4802      	ldr	r0, [pc, #8]	; (80090b8 <HW_IPCC_ZIGBEE_SendM4AckToM0Request+0x18>)
 80090b0:	f7ff fe30 	bl	8008d14 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 80090b4:	bf00      	nop
}
 80090b6:	bd80      	pop	{r7, pc}
 80090b8:	58000c00 	.word	0x58000c00

080090bc <HW_IPCC_MM_SendFreeBuf>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void HW_IPCC_MM_SendFreeBuf( void (*cb)( void ) )
{
 80090bc:	b580      	push	{r7, lr}
 80090be:	b082      	sub	sp, #8
 80090c0:	af00      	add	r7, sp, #0
 80090c2:	6078      	str	r0, [r7, #4]
  if ( LL_C1_IPCC_IsActiveFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ) )
 80090c4:	2108      	movs	r1, #8
 80090c6:	480c      	ldr	r0, [pc, #48]	; (80090f8 <HW_IPCC_MM_SendFreeBuf+0x3c>)
 80090c8:	f7ff fe64 	bl	8008d94 <LL_C1_IPCC_IsActiveFlag_CHx>
 80090cc:	4603      	mov	r3, r0
 80090ce:	2b00      	cmp	r3, #0
 80090d0:	d007      	beq.n	80090e2 <HW_IPCC_MM_SendFreeBuf+0x26>
  {
    FreeBufCb = cb;
 80090d2:	4a0a      	ldr	r2, [pc, #40]	; (80090fc <HW_IPCC_MM_SendFreeBuf+0x40>)
 80090d4:	687b      	ldr	r3, [r7, #4]
 80090d6:	6013      	str	r3, [r2, #0]
    LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 80090d8:	2108      	movs	r1, #8
 80090da:	4807      	ldr	r0, [pc, #28]	; (80090f8 <HW_IPCC_MM_SendFreeBuf+0x3c>)
 80090dc:	f7ff fdf5 	bl	8008cca <LL_C1_IPCC_EnableTransmitChannel>
    cb();

    LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
  }

  return;
 80090e0:	e006      	b.n	80090f0 <HW_IPCC_MM_SendFreeBuf+0x34>
    cb();
 80090e2:	687b      	ldr	r3, [r7, #4]
 80090e4:	4798      	blx	r3
    LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 80090e6:	2108      	movs	r1, #8
 80090e8:	4803      	ldr	r0, [pc, #12]	; (80090f8 <HW_IPCC_MM_SendFreeBuf+0x3c>)
 80090ea:	f7ff fe44 	bl	8008d76 <LL_C1_IPCC_SetFlag_CHx>
  return;
 80090ee:	bf00      	nop
}
 80090f0:	3708      	adds	r7, #8
 80090f2:	46bd      	mov	sp, r7
 80090f4:	bd80      	pop	{r7, pc}
 80090f6:	bf00      	nop
 80090f8:	58000c00 	.word	0x58000c00
 80090fc:	20000da8 	.word	0x20000da8

08009100 <HW_IPCC_MM_FreeBufHandler>:

static void HW_IPCC_MM_FreeBufHandler( void )
{
 8009100:	b580      	push	{r7, lr}
 8009102:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8009104:	2108      	movs	r1, #8
 8009106:	4806      	ldr	r0, [pc, #24]	; (8009120 <HW_IPCC_MM_FreeBufHandler+0x20>)
 8009108:	f7ff fdf2 	bl	8008cf0 <LL_C1_IPCC_DisableTransmitChannel>

  FreeBufCb();
 800910c:	4b05      	ldr	r3, [pc, #20]	; (8009124 <HW_IPCC_MM_FreeBufHandler+0x24>)
 800910e:	681b      	ldr	r3, [r3, #0]
 8009110:	4798      	blx	r3

  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8009112:	2108      	movs	r1, #8
 8009114:	4802      	ldr	r0, [pc, #8]	; (8009120 <HW_IPCC_MM_FreeBufHandler+0x20>)
 8009116:	f7ff fe2e 	bl	8008d76 <LL_C1_IPCC_SetFlag_CHx>

  return;
 800911a:	bf00      	nop
}
 800911c:	bd80      	pop	{r7, pc}
 800911e:	bf00      	nop
 8009120:	58000c00 	.word	0x58000c00
 8009124:	20000da8 	.word	0x20000da8

08009128 <HW_IPCC_TRACES_Init>:

/******************************************************************************
 * TRACES
 ******************************************************************************/
void HW_IPCC_TRACES_Init( void )
{
 8009128:	b580      	push	{r7, lr}
 800912a:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_TRACES_CHANNEL );
 800912c:	2108      	movs	r1, #8
 800912e:	4802      	ldr	r0, [pc, #8]	; (8009138 <HW_IPCC_TRACES_Init+0x10>)
 8009130:	f7ff fdf0 	bl	8008d14 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8009134:	bf00      	nop
}
 8009136:	bd80      	pop	{r7, pc}
 8009138:	58000c00 	.word	0x58000c00

0800913c <HW_IPCC_TRACES_EvtHandler>:

static void HW_IPCC_TRACES_EvtHandler( void )
{
 800913c:	b580      	push	{r7, lr}
 800913e:	af00      	add	r7, sp, #0
  HW_IPCC_TRACES_EvtNot();
 8009140:	f00a fdc8 	bl	8013cd4 <HW_IPCC_TRACES_EvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_TRACES_CHANNEL );
 8009144:	2108      	movs	r1, #8
 8009146:	4802      	ldr	r0, [pc, #8]	; (8009150 <HW_IPCC_TRACES_EvtHandler+0x14>)
 8009148:	f7ff fe07 	bl	8008d5a <LL_C1_IPCC_ClearFlag_CHx>

  return;
 800914c:	bf00      	nop
}
 800914e:	bd80      	pop	{r7, pc}
 8009150:	58000c00 	.word	0x58000c00

08009154 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 8009154:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8009156:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8009158:	3304      	adds	r3, #4

0800915a <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800915a:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800915c:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 800915e:	d3f9      	bcc.n	8009154 <CopyDataInit>
  bx lr
 8009160:	4770      	bx	lr

08009162 <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 8009162:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 8009164:	3004      	adds	r0, #4

08009166 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 8009166:	4288      	cmp	r0, r1
  bcc FillZerobss
 8009168:	d3fb      	bcc.n	8009162 <FillZerobss>
  bx lr
 800916a:	4770      	bx	lr

0800916c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800916c:	480c      	ldr	r0, [pc, #48]	; (80091a0 <LoopForever+0x4>)
  mov   sp, r0          /* set stack pointer */
 800916e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8009170:	f000 f928 	bl	80093c4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 8009174:	480b      	ldr	r0, [pc, #44]	; (80091a4 <LoopForever+0x8>)
 8009176:	490c      	ldr	r1, [pc, #48]	; (80091a8 <LoopForever+0xc>)
 8009178:	4a0c      	ldr	r2, [pc, #48]	; (80091ac <LoopForever+0x10>)
 800917a:	2300      	movs	r3, #0
 800917c:	f7ff ffed 	bl	800915a <LoopCopyDataInit>

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 8009180:	480b      	ldr	r0, [pc, #44]	; (80091b0 <LoopForever+0x14>)
 8009182:	490c      	ldr	r1, [pc, #48]	; (80091b4 <LoopForever+0x18>)
 8009184:	2300      	movs	r3, #0
 8009186:	f7ff ffee 	bl	8009166 <LoopFillZerobss>
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800918a:	480b      	ldr	r0, [pc, #44]	; (80091b8 <LoopForever+0x1c>)
 800918c:	490b      	ldr	r1, [pc, #44]	; (80091bc <LoopForever+0x20>)
 800918e:	2300      	movs	r3, #0
 8009190:	f7ff ffe9 	bl	8009166 <LoopFillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8009194:	f00f f9d6 	bl	8018544 <__libc_init_array>
/* Call the application s entry point.*/
	bl	main
 8009198:	f7fe fc42 	bl	8007a20 <main>

0800919c <LoopForever>:

LoopForever:
  b LoopForever
 800919c:	e7fe      	b.n	800919c <LoopForever>
 800919e:	0000      	.short	0x0000
  ldr   r0, =_estack
 80091a0:	20030000 	.word	0x20030000
  INIT_DATA _sdata, _edata, _sidata
 80091a4:	20000008 	.word	0x20000008
 80091a8:	20000170 	.word	0x20000170
 80091ac:	08019da0 	.word	0x08019da0
  INIT_BSS _sbss, _ebss
 80091b0:	20000184 	.word	0x20000184
 80091b4:	200028f8 	.word	0x200028f8
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 80091b8:	200300e4 	.word	0x200300e4
 80091bc:	20030b5a 	.word	0x20030b5a

080091c0 <ADC1_IRQHandler>:
 * @retval None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80091c0:	e7fe      	b.n	80091c0 <ADC1_IRQHandler>

080091c2 <LL_AHB2_GRP1_EnableClock>:
{
 80091c2:	b480      	push	{r7}
 80091c4:	b085      	sub	sp, #20
 80091c6:	af00      	add	r7, sp, #0
 80091c8:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 80091ca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80091ce:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80091d0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80091d4:	687b      	ldr	r3, [r7, #4]
 80091d6:	4313      	orrs	r3, r2
 80091d8:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80091da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80091de:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80091e0:	687b      	ldr	r3, [r7, #4]
 80091e2:	4013      	ands	r3, r2
 80091e4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80091e6:	68fb      	ldr	r3, [r7, #12]
}
 80091e8:	bf00      	nop
 80091ea:	3714      	adds	r7, #20
 80091ec:	46bd      	mov	sp, r7
 80091ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091f2:	4770      	bx	lr

080091f4 <BSP_LED_Init>:
  *          This parameter can be one of the following values:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 80091f4:	b580      	push	{r7, lr}
 80091f6:	b088      	sub	sp, #32
 80091f8:	af00      	add	r7, sp, #0
 80091fa:	4603      	mov	r3, r0
 80091fc:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  gpioinitstruct = {0};
 80091fe:	f107 030c 	add.w	r3, r7, #12
 8009202:	2200      	movs	r2, #0
 8009204:	601a      	str	r2, [r3, #0]
 8009206:	605a      	str	r2, [r3, #4]
 8009208:	609a      	str	r2, [r3, #8]
 800920a:	60da      	str	r2, [r3, #12]
 800920c:	611a      	str	r2, [r3, #16]

  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 800920e:	79fb      	ldrb	r3, [r7, #7]
 8009210:	2b00      	cmp	r3, #0
 8009212:	d103      	bne.n	800921c <BSP_LED_Init+0x28>
 8009214:	2001      	movs	r0, #1
 8009216:	f7ff ffd4 	bl	80091c2 <LL_AHB2_GRP1_EnableClock>
 800921a:	e00c      	b.n	8009236 <BSP_LED_Init+0x42>
 800921c:	79fb      	ldrb	r3, [r7, #7]
 800921e:	2b01      	cmp	r3, #1
 8009220:	d103      	bne.n	800922a <BSP_LED_Init+0x36>
 8009222:	2002      	movs	r0, #2
 8009224:	f7ff ffcd 	bl	80091c2 <LL_AHB2_GRP1_EnableClock>
 8009228:	e005      	b.n	8009236 <BSP_LED_Init+0x42>
 800922a:	79fb      	ldrb	r3, [r7, #7]
 800922c:	2b02      	cmp	r3, #2
 800922e:	d102      	bne.n	8009236 <BSP_LED_Init+0x42>
 8009230:	2002      	movs	r0, #2
 8009232:	f7ff ffc6 	bl	80091c2 <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpioinitstruct.Pin = GPIO_PIN[Led];
 8009236:	79fb      	ldrb	r3, [r7, #7]
 8009238:	4a11      	ldr	r2, [pc, #68]	; (8009280 <BSP_LED_Init+0x8c>)
 800923a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800923e:	60fb      	str	r3, [r7, #12]
  gpioinitstruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009240:	2301      	movs	r3, #1
 8009242:	613b      	str	r3, [r7, #16]
  gpioinitstruct.Pull = GPIO_NOPULL;
 8009244:	2300      	movs	r3, #0
 8009246:	617b      	str	r3, [r7, #20]
  gpioinitstruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8009248:	2302      	movs	r3, #2
 800924a:	61bb      	str	r3, [r7, #24]

  HAL_GPIO_Init(GPIO_PORT[Led], &gpioinitstruct);
 800924c:	79fb      	ldrb	r3, [r7, #7]
 800924e:	4a0d      	ldr	r2, [pc, #52]	; (8009284 <BSP_LED_Init+0x90>)
 8009250:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009254:	f107 020c 	add.w	r2, r7, #12
 8009258:	4611      	mov	r1, r2
 800925a:	4618      	mov	r0, r3
 800925c:	f000 fd8a 	bl	8009d74 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 8009260:	79fb      	ldrb	r3, [r7, #7]
 8009262:	4a08      	ldr	r2, [pc, #32]	; (8009284 <BSP_LED_Init+0x90>)
 8009264:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8009268:	79fb      	ldrb	r3, [r7, #7]
 800926a:	4a05      	ldr	r2, [pc, #20]	; (8009280 <BSP_LED_Init+0x8c>)
 800926c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8009270:	2200      	movs	r2, #0
 8009272:	4619      	mov	r1, r3
 8009274:	f000 feee 	bl	800a054 <HAL_GPIO_WritePin>
}
 8009278:	bf00      	nop
 800927a:	3720      	adds	r7, #32
 800927c:	46bd      	mov	sp, r7
 800927e:	bd80      	pop	{r7, pc}
 8009280:	08019a00 	.word	0x08019a00
 8009284:	20000008 	.word	0x20000008

08009288 <BSP_LED_On>:
  *   This parameter can be one of following parameters:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_On(Led_TypeDef Led)
{
 8009288:	b580      	push	{r7, lr}
 800928a:	b082      	sub	sp, #8
 800928c:	af00      	add	r7, sp, #0
 800928e:	4603      	mov	r3, r0
 8009290:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET); 
 8009292:	79fb      	ldrb	r3, [r7, #7]
 8009294:	4a07      	ldr	r2, [pc, #28]	; (80092b4 <BSP_LED_On+0x2c>)
 8009296:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 800929a:	79fb      	ldrb	r3, [r7, #7]
 800929c:	4a06      	ldr	r2, [pc, #24]	; (80092b8 <BSP_LED_On+0x30>)
 800929e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80092a2:	2201      	movs	r2, #1
 80092a4:	4619      	mov	r1, r3
 80092a6:	f000 fed5 	bl	800a054 <HAL_GPIO_WritePin>
}
 80092aa:	bf00      	nop
 80092ac:	3708      	adds	r7, #8
 80092ae:	46bd      	mov	sp, r7
 80092b0:	bd80      	pop	{r7, pc}
 80092b2:	bf00      	nop
 80092b4:	20000008 	.word	0x20000008
 80092b8:	08019a00 	.word	0x08019a00

080092bc <BSP_LED_Off>:
  *   This parameter can be one of following parameters:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Off(Led_TypeDef Led)
{
 80092bc:	b580      	push	{r7, lr}
 80092be:	b082      	sub	sp, #8
 80092c0:	af00      	add	r7, sp, #0
 80092c2:	4603      	mov	r3, r0
 80092c4:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 80092c6:	79fb      	ldrb	r3, [r7, #7]
 80092c8:	4a07      	ldr	r2, [pc, #28]	; (80092e8 <BSP_LED_Off+0x2c>)
 80092ca:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 80092ce:	79fb      	ldrb	r3, [r7, #7]
 80092d0:	4a06      	ldr	r2, [pc, #24]	; (80092ec <BSP_LED_Off+0x30>)
 80092d2:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80092d6:	2200      	movs	r2, #0
 80092d8:	4619      	mov	r1, r3
 80092da:	f000 febb 	bl	800a054 <HAL_GPIO_WritePin>
}
 80092de:	bf00      	nop
 80092e0:	3708      	adds	r7, #8
 80092e2:	46bd      	mov	sp, r7
 80092e4:	bd80      	pop	{r7, pc}
 80092e6:	bf00      	nop
 80092e8:	20000008 	.word	0x20000008
 80092ec:	08019a00 	.word	0x08019a00

080092f0 <BSP_LED_Toggle>:
  *   This parameter can be one of following parameters:
  *     @arg LED2
  * @retval None
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
 80092f0:	b580      	push	{r7, lr}
 80092f2:	b082      	sub	sp, #8
 80092f4:	af00      	add	r7, sp, #0
 80092f6:	4603      	mov	r3, r0
 80092f8:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 80092fa:	79fb      	ldrb	r3, [r7, #7]
 80092fc:	4a07      	ldr	r2, [pc, #28]	; (800931c <BSP_LED_Toggle+0x2c>)
 80092fe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8009302:	79fb      	ldrb	r3, [r7, #7]
 8009304:	4906      	ldr	r1, [pc, #24]	; (8009320 <BSP_LED_Toggle+0x30>)
 8009306:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800930a:	4619      	mov	r1, r3
 800930c:	4610      	mov	r0, r2
 800930e:	f000 feb9 	bl	800a084 <HAL_GPIO_TogglePin>
}
 8009312:	bf00      	nop
 8009314:	3708      	adds	r7, #8
 8009316:	46bd      	mov	sp, r7
 8009318:	bd80      	pop	{r7, pc}
 800931a:	bf00      	nop
 800931c:	20000008 	.word	0x20000008
 8009320:	08019a00 	.word	0x08019a00

08009324 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval None
  */
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 8009324:	b580      	push	{r7, lr}
 8009326:	b088      	sub	sp, #32
 8009328:	af00      	add	r7, sp, #0
 800932a:	4603      	mov	r3, r0
 800932c:	460a      	mov	r2, r1
 800932e:	71fb      	strb	r3, [r7, #7]
 8009330:	4613      	mov	r3, r2
 8009332:	71bb      	strb	r3, [r7, #6]
  GPIO_InitTypeDef gpioinitstruct = {0};
 8009334:	f107 030c 	add.w	r3, r7, #12
 8009338:	2200      	movs	r2, #0
 800933a:	601a      	str	r2, [r3, #0]
 800933c:	605a      	str	r2, [r3, #4]
 800933e:	609a      	str	r2, [r3, #8]
 8009340:	60da      	str	r2, [r3, #12]
 8009342:	611a      	str	r2, [r3, #16]

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 8009344:	2001      	movs	r0, #1
 8009346:	f7ff ff3c 	bl	80091c2 <LL_AHB2_GRP1_EnableClock>

  if(ButtonMode == BUTTON_MODE_GPIO)
 800934a:	79bb      	ldrb	r3, [r7, #6]
 800934c:	2b00      	cmp	r3, #0
 800934e:	d112      	bne.n	8009376 <BSP_PB_Init+0x52>
  {
    /* Configure Button pin as input */
    gpioinitstruct.Pin = BUTTON_PIN[Button];
 8009350:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009354:	60fb      	str	r3, [r7, #12]
    gpioinitstruct.Mode = GPIO_MODE_INPUT;
 8009356:	2300      	movs	r3, #0
 8009358:	613b      	str	r3, [r7, #16]
    gpioinitstruct.Pull = GPIO_PULLUP;
 800935a:	2301      	movs	r3, #1
 800935c:	617b      	str	r3, [r7, #20]
    gpioinitstruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800935e:	2302      	movs	r3, #2
 8009360:	61bb      	str	r3, [r7, #24]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
 8009362:	79fb      	ldrb	r3, [r7, #7]
 8009364:	4a16      	ldr	r2, [pc, #88]	; (80093c0 <BSP_PB_Init+0x9c>)
 8009366:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800936a:	f107 020c 	add.w	r2, r7, #12
 800936e:	4611      	mov	r1, r2
 8009370:	4618      	mov	r0, r3
 8009372:	f000 fcff 	bl	8009d74 <HAL_GPIO_Init>
  }

  if(ButtonMode == BUTTON_MODE_EXTI)
 8009376:	79bb      	ldrb	r3, [r7, #6]
 8009378:	2b01      	cmp	r3, #1
 800937a:	d11d      	bne.n	80093b8 <BSP_PB_Init+0x94>
  {
    /* Configure Button pin as input with External interrupt */
    gpioinitstruct.Pin = BUTTON_PIN[Button];
 800937c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009380:	60fb      	str	r3, [r7, #12]
    gpioinitstruct.Pull = GPIO_PULLUP;
 8009382:	2301      	movs	r3, #1
 8009384:	617b      	str	r3, [r7, #20]
    gpioinitstruct.Mode = GPIO_MODE_IT_FALLING; 
 8009386:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
 800938a:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpioinitstruct);
 800938c:	79fb      	ldrb	r3, [r7, #7]
 800938e:	4a0c      	ldr	r2, [pc, #48]	; (80093c0 <BSP_PB_Init+0x9c>)
 8009390:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009394:	f107 020c 	add.w	r2, r7, #12
 8009398:	4611      	mov	r1, r2
 800939a:	4618      	mov	r0, r3
 800939c:	f000 fcea 	bl	8009d74 <HAL_GPIO_Init>
    
    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 80093a0:	2328      	movs	r3, #40	; 0x28
 80093a2:	b25b      	sxtb	r3, r3
 80093a4:	2200      	movs	r2, #0
 80093a6:	210f      	movs	r1, #15
 80093a8:	4618      	mov	r0, r3
 80093aa:	f000 fa38 	bl	800981e <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 80093ae:	2328      	movs	r3, #40	; 0x28
 80093b0:	b25b      	sxtb	r3, r3
 80093b2:	4618      	mov	r0, r3
 80093b4:	f000 fa4d 	bl	8009852 <HAL_NVIC_EnableIRQ>
  }
}
 80093b8:	bf00      	nop
 80093ba:	3720      	adds	r7, #32
 80093bc:	46bd      	mov	sp, r7
 80093be:	bd80      	pop	{r7, pc}
 80093c0:	20000014 	.word	0x20000014

080093c4 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80093c4:	b480      	push	{r7}
 80093c6:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined(VECT_TAB_SRAM) && defined(VECT_TAB_BASE_ADDRESS)  
  /* program in SRAMx */
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;  /* Vector Table Relocation in Internal SRAMx for CPU1 */
#else    /* program in FLASH */
  SCB->VTOR = VECT_TAB_OFFSET;              /* Vector Table Relocation in Internal FLASH */
 80093c8:	4b26      	ldr	r3, [pc, #152]	; (8009464 <SystemInit+0xa0>)
 80093ca:	2200      	movs	r2, #0
 80093cc:	609a      	str	r2, [r3, #8]
#endif

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
 80093ce:	4b25      	ldr	r3, [pc, #148]	; (8009464 <SystemInit+0xa0>)
 80093d0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80093d4:	4a23      	ldr	r2, [pc, #140]	; (8009464 <SystemInit+0xa0>)
 80093d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80093da:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 80093de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80093e2:	681b      	ldr	r3, [r3, #0]
 80093e4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80093e8:	f043 0301 	orr.w	r3, r3, #1
 80093ec:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 80093ee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80093f2:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 80093f6:	609a      	str	r2, [r3, #8]

  /* Reset PLLSAI1ON, PLLON, HSECSSON, HSEON, HSION, and MSIPLLON bits */
  RCC->CR &= (uint32_t)0xFAF6FEFBU;
 80093f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80093fc:	681a      	ldr	r2, [r3, #0]
 80093fe:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8009402:	4b19      	ldr	r3, [pc, #100]	; (8009468 <SystemInit+0xa4>)
 8009404:	4013      	ands	r3, r2
 8009406:	600b      	str	r3, [r1, #0]

  /*!< Reset LSI1 and LSI2 bits */
  RCC->CSR &= (uint32_t)0xFFFFFFFAU;
 8009408:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800940c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8009410:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8009414:	f023 0305 	bic.w	r3, r3, #5
 8009418:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  
  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 800941c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009420:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8009424:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8009428:	f023 0301 	bic.w	r3, r3, #1
 800942c:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    
  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22041000U;
 8009430:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009434:	4a0d      	ldr	r2, [pc, #52]	; (800946c <SystemInit+0xa8>)
 8009436:	60da      	str	r2, [r3, #12]

  /* Reset PLLSAI1CFGR register */
  RCC->PLLSAI1CFGR = 0x22041000U;
 8009438:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800943c:	4a0b      	ldr	r2, [pc, #44]	; (800946c <SystemInit+0xa8>)
 800943e:	611a      	str	r2, [r3, #16]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8009440:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009444:	681b      	ldr	r3, [r3, #0]
 8009446:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800944a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800944e:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8009450:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009454:	2200      	movs	r2, #0
 8009456:	619a      	str	r2, [r3, #24]
}
 8009458:	bf00      	nop
 800945a:	46bd      	mov	sp, r7
 800945c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009460:	4770      	bx	lr
 8009462:	bf00      	nop
 8009464:	e000ed00 	.word	0xe000ed00
 8009468:	faf6fefb 	.word	0xfaf6fefb
 800946c:	22041000 	.word	0x22041000

08009470 <LL_DBGMCU_EnableDBGSleepMode>:
  * @brief  Enable the Debug Module during SLEEP mode
  * @rmtoll DBGMCU_CR    DBG_SLEEP     LL_DBGMCU_EnableDBGSleepMode
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_EnableDBGSleepMode(void)
{
 8009470:	b480      	push	{r7}
 8009472:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8009474:	4b05      	ldr	r3, [pc, #20]	; (800948c <LL_DBGMCU_EnableDBGSleepMode+0x1c>)
 8009476:	685b      	ldr	r3, [r3, #4]
 8009478:	4a04      	ldr	r2, [pc, #16]	; (800948c <LL_DBGMCU_EnableDBGSleepMode+0x1c>)
 800947a:	f043 0301 	orr.w	r3, r3, #1
 800947e:	6053      	str	r3, [r2, #4]
}
 8009480:	bf00      	nop
 8009482:	46bd      	mov	sp, r7
 8009484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009488:	4770      	bx	lr
 800948a:	bf00      	nop
 800948c:	e0042000 	.word	0xe0042000

08009490 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8009490:	b580      	push	{r7, lr}
 8009492:	b082      	sub	sp, #8
 8009494:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 8009496:	2300      	movs	r3, #0
 8009498:	71fb      	strb	r3, [r7, #7]
#if (DATA_CACHE_ENABLE == 0U)
  __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800949a:	4b0c      	ldr	r3, [pc, #48]	; (80094cc <HAL_Init+0x3c>)
 800949c:	681b      	ldr	r3, [r3, #0]
 800949e:	4a0b      	ldr	r2, [pc, #44]	; (80094cc <HAL_Init+0x3c>)
 80094a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80094a4:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80094a6:	2003      	movs	r0, #3
 80094a8:	f000 f9ae 	bl	8009808 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80094ac:	2000      	movs	r0, #0
 80094ae:	f000 f80f 	bl	80094d0 <HAL_InitTick>
 80094b2:	4603      	mov	r3, r0
 80094b4:	2b00      	cmp	r3, #0
 80094b6:	d002      	beq.n	80094be <HAL_Init+0x2e>
  {
    status = HAL_ERROR;
 80094b8:	2301      	movs	r3, #1
 80094ba:	71fb      	strb	r3, [r7, #7]
 80094bc:	e001      	b.n	80094c2 <HAL_Init+0x32>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80094be:	f7fe fc94 	bl	8007dea <HAL_MspInit>
  }

  /* Return function status */
  return status;
 80094c2:	79fb      	ldrb	r3, [r7, #7]
}
 80094c4:	4618      	mov	r0, r3
 80094c6:	3708      	adds	r7, #8
 80094c8:	46bd      	mov	sp, r7
 80094ca:	bd80      	pop	{r7, pc}
 80094cc:	58004000 	.word	0x58004000

080094d0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80094d0:	b580      	push	{r7, lr}
 80094d2:	b084      	sub	sp, #16
 80094d4:	af00      	add	r7, sp, #0
 80094d6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 80094d8:	2300      	movs	r3, #0
 80094da:	73fb      	strb	r3, [r7, #15]

  if ((uint32_t)uwTickFreq != 0U)
 80094dc:	4b17      	ldr	r3, [pc, #92]	; (800953c <HAL_InitTick+0x6c>)
 80094de:	781b      	ldrb	r3, [r3, #0]
 80094e0:	2b00      	cmp	r3, #0
 80094e2:	d024      	beq.n	800952e <HAL_InitTick+0x5e>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 80094e4:	f003 fc8e 	bl	800ce04 <HAL_RCC_GetHCLKFreq>
 80094e8:	4602      	mov	r2, r0
 80094ea:	4b14      	ldr	r3, [pc, #80]	; (800953c <HAL_InitTick+0x6c>)
 80094ec:	781b      	ldrb	r3, [r3, #0]
 80094ee:	4619      	mov	r1, r3
 80094f0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80094f4:	fbb3 f3f1 	udiv	r3, r3, r1
 80094f8:	fbb2 f3f3 	udiv	r3, r2, r3
 80094fc:	4618      	mov	r0, r3
 80094fe:	f000 f9c4 	bl	800988a <HAL_SYSTICK_Config>
 8009502:	4603      	mov	r3, r0
 8009504:	2b00      	cmp	r3, #0
 8009506:	d10f      	bne.n	8009528 <HAL_InitTick+0x58>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8009508:	687b      	ldr	r3, [r7, #4]
 800950a:	2b0f      	cmp	r3, #15
 800950c:	d809      	bhi.n	8009522 <HAL_InitTick+0x52>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800950e:	2200      	movs	r2, #0
 8009510:	6879      	ldr	r1, [r7, #4]
 8009512:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8009516:	f000 f982 	bl	800981e <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800951a:	4a09      	ldr	r2, [pc, #36]	; (8009540 <HAL_InitTick+0x70>)
 800951c:	687b      	ldr	r3, [r7, #4]
 800951e:	6013      	str	r3, [r2, #0]
 8009520:	e007      	b.n	8009532 <HAL_InitTick+0x62>
      }
      else
      {
        status = HAL_ERROR;
 8009522:	2301      	movs	r3, #1
 8009524:	73fb      	strb	r3, [r7, #15]
 8009526:	e004      	b.n	8009532 <HAL_InitTick+0x62>
      }
    }
    else
    {
      status = HAL_ERROR;
 8009528:	2301      	movs	r3, #1
 800952a:	73fb      	strb	r3, [r7, #15]
 800952c:	e001      	b.n	8009532 <HAL_InitTick+0x62>
    }
  }
  else
  {
    status = HAL_ERROR;
 800952e:	2301      	movs	r3, #1
 8009530:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 8009532:	7bfb      	ldrb	r3, [r7, #15]
}
 8009534:	4618      	mov	r0, r3
 8009536:	3710      	adds	r7, #16
 8009538:	46bd      	mov	sp, r7
 800953a:	bd80      	pop	{r7, pc}
 800953c:	20000020 	.word	0x20000020
 8009540:	2000001c 	.word	0x2000001c

08009544 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8009544:	b480      	push	{r7}
 8009546:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8009548:	4b06      	ldr	r3, [pc, #24]	; (8009564 <HAL_IncTick+0x20>)
 800954a:	781b      	ldrb	r3, [r3, #0]
 800954c:	461a      	mov	r2, r3
 800954e:	4b06      	ldr	r3, [pc, #24]	; (8009568 <HAL_IncTick+0x24>)
 8009550:	681b      	ldr	r3, [r3, #0]
 8009552:	4413      	add	r3, r2
 8009554:	4a04      	ldr	r2, [pc, #16]	; (8009568 <HAL_IncTick+0x24>)
 8009556:	6013      	str	r3, [r2, #0]
}
 8009558:	bf00      	nop
 800955a:	46bd      	mov	sp, r7
 800955c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009560:	4770      	bx	lr
 8009562:	bf00      	nop
 8009564:	20000020 	.word	0x20000020
 8009568:	20000dac 	.word	0x20000dac

0800956c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800956c:	b480      	push	{r7}
 800956e:	af00      	add	r7, sp, #0
  return uwTick;
 8009570:	4b03      	ldr	r3, [pc, #12]	; (8009580 <HAL_GetTick+0x14>)
 8009572:	681b      	ldr	r3, [r3, #0]
}
 8009574:	4618      	mov	r0, r3
 8009576:	46bd      	mov	sp, r7
 8009578:	f85d 7b04 	ldr.w	r7, [sp], #4
 800957c:	4770      	bx	lr
 800957e:	bf00      	nop
 8009580:	20000dac 	.word	0x20000dac

08009584 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
 8009584:	b480      	push	{r7}
 8009586:	af00      	add	r7, sp, #0
  return uwTickPrio;
 8009588:	4b03      	ldr	r3, [pc, #12]	; (8009598 <HAL_GetTickPrio+0x14>)
 800958a:	681b      	ldr	r3, [r3, #0]
}
 800958c:	4618      	mov	r0, r3
 800958e:	46bd      	mov	sp, r7
 8009590:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009594:	4770      	bx	lr
 8009596:	bf00      	nop
 8009598:	2000001c 	.word	0x2000001c

0800959c <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
 800959c:	b580      	push	{r7, lr}
 800959e:	af00      	add	r7, sp, #0
  LL_DBGMCU_EnableDBGSleepMode();
 80095a0:	f7ff ff66 	bl	8009470 <LL_DBGMCU_EnableDBGSleepMode>
}
 80095a4:	bf00      	nop
 80095a6:	bd80      	pop	{r7, pc}

080095a8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80095a8:	b480      	push	{r7}
 80095aa:	b085      	sub	sp, #20
 80095ac:	af00      	add	r7, sp, #0
 80095ae:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80095b0:	687b      	ldr	r3, [r7, #4]
 80095b2:	f003 0307 	and.w	r3, r3, #7
 80095b6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80095b8:	4b0c      	ldr	r3, [pc, #48]	; (80095ec <__NVIC_SetPriorityGrouping+0x44>)
 80095ba:	68db      	ldr	r3, [r3, #12]
 80095bc:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80095be:	68ba      	ldr	r2, [r7, #8]
 80095c0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80095c4:	4013      	ands	r3, r2
 80095c6:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80095c8:	68fb      	ldr	r3, [r7, #12]
 80095ca:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80095cc:	68bb      	ldr	r3, [r7, #8]
 80095ce:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80095d0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80095d4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80095d8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80095da:	4a04      	ldr	r2, [pc, #16]	; (80095ec <__NVIC_SetPriorityGrouping+0x44>)
 80095dc:	68bb      	ldr	r3, [r7, #8]
 80095de:	60d3      	str	r3, [r2, #12]
}
 80095e0:	bf00      	nop
 80095e2:	3714      	adds	r7, #20
 80095e4:	46bd      	mov	sp, r7
 80095e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80095ea:	4770      	bx	lr
 80095ec:	e000ed00 	.word	0xe000ed00

080095f0 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 80095f0:	b480      	push	{r7}
 80095f2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80095f4:	4b04      	ldr	r3, [pc, #16]	; (8009608 <__NVIC_GetPriorityGrouping+0x18>)
 80095f6:	68db      	ldr	r3, [r3, #12]
 80095f8:	0a1b      	lsrs	r3, r3, #8
 80095fa:	f003 0307 	and.w	r3, r3, #7
}
 80095fe:	4618      	mov	r0, r3
 8009600:	46bd      	mov	sp, r7
 8009602:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009606:	4770      	bx	lr
 8009608:	e000ed00 	.word	0xe000ed00

0800960c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800960c:	b480      	push	{r7}
 800960e:	b083      	sub	sp, #12
 8009610:	af00      	add	r7, sp, #0
 8009612:	4603      	mov	r3, r0
 8009614:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8009616:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800961a:	2b00      	cmp	r3, #0
 800961c:	db0b      	blt.n	8009636 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800961e:	79fb      	ldrb	r3, [r7, #7]
 8009620:	f003 021f 	and.w	r2, r3, #31
 8009624:	4907      	ldr	r1, [pc, #28]	; (8009644 <__NVIC_EnableIRQ+0x38>)
 8009626:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800962a:	095b      	lsrs	r3, r3, #5
 800962c:	2001      	movs	r0, #1
 800962e:	fa00 f202 	lsl.w	r2, r0, r2
 8009632:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8009636:	bf00      	nop
 8009638:	370c      	adds	r7, #12
 800963a:	46bd      	mov	sp, r7
 800963c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009640:	4770      	bx	lr
 8009642:	bf00      	nop
 8009644:	e000e100 	.word	0xe000e100

08009648 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8009648:	b480      	push	{r7}
 800964a:	b083      	sub	sp, #12
 800964c:	af00      	add	r7, sp, #0
 800964e:	4603      	mov	r3, r0
 8009650:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8009652:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009656:	2b00      	cmp	r3, #0
 8009658:	db12      	blt.n	8009680 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800965a:	79fb      	ldrb	r3, [r7, #7]
 800965c:	f003 021f 	and.w	r2, r3, #31
 8009660:	490a      	ldr	r1, [pc, #40]	; (800968c <__NVIC_DisableIRQ+0x44>)
 8009662:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009666:	095b      	lsrs	r3, r3, #5
 8009668:	2001      	movs	r0, #1
 800966a:	fa00 f202 	lsl.w	r2, r0, r2
 800966e:	3320      	adds	r3, #32
 8009670:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8009674:	f3bf 8f4f 	dsb	sy
}
 8009678:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800967a:	f3bf 8f6f 	isb	sy
}
 800967e:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 8009680:	bf00      	nop
 8009682:	370c      	adds	r7, #12
 8009684:	46bd      	mov	sp, r7
 8009686:	f85d 7b04 	ldr.w	r7, [sp], #4
 800968a:	4770      	bx	lr
 800968c:	e000e100 	.word	0xe000e100

08009690 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 8009690:	b480      	push	{r7}
 8009692:	b083      	sub	sp, #12
 8009694:	af00      	add	r7, sp, #0
 8009696:	4603      	mov	r3, r0
 8009698:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800969a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800969e:	2b00      	cmp	r3, #0
 80096a0:	db0c      	blt.n	80096bc <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80096a2:	79fb      	ldrb	r3, [r7, #7]
 80096a4:	f003 021f 	and.w	r2, r3, #31
 80096a8:	4907      	ldr	r1, [pc, #28]	; (80096c8 <__NVIC_SetPendingIRQ+0x38>)
 80096aa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80096ae:	095b      	lsrs	r3, r3, #5
 80096b0:	2001      	movs	r0, #1
 80096b2:	fa00 f202 	lsl.w	r2, r0, r2
 80096b6:	3340      	adds	r3, #64	; 0x40
 80096b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 80096bc:	bf00      	nop
 80096be:	370c      	adds	r7, #12
 80096c0:	46bd      	mov	sp, r7
 80096c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80096c6:	4770      	bx	lr
 80096c8:	e000e100 	.word	0xe000e100

080096cc <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 80096cc:	b480      	push	{r7}
 80096ce:	b083      	sub	sp, #12
 80096d0:	af00      	add	r7, sp, #0
 80096d2:	4603      	mov	r3, r0
 80096d4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80096d6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80096da:	2b00      	cmp	r3, #0
 80096dc:	db0c      	blt.n	80096f8 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80096de:	79fb      	ldrb	r3, [r7, #7]
 80096e0:	f003 021f 	and.w	r2, r3, #31
 80096e4:	4907      	ldr	r1, [pc, #28]	; (8009704 <__NVIC_ClearPendingIRQ+0x38>)
 80096e6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80096ea:	095b      	lsrs	r3, r3, #5
 80096ec:	2001      	movs	r0, #1
 80096ee:	fa00 f202 	lsl.w	r2, r0, r2
 80096f2:	3360      	adds	r3, #96	; 0x60
 80096f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 80096f8:	bf00      	nop
 80096fa:	370c      	adds	r7, #12
 80096fc:	46bd      	mov	sp, r7
 80096fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009702:	4770      	bx	lr
 8009704:	e000e100 	.word	0xe000e100

08009708 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8009708:	b480      	push	{r7}
 800970a:	b083      	sub	sp, #12
 800970c:	af00      	add	r7, sp, #0
 800970e:	4603      	mov	r3, r0
 8009710:	6039      	str	r1, [r7, #0]
 8009712:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8009714:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009718:	2b00      	cmp	r3, #0
 800971a:	db0a      	blt.n	8009732 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800971c:	683b      	ldr	r3, [r7, #0]
 800971e:	b2da      	uxtb	r2, r3
 8009720:	490c      	ldr	r1, [pc, #48]	; (8009754 <__NVIC_SetPriority+0x4c>)
 8009722:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009726:	0112      	lsls	r2, r2, #4
 8009728:	b2d2      	uxtb	r2, r2
 800972a:	440b      	add	r3, r1
 800972c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8009730:	e00a      	b.n	8009748 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009732:	683b      	ldr	r3, [r7, #0]
 8009734:	b2da      	uxtb	r2, r3
 8009736:	4908      	ldr	r1, [pc, #32]	; (8009758 <__NVIC_SetPriority+0x50>)
 8009738:	79fb      	ldrb	r3, [r7, #7]
 800973a:	f003 030f 	and.w	r3, r3, #15
 800973e:	3b04      	subs	r3, #4
 8009740:	0112      	lsls	r2, r2, #4
 8009742:	b2d2      	uxtb	r2, r2
 8009744:	440b      	add	r3, r1
 8009746:	761a      	strb	r2, [r3, #24]
}
 8009748:	bf00      	nop
 800974a:	370c      	adds	r7, #12
 800974c:	46bd      	mov	sp, r7
 800974e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009752:	4770      	bx	lr
 8009754:	e000e100 	.word	0xe000e100
 8009758:	e000ed00 	.word	0xe000ed00

0800975c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800975c:	b480      	push	{r7}
 800975e:	b089      	sub	sp, #36	; 0x24
 8009760:	af00      	add	r7, sp, #0
 8009762:	60f8      	str	r0, [r7, #12]
 8009764:	60b9      	str	r1, [r7, #8]
 8009766:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8009768:	68fb      	ldr	r3, [r7, #12]
 800976a:	f003 0307 	and.w	r3, r3, #7
 800976e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8009770:	69fb      	ldr	r3, [r7, #28]
 8009772:	f1c3 0307 	rsb	r3, r3, #7
 8009776:	2b04      	cmp	r3, #4
 8009778:	bf28      	it	cs
 800977a:	2304      	movcs	r3, #4
 800977c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800977e:	69fb      	ldr	r3, [r7, #28]
 8009780:	3304      	adds	r3, #4
 8009782:	2b06      	cmp	r3, #6
 8009784:	d902      	bls.n	800978c <NVIC_EncodePriority+0x30>
 8009786:	69fb      	ldr	r3, [r7, #28]
 8009788:	3b03      	subs	r3, #3
 800978a:	e000      	b.n	800978e <NVIC_EncodePriority+0x32>
 800978c:	2300      	movs	r3, #0
 800978e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8009790:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009794:	69bb      	ldr	r3, [r7, #24]
 8009796:	fa02 f303 	lsl.w	r3, r2, r3
 800979a:	43da      	mvns	r2, r3
 800979c:	68bb      	ldr	r3, [r7, #8]
 800979e:	401a      	ands	r2, r3
 80097a0:	697b      	ldr	r3, [r7, #20]
 80097a2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80097a4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80097a8:	697b      	ldr	r3, [r7, #20]
 80097aa:	fa01 f303 	lsl.w	r3, r1, r3
 80097ae:	43d9      	mvns	r1, r3
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80097b4:	4313      	orrs	r3, r2
         );
}
 80097b6:	4618      	mov	r0, r3
 80097b8:	3724      	adds	r7, #36	; 0x24
 80097ba:	46bd      	mov	sp, r7
 80097bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097c0:	4770      	bx	lr
	...

080097c4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80097c4:	b580      	push	{r7, lr}
 80097c6:	b082      	sub	sp, #8
 80097c8:	af00      	add	r7, sp, #0
 80097ca:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80097cc:	687b      	ldr	r3, [r7, #4]
 80097ce:	3b01      	subs	r3, #1
 80097d0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80097d4:	d301      	bcc.n	80097da <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 80097d6:	2301      	movs	r3, #1
 80097d8:	e00f      	b.n	80097fa <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80097da:	4a0a      	ldr	r2, [pc, #40]	; (8009804 <SysTick_Config+0x40>)
 80097dc:	687b      	ldr	r3, [r7, #4]
 80097de:	3b01      	subs	r3, #1
 80097e0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80097e2:	210f      	movs	r1, #15
 80097e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80097e8:	f7ff ff8e 	bl	8009708 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80097ec:	4b05      	ldr	r3, [pc, #20]	; (8009804 <SysTick_Config+0x40>)
 80097ee:	2200      	movs	r2, #0
 80097f0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80097f2:	4b04      	ldr	r3, [pc, #16]	; (8009804 <SysTick_Config+0x40>)
 80097f4:	2207      	movs	r2, #7
 80097f6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80097f8:	2300      	movs	r3, #0
}
 80097fa:	4618      	mov	r0, r3
 80097fc:	3708      	adds	r7, #8
 80097fe:	46bd      	mov	sp, r7
 8009800:	bd80      	pop	{r7, pc}
 8009802:	bf00      	nop
 8009804:	e000e010 	.word	0xe000e010

08009808 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8009808:	b580      	push	{r7, lr}
 800980a:	b082      	sub	sp, #8
 800980c:	af00      	add	r7, sp, #0
 800980e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8009810:	6878      	ldr	r0, [r7, #4]
 8009812:	f7ff fec9 	bl	80095a8 <__NVIC_SetPriorityGrouping>
}
 8009816:	bf00      	nop
 8009818:	3708      	adds	r7, #8
 800981a:	46bd      	mov	sp, r7
 800981c:	bd80      	pop	{r7, pc}

0800981e <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800981e:	b580      	push	{r7, lr}
 8009820:	b086      	sub	sp, #24
 8009822:	af00      	add	r7, sp, #0
 8009824:	4603      	mov	r3, r0
 8009826:	60b9      	str	r1, [r7, #8]
 8009828:	607a      	str	r2, [r7, #4]
 800982a:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 800982c:	f7ff fee0 	bl	80095f0 <__NVIC_GetPriorityGrouping>
 8009830:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8009832:	687a      	ldr	r2, [r7, #4]
 8009834:	68b9      	ldr	r1, [r7, #8]
 8009836:	6978      	ldr	r0, [r7, #20]
 8009838:	f7ff ff90 	bl	800975c <NVIC_EncodePriority>
 800983c:	4602      	mov	r2, r0
 800983e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8009842:	4611      	mov	r1, r2
 8009844:	4618      	mov	r0, r3
 8009846:	f7ff ff5f 	bl	8009708 <__NVIC_SetPriority>
}
 800984a:	bf00      	nop
 800984c:	3718      	adds	r7, #24
 800984e:	46bd      	mov	sp, r7
 8009850:	bd80      	pop	{r7, pc}

08009852 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009852:	b580      	push	{r7, lr}
 8009854:	b082      	sub	sp, #8
 8009856:	af00      	add	r7, sp, #0
 8009858:	4603      	mov	r3, r0
 800985a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800985c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009860:	4618      	mov	r0, r3
 8009862:	f7ff fed3 	bl	800960c <__NVIC_EnableIRQ>
}
 8009866:	bf00      	nop
 8009868:	3708      	adds	r7, #8
 800986a:	46bd      	mov	sp, r7
 800986c:	bd80      	pop	{r7, pc}

0800986e <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800986e:	b580      	push	{r7, lr}
 8009870:	b082      	sub	sp, #8
 8009872:	af00      	add	r7, sp, #0
 8009874:	4603      	mov	r3, r0
 8009876:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8009878:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800987c:	4618      	mov	r0, r3
 800987e:	f7ff fee3 	bl	8009648 <__NVIC_DisableIRQ>
}
 8009882:	bf00      	nop
 8009884:	3708      	adds	r7, #8
 8009886:	46bd      	mov	sp, r7
 8009888:	bd80      	pop	{r7, pc}

0800988a <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800988a:	b580      	push	{r7, lr}
 800988c:	b082      	sub	sp, #8
 800988e:	af00      	add	r7, sp, #0
 8009890:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 8009892:	6878      	ldr	r0, [r7, #4]
 8009894:	f7ff ff96 	bl	80097c4 <SysTick_Config>
 8009898:	4603      	mov	r3, r0
}
 800989a:	4618      	mov	r0, r3
 800989c:	3708      	adds	r7, #8
 800989e:	46bd      	mov	sp, r7
 80098a0:	bd80      	pop	{r7, pc}

080098a2 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 80098a2:	b580      	push	{r7, lr}
 80098a4:	b082      	sub	sp, #8
 80098a6:	af00      	add	r7, sp, #0
 80098a8:	4603      	mov	r3, r0
 80098aa:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
 80098ac:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80098b0:	4618      	mov	r0, r3
 80098b2:	f7ff feed 	bl	8009690 <__NVIC_SetPendingIRQ>
}
 80098b6:	bf00      	nop
 80098b8:	3708      	adds	r7, #8
 80098ba:	46bd      	mov	sp, r7
 80098bc:	bd80      	pop	{r7, pc}

080098be <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 80098be:	b580      	push	{r7, lr}
 80098c0:	b082      	sub	sp, #8
 80098c2:	af00      	add	r7, sp, #0
 80098c4:	4603      	mov	r3, r0
 80098c6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
 80098c8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80098cc:	4618      	mov	r0, r3
 80098ce:	f7ff fefd 	bl	80096cc <__NVIC_ClearPendingIRQ>
}
 80098d2:	bf00      	nop
 80098d4:	3708      	adds	r7, #8
 80098d6:	46bd      	mov	sp, r7
 80098d8:	bd80      	pop	{r7, pc}

080098da <HAL_DMA_Abort>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80098da:	b480      	push	{r7}
 80098dc:	b083      	sub	sp, #12
 80098de:	af00      	add	r7, sp, #0
 80098e0:	6078      	str	r0, [r7, #4]

  /* Check the DMA peripheral handle */
  if (NULL == hdma)
 80098e2:	687b      	ldr	r3, [r7, #4]
 80098e4:	2b00      	cmp	r3, #0
 80098e6:	d101      	bne.n	80098ec <HAL_DMA_Abort+0x12>
  {
    return HAL_ERROR;
 80098e8:	2301      	movs	r3, #1
 80098ea:	e04f      	b.n	800998c <HAL_DMA_Abort+0xb2>
  }

  /* Check the DMA peripheral state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
 80098ec:	687b      	ldr	r3, [r7, #4]
 80098ee:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80098f2:	b2db      	uxtb	r3, r3
 80098f4:	2b02      	cmp	r3, #2
 80098f6:	d008      	beq.n	800990a <HAL_DMA_Abort+0x30>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80098f8:	687b      	ldr	r3, [r7, #4]
 80098fa:	2204      	movs	r2, #4
 80098fc:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80098fe:	687b      	ldr	r3, [r7, #4]
 8009900:	2200      	movs	r2, #0
 8009902:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    return HAL_ERROR;
 8009906:	2301      	movs	r3, #1
 8009908:	e040      	b.n	800998c <HAL_DMA_Abort+0xb2>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800990a:	687b      	ldr	r3, [r7, #4]
 800990c:	681b      	ldr	r3, [r3, #0]
 800990e:	681a      	ldr	r2, [r3, #0]
 8009910:	687b      	ldr	r3, [r7, #4]
 8009912:	681b      	ldr	r3, [r3, #0]
 8009914:	f022 020e 	bic.w	r2, r2, #14
 8009918:	601a      	str	r2, [r3, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800991a:	687b      	ldr	r3, [r7, #4]
 800991c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800991e:	681a      	ldr	r2, [r3, #0]
 8009920:	687b      	ldr	r3, [r7, #4]
 8009922:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009924:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009928:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 800992a:	687b      	ldr	r3, [r7, #4]
 800992c:	681b      	ldr	r3, [r3, #0]
 800992e:	681a      	ldr	r2, [r3, #0]
 8009930:	687b      	ldr	r3, [r7, #4]
 8009932:	681b      	ldr	r3, [r3, #0]
 8009934:	f022 0201 	bic.w	r2, r2, #1
 8009938:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800993a:	687b      	ldr	r3, [r7, #4]
 800993c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800993e:	f003 021c 	and.w	r2, r3, #28
 8009942:	687b      	ldr	r3, [r7, #4]
 8009944:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009946:	2101      	movs	r1, #1
 8009948:	fa01 f202 	lsl.w	r2, r1, r2
 800994c:	605a      	str	r2, [r3, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800994e:	687b      	ldr	r3, [r7, #4]
 8009950:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009952:	687a      	ldr	r2, [r7, #4]
 8009954:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8009956:	605a      	str	r2, [r3, #4]

    if (hdma->DMAmuxRequestGen != 0U)
 8009958:	687b      	ldr	r3, [r7, #4]
 800995a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800995c:	2b00      	cmp	r3, #0
 800995e:	d00c      	beq.n	800997a <HAL_DMA_Abort+0xa0>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8009960:	687b      	ldr	r3, [r7, #4]
 8009962:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009964:	681a      	ldr	r2, [r3, #0]
 8009966:	687b      	ldr	r3, [r7, #4]
 8009968:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800996a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800996e:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8009970:	687b      	ldr	r3, [r7, #4]
 8009972:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009974:	687a      	ldr	r2, [r7, #4]
 8009976:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8009978:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800997a:	687b      	ldr	r3, [r7, #4]
 800997c:	2201      	movs	r2, #1
 800997e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009982:	687b      	ldr	r3, [r7, #4]
 8009984:	2200      	movs	r2, #0
 8009986:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  }

  return HAL_OK;
 800998a:	2300      	movs	r3, #0
}
 800998c:	4618      	mov	r0, r3
 800998e:	370c      	adds	r7, #12
 8009990:	46bd      	mov	sp, r7
 8009992:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009996:	4770      	bx	lr

08009998 <HAL_DMA_Abort_IT>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8009998:	b580      	push	{r7, lr}
 800999a:	b084      	sub	sp, #16
 800999c:	af00      	add	r7, sp, #0
 800999e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80099a0:	2300      	movs	r3, #0
 80099a2:	73fb      	strb	r3, [r7, #15]

  if (HAL_DMA_STATE_BUSY != hdma->State)
 80099a4:	687b      	ldr	r3, [r7, #4]
 80099a6:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80099aa:	b2db      	uxtb	r3, r3
 80099ac:	2b02      	cmp	r3, #2
 80099ae:	d005      	beq.n	80099bc <HAL_DMA_Abort_IT+0x24>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80099b0:	687b      	ldr	r3, [r7, #4]
 80099b2:	2204      	movs	r2, #4
 80099b4:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 80099b6:	2301      	movs	r3, #1
 80099b8:	73fb      	strb	r3, [r7, #15]
 80099ba:	e047      	b.n	8009a4c <HAL_DMA_Abort_IT+0xb4>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80099bc:	687b      	ldr	r3, [r7, #4]
 80099be:	681b      	ldr	r3, [r3, #0]
 80099c0:	681a      	ldr	r2, [r3, #0]
 80099c2:	687b      	ldr	r3, [r7, #4]
 80099c4:	681b      	ldr	r3, [r3, #0]
 80099c6:	f022 020e 	bic.w	r2, r2, #14
 80099ca:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 80099cc:	687b      	ldr	r3, [r7, #4]
 80099ce:	681b      	ldr	r3, [r3, #0]
 80099d0:	681a      	ldr	r2, [r3, #0]
 80099d2:	687b      	ldr	r3, [r7, #4]
 80099d4:	681b      	ldr	r3, [r3, #0]
 80099d6:	f022 0201 	bic.w	r2, r2, #1
 80099da:	601a      	str	r2, [r3, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80099dc:	687b      	ldr	r3, [r7, #4]
 80099de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80099e0:	681a      	ldr	r2, [r3, #0]
 80099e2:	687b      	ldr	r3, [r7, #4]
 80099e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80099e6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80099ea:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 80099ec:	687b      	ldr	r3, [r7, #4]
 80099ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80099f0:	f003 021c 	and.w	r2, r3, #28
 80099f4:	687b      	ldr	r3, [r7, #4]
 80099f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80099f8:	2101      	movs	r1, #1
 80099fa:	fa01 f202 	lsl.w	r2, r1, r2
 80099fe:	605a      	str	r2, [r3, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8009a00:	687b      	ldr	r3, [r7, #4]
 8009a02:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009a04:	687a      	ldr	r2, [r7, #4]
 8009a06:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8009a08:	605a      	str	r2, [r3, #4]

    if (hdma->DMAmuxRequestGen != 0U)
 8009a0a:	687b      	ldr	r3, [r7, #4]
 8009a0c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009a0e:	2b00      	cmp	r3, #0
 8009a10:	d00c      	beq.n	8009a2c <HAL_DMA_Abort_IT+0x94>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8009a12:	687b      	ldr	r3, [r7, #4]
 8009a14:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009a16:	681a      	ldr	r2, [r3, #0]
 8009a18:	687b      	ldr	r3, [r7, #4]
 8009a1a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009a1c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009a20:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8009a22:	687b      	ldr	r3, [r7, #4]
 8009a24:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009a26:	687a      	ldr	r2, [r7, #4]
 8009a28:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8009a2a:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8009a2c:	687b      	ldr	r3, [r7, #4]
 8009a2e:	2201      	movs	r2, #1
 8009a30:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009a34:	687b      	ldr	r3, [r7, #4]
 8009a36:	2200      	movs	r2, #0
 8009a38:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /* Call User Abort callback */
    if (hdma->XferAbortCallback != NULL)
 8009a3c:	687b      	ldr	r3, [r7, #4]
 8009a3e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009a40:	2b00      	cmp	r3, #0
 8009a42:	d003      	beq.n	8009a4c <HAL_DMA_Abort_IT+0xb4>
    {
      hdma->XferAbortCallback(hdma);
 8009a44:	687b      	ldr	r3, [r7, #4]
 8009a46:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009a48:	6878      	ldr	r0, [r7, #4]
 8009a4a:	4798      	blx	r3
    }
  }
  return status;
 8009a4c:	7bfb      	ldrb	r3, [r7, #15]
}
 8009a4e:	4618      	mov	r0, r3
 8009a50:	3710      	adds	r7, #16
 8009a52:	46bd      	mov	sp, r7
 8009a54:	bd80      	pop	{r7, pc}

08009a56 <HAL_DMA_IRQHandler>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8009a56:	b580      	push	{r7, lr}
 8009a58:	b084      	sub	sp, #16
 8009a5a:	af00      	add	r7, sp, #0
 8009a5c:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8009a5e:	687b      	ldr	r3, [r7, #4]
 8009a60:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009a62:	681b      	ldr	r3, [r3, #0]
 8009a64:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
 8009a66:	687b      	ldr	r3, [r7, #4]
 8009a68:	681b      	ldr	r3, [r3, #0]
 8009a6a:	681b      	ldr	r3, [r3, #0]
 8009a6c:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8009a6e:	687b      	ldr	r3, [r7, #4]
 8009a70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009a72:	f003 031c 	and.w	r3, r3, #28
 8009a76:	2204      	movs	r2, #4
 8009a78:	409a      	lsls	r2, r3
 8009a7a:	68fb      	ldr	r3, [r7, #12]
 8009a7c:	4013      	ands	r3, r2
 8009a7e:	2b00      	cmp	r3, #0
 8009a80:	d026      	beq.n	8009ad0 <HAL_DMA_IRQHandler+0x7a>
 8009a82:	68bb      	ldr	r3, [r7, #8]
 8009a84:	f003 0304 	and.w	r3, r3, #4
 8009a88:	2b00      	cmp	r3, #0
 8009a8a:	d021      	beq.n	8009ad0 <HAL_DMA_IRQHandler+0x7a>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8009a8c:	687b      	ldr	r3, [r7, #4]
 8009a8e:	681b      	ldr	r3, [r3, #0]
 8009a90:	681b      	ldr	r3, [r3, #0]
 8009a92:	f003 0320 	and.w	r3, r3, #32
 8009a96:	2b00      	cmp	r3, #0
 8009a98:	d107      	bne.n	8009aaa <HAL_DMA_IRQHandler+0x54>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8009a9a:	687b      	ldr	r3, [r7, #4]
 8009a9c:	681b      	ldr	r3, [r3, #0]
 8009a9e:	681a      	ldr	r2, [r3, #0]
 8009aa0:	687b      	ldr	r3, [r7, #4]
 8009aa2:	681b      	ldr	r3, [r3, #0]
 8009aa4:	f022 0204 	bic.w	r2, r2, #4
 8009aa8:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU));
 8009aaa:	687b      	ldr	r3, [r7, #4]
 8009aac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009aae:	f003 021c 	and.w	r2, r3, #28
 8009ab2:	687b      	ldr	r3, [r7, #4]
 8009ab4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009ab6:	2104      	movs	r1, #4
 8009ab8:	fa01 f202 	lsl.w	r2, r1, r2
 8009abc:	605a      	str	r2, [r3, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
 8009abe:	687b      	ldr	r3, [r7, #4]
 8009ac0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ac2:	2b00      	cmp	r3, #0
 8009ac4:	d071      	beq.n	8009baa <HAL_DMA_IRQHandler+0x154>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
 8009ac6:	687b      	ldr	r3, [r7, #4]
 8009ac8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009aca:	6878      	ldr	r0, [r7, #4]
 8009acc:	4798      	blx	r3
    if (hdma->XferHalfCpltCallback != NULL)
 8009ace:	e06c      	b.n	8009baa <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 8009ad0:	687b      	ldr	r3, [r7, #4]
 8009ad2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ad4:	f003 031c 	and.w	r3, r3, #28
 8009ad8:	2202      	movs	r2, #2
 8009ada:	409a      	lsls	r2, r3
 8009adc:	68fb      	ldr	r3, [r7, #12]
 8009ade:	4013      	ands	r3, r2
 8009ae0:	2b00      	cmp	r3, #0
 8009ae2:	d02e      	beq.n	8009b42 <HAL_DMA_IRQHandler+0xec>
 8009ae4:	68bb      	ldr	r3, [r7, #8]
 8009ae6:	f003 0302 	and.w	r3, r3, #2
 8009aea:	2b00      	cmp	r3, #0
 8009aec:	d029      	beq.n	8009b42 <HAL_DMA_IRQHandler+0xec>
  {
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8009aee:	687b      	ldr	r3, [r7, #4]
 8009af0:	681b      	ldr	r3, [r3, #0]
 8009af2:	681b      	ldr	r3, [r3, #0]
 8009af4:	f003 0320 	and.w	r3, r3, #32
 8009af8:	2b00      	cmp	r3, #0
 8009afa:	d10b      	bne.n	8009b14 <HAL_DMA_IRQHandler+0xbe>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	681b      	ldr	r3, [r3, #0]
 8009b00:	681a      	ldr	r2, [r3, #0]
 8009b02:	687b      	ldr	r3, [r7, #4]
 8009b04:	681b      	ldr	r3, [r3, #0]
 8009b06:	f022 020a 	bic.w	r2, r2, #10
 8009b0a:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8009b0c:	687b      	ldr	r3, [r7, #4]
 8009b0e:	2201      	movs	r2, #1
 8009b10:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
 8009b14:	687b      	ldr	r3, [r7, #4]
 8009b16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b18:	f003 021c 	and.w	r2, r3, #28
 8009b1c:	687b      	ldr	r3, [r7, #4]
 8009b1e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009b20:	2102      	movs	r1, #2
 8009b22:	fa01 f202 	lsl.w	r2, r1, r2
 8009b26:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009b28:	687b      	ldr	r3, [r7, #4]
 8009b2a:	2200      	movs	r2, #0
 8009b2c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferCpltCallback != NULL)
 8009b30:	687b      	ldr	r3, [r7, #4]
 8009b32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b34:	2b00      	cmp	r3, #0
 8009b36:	d038      	beq.n	8009baa <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
 8009b38:	687b      	ldr	r3, [r7, #4]
 8009b3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b3c:	6878      	ldr	r0, [r7, #4]
 8009b3e:	4798      	blx	r3
    if (hdma->XferCpltCallback != NULL)
 8009b40:	e033      	b.n	8009baa <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 8009b42:	687b      	ldr	r3, [r7, #4]
 8009b44:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b46:	f003 031c 	and.w	r3, r3, #28
 8009b4a:	2208      	movs	r2, #8
 8009b4c:	409a      	lsls	r2, r3
 8009b4e:	68fb      	ldr	r3, [r7, #12]
 8009b50:	4013      	ands	r3, r2
 8009b52:	2b00      	cmp	r3, #0
 8009b54:	d02a      	beq.n	8009bac <HAL_DMA_IRQHandler+0x156>
 8009b56:	68bb      	ldr	r3, [r7, #8]
 8009b58:	f003 0308 	and.w	r3, r3, #8
 8009b5c:	2b00      	cmp	r3, #0
 8009b5e:	d025      	beq.n	8009bac <HAL_DMA_IRQHandler+0x156>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8009b60:	687b      	ldr	r3, [r7, #4]
 8009b62:	681b      	ldr	r3, [r3, #0]
 8009b64:	681a      	ldr	r2, [r3, #0]
 8009b66:	687b      	ldr	r3, [r7, #4]
 8009b68:	681b      	ldr	r3, [r3, #0]
 8009b6a:	f022 020e 	bic.w	r2, r2, #14
 8009b6e:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8009b70:	687b      	ldr	r3, [r7, #4]
 8009b72:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b74:	f003 021c 	and.w	r2, r3, #28
 8009b78:	687b      	ldr	r3, [r7, #4]
 8009b7a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009b7c:	2101      	movs	r1, #1
 8009b7e:	fa01 f202 	lsl.w	r2, r1, r2
 8009b82:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8009b84:	687b      	ldr	r3, [r7, #4]
 8009b86:	2201      	movs	r2, #1
 8009b88:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8009b8a:	687b      	ldr	r3, [r7, #4]
 8009b8c:	2201      	movs	r2, #1
 8009b8e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009b92:	687b      	ldr	r3, [r7, #4]
 8009b94:	2200      	movs	r2, #0
 8009b96:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferErrorCallback != NULL)
 8009b9a:	687b      	ldr	r3, [r7, #4]
 8009b9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009b9e:	2b00      	cmp	r3, #0
 8009ba0:	d004      	beq.n	8009bac <HAL_DMA_IRQHandler+0x156>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 8009ba2:	687b      	ldr	r3, [r7, #4]
 8009ba4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009ba6:	6878      	ldr	r0, [r7, #4]
 8009ba8:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
 8009baa:	bf00      	nop
 8009bac:	bf00      	nop
}
 8009bae:	3710      	adds	r7, #16
 8009bb0:	46bd      	mov	sp, r7
 8009bb2:	bd80      	pop	{r7, pc}

08009bb4 <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
 8009bb4:	b480      	push	{r7}
 8009bb6:	b087      	sub	sp, #28
 8009bb8:	af00      	add	r7, sp, #0
 8009bba:	6078      	str	r0, [r7, #4]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 8009bbc:	687b      	ldr	r3, [r7, #4]
 8009bbe:	681b      	ldr	r3, [r3, #0]
 8009bc0:	0c1b      	lsrs	r3, r3, #16
 8009bc2:	f003 0301 	and.w	r3, r3, #1
 8009bc6:	617b      	str	r3, [r7, #20]
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
 8009bc8:	687b      	ldr	r3, [r7, #4]
 8009bca:	681b      	ldr	r3, [r3, #0]
 8009bcc:	f003 031f 	and.w	r3, r3, #31
 8009bd0:	2201      	movs	r2, #1
 8009bd2:	fa02 f303 	lsl.w	r3, r2, r3
 8009bd6:	613b      	str	r3, [r7, #16]

  regaddr = (&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
 8009bd8:	697b      	ldr	r3, [r7, #20]
 8009bda:	015b      	lsls	r3, r3, #5
 8009bdc:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
 8009be0:	f603 0308 	addw	r3, r3, #2056	; 0x808
 8009be4:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
 8009be6:	68fb      	ldr	r3, [r7, #12]
 8009be8:	693a      	ldr	r2, [r7, #16]
 8009bea:	601a      	str	r2, [r3, #0]
}
 8009bec:	bf00      	nop
 8009bee:	371c      	adds	r7, #28
 8009bf0:	46bd      	mov	sp, r7
 8009bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009bf6:	4770      	bx	lr

08009bf8 <HAL_FLASH_IRQHandler>:
/**
  * @brief Handle FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
 8009bf8:	b580      	push	{r7, lr}
 8009bfa:	b082      	sub	sp, #8
 8009bfc:	af00      	add	r7, sp, #0
  uint32_t param = 0xFFFFFFFFU;
 8009bfe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8009c02:	607b      	str	r3, [r7, #4]
  uint32_t error;

  /* Check FLASH operation error flags */
  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8009c04:	4b41      	ldr	r3, [pc, #260]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c06:	691a      	ldr	r2, [r3, #16]
 8009c08:	f24c 33fa 	movw	r3, #50170	; 0xc3fa
 8009c0c:	4013      	ands	r3, r2
 8009c0e:	603b      	str	r3, [r7, #0]

  /* Clear Current operation */
  CLEAR_BIT(FLASH->CR, pFlash.ProcedureOnGoing);
 8009c10:	4b3e      	ldr	r3, [pc, #248]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c12:	695a      	ldr	r2, [r3, #20]
 8009c14:	4b3e      	ldr	r3, [pc, #248]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c16:	689b      	ldr	r3, [r3, #8]
 8009c18:	43db      	mvns	r3, r3
 8009c1a:	493c      	ldr	r1, [pc, #240]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c1c:	4013      	ands	r3, r2
 8009c1e:	614b      	str	r3, [r1, #20]

  /* A] Set parameter for user or error callbacks */
  /* check operation was a program or erase */
  if ((pFlash.ProcedureOnGoing & (FLASH_TYPEPROGRAM_DOUBLEWORD | FLASH_TYPEPROGRAM_FAST)) != 0U)
 8009c20:	4b3b      	ldr	r3, [pc, #236]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c22:	689a      	ldr	r2, [r3, #8]
 8009c24:	4b3b      	ldr	r3, [pc, #236]	; (8009d14 <HAL_FLASH_IRQHandler+0x11c>)
 8009c26:	4013      	ands	r3, r2
 8009c28:	2b00      	cmp	r3, #0
 8009c2a:	d003      	beq.n	8009c34 <HAL_FLASH_IRQHandler+0x3c>
  {
    /* return address being programmed */
    param = pFlash.Address;
 8009c2c:	4b38      	ldr	r3, [pc, #224]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c2e:	68db      	ldr	r3, [r3, #12]
 8009c30:	607b      	str	r3, [r7, #4]
 8009c32:	e008      	b.n	8009c46 <HAL_FLASH_IRQHandler+0x4e>
  }
  else if ((pFlash.ProcedureOnGoing & (FLASH_TYPEERASE_PAGES)) != 0U)
 8009c34:	4b36      	ldr	r3, [pc, #216]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c36:	689b      	ldr	r3, [r3, #8]
 8009c38:	f003 0302 	and.w	r3, r3, #2
 8009c3c:	2b00      	cmp	r3, #0
 8009c3e:	d002      	beq.n	8009c46 <HAL_FLASH_IRQHandler+0x4e>
  {
    /* return page number being erased */
    param = pFlash.Page;
 8009c40:	4b33      	ldr	r3, [pc, #204]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c42:	691b      	ldr	r3, [r3, #16]
 8009c44:	607b      	str	r3, [r7, #4]
    /* No Procedure on-going */
    /* Nothing to do, but check error if any */
  }

  /* B] Check errors */
  if (error != 0U)
 8009c46:	683b      	ldr	r3, [r7, #0]
 8009c48:	2b00      	cmp	r3, #0
 8009c4a:	d022      	beq.n	8009c92 <HAL_FLASH_IRQHandler+0x9a>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 8009c4c:	4b30      	ldr	r3, [pc, #192]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c4e:	685a      	ldr	r2, [r3, #4]
 8009c50:	683b      	ldr	r3, [r7, #0]
 8009c52:	4313      	orrs	r3, r2
 8009c54:	4a2e      	ldr	r2, [pc, #184]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c56:	6053      	str	r3, [r2, #4]

    /* clear error flags */
    __HAL_FLASH_CLEAR_FLAG(error);
 8009c58:	683b      	ldr	r3, [r7, #0]
 8009c5a:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 8009c5e:	2b00      	cmp	r3, #0
 8009c60:	d007      	beq.n	8009c72 <HAL_FLASH_IRQHandler+0x7a>
 8009c62:	4b2a      	ldr	r3, [pc, #168]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c64:	699a      	ldr	r2, [r3, #24]
 8009c66:	683b      	ldr	r3, [r7, #0]
 8009c68:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 8009c6c:	4927      	ldr	r1, [pc, #156]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c6e:	4313      	orrs	r3, r2
 8009c70:	618b      	str	r3, [r1, #24]
 8009c72:	683b      	ldr	r3, [r7, #0]
 8009c74:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8009c78:	2b00      	cmp	r3, #0
 8009c7a:	d004      	beq.n	8009c86 <HAL_FLASH_IRQHandler+0x8e>
 8009c7c:	4a23      	ldr	r2, [pc, #140]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c7e:	683b      	ldr	r3, [r7, #0]
 8009c80:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8009c84:	6113      	str	r3, [r2, #16]

    /*Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_TYPENONE;
 8009c86:	4b22      	ldr	r3, [pc, #136]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009c88:	2200      	movs	r2, #0
 8009c8a:	609a      	str	r2, [r3, #8]

    /* Error callback */
    HAL_FLASH_OperationErrorCallback(param);
 8009c8c:	6878      	ldr	r0, [r7, #4]
 8009c8e:	f000 f84d 	bl	8009d2c <HAL_FLASH_OperationErrorCallback>
  }

  /* C] Check FLASH End of Operation flag */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8009c92:	4b1e      	ldr	r3, [pc, #120]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009c94:	691b      	ldr	r3, [r3, #16]
 8009c96:	f003 0301 	and.w	r3, r3, #1
 8009c9a:	2b01      	cmp	r3, #1
 8009c9c:	d124      	bne.n	8009ce8 <HAL_FLASH_IRQHandler+0xf0>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8009c9e:	4b1b      	ldr	r3, [pc, #108]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009ca0:	2201      	movs	r2, #1
 8009ca2:	611a      	str	r2, [r3, #16]

    if (pFlash.ProcedureOnGoing == FLASH_TYPEERASE_PAGES)
 8009ca4:	4b1a      	ldr	r3, [pc, #104]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009ca6:	689b      	ldr	r3, [r3, #8]
 8009ca8:	2b02      	cmp	r3, #2
 8009caa:	d117      	bne.n	8009cdc <HAL_FLASH_IRQHandler+0xe4>
    {
      /* Nb of pages to erased can be decreased */
      pFlash.NbPagesToErase--;
 8009cac:	4b18      	ldr	r3, [pc, #96]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cae:	695b      	ldr	r3, [r3, #20]
 8009cb0:	3b01      	subs	r3, #1
 8009cb2:	4a17      	ldr	r2, [pc, #92]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cb4:	6153      	str	r3, [r2, #20]

      /* Check if there are still pages to erase*/
      if (pFlash.NbPagesToErase != 0U)
 8009cb6:	4b16      	ldr	r3, [pc, #88]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cb8:	695b      	ldr	r3, [r3, #20]
 8009cba:	2b00      	cmp	r3, #0
 8009cbc:	d00a      	beq.n	8009cd4 <HAL_FLASH_IRQHandler+0xdc>
      {
        /* Increment page number */
        pFlash.Page++;
 8009cbe:	4b14      	ldr	r3, [pc, #80]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cc0:	691b      	ldr	r3, [r3, #16]
 8009cc2:	3301      	adds	r3, #1
 8009cc4:	4a12      	ldr	r2, [pc, #72]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cc6:	6113      	str	r3, [r2, #16]
        FLASH_PageErase(pFlash.Page);
 8009cc8:	4b11      	ldr	r3, [pc, #68]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cca:	691b      	ldr	r3, [r3, #16]
 8009ccc:	4618      	mov	r0, r3
 8009cce:	f000 f837 	bl	8009d40 <FLASH_PageErase>
 8009cd2:	e006      	b.n	8009ce2 <HAL_FLASH_IRQHandler+0xea>
      }
      else
      {
        /* No more pages to erase: stop erase pages procedure */
        pFlash.ProcedureOnGoing = FLASH_TYPENONE;
 8009cd4:	4b0e      	ldr	r3, [pc, #56]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cd6:	2200      	movs	r2, #0
 8009cd8:	609a      	str	r2, [r3, #8]
 8009cda:	e002      	b.n	8009ce2 <HAL_FLASH_IRQHandler+0xea>
      }
    }
    else
    {
      /*Stop the ongoing procedure */
      pFlash.ProcedureOnGoing = FLASH_TYPENONE;
 8009cdc:	4b0c      	ldr	r3, [pc, #48]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cde:	2200      	movs	r2, #0
 8009ce0:	609a      	str	r2, [r3, #8]
    }

    /* User callback */
    HAL_FLASH_EndOfOperationCallback(param);
 8009ce2:	6878      	ldr	r0, [r7, #4]
 8009ce4:	f000 f818 	bl	8009d18 <HAL_FLASH_EndOfOperationCallback>
  }

  if (pFlash.ProcedureOnGoing == FLASH_TYPENONE)
 8009ce8:	4b09      	ldr	r3, [pc, #36]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cea:	689b      	ldr	r3, [r3, #8]
 8009cec:	2b00      	cmp	r3, #0
 8009cee:	d108      	bne.n	8009d02 <HAL_FLASH_IRQHandler+0x10a>
  {
    /* Disable End of Operation and Error interrupts */
    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR);
 8009cf0:	4b06      	ldr	r3, [pc, #24]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009cf2:	695b      	ldr	r3, [r3, #20]
 8009cf4:	4a05      	ldr	r2, [pc, #20]	; (8009d0c <HAL_FLASH_IRQHandler+0x114>)
 8009cf6:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 8009cfa:	6153      	str	r3, [r2, #20]

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
 8009cfc:	4b04      	ldr	r3, [pc, #16]	; (8009d10 <HAL_FLASH_IRQHandler+0x118>)
 8009cfe:	2200      	movs	r2, #0
 8009d00:	701a      	strb	r2, [r3, #0]
  }
}
 8009d02:	bf00      	nop
 8009d04:	3708      	adds	r7, #8
 8009d06:	46bd      	mov	sp, r7
 8009d08:	bd80      	pop	{r7, pc}
 8009d0a:	bf00      	nop
 8009d0c:	58004000 	.word	0x58004000
 8009d10:	20000db0 	.word	0x20000db0
 8009d14:	00040001 	.word	0x00040001

08009d18 <HAL_FLASH_EndOfOperationCallback>:
  *                  Page Erase: Page which has been erased
  *                  Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
 8009d18:	b480      	push	{r7}
 8009d1a:	b083      	sub	sp, #12
 8009d1c:	af00      	add	r7, sp, #0
 8009d1e:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
 8009d20:	bf00      	nop
 8009d22:	370c      	adds	r7, #12
 8009d24:	46bd      	mov	sp, r7
 8009d26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d2a:	4770      	bx	lr

08009d2c <HAL_FLASH_OperationErrorCallback>:
  *                 Page Erase: Page number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
 8009d2c:	b480      	push	{r7}
 8009d2e:	b083      	sub	sp, #12
 8009d30:	af00      	add	r7, sp, #0
 8009d32:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
 8009d34:	bf00      	nop
 8009d36:	370c      	adds	r7, #12
 8009d38:	46bd      	mov	sp, r7
 8009d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d3e:	4770      	bx	lr

08009d40 <FLASH_PageErase>:
  * @param  Page FLASH page to erase
  *         This parameter must be a value between 0 and (max number of pages in Flash - 1)
  * @retval None
  */
void FLASH_PageErase(uint32_t Page)
{
 8009d40:	b480      	push	{r7}
 8009d42:	b083      	sub	sp, #12
 8009d44:	af00      	add	r7, sp, #0
 8009d46:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 8009d48:	4b09      	ldr	r3, [pc, #36]	; (8009d70 <FLASH_PageErase+0x30>)
 8009d4a:	695b      	ldr	r3, [r3, #20]
 8009d4c:	f423 62ff 	bic.w	r2, r3, #2040	; 0x7f8
 8009d50:	687b      	ldr	r3, [r7, #4]
 8009d52:	00db      	lsls	r3, r3, #3
 8009d54:	4313      	orrs	r3, r2
 8009d56:	4a06      	ldr	r2, [pc, #24]	; (8009d70 <FLASH_PageErase+0x30>)
 8009d58:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009d5c:	f043 0302 	orr.w	r3, r3, #2
 8009d60:	6153      	str	r3, [r2, #20]
}
 8009d62:	bf00      	nop
 8009d64:	370c      	adds	r7, #12
 8009d66:	46bd      	mov	sp, r7
 8009d68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d6c:	4770      	bx	lr
 8009d6e:	bf00      	nop
 8009d70:	58004000 	.word	0x58004000

08009d74 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8009d74:	b480      	push	{r7}
 8009d76:	b087      	sub	sp, #28
 8009d78:	af00      	add	r7, sp, #0
 8009d7a:	6078      	str	r0, [r7, #4]
 8009d7c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8009d7e:	2300      	movs	r3, #0
 8009d80:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8009d82:	e14c      	b.n	800a01e <HAL_GPIO_Init+0x2aa>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8009d84:	683b      	ldr	r3, [r7, #0]
 8009d86:	681a      	ldr	r2, [r3, #0]
 8009d88:	2101      	movs	r1, #1
 8009d8a:	697b      	ldr	r3, [r7, #20]
 8009d8c:	fa01 f303 	lsl.w	r3, r1, r3
 8009d90:	4013      	ands	r3, r2
 8009d92:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 8009d94:	68fb      	ldr	r3, [r7, #12]
 8009d96:	2b00      	cmp	r3, #0
 8009d98:	f000 813e 	beq.w	800a018 <HAL_GPIO_Init+0x2a4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8009d9c:	683b      	ldr	r3, [r7, #0]
 8009d9e:	685b      	ldr	r3, [r3, #4]
 8009da0:	f003 0303 	and.w	r3, r3, #3
 8009da4:	2b01      	cmp	r3, #1
 8009da6:	d005      	beq.n	8009db4 <HAL_GPIO_Init+0x40>
 8009da8:	683b      	ldr	r3, [r7, #0]
 8009daa:	685b      	ldr	r3, [r3, #4]
 8009dac:	f003 0303 	and.w	r3, r3, #3
 8009db0:	2b02      	cmp	r3, #2
 8009db2:	d130      	bne.n	8009e16 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8009db4:	687b      	ldr	r3, [r7, #4]
 8009db6:	689b      	ldr	r3, [r3, #8]
 8009db8:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8009dba:	697b      	ldr	r3, [r7, #20]
 8009dbc:	005b      	lsls	r3, r3, #1
 8009dbe:	2203      	movs	r2, #3
 8009dc0:	fa02 f303 	lsl.w	r3, r2, r3
 8009dc4:	43db      	mvns	r3, r3
 8009dc6:	693a      	ldr	r2, [r7, #16]
 8009dc8:	4013      	ands	r3, r2
 8009dca:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 8009dcc:	683b      	ldr	r3, [r7, #0]
 8009dce:	68da      	ldr	r2, [r3, #12]
 8009dd0:	697b      	ldr	r3, [r7, #20]
 8009dd2:	005b      	lsls	r3, r3, #1
 8009dd4:	fa02 f303 	lsl.w	r3, r2, r3
 8009dd8:	693a      	ldr	r2, [r7, #16]
 8009dda:	4313      	orrs	r3, r2
 8009ddc:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8009dde:	687b      	ldr	r3, [r7, #4]
 8009de0:	693a      	ldr	r2, [r7, #16]
 8009de2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8009de4:	687b      	ldr	r3, [r7, #4]
 8009de6:	685b      	ldr	r3, [r3, #4]
 8009de8:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8009dea:	2201      	movs	r2, #1
 8009dec:	697b      	ldr	r3, [r7, #20]
 8009dee:	fa02 f303 	lsl.w	r3, r2, r3
 8009df2:	43db      	mvns	r3, r3
 8009df4:	693a      	ldr	r2, [r7, #16]
 8009df6:	4013      	ands	r3, r2
 8009df8:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8009dfa:	683b      	ldr	r3, [r7, #0]
 8009dfc:	685b      	ldr	r3, [r3, #4]
 8009dfe:	091b      	lsrs	r3, r3, #4
 8009e00:	f003 0201 	and.w	r2, r3, #1
 8009e04:	697b      	ldr	r3, [r7, #20]
 8009e06:	fa02 f303 	lsl.w	r3, r2, r3
 8009e0a:	693a      	ldr	r2, [r7, #16]
 8009e0c:	4313      	orrs	r3, r2
 8009e0e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8009e10:	687b      	ldr	r3, [r7, #4]
 8009e12:	693a      	ldr	r2, [r7, #16]
 8009e14:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8009e16:	683b      	ldr	r3, [r7, #0]
 8009e18:	685b      	ldr	r3, [r3, #4]
 8009e1a:	f003 0303 	and.w	r3, r3, #3
 8009e1e:	2b03      	cmp	r3, #3
 8009e20:	d017      	beq.n	8009e52 <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
 8009e22:	687b      	ldr	r3, [r7, #4]
 8009e24:	68db      	ldr	r3, [r3, #12]
 8009e26:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8009e28:	697b      	ldr	r3, [r7, #20]
 8009e2a:	005b      	lsls	r3, r3, #1
 8009e2c:	2203      	movs	r2, #3
 8009e2e:	fa02 f303 	lsl.w	r3, r2, r3
 8009e32:	43db      	mvns	r3, r3
 8009e34:	693a      	ldr	r2, [r7, #16]
 8009e36:	4013      	ands	r3, r2
 8009e38:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8009e3a:	683b      	ldr	r3, [r7, #0]
 8009e3c:	689a      	ldr	r2, [r3, #8]
 8009e3e:	697b      	ldr	r3, [r7, #20]
 8009e40:	005b      	lsls	r3, r3, #1
 8009e42:	fa02 f303 	lsl.w	r3, r2, r3
 8009e46:	693a      	ldr	r2, [r7, #16]
 8009e48:	4313      	orrs	r3, r2
 8009e4a:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 8009e4c:	687b      	ldr	r3, [r7, #4]
 8009e4e:	693a      	ldr	r2, [r7, #16]
 8009e50:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8009e52:	683b      	ldr	r3, [r7, #0]
 8009e54:	685b      	ldr	r3, [r3, #4]
 8009e56:	f003 0303 	and.w	r3, r3, #3
 8009e5a:	2b02      	cmp	r3, #2
 8009e5c:	d123      	bne.n	8009ea6 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 8009e5e:	697b      	ldr	r3, [r7, #20]
 8009e60:	08da      	lsrs	r2, r3, #3
 8009e62:	687b      	ldr	r3, [r7, #4]
 8009e64:	3208      	adds	r2, #8
 8009e66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8009e6a:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8009e6c:	697b      	ldr	r3, [r7, #20]
 8009e6e:	f003 0307 	and.w	r3, r3, #7
 8009e72:	009b      	lsls	r3, r3, #2
 8009e74:	220f      	movs	r2, #15
 8009e76:	fa02 f303 	lsl.w	r3, r2, r3
 8009e7a:	43db      	mvns	r3, r3
 8009e7c:	693a      	ldr	r2, [r7, #16]
 8009e7e:	4013      	ands	r3, r2
 8009e80:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8009e82:	683b      	ldr	r3, [r7, #0]
 8009e84:	691a      	ldr	r2, [r3, #16]
 8009e86:	697b      	ldr	r3, [r7, #20]
 8009e88:	f003 0307 	and.w	r3, r3, #7
 8009e8c:	009b      	lsls	r3, r3, #2
 8009e8e:	fa02 f303 	lsl.w	r3, r2, r3
 8009e92:	693a      	ldr	r2, [r7, #16]
 8009e94:	4313      	orrs	r3, r2
 8009e96:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 8009e98:	697b      	ldr	r3, [r7, #20]
 8009e9a:	08da      	lsrs	r2, r3, #3
 8009e9c:	687b      	ldr	r3, [r7, #4]
 8009e9e:	3208      	adds	r2, #8
 8009ea0:	6939      	ldr	r1, [r7, #16]
 8009ea2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8009ea6:	687b      	ldr	r3, [r7, #4]
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8009eac:	697b      	ldr	r3, [r7, #20]
 8009eae:	005b      	lsls	r3, r3, #1
 8009eb0:	2203      	movs	r2, #3
 8009eb2:	fa02 f303 	lsl.w	r3, r2, r3
 8009eb6:	43db      	mvns	r3, r3
 8009eb8:	693a      	ldr	r2, [r7, #16]
 8009eba:	4013      	ands	r3, r2
 8009ebc:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8009ebe:	683b      	ldr	r3, [r7, #0]
 8009ec0:	685b      	ldr	r3, [r3, #4]
 8009ec2:	f003 0203 	and.w	r2, r3, #3
 8009ec6:	697b      	ldr	r3, [r7, #20]
 8009ec8:	005b      	lsls	r3, r3, #1
 8009eca:	fa02 f303 	lsl.w	r3, r2, r3
 8009ece:	693a      	ldr	r2, [r7, #16]
 8009ed0:	4313      	orrs	r3, r2
 8009ed2:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8009ed4:	687b      	ldr	r3, [r7, #4]
 8009ed6:	693a      	ldr	r2, [r7, #16]
 8009ed8:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8009eda:	683b      	ldr	r3, [r7, #0]
 8009edc:	685b      	ldr	r3, [r3, #4]
 8009ede:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8009ee2:	2b00      	cmp	r3, #0
 8009ee4:	f000 8098 	beq.w	800a018 <HAL_GPIO_Init+0x2a4>
      {
        temp = SYSCFG->EXTICR[position >> 2u];
 8009ee8:	4a54      	ldr	r2, [pc, #336]	; (800a03c <HAL_GPIO_Init+0x2c8>)
 8009eea:	697b      	ldr	r3, [r7, #20]
 8009eec:	089b      	lsrs	r3, r3, #2
 8009eee:	3302      	adds	r3, #2
 8009ef0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009ef4:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8009ef6:	697b      	ldr	r3, [r7, #20]
 8009ef8:	f003 0303 	and.w	r3, r3, #3
 8009efc:	009b      	lsls	r3, r3, #2
 8009efe:	220f      	movs	r2, #15
 8009f00:	fa02 f303 	lsl.w	r3, r2, r3
 8009f04:	43db      	mvns	r3, r3
 8009f06:	693a      	ldr	r2, [r7, #16]
 8009f08:	4013      	ands	r3, r2
 8009f0a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8009f0c:	687b      	ldr	r3, [r7, #4]
 8009f0e:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 8009f12:	d019      	beq.n	8009f48 <HAL_GPIO_Init+0x1d4>
 8009f14:	687b      	ldr	r3, [r7, #4]
 8009f16:	4a4a      	ldr	r2, [pc, #296]	; (800a040 <HAL_GPIO_Init+0x2cc>)
 8009f18:	4293      	cmp	r3, r2
 8009f1a:	d013      	beq.n	8009f44 <HAL_GPIO_Init+0x1d0>
 8009f1c:	687b      	ldr	r3, [r7, #4]
 8009f1e:	4a49      	ldr	r2, [pc, #292]	; (800a044 <HAL_GPIO_Init+0x2d0>)
 8009f20:	4293      	cmp	r3, r2
 8009f22:	d00d      	beq.n	8009f40 <HAL_GPIO_Init+0x1cc>
 8009f24:	687b      	ldr	r3, [r7, #4]
 8009f26:	4a48      	ldr	r2, [pc, #288]	; (800a048 <HAL_GPIO_Init+0x2d4>)
 8009f28:	4293      	cmp	r3, r2
 8009f2a:	d007      	beq.n	8009f3c <HAL_GPIO_Init+0x1c8>
 8009f2c:	687b      	ldr	r3, [r7, #4]
 8009f2e:	4a47      	ldr	r2, [pc, #284]	; (800a04c <HAL_GPIO_Init+0x2d8>)
 8009f30:	4293      	cmp	r3, r2
 8009f32:	d101      	bne.n	8009f38 <HAL_GPIO_Init+0x1c4>
 8009f34:	2304      	movs	r3, #4
 8009f36:	e008      	b.n	8009f4a <HAL_GPIO_Init+0x1d6>
 8009f38:	2307      	movs	r3, #7
 8009f3a:	e006      	b.n	8009f4a <HAL_GPIO_Init+0x1d6>
 8009f3c:	2303      	movs	r3, #3
 8009f3e:	e004      	b.n	8009f4a <HAL_GPIO_Init+0x1d6>
 8009f40:	2302      	movs	r3, #2
 8009f42:	e002      	b.n	8009f4a <HAL_GPIO_Init+0x1d6>
 8009f44:	2301      	movs	r3, #1
 8009f46:	e000      	b.n	8009f4a <HAL_GPIO_Init+0x1d6>
 8009f48:	2300      	movs	r3, #0
 8009f4a:	697a      	ldr	r2, [r7, #20]
 8009f4c:	f002 0203 	and.w	r2, r2, #3
 8009f50:	0092      	lsls	r2, r2, #2
 8009f52:	4093      	lsls	r3, r2
 8009f54:	693a      	ldr	r2, [r7, #16]
 8009f56:	4313      	orrs	r3, r2
 8009f58:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 8009f5a:	4938      	ldr	r1, [pc, #224]	; (800a03c <HAL_GPIO_Init+0x2c8>)
 8009f5c:	697b      	ldr	r3, [r7, #20]
 8009f5e:	089b      	lsrs	r3, r3, #2
 8009f60:	3302      	adds	r3, #2
 8009f62:	693a      	ldr	r2, [r7, #16]
 8009f64:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8009f68:	4b39      	ldr	r3, [pc, #228]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009f6a:	681b      	ldr	r3, [r3, #0]
 8009f6c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8009f6e:	68fb      	ldr	r3, [r7, #12]
 8009f70:	43db      	mvns	r3, r3
 8009f72:	693a      	ldr	r2, [r7, #16]
 8009f74:	4013      	ands	r3, r2
 8009f76:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8009f78:	683b      	ldr	r3, [r7, #0]
 8009f7a:	685b      	ldr	r3, [r3, #4]
 8009f7c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8009f80:	2b00      	cmp	r3, #0
 8009f82:	d003      	beq.n	8009f8c <HAL_GPIO_Init+0x218>
        {
          temp |= iocurrent;
 8009f84:	693a      	ldr	r2, [r7, #16]
 8009f86:	68fb      	ldr	r3, [r7, #12]
 8009f88:	4313      	orrs	r3, r2
 8009f8a:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8009f8c:	4a30      	ldr	r2, [pc, #192]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009f8e:	693b      	ldr	r3, [r7, #16]
 8009f90:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8009f92:	4b2f      	ldr	r3, [pc, #188]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009f94:	685b      	ldr	r3, [r3, #4]
 8009f96:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8009f98:	68fb      	ldr	r3, [r7, #12]
 8009f9a:	43db      	mvns	r3, r3
 8009f9c:	693a      	ldr	r2, [r7, #16]
 8009f9e:	4013      	ands	r3, r2
 8009fa0:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8009fa2:	683b      	ldr	r3, [r7, #0]
 8009fa4:	685b      	ldr	r3, [r3, #4]
 8009fa6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009faa:	2b00      	cmp	r3, #0
 8009fac:	d003      	beq.n	8009fb6 <HAL_GPIO_Init+0x242>
        {
          temp |= iocurrent;
 8009fae:	693a      	ldr	r2, [r7, #16]
 8009fb0:	68fb      	ldr	r3, [r7, #12]
 8009fb2:	4313      	orrs	r3, r2
 8009fb4:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8009fb6:	4a26      	ldr	r2, [pc, #152]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009fb8:	693b      	ldr	r3, [r7, #16]
 8009fba:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8009fbc:	4b24      	ldr	r3, [pc, #144]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009fbe:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8009fc2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8009fc4:	68fb      	ldr	r3, [r7, #12]
 8009fc6:	43db      	mvns	r3, r3
 8009fc8:	693a      	ldr	r2, [r7, #16]
 8009fca:	4013      	ands	r3, r2
 8009fcc:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8009fce:	683b      	ldr	r3, [r7, #0]
 8009fd0:	685b      	ldr	r3, [r3, #4]
 8009fd2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009fd6:	2b00      	cmp	r3, #0
 8009fd8:	d003      	beq.n	8009fe2 <HAL_GPIO_Init+0x26e>
        {
          temp |= iocurrent;
 8009fda:	693a      	ldr	r2, [r7, #16]
 8009fdc:	68fb      	ldr	r3, [r7, #12]
 8009fde:	4313      	orrs	r3, r2
 8009fe0:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 8009fe2:	4a1b      	ldr	r2, [pc, #108]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009fe4:	693b      	ldr	r3, [r7, #16]
 8009fe6:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

        temp = EXTI->EMR1;
 8009fea:	4b19      	ldr	r3, [pc, #100]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 8009fec:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8009ff0:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8009ff2:	68fb      	ldr	r3, [r7, #12]
 8009ff4:	43db      	mvns	r3, r3
 8009ff6:	693a      	ldr	r2, [r7, #16]
 8009ff8:	4013      	ands	r3, r2
 8009ffa:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8009ffc:	683b      	ldr	r3, [r7, #0]
 8009ffe:	685b      	ldr	r3, [r3, #4]
 800a000:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800a004:	2b00      	cmp	r3, #0
 800a006:	d003      	beq.n	800a010 <HAL_GPIO_Init+0x29c>
        {
          temp |= iocurrent;
 800a008:	693a      	ldr	r2, [r7, #16]
 800a00a:	68fb      	ldr	r3, [r7, #12]
 800a00c:	4313      	orrs	r3, r2
 800a00e:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 800a010:	4a0f      	ldr	r2, [pc, #60]	; (800a050 <HAL_GPIO_Init+0x2dc>)
 800a012:	693b      	ldr	r3, [r7, #16]
 800a014:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      }
    }

    position++;
 800a018:	697b      	ldr	r3, [r7, #20]
 800a01a:	3301      	adds	r3, #1
 800a01c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800a01e:	683b      	ldr	r3, [r7, #0]
 800a020:	681a      	ldr	r2, [r3, #0]
 800a022:	697b      	ldr	r3, [r7, #20]
 800a024:	fa22 f303 	lsr.w	r3, r2, r3
 800a028:	2b00      	cmp	r3, #0
 800a02a:	f47f aeab 	bne.w	8009d84 <HAL_GPIO_Init+0x10>
  }
}
 800a02e:	bf00      	nop
 800a030:	bf00      	nop
 800a032:	371c      	adds	r7, #28
 800a034:	46bd      	mov	sp, r7
 800a036:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a03a:	4770      	bx	lr
 800a03c:	40010000 	.word	0x40010000
 800a040:	48000400 	.word	0x48000400
 800a044:	48000800 	.word	0x48000800
 800a048:	48000c00 	.word	0x48000c00
 800a04c:	48001000 	.word	0x48001000
 800a050:	58000800 	.word	0x58000800

0800a054 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800a054:	b480      	push	{r7}
 800a056:	b083      	sub	sp, #12
 800a058:	af00      	add	r7, sp, #0
 800a05a:	6078      	str	r0, [r7, #4]
 800a05c:	460b      	mov	r3, r1
 800a05e:	807b      	strh	r3, [r7, #2]
 800a060:	4613      	mov	r3, r2
 800a062:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800a064:	787b      	ldrb	r3, [r7, #1]
 800a066:	2b00      	cmp	r3, #0
 800a068:	d003      	beq.n	800a072 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800a06a:	887a      	ldrh	r2, [r7, #2]
 800a06c:	687b      	ldr	r3, [r7, #4]
 800a06e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800a070:	e002      	b.n	800a078 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800a072:	887a      	ldrh	r2, [r7, #2]
 800a074:	687b      	ldr	r3, [r7, #4]
 800a076:	629a      	str	r2, [r3, #40]	; 0x28
}
 800a078:	bf00      	nop
 800a07a:	370c      	adds	r7, #12
 800a07c:	46bd      	mov	sp, r7
 800a07e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a082:	4770      	bx	lr

0800a084 <HAL_GPIO_TogglePin>:
  * @param GPIOx where x can be (A..H) to select the GPIO peripheral for STM32WBxx family
  * @param GPIO_Pin specifies the pin to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 800a084:	b480      	push	{r7}
 800a086:	b085      	sub	sp, #20
 800a088:	af00      	add	r7, sp, #0
 800a08a:	6078      	str	r0, [r7, #4]
 800a08c:	460b      	mov	r3, r1
 800a08e:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800a090:	687b      	ldr	r3, [r7, #4]
 800a092:	695b      	ldr	r3, [r3, #20]
 800a094:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800a096:	887a      	ldrh	r2, [r7, #2]
 800a098:	68fb      	ldr	r3, [r7, #12]
 800a09a:	4013      	ands	r3, r2
 800a09c:	041a      	lsls	r2, r3, #16
 800a09e:	68fb      	ldr	r3, [r7, #12]
 800a0a0:	43d9      	mvns	r1, r3
 800a0a2:	887b      	ldrh	r3, [r7, #2]
 800a0a4:	400b      	ands	r3, r1
 800a0a6:	431a      	orrs	r2, r3
 800a0a8:	687b      	ldr	r3, [r7, #4]
 800a0aa:	619a      	str	r2, [r3, #24]
}
 800a0ac:	bf00      	nop
 800a0ae:	3714      	adds	r7, #20
 800a0b0:	46bd      	mov	sp, r7
 800a0b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a0b6:	4770      	bx	lr

0800a0b8 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800a0b8:	b580      	push	{r7, lr}
 800a0ba:	b082      	sub	sp, #8
 800a0bc:	af00      	add	r7, sp, #0
 800a0be:	4603      	mov	r3, r0
 800a0c0:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 800a0c2:	4b08      	ldr	r3, [pc, #32]	; (800a0e4 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800a0c4:	68da      	ldr	r2, [r3, #12]
 800a0c6:	88fb      	ldrh	r3, [r7, #6]
 800a0c8:	4013      	ands	r3, r2
 800a0ca:	2b00      	cmp	r3, #0
 800a0cc:	d006      	beq.n	800a0dc <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800a0ce:	4a05      	ldr	r2, [pc, #20]	; (800a0e4 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800a0d0:	88fb      	ldrh	r3, [r7, #6]
 800a0d2:	60d3      	str	r3, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800a0d4:	88fb      	ldrh	r3, [r7, #6]
 800a0d6:	4618      	mov	r0, r3
 800a0d8:	f7fc fbef 	bl	80068ba <HAL_GPIO_EXTI_Callback>
  }
}
 800a0dc:	bf00      	nop
 800a0de:	3708      	adds	r7, #8
 800a0e0:	46bd      	mov	sp, r7
 800a0e2:	bd80      	pop	{r7, pc}
 800a0e4:	58000800 	.word	0x58000800

0800a0e8 <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
 800a0e8:	b580      	push	{r7, lr}
 800a0ea:	b082      	sub	sp, #8
 800a0ec:	af00      	add	r7, sp, #0
  uint32_t statusreg;
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
 800a0ee:	4b0a      	ldr	r3, [pc, #40]	; (800a118 <HAL_HSEM_IRQHandler+0x30>)
 800a0f0:	68db      	ldr	r3, [r3, #12]
 800a0f2:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
 800a0f4:	4b08      	ldr	r3, [pc, #32]	; (800a118 <HAL_HSEM_IRQHandler+0x30>)
 800a0f6:	681a      	ldr	r2, [r3, #0]
 800a0f8:	687b      	ldr	r3, [r7, #4]
 800a0fa:	43db      	mvns	r3, r3
 800a0fc:	4906      	ldr	r1, [pc, #24]	; (800a118 <HAL_HSEM_IRQHandler+0x30>)
 800a0fe:	4013      	ands	r3, r2
 800a100:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
 800a102:	4a05      	ldr	r2, [pc, #20]	; (800a118 <HAL_HSEM_IRQHandler+0x30>)
 800a104:	687b      	ldr	r3, [r7, #4]
 800a106:	6053      	str	r3, [r2, #4]

  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
 800a108:	6878      	ldr	r0, [r7, #4]
 800a10a:	f000 f807 	bl	800a11c <HAL_HSEM_FreeCallback>
}
 800a10e:	bf00      	nop
 800a110:	3708      	adds	r7, #8
 800a112:	46bd      	mov	sp, r7
 800a114:	bd80      	pop	{r7, pc}
 800a116:	bf00      	nop
 800a118:	58001500 	.word	0x58001500

0800a11c <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
 800a11c:	b480      	push	{r7}
 800a11e:	b083      	sub	sp, #12
 800a120:	af00      	add	r7, sp, #0
 800a122:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
 800a124:	bf00      	nop
 800a126:	370c      	adds	r7, #12
 800a128:	46bd      	mov	sp, r7
 800a12a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a12e:	4770      	bx	lr

0800a130 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800a130:	b580      	push	{r7, lr}
 800a132:	b084      	sub	sp, #16
 800a134:	af00      	add	r7, sp, #0
 800a136:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800a138:	687b      	ldr	r3, [r7, #4]
 800a13a:	2b00      	cmp	r3, #0
 800a13c:	d101      	bne.n	800a142 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 800a13e:	2301      	movs	r3, #1
 800a140:	e0c0      	b.n	800a2c4 <HAL_PCD_Init+0x194>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800a142:	687b      	ldr	r3, [r7, #4]
 800a144:	f893 3291 	ldrb.w	r3, [r3, #657]	; 0x291
 800a148:	b2db      	uxtb	r3, r3
 800a14a:	2b00      	cmp	r3, #0
 800a14c:	d106      	bne.n	800a15c <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 800a14e:	687b      	ldr	r3, [r7, #4]
 800a150:	2200      	movs	r2, #0
 800a152:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800a156:	6878      	ldr	r0, [r7, #4]
 800a158:	f009 fe4c 	bl	8013df4 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800a15c:	687b      	ldr	r3, [r7, #4]
 800a15e:	2203      	movs	r2, #3
 800a160:	f883 2291 	strb.w	r2, [r3, #657]	; 0x291

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800a164:	687b      	ldr	r3, [r7, #4]
 800a166:	681b      	ldr	r3, [r3, #0]
 800a168:	4618      	mov	r0, r3
 800a16a:	f004 ff38 	bl	800efde <USB_DisableGlobalInt>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800a16e:	2300      	movs	r3, #0
 800a170:	73fb      	strb	r3, [r7, #15]
 800a172:	e03e      	b.n	800a1f2 <HAL_PCD_Init+0xc2>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800a174:	7bfa      	ldrb	r2, [r7, #15]
 800a176:	6879      	ldr	r1, [r7, #4]
 800a178:	4613      	mov	r3, r2
 800a17a:	009b      	lsls	r3, r3, #2
 800a17c:	4413      	add	r3, r2
 800a17e:	00db      	lsls	r3, r3, #3
 800a180:	440b      	add	r3, r1
 800a182:	3311      	adds	r3, #17
 800a184:	2201      	movs	r2, #1
 800a186:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 800a188:	7bfa      	ldrb	r2, [r7, #15]
 800a18a:	6879      	ldr	r1, [r7, #4]
 800a18c:	4613      	mov	r3, r2
 800a18e:	009b      	lsls	r3, r3, #2
 800a190:	4413      	add	r3, r2
 800a192:	00db      	lsls	r3, r3, #3
 800a194:	440b      	add	r3, r1
 800a196:	3310      	adds	r3, #16
 800a198:	7bfa      	ldrb	r2, [r7, #15]
 800a19a:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800a19c:	7bfa      	ldrb	r2, [r7, #15]
 800a19e:	6879      	ldr	r1, [r7, #4]
 800a1a0:	4613      	mov	r3, r2
 800a1a2:	009b      	lsls	r3, r3, #2
 800a1a4:	4413      	add	r3, r2
 800a1a6:	00db      	lsls	r3, r3, #3
 800a1a8:	440b      	add	r3, r1
 800a1aa:	3313      	adds	r3, #19
 800a1ac:	2200      	movs	r2, #0
 800a1ae:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 800a1b0:	7bfa      	ldrb	r2, [r7, #15]
 800a1b2:	6879      	ldr	r1, [r7, #4]
 800a1b4:	4613      	mov	r3, r2
 800a1b6:	009b      	lsls	r3, r3, #2
 800a1b8:	4413      	add	r3, r2
 800a1ba:	00db      	lsls	r3, r3, #3
 800a1bc:	440b      	add	r3, r1
 800a1be:	3320      	adds	r3, #32
 800a1c0:	2200      	movs	r2, #0
 800a1c2:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 800a1c4:	7bfa      	ldrb	r2, [r7, #15]
 800a1c6:	6879      	ldr	r1, [r7, #4]
 800a1c8:	4613      	mov	r3, r2
 800a1ca:	009b      	lsls	r3, r3, #2
 800a1cc:	4413      	add	r3, r2
 800a1ce:	00db      	lsls	r3, r3, #3
 800a1d0:	440b      	add	r3, r1
 800a1d2:	3324      	adds	r3, #36	; 0x24
 800a1d4:	2200      	movs	r2, #0
 800a1d6:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 800a1d8:	7bfb      	ldrb	r3, [r7, #15]
 800a1da:	6879      	ldr	r1, [r7, #4]
 800a1dc:	1c5a      	adds	r2, r3, #1
 800a1de:	4613      	mov	r3, r2
 800a1e0:	009b      	lsls	r3, r3, #2
 800a1e2:	4413      	add	r3, r2
 800a1e4:	00db      	lsls	r3, r3, #3
 800a1e6:	440b      	add	r3, r1
 800a1e8:	2200      	movs	r2, #0
 800a1ea:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800a1ec:	7bfb      	ldrb	r3, [r7, #15]
 800a1ee:	3301      	adds	r3, #1
 800a1f0:	73fb      	strb	r3, [r7, #15]
 800a1f2:	687b      	ldr	r3, [r7, #4]
 800a1f4:	791b      	ldrb	r3, [r3, #4]
 800a1f6:	7bfa      	ldrb	r2, [r7, #15]
 800a1f8:	429a      	cmp	r2, r3
 800a1fa:	d3bb      	bcc.n	800a174 <HAL_PCD_Init+0x44>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800a1fc:	2300      	movs	r3, #0
 800a1fe:	73fb      	strb	r3, [r7, #15]
 800a200:	e044      	b.n	800a28c <HAL_PCD_Init+0x15c>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 800a202:	7bfa      	ldrb	r2, [r7, #15]
 800a204:	6879      	ldr	r1, [r7, #4]
 800a206:	4613      	mov	r3, r2
 800a208:	009b      	lsls	r3, r3, #2
 800a20a:	4413      	add	r3, r2
 800a20c:	00db      	lsls	r3, r3, #3
 800a20e:	440b      	add	r3, r1
 800a210:	f203 1351 	addw	r3, r3, #337	; 0x151
 800a214:	2200      	movs	r2, #0
 800a216:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 800a218:	7bfa      	ldrb	r2, [r7, #15]
 800a21a:	6879      	ldr	r1, [r7, #4]
 800a21c:	4613      	mov	r3, r2
 800a21e:	009b      	lsls	r3, r3, #2
 800a220:	4413      	add	r3, r2
 800a222:	00db      	lsls	r3, r3, #3
 800a224:	440b      	add	r3, r1
 800a226:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800a22a:	7bfa      	ldrb	r2, [r7, #15]
 800a22c:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800a22e:	7bfa      	ldrb	r2, [r7, #15]
 800a230:	6879      	ldr	r1, [r7, #4]
 800a232:	4613      	mov	r3, r2
 800a234:	009b      	lsls	r3, r3, #2
 800a236:	4413      	add	r3, r2
 800a238:	00db      	lsls	r3, r3, #3
 800a23a:	440b      	add	r3, r1
 800a23c:	f203 1353 	addw	r3, r3, #339	; 0x153
 800a240:	2200      	movs	r2, #0
 800a242:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 800a244:	7bfa      	ldrb	r2, [r7, #15]
 800a246:	6879      	ldr	r1, [r7, #4]
 800a248:	4613      	mov	r3, r2
 800a24a:	009b      	lsls	r3, r3, #2
 800a24c:	4413      	add	r3, r2
 800a24e:	00db      	lsls	r3, r3, #3
 800a250:	440b      	add	r3, r1
 800a252:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 800a256:	2200      	movs	r2, #0
 800a258:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800a25a:	7bfa      	ldrb	r2, [r7, #15]
 800a25c:	6879      	ldr	r1, [r7, #4]
 800a25e:	4613      	mov	r3, r2
 800a260:	009b      	lsls	r3, r3, #2
 800a262:	4413      	add	r3, r2
 800a264:	00db      	lsls	r3, r3, #3
 800a266:	440b      	add	r3, r1
 800a268:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 800a26c:	2200      	movs	r2, #0
 800a26e:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 800a270:	7bfa      	ldrb	r2, [r7, #15]
 800a272:	6879      	ldr	r1, [r7, #4]
 800a274:	4613      	mov	r3, r2
 800a276:	009b      	lsls	r3, r3, #2
 800a278:	4413      	add	r3, r2
 800a27a:	00db      	lsls	r3, r3, #3
 800a27c:	440b      	add	r3, r1
 800a27e:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800a282:	2200      	movs	r2, #0
 800a284:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800a286:	7bfb      	ldrb	r3, [r7, #15]
 800a288:	3301      	adds	r3, #1
 800a28a:	73fb      	strb	r3, [r7, #15]
 800a28c:	687b      	ldr	r3, [r7, #4]
 800a28e:	791b      	ldrb	r3, [r3, #4]
 800a290:	7bfa      	ldrb	r2, [r7, #15]
 800a292:	429a      	cmp	r2, r3
 800a294:	d3b5      	bcc.n	800a202 <HAL_PCD_Init+0xd2>
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 800a296:	687b      	ldr	r3, [r7, #4]
 800a298:	6818      	ldr	r0, [r3, #0]
 800a29a:	687b      	ldr	r3, [r7, #4]
 800a29c:	3304      	adds	r3, #4
 800a29e:	e893 0006 	ldmia.w	r3, {r1, r2}
 800a2a2:	f004 feb7 	bl	800f014 <USB_DevInit>

  hpcd->USB_Address = 0U;
 800a2a6:	687b      	ldr	r3, [r7, #4]
 800a2a8:	2200      	movs	r2, #0
 800a2aa:	731a      	strb	r2, [r3, #12]
  hpcd->State = HAL_PCD_STATE_READY;
 800a2ac:	687b      	ldr	r3, [r7, #4]
 800a2ae:	2201      	movs	r2, #1
 800a2b0:	f883 2291 	strb.w	r2, [r3, #657]	; 0x291

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 800a2b4:	687b      	ldr	r3, [r7, #4]
 800a2b6:	7a9b      	ldrb	r3, [r3, #10]
 800a2b8:	2b01      	cmp	r3, #1
 800a2ba:	d102      	bne.n	800a2c2 <HAL_PCD_Init+0x192>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 800a2bc:	6878      	ldr	r0, [r7, #4]
 800a2be:	f001 fc41 	bl	800bb44 <HAL_PCDEx_ActivateLPM>
  }

  return HAL_OK;
 800a2c2:	2300      	movs	r3, #0
}
 800a2c4:	4618      	mov	r0, r3
 800a2c6:	3710      	adds	r7, #16
 800a2c8:	46bd      	mov	sp, r7
 800a2ca:	bd80      	pop	{r7, pc}

0800a2cc <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 800a2cc:	b580      	push	{r7, lr}
 800a2ce:	b082      	sub	sp, #8
 800a2d0:	af00      	add	r7, sp, #0
 800a2d2:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hpcd);
 800a2d4:	687b      	ldr	r3, [r7, #4]
 800a2d6:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 800a2da:	2b01      	cmp	r3, #1
 800a2dc:	d101      	bne.n	800a2e2 <HAL_PCD_Start+0x16>
 800a2de:	2302      	movs	r3, #2
 800a2e0:	e012      	b.n	800a308 <HAL_PCD_Start+0x3c>
 800a2e2:	687b      	ldr	r3, [r7, #4]
 800a2e4:	2201      	movs	r2, #1
 800a2e6:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
  __HAL_PCD_ENABLE(hpcd);
 800a2ea:	687b      	ldr	r3, [r7, #4]
 800a2ec:	681b      	ldr	r3, [r3, #0]
 800a2ee:	4618      	mov	r0, r3
 800a2f0:	f004 fe5e 	bl	800efb0 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800a2f4:	687b      	ldr	r3, [r7, #4]
 800a2f6:	681b      	ldr	r3, [r3, #0]
 800a2f8:	4618      	mov	r0, r3
 800a2fa:	f007 f91e 	bl	801153a <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800a2fe:	687b      	ldr	r3, [r7, #4]
 800a300:	2200      	movs	r2, #0
 800a302:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

  return HAL_OK;
 800a306:	2300      	movs	r3, #0
}
 800a308:	4618      	mov	r0, r3
 800a30a:	3708      	adds	r7, #8
 800a30c:	46bd      	mov	sp, r7
 800a30e:	bd80      	pop	{r7, pc}

0800a310 <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800a310:	b580      	push	{r7, lr}
 800a312:	b084      	sub	sp, #16
 800a314:	af00      	add	r7, sp, #0
 800a316:	6078      	str	r0, [r7, #4]
  uint32_t wIstr = USB_ReadInterrupts(hpcd->Instance);
 800a318:	687b      	ldr	r3, [r7, #4]
 800a31a:	681b      	ldr	r3, [r3, #0]
 800a31c:	4618      	mov	r0, r3
 800a31e:	f007 f923 	bl	8011568 <USB_ReadInterrupts>
 800a322:	60f8      	str	r0, [r7, #12]

  if ((wIstr & USB_ISTR_CTR) == USB_ISTR_CTR)
 800a324:	68fb      	ldr	r3, [r7, #12]
 800a326:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	d003      	beq.n	800a336 <HAL_PCD_IRQHandler+0x26>
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    (void)PCD_EP_ISR_Handler(hpcd);
 800a32e:	6878      	ldr	r0, [r7, #4]
 800a330:	f000 fb04 	bl	800a93c <PCD_EP_ISR_Handler>

    return;
 800a334:	e110      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_RESET) == USB_ISTR_RESET)
 800a336:	68fb      	ldr	r3, [r7, #12]
 800a338:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a33c:	2b00      	cmp	r3, #0
 800a33e:	d013      	beq.n	800a368 <HAL_PCD_IRQHandler+0x58>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800a340:	687b      	ldr	r3, [r7, #4]
 800a342:	681b      	ldr	r3, [r3, #0]
 800a344:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a348:	b29a      	uxth	r2, r3
 800a34a:	687b      	ldr	r3, [r7, #4]
 800a34c:	681b      	ldr	r3, [r3, #0]
 800a34e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a352:	b292      	uxth	r2, r2
 800a354:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResetCallback(hpcd);
#else
    HAL_PCD_ResetCallback(hpcd);
 800a358:	6878      	ldr	r0, [r7, #4]
 800a35a:	f009 fdb4 	bl	8013ec6 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    (void)HAL_PCD_SetAddress(hpcd, 0U);
 800a35e:	2100      	movs	r1, #0
 800a360:	6878      	ldr	r0, [r7, #4]
 800a362:	f000 f8fc 	bl	800a55e <HAL_PCD_SetAddress>

    return;
 800a366:	e0f7      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_PMAOVR) == USB_ISTR_PMAOVR)
 800a368:	68fb      	ldr	r3, [r7, #12]
 800a36a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800a36e:	2b00      	cmp	r3, #0
 800a370:	d00c      	beq.n	800a38c <HAL_PCD_IRQHandler+0x7c>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 800a372:	687b      	ldr	r3, [r7, #4]
 800a374:	681b      	ldr	r3, [r3, #0]
 800a376:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a37a:	b29a      	uxth	r2, r3
 800a37c:	687b      	ldr	r3, [r7, #4]
 800a37e:	681b      	ldr	r3, [r3, #0]
 800a380:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a384:	b292      	uxth	r2, r2
 800a386:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800a38a:	e0e5      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_ERR) == USB_ISTR_ERR)
 800a38c:	68fb      	ldr	r3, [r7, #12]
 800a38e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800a392:	2b00      	cmp	r3, #0
 800a394:	d00c      	beq.n	800a3b0 <HAL_PCD_IRQHandler+0xa0>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 800a396:	687b      	ldr	r3, [r7, #4]
 800a398:	681b      	ldr	r3, [r3, #0]
 800a39a:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a39e:	b29a      	uxth	r2, r3
 800a3a0:	687b      	ldr	r3, [r7, #4]
 800a3a2:	681b      	ldr	r3, [r3, #0]
 800a3a4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a3a8:	b292      	uxth	r2, r2
 800a3aa:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800a3ae:	e0d3      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_WKUP) == USB_ISTR_WKUP)
 800a3b0:	68fb      	ldr	r3, [r7, #12]
 800a3b2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800a3b6:	2b00      	cmp	r3, #0
 800a3b8:	d034      	beq.n	800a424 <HAL_PCD_IRQHandler+0x114>
  {
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LPMODE);
 800a3ba:	687b      	ldr	r3, [r7, #4]
 800a3bc:	681b      	ldr	r3, [r3, #0]
 800a3be:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800a3c2:	b29a      	uxth	r2, r3
 800a3c4:	687b      	ldr	r3, [r7, #4]
 800a3c6:	681b      	ldr	r3, [r3, #0]
 800a3c8:	f022 0204 	bic.w	r2, r2, #4
 800a3cc:	b292      	uxth	r2, r2
 800a3ce:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 800a3d2:	687b      	ldr	r3, [r7, #4]
 800a3d4:	681b      	ldr	r3, [r3, #0]
 800a3d6:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800a3da:	b29a      	uxth	r2, r3
 800a3dc:	687b      	ldr	r3, [r7, #4]
 800a3de:	681b      	ldr	r3, [r3, #0]
 800a3e0:	f022 0208 	bic.w	r2, r2, #8
 800a3e4:	b292      	uxth	r2, r2
 800a3e6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

    if (hpcd->LPM_State == LPM_L1)
 800a3ea:	687b      	ldr	r3, [r7, #4]
 800a3ec:	f893 32c8 	ldrb.w	r3, [r3, #712]	; 0x2c8
 800a3f0:	2b01      	cmp	r3, #1
 800a3f2:	d107      	bne.n	800a404 <HAL_PCD_IRQHandler+0xf4>
    {
      hpcd->LPM_State = LPM_L0;
 800a3f4:	687b      	ldr	r3, [r7, #4]
 800a3f6:	2200      	movs	r2, #0
 800a3f8:	f883 22c8 	strb.w	r2, [r3, #712]	; 0x2c8
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800a3fc:	2100      	movs	r1, #0
 800a3fe:	6878      	ldr	r0, [r7, #4]
 800a400:	f001 fbca 	bl	800bb98 <HAL_PCDEx_LPM_Callback>
    }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResumeCallback(hpcd);
#else
    HAL_PCD_ResumeCallback(hpcd);
 800a404:	6878      	ldr	r0, [r7, #4]
 800a406:	f009 fd81 	bl	8013f0c <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 800a40a:	687b      	ldr	r3, [r7, #4]
 800a40c:	681b      	ldr	r3, [r3, #0]
 800a40e:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a412:	b29a      	uxth	r2, r3
 800a414:	687b      	ldr	r3, [r7, #4]
 800a416:	681b      	ldr	r3, [r3, #0]
 800a418:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800a41c:	b292      	uxth	r2, r2
 800a41e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800a422:	e099      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_SUSP) == USB_ISTR_SUSP)
 800a424:	68fb      	ldr	r3, [r7, #12]
 800a426:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800a42a:	2b00      	cmp	r3, #0
 800a42c:	d027      	beq.n	800a47e <HAL_PCD_IRQHandler+0x16e>
  {
    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800a42e:	687b      	ldr	r3, [r7, #4]
 800a430:	681b      	ldr	r3, [r3, #0]
 800a432:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800a436:	b29a      	uxth	r2, r3
 800a438:	687b      	ldr	r3, [r7, #4]
 800a43a:	681b      	ldr	r3, [r3, #0]
 800a43c:	f042 0208 	orr.w	r2, r2, #8
 800a440:	b292      	uxth	r2, r2
 800a442:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 800a446:	687b      	ldr	r3, [r7, #4]
 800a448:	681b      	ldr	r3, [r3, #0]
 800a44a:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a44e:	b29a      	uxth	r2, r3
 800a450:	687b      	ldr	r3, [r7, #4]
 800a452:	681b      	ldr	r3, [r3, #0]
 800a454:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800a458:	b292      	uxth	r2, r2
 800a45a:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800a45e:	687b      	ldr	r3, [r7, #4]
 800a460:	681b      	ldr	r3, [r3, #0]
 800a462:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800a466:	b29a      	uxth	r2, r3
 800a468:	687b      	ldr	r3, [r7, #4]
 800a46a:	681b      	ldr	r3, [r3, #0]
 800a46c:	f042 0204 	orr.w	r2, r2, #4
 800a470:	b292      	uxth	r2, r2
 800a472:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SuspendCallback(hpcd);
#else
    HAL_PCD_SuspendCallback(hpcd);
 800a476:	6878      	ldr	r0, [r7, #4]
 800a478:	f009 fd3a 	bl	8013ef0 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    return;
 800a47c:	e06c      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  /* Handle LPM Interrupt */
  if ((wIstr & USB_ISTR_L1REQ) == USB_ISTR_L1REQ)
 800a47e:	68fb      	ldr	r3, [r7, #12]
 800a480:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a484:	2b00      	cmp	r3, #0
 800a486:	d040      	beq.n	800a50a <HAL_PCD_IRQHandler+0x1fa>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_L1REQ);
 800a488:	687b      	ldr	r3, [r7, #4]
 800a48a:	681b      	ldr	r3, [r3, #0]
 800a48c:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a490:	b29a      	uxth	r2, r3
 800a492:	687b      	ldr	r3, [r7, #4]
 800a494:	681b      	ldr	r3, [r3, #0]
 800a496:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a49a:	b292      	uxth	r2, r2
 800a49c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    if (hpcd->LPM_State == LPM_L0)
 800a4a0:	687b      	ldr	r3, [r7, #4]
 800a4a2:	f893 32c8 	ldrb.w	r3, [r3, #712]	; 0x2c8
 800a4a6:	2b00      	cmp	r3, #0
 800a4a8:	d12b      	bne.n	800a502 <HAL_PCD_IRQHandler+0x1f2>
    {
      /* Force suspend and low-power mode before going to L1 state*/
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800a4aa:	687b      	ldr	r3, [r7, #4]
 800a4ac:	681b      	ldr	r3, [r3, #0]
 800a4ae:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800a4b2:	b29a      	uxth	r2, r3
 800a4b4:	687b      	ldr	r3, [r7, #4]
 800a4b6:	681b      	ldr	r3, [r3, #0]
 800a4b8:	f042 0204 	orr.w	r2, r2, #4
 800a4bc:	b292      	uxth	r2, r2
 800a4be:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800a4c2:	687b      	ldr	r3, [r7, #4]
 800a4c4:	681b      	ldr	r3, [r3, #0]
 800a4c6:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800a4ca:	b29a      	uxth	r2, r3
 800a4cc:	687b      	ldr	r3, [r7, #4]
 800a4ce:	681b      	ldr	r3, [r3, #0]
 800a4d0:	f042 0208 	orr.w	r2, r2, #8
 800a4d4:	b292      	uxth	r2, r2
 800a4d6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

      hpcd->LPM_State = LPM_L1;
 800a4da:	687b      	ldr	r3, [r7, #4]
 800a4dc:	2201      	movs	r2, #1
 800a4de:	f883 22c8 	strb.w	r2, [r3, #712]	; 0x2c8
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800a4e2:	687b      	ldr	r3, [r7, #4]
 800a4e4:	681b      	ldr	r3, [r3, #0]
 800a4e6:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 800a4ea:	b29b      	uxth	r3, r3
 800a4ec:	089b      	lsrs	r3, r3, #2
 800a4ee:	f003 023c 	and.w	r2, r3, #60	; 0x3c
 800a4f2:	687b      	ldr	r3, [r7, #4]
 800a4f4:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800a4f8:	2101      	movs	r1, #1
 800a4fa:	6878      	ldr	r0, [r7, #4]
 800a4fc:	f001 fb4c 	bl	800bb98 <HAL_PCDEx_LPM_Callback>
#else
      HAL_PCD_SuspendCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }

    return;
 800a500:	e02a      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
      HAL_PCD_SuspendCallback(hpcd);
 800a502:	6878      	ldr	r0, [r7, #4]
 800a504:	f009 fcf4 	bl	8013ef0 <HAL_PCD_SuspendCallback>
    return;
 800a508:	e026      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_SOF) == USB_ISTR_SOF)
 800a50a:	68fb      	ldr	r3, [r7, #12]
 800a50c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800a510:	2b00      	cmp	r3, #0
 800a512:	d00f      	beq.n	800a534 <HAL_PCD_IRQHandler+0x224>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 800a514:	687b      	ldr	r3, [r7, #4]
 800a516:	681b      	ldr	r3, [r3, #0]
 800a518:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a51c:	b29a      	uxth	r2, r3
 800a51e:	687b      	ldr	r3, [r7, #4]
 800a520:	681b      	ldr	r3, [r3, #0]
 800a522:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800a526:	b292      	uxth	r2, r2
 800a528:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SOFCallback(hpcd);
#else
    HAL_PCD_SOFCallback(hpcd);
 800a52c:	6878      	ldr	r0, [r7, #4]
 800a52e:	f009 fcbc 	bl	8013eaa <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    return;
 800a532:	e011      	b.n	800a558 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_ESOF) == USB_ISTR_ESOF)
 800a534:	68fb      	ldr	r3, [r7, #12]
 800a536:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a53a:	2b00      	cmp	r3, #0
 800a53c:	d00c      	beq.n	800a558 <HAL_PCD_IRQHandler+0x248>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF);
 800a53e:	687b      	ldr	r3, [r7, #4]
 800a540:	681b      	ldr	r3, [r3, #0]
 800a542:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a546:	b29a      	uxth	r2, r3
 800a548:	687b      	ldr	r3, [r7, #4]
 800a54a:	681b      	ldr	r3, [r3, #0]
 800a54c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800a550:	b292      	uxth	r2, r2
 800a552:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800a556:	bf00      	nop
  }
}
 800a558:	3710      	adds	r7, #16
 800a55a:	46bd      	mov	sp, r7
 800a55c:	bd80      	pop	{r7, pc}

0800a55e <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 800a55e:	b580      	push	{r7, lr}
 800a560:	b082      	sub	sp, #8
 800a562:	af00      	add	r7, sp, #0
 800a564:	6078      	str	r0, [r7, #4]
 800a566:	460b      	mov	r3, r1
 800a568:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 800a56a:	687b      	ldr	r3, [r7, #4]
 800a56c:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 800a570:	2b01      	cmp	r3, #1
 800a572:	d101      	bne.n	800a578 <HAL_PCD_SetAddress+0x1a>
 800a574:	2302      	movs	r3, #2
 800a576:	e012      	b.n	800a59e <HAL_PCD_SetAddress+0x40>
 800a578:	687b      	ldr	r3, [r7, #4]
 800a57a:	2201      	movs	r2, #1
 800a57c:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
  hpcd->USB_Address = address;
 800a580:	687b      	ldr	r3, [r7, #4]
 800a582:	78fa      	ldrb	r2, [r7, #3]
 800a584:	731a      	strb	r2, [r3, #12]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800a586:	687b      	ldr	r3, [r7, #4]
 800a588:	681b      	ldr	r3, [r3, #0]
 800a58a:	78fa      	ldrb	r2, [r7, #3]
 800a58c:	4611      	mov	r1, r2
 800a58e:	4618      	mov	r0, r3
 800a590:	f006 ffbf 	bl	8011512 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800a594:	687b      	ldr	r3, [r7, #4]
 800a596:	2200      	movs	r2, #0
 800a598:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

  return HAL_OK;
 800a59c:	2300      	movs	r3, #0
}
 800a59e:	4618      	mov	r0, r3
 800a5a0:	3708      	adds	r7, #8
 800a5a2:	46bd      	mov	sp, r7
 800a5a4:	bd80      	pop	{r7, pc}

0800a5a6 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 800a5a6:	b580      	push	{r7, lr}
 800a5a8:	b084      	sub	sp, #16
 800a5aa:	af00      	add	r7, sp, #0
 800a5ac:	6078      	str	r0, [r7, #4]
 800a5ae:	4608      	mov	r0, r1
 800a5b0:	4611      	mov	r1, r2
 800a5b2:	461a      	mov	r2, r3
 800a5b4:	4603      	mov	r3, r0
 800a5b6:	70fb      	strb	r3, [r7, #3]
 800a5b8:	460b      	mov	r3, r1
 800a5ba:	803b      	strh	r3, [r7, #0]
 800a5bc:	4613      	mov	r3, r2
 800a5be:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 800a5c0:	2300      	movs	r3, #0
 800a5c2:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800a5c4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800a5c8:	2b00      	cmp	r3, #0
 800a5ca:	da0e      	bge.n	800a5ea <HAL_PCD_EP_Open+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800a5cc:	78fb      	ldrb	r3, [r7, #3]
 800a5ce:	f003 0207 	and.w	r2, r3, #7
 800a5d2:	4613      	mov	r3, r2
 800a5d4:	009b      	lsls	r3, r3, #2
 800a5d6:	4413      	add	r3, r2
 800a5d8:	00db      	lsls	r3, r3, #3
 800a5da:	3310      	adds	r3, #16
 800a5dc:	687a      	ldr	r2, [r7, #4]
 800a5de:	4413      	add	r3, r2
 800a5e0:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800a5e2:	68fb      	ldr	r3, [r7, #12]
 800a5e4:	2201      	movs	r2, #1
 800a5e6:	705a      	strb	r2, [r3, #1]
 800a5e8:	e00e      	b.n	800a608 <HAL_PCD_EP_Open+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800a5ea:	78fb      	ldrb	r3, [r7, #3]
 800a5ec:	f003 0207 	and.w	r2, r3, #7
 800a5f0:	4613      	mov	r3, r2
 800a5f2:	009b      	lsls	r3, r3, #2
 800a5f4:	4413      	add	r3, r2
 800a5f6:	00db      	lsls	r3, r3, #3
 800a5f8:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800a5fc:	687a      	ldr	r2, [r7, #4]
 800a5fe:	4413      	add	r3, r2
 800a600:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800a602:	68fb      	ldr	r3, [r7, #12]
 800a604:	2200      	movs	r2, #0
 800a606:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 800a608:	78fb      	ldrb	r3, [r7, #3]
 800a60a:	f003 0307 	and.w	r3, r3, #7
 800a60e:	b2da      	uxtb	r2, r3
 800a610:	68fb      	ldr	r3, [r7, #12]
 800a612:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 800a614:	883a      	ldrh	r2, [r7, #0]
 800a616:	68fb      	ldr	r3, [r7, #12]
 800a618:	611a      	str	r2, [r3, #16]
  ep->type = ep_type;
 800a61a:	68fb      	ldr	r3, [r7, #12]
 800a61c:	78ba      	ldrb	r2, [r7, #2]
 800a61e:	70da      	strb	r2, [r3, #3]

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 800a620:	78bb      	ldrb	r3, [r7, #2]
 800a622:	2b02      	cmp	r3, #2
 800a624:	d102      	bne.n	800a62c <HAL_PCD_EP_Open+0x86>
  {
    ep->data_pid_start = 0U;
 800a626:	68fb      	ldr	r3, [r7, #12]
 800a628:	2200      	movs	r2, #0
 800a62a:	711a      	strb	r2, [r3, #4]
  }

  __HAL_LOCK(hpcd);
 800a62c:	687b      	ldr	r3, [r7, #4]
 800a62e:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 800a632:	2b01      	cmp	r3, #1
 800a634:	d101      	bne.n	800a63a <HAL_PCD_EP_Open+0x94>
 800a636:	2302      	movs	r3, #2
 800a638:	e00e      	b.n	800a658 <HAL_PCD_EP_Open+0xb2>
 800a63a:	687b      	ldr	r3, [r7, #4]
 800a63c:	2201      	movs	r2, #1
 800a63e:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800a642:	687b      	ldr	r3, [r7, #4]
 800a644:	681b      	ldr	r3, [r3, #0]
 800a646:	68f9      	ldr	r1, [r7, #12]
 800a648:	4618      	mov	r0, r3
 800a64a:	f004 fd01 	bl	800f050 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800a64e:	687b      	ldr	r3, [r7, #4]
 800a650:	2200      	movs	r2, #0
 800a652:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

  return ret;
 800a656:	7afb      	ldrb	r3, [r7, #11]
}
 800a658:	4618      	mov	r0, r3
 800a65a:	3710      	adds	r7, #16
 800a65c:	46bd      	mov	sp, r7
 800a65e:	bd80      	pop	{r7, pc}

0800a660 <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800a660:	b580      	push	{r7, lr}
 800a662:	b084      	sub	sp, #16
 800a664:	af00      	add	r7, sp, #0
 800a666:	6078      	str	r0, [r7, #4]
 800a668:	460b      	mov	r3, r1
 800a66a:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800a66c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800a670:	2b00      	cmp	r3, #0
 800a672:	da0e      	bge.n	800a692 <HAL_PCD_EP_Close+0x32>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800a674:	78fb      	ldrb	r3, [r7, #3]
 800a676:	f003 0207 	and.w	r2, r3, #7
 800a67a:	4613      	mov	r3, r2
 800a67c:	009b      	lsls	r3, r3, #2
 800a67e:	4413      	add	r3, r2
 800a680:	00db      	lsls	r3, r3, #3
 800a682:	3310      	adds	r3, #16
 800a684:	687a      	ldr	r2, [r7, #4]
 800a686:	4413      	add	r3, r2
 800a688:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800a68a:	68fb      	ldr	r3, [r7, #12]
 800a68c:	2201      	movs	r2, #1
 800a68e:	705a      	strb	r2, [r3, #1]
 800a690:	e00e      	b.n	800a6b0 <HAL_PCD_EP_Close+0x50>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800a692:	78fb      	ldrb	r3, [r7, #3]
 800a694:	f003 0207 	and.w	r2, r3, #7
 800a698:	4613      	mov	r3, r2
 800a69a:	009b      	lsls	r3, r3, #2
 800a69c:	4413      	add	r3, r2
 800a69e:	00db      	lsls	r3, r3, #3
 800a6a0:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800a6a4:	687a      	ldr	r2, [r7, #4]
 800a6a6:	4413      	add	r3, r2
 800a6a8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800a6aa:	68fb      	ldr	r3, [r7, #12]
 800a6ac:	2200      	movs	r2, #0
 800a6ae:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 800a6b0:	78fb      	ldrb	r3, [r7, #3]
 800a6b2:	f003 0307 	and.w	r3, r3, #7
 800a6b6:	b2da      	uxtb	r2, r3
 800a6b8:	68fb      	ldr	r3, [r7, #12]
 800a6ba:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800a6bc:	687b      	ldr	r3, [r7, #4]
 800a6be:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 800a6c2:	2b01      	cmp	r3, #1
 800a6c4:	d101      	bne.n	800a6ca <HAL_PCD_EP_Close+0x6a>
 800a6c6:	2302      	movs	r3, #2
 800a6c8:	e00e      	b.n	800a6e8 <HAL_PCD_EP_Close+0x88>
 800a6ca:	687b      	ldr	r3, [r7, #4]
 800a6cc:	2201      	movs	r2, #1
 800a6ce:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800a6d2:	687b      	ldr	r3, [r7, #4]
 800a6d4:	681b      	ldr	r3, [r3, #0]
 800a6d6:	68f9      	ldr	r1, [r7, #12]
 800a6d8:	4618      	mov	r0, r3
 800a6da:	f005 f87d 	bl	800f7d8 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800a6de:	687b      	ldr	r3, [r7, #4]
 800a6e0:	2200      	movs	r2, #0
 800a6e2:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
  return HAL_OK;
 800a6e6:	2300      	movs	r3, #0
}
 800a6e8:	4618      	mov	r0, r3
 800a6ea:	3710      	adds	r7, #16
 800a6ec:	46bd      	mov	sp, r7
 800a6ee:	bd80      	pop	{r7, pc}

0800a6f0 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800a6f0:	b580      	push	{r7, lr}
 800a6f2:	b086      	sub	sp, #24
 800a6f4:	af00      	add	r7, sp, #0
 800a6f6:	60f8      	str	r0, [r7, #12]
 800a6f8:	607a      	str	r2, [r7, #4]
 800a6fa:	603b      	str	r3, [r7, #0]
 800a6fc:	460b      	mov	r3, r1
 800a6fe:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800a700:	7afb      	ldrb	r3, [r7, #11]
 800a702:	f003 0207 	and.w	r2, r3, #7
 800a706:	4613      	mov	r3, r2
 800a708:	009b      	lsls	r3, r3, #2
 800a70a:	4413      	add	r3, r2
 800a70c:	00db      	lsls	r3, r3, #3
 800a70e:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800a712:	68fa      	ldr	r2, [r7, #12]
 800a714:	4413      	add	r3, r2
 800a716:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800a718:	697b      	ldr	r3, [r7, #20]
 800a71a:	687a      	ldr	r2, [r7, #4]
 800a71c:	615a      	str	r2, [r3, #20]
  ep->xfer_len = len;
 800a71e:	697b      	ldr	r3, [r7, #20]
 800a720:	683a      	ldr	r2, [r7, #0]
 800a722:	619a      	str	r2, [r3, #24]
  ep->xfer_count = 0U;
 800a724:	697b      	ldr	r3, [r7, #20]
 800a726:	2200      	movs	r2, #0
 800a728:	61da      	str	r2, [r3, #28]
  ep->is_in = 0U;
 800a72a:	697b      	ldr	r3, [r7, #20]
 800a72c:	2200      	movs	r2, #0
 800a72e:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800a730:	7afb      	ldrb	r3, [r7, #11]
 800a732:	f003 0307 	and.w	r3, r3, #7
 800a736:	b2da      	uxtb	r2, r3
 800a738:	697b      	ldr	r3, [r7, #20]
 800a73a:	701a      	strb	r2, [r3, #0]

  (void)USB_EPStartXfer(hpcd->Instance, ep);
 800a73c:	68fb      	ldr	r3, [r7, #12]
 800a73e:	681b      	ldr	r3, [r3, #0]
 800a740:	6979      	ldr	r1, [r7, #20]
 800a742:	4618      	mov	r0, r3
 800a744:	f005 fa35 	bl	800fbb2 <USB_EPStartXfer>

  return HAL_OK;
 800a748:	2300      	movs	r3, #0
}
 800a74a:	4618      	mov	r0, r3
 800a74c:	3718      	adds	r7, #24
 800a74e:	46bd      	mov	sp, r7
 800a750:	bd80      	pop	{r7, pc}

0800a752 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 800a752:	b480      	push	{r7}
 800a754:	b083      	sub	sp, #12
 800a756:	af00      	add	r7, sp, #0
 800a758:	6078      	str	r0, [r7, #4]
 800a75a:	460b      	mov	r3, r1
 800a75c:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 800a75e:	78fb      	ldrb	r3, [r7, #3]
 800a760:	f003 0207 	and.w	r2, r3, #7
 800a764:	6879      	ldr	r1, [r7, #4]
 800a766:	4613      	mov	r3, r2
 800a768:	009b      	lsls	r3, r3, #2
 800a76a:	4413      	add	r3, r2
 800a76c:	00db      	lsls	r3, r3, #3
 800a76e:	440b      	add	r3, r1
 800a770:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 800a774:	681b      	ldr	r3, [r3, #0]
}
 800a776:	4618      	mov	r0, r3
 800a778:	370c      	adds	r7, #12
 800a77a:	46bd      	mov	sp, r7
 800a77c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a780:	4770      	bx	lr

0800a782 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800a782:	b580      	push	{r7, lr}
 800a784:	b086      	sub	sp, #24
 800a786:	af00      	add	r7, sp, #0
 800a788:	60f8      	str	r0, [r7, #12]
 800a78a:	607a      	str	r2, [r7, #4]
 800a78c:	603b      	str	r3, [r7, #0]
 800a78e:	460b      	mov	r3, r1
 800a790:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800a792:	7afb      	ldrb	r3, [r7, #11]
 800a794:	f003 0207 	and.w	r2, r3, #7
 800a798:	4613      	mov	r3, r2
 800a79a:	009b      	lsls	r3, r3, #2
 800a79c:	4413      	add	r3, r2
 800a79e:	00db      	lsls	r3, r3, #3
 800a7a0:	3310      	adds	r3, #16
 800a7a2:	68fa      	ldr	r2, [r7, #12]
 800a7a4:	4413      	add	r3, r2
 800a7a6:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800a7a8:	697b      	ldr	r3, [r7, #20]
 800a7aa:	687a      	ldr	r2, [r7, #4]
 800a7ac:	615a      	str	r2, [r3, #20]
  ep->xfer_len = len;
 800a7ae:	697b      	ldr	r3, [r7, #20]
 800a7b0:	683a      	ldr	r2, [r7, #0]
 800a7b2:	619a      	str	r2, [r3, #24]
  ep->xfer_fill_db = 1U;
 800a7b4:	697b      	ldr	r3, [r7, #20]
 800a7b6:	2201      	movs	r2, #1
 800a7b8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  ep->xfer_len_db = len;
 800a7bc:	697b      	ldr	r3, [r7, #20]
 800a7be:	683a      	ldr	r2, [r7, #0]
 800a7c0:	621a      	str	r2, [r3, #32]
  ep->xfer_count = 0U;
 800a7c2:	697b      	ldr	r3, [r7, #20]
 800a7c4:	2200      	movs	r2, #0
 800a7c6:	61da      	str	r2, [r3, #28]
  ep->is_in = 1U;
 800a7c8:	697b      	ldr	r3, [r7, #20]
 800a7ca:	2201      	movs	r2, #1
 800a7cc:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800a7ce:	7afb      	ldrb	r3, [r7, #11]
 800a7d0:	f003 0307 	and.w	r3, r3, #7
 800a7d4:	b2da      	uxtb	r2, r3
 800a7d6:	697b      	ldr	r3, [r7, #20]
 800a7d8:	701a      	strb	r2, [r3, #0]

  (void)USB_EPStartXfer(hpcd->Instance, ep);
 800a7da:	68fb      	ldr	r3, [r7, #12]
 800a7dc:	681b      	ldr	r3, [r3, #0]
 800a7de:	6979      	ldr	r1, [r7, #20]
 800a7e0:	4618      	mov	r0, r3
 800a7e2:	f005 f9e6 	bl	800fbb2 <USB_EPStartXfer>

  return HAL_OK;
 800a7e6:	2300      	movs	r3, #0
}
 800a7e8:	4618      	mov	r0, r3
 800a7ea:	3718      	adds	r7, #24
 800a7ec:	46bd      	mov	sp, r7
 800a7ee:	bd80      	pop	{r7, pc}

0800a7f0 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800a7f0:	b580      	push	{r7, lr}
 800a7f2:	b084      	sub	sp, #16
 800a7f4:	af00      	add	r7, sp, #0
 800a7f6:	6078      	str	r0, [r7, #4]
 800a7f8:	460b      	mov	r3, r1
 800a7fa:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800a7fc:	78fb      	ldrb	r3, [r7, #3]
 800a7fe:	f003 0307 	and.w	r3, r3, #7
 800a802:	687a      	ldr	r2, [r7, #4]
 800a804:	7912      	ldrb	r2, [r2, #4]
 800a806:	4293      	cmp	r3, r2
 800a808:	d901      	bls.n	800a80e <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 800a80a:	2301      	movs	r3, #1
 800a80c:	e03e      	b.n	800a88c <HAL_PCD_EP_SetStall+0x9c>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800a80e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800a812:	2b00      	cmp	r3, #0
 800a814:	da0e      	bge.n	800a834 <HAL_PCD_EP_SetStall+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800a816:	78fb      	ldrb	r3, [r7, #3]
 800a818:	f003 0207 	and.w	r2, r3, #7
 800a81c:	4613      	mov	r3, r2
 800a81e:	009b      	lsls	r3, r3, #2
 800a820:	4413      	add	r3, r2
 800a822:	00db      	lsls	r3, r3, #3
 800a824:	3310      	adds	r3, #16
 800a826:	687a      	ldr	r2, [r7, #4]
 800a828:	4413      	add	r3, r2
 800a82a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800a82c:	68fb      	ldr	r3, [r7, #12]
 800a82e:	2201      	movs	r2, #1
 800a830:	705a      	strb	r2, [r3, #1]
 800a832:	e00c      	b.n	800a84e <HAL_PCD_EP_SetStall+0x5e>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800a834:	78fa      	ldrb	r2, [r7, #3]
 800a836:	4613      	mov	r3, r2
 800a838:	009b      	lsls	r3, r3, #2
 800a83a:	4413      	add	r3, r2
 800a83c:	00db      	lsls	r3, r3, #3
 800a83e:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800a842:	687a      	ldr	r2, [r7, #4]
 800a844:	4413      	add	r3, r2
 800a846:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800a848:	68fb      	ldr	r3, [r7, #12]
 800a84a:	2200      	movs	r2, #0
 800a84c:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 800a84e:	68fb      	ldr	r3, [r7, #12]
 800a850:	2201      	movs	r2, #1
 800a852:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800a854:	78fb      	ldrb	r3, [r7, #3]
 800a856:	f003 0307 	and.w	r3, r3, #7
 800a85a:	b2da      	uxtb	r2, r3
 800a85c:	68fb      	ldr	r3, [r7, #12]
 800a85e:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800a860:	687b      	ldr	r3, [r7, #4]
 800a862:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 800a866:	2b01      	cmp	r3, #1
 800a868:	d101      	bne.n	800a86e <HAL_PCD_EP_SetStall+0x7e>
 800a86a:	2302      	movs	r3, #2
 800a86c:	e00e      	b.n	800a88c <HAL_PCD_EP_SetStall+0x9c>
 800a86e:	687b      	ldr	r3, [r7, #4]
 800a870:	2201      	movs	r2, #1
 800a872:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

  (void)USB_EPSetStall(hpcd->Instance, ep);
 800a876:	687b      	ldr	r3, [r7, #4]
 800a878:	681b      	ldr	r3, [r3, #0]
 800a87a:	68f9      	ldr	r1, [r7, #12]
 800a87c:	4618      	mov	r0, r3
 800a87e:	f006 fd49 	bl	8011314 <USB_EPSetStall>

  __HAL_UNLOCK(hpcd);
 800a882:	687b      	ldr	r3, [r7, #4]
 800a884:	2200      	movs	r2, #0
 800a886:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

  return HAL_OK;
 800a88a:	2300      	movs	r3, #0
}
 800a88c:	4618      	mov	r0, r3
 800a88e:	3710      	adds	r7, #16
 800a890:	46bd      	mov	sp, r7
 800a892:	bd80      	pop	{r7, pc}

0800a894 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800a894:	b580      	push	{r7, lr}
 800a896:	b084      	sub	sp, #16
 800a898:	af00      	add	r7, sp, #0
 800a89a:	6078      	str	r0, [r7, #4]
 800a89c:	460b      	mov	r3, r1
 800a89e:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800a8a0:	78fb      	ldrb	r3, [r7, #3]
 800a8a2:	f003 030f 	and.w	r3, r3, #15
 800a8a6:	687a      	ldr	r2, [r7, #4]
 800a8a8:	7912      	ldrb	r2, [r2, #4]
 800a8aa:	4293      	cmp	r3, r2
 800a8ac:	d901      	bls.n	800a8b2 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 800a8ae:	2301      	movs	r3, #1
 800a8b0:	e040      	b.n	800a934 <HAL_PCD_EP_ClrStall+0xa0>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800a8b2:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800a8b6:	2b00      	cmp	r3, #0
 800a8b8:	da0e      	bge.n	800a8d8 <HAL_PCD_EP_ClrStall+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800a8ba:	78fb      	ldrb	r3, [r7, #3]
 800a8bc:	f003 0207 	and.w	r2, r3, #7
 800a8c0:	4613      	mov	r3, r2
 800a8c2:	009b      	lsls	r3, r3, #2
 800a8c4:	4413      	add	r3, r2
 800a8c6:	00db      	lsls	r3, r3, #3
 800a8c8:	3310      	adds	r3, #16
 800a8ca:	687a      	ldr	r2, [r7, #4]
 800a8cc:	4413      	add	r3, r2
 800a8ce:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800a8d0:	68fb      	ldr	r3, [r7, #12]
 800a8d2:	2201      	movs	r2, #1
 800a8d4:	705a      	strb	r2, [r3, #1]
 800a8d6:	e00e      	b.n	800a8f6 <HAL_PCD_EP_ClrStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800a8d8:	78fb      	ldrb	r3, [r7, #3]
 800a8da:	f003 0207 	and.w	r2, r3, #7
 800a8de:	4613      	mov	r3, r2
 800a8e0:	009b      	lsls	r3, r3, #2
 800a8e2:	4413      	add	r3, r2
 800a8e4:	00db      	lsls	r3, r3, #3
 800a8e6:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800a8ea:	687a      	ldr	r2, [r7, #4]
 800a8ec:	4413      	add	r3, r2
 800a8ee:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800a8f0:	68fb      	ldr	r3, [r7, #12]
 800a8f2:	2200      	movs	r2, #0
 800a8f4:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 800a8f6:	68fb      	ldr	r3, [r7, #12]
 800a8f8:	2200      	movs	r2, #0
 800a8fa:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800a8fc:	78fb      	ldrb	r3, [r7, #3]
 800a8fe:	f003 0307 	and.w	r3, r3, #7
 800a902:	b2da      	uxtb	r2, r3
 800a904:	68fb      	ldr	r3, [r7, #12]
 800a906:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800a908:	687b      	ldr	r3, [r7, #4]
 800a90a:	f893 3290 	ldrb.w	r3, [r3, #656]	; 0x290
 800a90e:	2b01      	cmp	r3, #1
 800a910:	d101      	bne.n	800a916 <HAL_PCD_EP_ClrStall+0x82>
 800a912:	2302      	movs	r3, #2
 800a914:	e00e      	b.n	800a934 <HAL_PCD_EP_ClrStall+0xa0>
 800a916:	687b      	ldr	r3, [r7, #4]
 800a918:	2201      	movs	r2, #1
 800a91a:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800a91e:	687b      	ldr	r3, [r7, #4]
 800a920:	681b      	ldr	r3, [r3, #0]
 800a922:	68f9      	ldr	r1, [r7, #12]
 800a924:	4618      	mov	r0, r3
 800a926:	f006 fd46 	bl	80113b6 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 800a92a:	687b      	ldr	r3, [r7, #4]
 800a92c:	2200      	movs	r2, #0
 800a92e:	f883 2290 	strb.w	r2, [r3, #656]	; 0x290

  return HAL_OK;
 800a932:	2300      	movs	r3, #0
}
 800a934:	4618      	mov	r0, r3
 800a936:	3710      	adds	r7, #16
 800a938:	46bd      	mov	sp, r7
 800a93a:	bd80      	pop	{r7, pc}

0800a93c <PCD_EP_ISR_Handler>:
  * @brief  This function handles PCD Endpoint interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
 800a93c:	b580      	push	{r7, lr}
 800a93e:	b096      	sub	sp, #88	; 0x58
 800a940:	af00      	add	r7, sp, #0
 800a942:	6078      	str	r0, [r7, #4]
#if (USE_USB_DOUBLE_BUFFER != 1U)
  count = 0U;
#endif /* USE_USB_DOUBLE_BUFFER */

  /* stay in loop while pending interrupts */
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800a944:	e3ae      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
  {
    wIstr = hpcd->Instance->ISTR;
 800a946:	687b      	ldr	r3, [r7, #4]
 800a948:	681b      	ldr	r3, [r3, #0]
 800a94a:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800a94e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

    /* extract highest priority endpoint number */
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 800a952:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a956:	b2db      	uxtb	r3, r3
 800a958:	f003 030f 	and.w	r3, r3, #15
 800a95c:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d

    if (epindex == 0U)
 800a960:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800a964:	2b00      	cmp	r3, #0
 800a966:	f040 8170 	bne.w	800ac4a <PCD_EP_ISR_Handler+0x30e>
    {
      /* Decode and service control endpoint interrupt */

      /* DIR bit = origin of the interrupt */
      if ((wIstr & USB_ISTR_DIR) == 0U)
 800a96a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a96e:	f003 0310 	and.w	r3, r3, #16
 800a972:	2b00      	cmp	r3, #0
 800a974:	d14d      	bne.n	800aa12 <PCD_EP_ISR_Handler+0xd6>
      {
        /* DIR = 0 */

        /* DIR = 0 => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800a976:	687b      	ldr	r3, [r7, #4]
 800a978:	681b      	ldr	r3, [r3, #0]
 800a97a:	881b      	ldrh	r3, [r3, #0]
 800a97c:	b29b      	uxth	r3, r3
 800a97e:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 800a982:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800a986:	81fb      	strh	r3, [r7, #14]
 800a988:	687b      	ldr	r3, [r7, #4]
 800a98a:	681a      	ldr	r2, [r3, #0]
 800a98c:	89fb      	ldrh	r3, [r7, #14]
 800a98e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800a992:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800a996:	b29b      	uxth	r3, r3
 800a998:	8013      	strh	r3, [r2, #0]
        ep = &hpcd->IN_ep[0];
 800a99a:	687b      	ldr	r3, [r7, #4]
 800a99c:	3310      	adds	r3, #16
 800a99e:	657b      	str	r3, [r7, #84]	; 0x54

        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800a9a0:	687b      	ldr	r3, [r7, #4]
 800a9a2:	681b      	ldr	r3, [r3, #0]
 800a9a4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800a9a8:	b29b      	uxth	r3, r3
 800a9aa:	461a      	mov	r2, r3
 800a9ac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9ae:	781b      	ldrb	r3, [r3, #0]
 800a9b0:	00db      	lsls	r3, r3, #3
 800a9b2:	4413      	add	r3, r2
 800a9b4:	687a      	ldr	r2, [r7, #4]
 800a9b6:	6812      	ldr	r2, [r2, #0]
 800a9b8:	4413      	add	r3, r2
 800a9ba:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800a9be:	881b      	ldrh	r3, [r3, #0]
 800a9c0:	f3c3 0209 	ubfx	r2, r3, #0, #10
 800a9c4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9c6:	61da      	str	r2, [r3, #28]
        ep->xfer_buff += ep->xfer_count;
 800a9c8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9ca:	695a      	ldr	r2, [r3, #20]
 800a9cc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9ce:	69db      	ldr	r3, [r3, #28]
 800a9d0:	441a      	add	r2, r3
 800a9d2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9d4:	615a      	str	r2, [r3, #20]

        /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataInStageCallback(hpcd, 0U);
#else
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 800a9d6:	2100      	movs	r1, #0
 800a9d8:	6878      	ldr	r0, [r7, #4]
 800a9da:	f009 fa4c 	bl	8013e76 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

        if ((hpcd->USB_Address > 0U) && (ep->xfer_len == 0U))
 800a9de:	687b      	ldr	r3, [r7, #4]
 800a9e0:	7b1b      	ldrb	r3, [r3, #12]
 800a9e2:	b2db      	uxtb	r3, r3
 800a9e4:	2b00      	cmp	r3, #0
 800a9e6:	f000 835d 	beq.w	800b0a4 <PCD_EP_ISR_Handler+0x768>
 800a9ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9ec:	699b      	ldr	r3, [r3, #24]
 800a9ee:	2b00      	cmp	r3, #0
 800a9f0:	f040 8358 	bne.w	800b0a4 <PCD_EP_ISR_Handler+0x768>
        {
          hpcd->Instance->DADDR = ((uint16_t)hpcd->USB_Address | USB_DADDR_EF);
 800a9f4:	687b      	ldr	r3, [r7, #4]
 800a9f6:	7b1b      	ldrb	r3, [r3, #12]
 800a9f8:	b2db      	uxtb	r3, r3
 800a9fa:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800a9fe:	b2da      	uxtb	r2, r3
 800aa00:	687b      	ldr	r3, [r7, #4]
 800aa02:	681b      	ldr	r3, [r3, #0]
 800aa04:	b292      	uxth	r2, r2
 800aa06:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
          hpcd->USB_Address = 0U;
 800aa0a:	687b      	ldr	r3, [r7, #4]
 800aa0c:	2200      	movs	r2, #0
 800aa0e:	731a      	strb	r2, [r3, #12]
 800aa10:	e348      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
      {
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
        ep = &hpcd->OUT_ep[0];
 800aa12:	687b      	ldr	r3, [r7, #4]
 800aa14:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800aa18:	657b      	str	r3, [r7, #84]	; 0x54
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800aa1a:	687b      	ldr	r3, [r7, #4]
 800aa1c:	681b      	ldr	r3, [r3, #0]
 800aa1e:	881b      	ldrh	r3, [r3, #0]
 800aa20:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a

        if ((wEPVal & USB_EP_SETUP) != 0U)
 800aa24:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800aa28:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800aa2c:	2b00      	cmp	r3, #0
 800aa2e:	d032      	beq.n	800aa96 <PCD_EP_ISR_Handler+0x15a>
        {
          /* Get SETUP Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800aa30:	687b      	ldr	r3, [r7, #4]
 800aa32:	681b      	ldr	r3, [r3, #0]
 800aa34:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800aa38:	b29b      	uxth	r3, r3
 800aa3a:	461a      	mov	r2, r3
 800aa3c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa3e:	781b      	ldrb	r3, [r3, #0]
 800aa40:	00db      	lsls	r3, r3, #3
 800aa42:	4413      	add	r3, r2
 800aa44:	687a      	ldr	r2, [r7, #4]
 800aa46:	6812      	ldr	r2, [r2, #0]
 800aa48:	4413      	add	r3, r2
 800aa4a:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800aa4e:	881b      	ldrh	r3, [r3, #0]
 800aa50:	f3c3 0209 	ubfx	r2, r3, #0, #10
 800aa54:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa56:	61da      	str	r2, [r3, #28]

          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800aa58:	687b      	ldr	r3, [r7, #4]
 800aa5a:	6818      	ldr	r0, [r3, #0]
 800aa5c:	687b      	ldr	r3, [r7, #4]
 800aa5e:	f503 7126 	add.w	r1, r3, #664	; 0x298
 800aa62:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa64:	88da      	ldrh	r2, [r3, #6]
                      ep->pmaadress, (uint16_t)ep->xfer_count);
 800aa66:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa68:	69db      	ldr	r3, [r3, #28]
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800aa6a:	b29b      	uxth	r3, r3
 800aa6c:	f006 fdce 	bl	801160c <USB_ReadPMA>

          /* SETUP bit kept frozen while CTR_RX = 1 */
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800aa70:	687b      	ldr	r3, [r7, #4]
 800aa72:	681b      	ldr	r3, [r3, #0]
 800aa74:	881b      	ldrh	r3, [r3, #0]
 800aa76:	b29a      	uxth	r2, r3
 800aa78:	f640 738f 	movw	r3, #3983	; 0xf8f
 800aa7c:	4013      	ands	r3, r2
 800aa7e:	823b      	strh	r3, [r7, #16]
 800aa80:	687b      	ldr	r3, [r7, #4]
 800aa82:	681b      	ldr	r3, [r3, #0]
 800aa84:	8a3a      	ldrh	r2, [r7, #16]
 800aa86:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800aa8a:	b292      	uxth	r2, r2
 800aa8c:	801a      	strh	r2, [r3, #0]

          /* Process SETUP Packet*/
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->SetupStageCallback(hpcd);
#else
          HAL_PCD_SetupStageCallback(hpcd);
 800aa8e:	6878      	ldr	r0, [r7, #4]
 800aa90:	f009 f9c4 	bl	8013e1c <HAL_PCD_SetupStageCallback>
 800aa94:	e306      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800aa96:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 800aa9a:	2b00      	cmp	r3, #0
 800aa9c:	f280 8302 	bge.w	800b0a4 <PCD_EP_ISR_Handler+0x768>
        {
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800aaa0:	687b      	ldr	r3, [r7, #4]
 800aaa2:	681b      	ldr	r3, [r3, #0]
 800aaa4:	881b      	ldrh	r3, [r3, #0]
 800aaa6:	b29a      	uxth	r2, r3
 800aaa8:	f640 738f 	movw	r3, #3983	; 0xf8f
 800aaac:	4013      	ands	r3, r2
 800aaae:	83fb      	strh	r3, [r7, #30]
 800aab0:	687b      	ldr	r3, [r7, #4]
 800aab2:	681b      	ldr	r3, [r3, #0]
 800aab4:	8bfa      	ldrh	r2, [r7, #30]
 800aab6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800aaba:	b292      	uxth	r2, r2
 800aabc:	801a      	strh	r2, [r3, #0]

          /* Get Control Data OUT Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800aabe:	687b      	ldr	r3, [r7, #4]
 800aac0:	681b      	ldr	r3, [r3, #0]
 800aac2:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800aac6:	b29b      	uxth	r3, r3
 800aac8:	461a      	mov	r2, r3
 800aaca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aacc:	781b      	ldrb	r3, [r3, #0]
 800aace:	00db      	lsls	r3, r3, #3
 800aad0:	4413      	add	r3, r2
 800aad2:	687a      	ldr	r2, [r7, #4]
 800aad4:	6812      	ldr	r2, [r2, #0]
 800aad6:	4413      	add	r3, r2
 800aad8:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800aadc:	881b      	ldrh	r3, [r3, #0]
 800aade:	f3c3 0209 	ubfx	r2, r3, #0, #10
 800aae2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aae4:	61da      	str	r2, [r3, #28]

          if ((ep->xfer_count != 0U) && (ep->xfer_buff != 0U))
 800aae6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aae8:	69db      	ldr	r3, [r3, #28]
 800aaea:	2b00      	cmp	r3, #0
 800aaec:	d019      	beq.n	800ab22 <PCD_EP_ISR_Handler+0x1e6>
 800aaee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aaf0:	695b      	ldr	r3, [r3, #20]
 800aaf2:	2b00      	cmp	r3, #0
 800aaf4:	d015      	beq.n	800ab22 <PCD_EP_ISR_Handler+0x1e6>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800aaf6:	687b      	ldr	r3, [r7, #4]
 800aaf8:	6818      	ldr	r0, [r3, #0]
 800aafa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aafc:	6959      	ldr	r1, [r3, #20]
 800aafe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab00:	88da      	ldrh	r2, [r3, #6]
                        ep->pmaadress, (uint16_t)ep->xfer_count);
 800ab02:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab04:	69db      	ldr	r3, [r3, #28]
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800ab06:	b29b      	uxth	r3, r3
 800ab08:	f006 fd80 	bl	801160c <USB_ReadPMA>

            ep->xfer_buff += ep->xfer_count;
 800ab0c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab0e:	695a      	ldr	r2, [r3, #20]
 800ab10:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab12:	69db      	ldr	r3, [r3, #28]
 800ab14:	441a      	add	r2, r3
 800ab16:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab18:	615a      	str	r2, [r3, #20]

            /* Process Control Data OUT Packet */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataOutStageCallback(hpcd, 0U);
#else
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800ab1a:	2100      	movs	r1, #0
 800ab1c:	6878      	ldr	r0, [r7, #4]
 800ab1e:	f009 f98f 	bl	8013e40 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }

          wEPVal = (uint16_t)PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800ab22:	687b      	ldr	r3, [r7, #4]
 800ab24:	681b      	ldr	r3, [r3, #0]
 800ab26:	881b      	ldrh	r3, [r3, #0]
 800ab28:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a

          if (((wEPVal & USB_EP_SETUP) == 0U) && ((wEPVal & USB_EP_RX_STRX) != USB_EP_RX_VALID))
 800ab2c:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800ab30:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800ab34:	2b00      	cmp	r3, #0
 800ab36:	f040 82b5 	bne.w	800b0a4 <PCD_EP_ISR_Handler+0x768>
 800ab3a:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800ab3e:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800ab42:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800ab46:	f000 82ad 	beq.w	800b0a4 <PCD_EP_ISR_Handler+0x768>
          {
            PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800ab4a:	687b      	ldr	r3, [r7, #4]
 800ab4c:	681b      	ldr	r3, [r3, #0]
 800ab4e:	61bb      	str	r3, [r7, #24]
 800ab50:	687b      	ldr	r3, [r7, #4]
 800ab52:	681b      	ldr	r3, [r3, #0]
 800ab54:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800ab58:	b29b      	uxth	r3, r3
 800ab5a:	461a      	mov	r2, r3
 800ab5c:	69bb      	ldr	r3, [r7, #24]
 800ab5e:	4413      	add	r3, r2
 800ab60:	61bb      	str	r3, [r7, #24]
 800ab62:	69bb      	ldr	r3, [r7, #24]
 800ab64:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800ab68:	617b      	str	r3, [r7, #20]
 800ab6a:	697b      	ldr	r3, [r7, #20]
 800ab6c:	881b      	ldrh	r3, [r3, #0]
 800ab6e:	b29b      	uxth	r3, r3
 800ab70:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800ab74:	b29a      	uxth	r2, r3
 800ab76:	697b      	ldr	r3, [r7, #20]
 800ab78:	801a      	strh	r2, [r3, #0]
 800ab7a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab7c:	691b      	ldr	r3, [r3, #16]
 800ab7e:	2b3e      	cmp	r3, #62	; 0x3e
 800ab80:	d91d      	bls.n	800abbe <PCD_EP_ISR_Handler+0x282>
 800ab82:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab84:	691b      	ldr	r3, [r3, #16]
 800ab86:	095b      	lsrs	r3, r3, #5
 800ab88:	647b      	str	r3, [r7, #68]	; 0x44
 800ab8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab8c:	691b      	ldr	r3, [r3, #16]
 800ab8e:	f003 031f 	and.w	r3, r3, #31
 800ab92:	2b00      	cmp	r3, #0
 800ab94:	d102      	bne.n	800ab9c <PCD_EP_ISR_Handler+0x260>
 800ab96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ab98:	3b01      	subs	r3, #1
 800ab9a:	647b      	str	r3, [r7, #68]	; 0x44
 800ab9c:	697b      	ldr	r3, [r7, #20]
 800ab9e:	881b      	ldrh	r3, [r3, #0]
 800aba0:	b29a      	uxth	r2, r3
 800aba2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aba4:	b29b      	uxth	r3, r3
 800aba6:	029b      	lsls	r3, r3, #10
 800aba8:	b29b      	uxth	r3, r3
 800abaa:	4313      	orrs	r3, r2
 800abac:	b29b      	uxth	r3, r3
 800abae:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800abb2:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800abb6:	b29a      	uxth	r2, r3
 800abb8:	697b      	ldr	r3, [r7, #20]
 800abba:	801a      	strh	r2, [r3, #0]
 800abbc:	e026      	b.n	800ac0c <PCD_EP_ISR_Handler+0x2d0>
 800abbe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800abc0:	691b      	ldr	r3, [r3, #16]
 800abc2:	2b00      	cmp	r3, #0
 800abc4:	d10a      	bne.n	800abdc <PCD_EP_ISR_Handler+0x2a0>
 800abc6:	697b      	ldr	r3, [r7, #20]
 800abc8:	881b      	ldrh	r3, [r3, #0]
 800abca:	b29b      	uxth	r3, r3
 800abcc:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800abd0:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800abd4:	b29a      	uxth	r2, r3
 800abd6:	697b      	ldr	r3, [r7, #20]
 800abd8:	801a      	strh	r2, [r3, #0]
 800abda:	e017      	b.n	800ac0c <PCD_EP_ISR_Handler+0x2d0>
 800abdc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800abde:	691b      	ldr	r3, [r3, #16]
 800abe0:	085b      	lsrs	r3, r3, #1
 800abe2:	647b      	str	r3, [r7, #68]	; 0x44
 800abe4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800abe6:	691b      	ldr	r3, [r3, #16]
 800abe8:	f003 0301 	and.w	r3, r3, #1
 800abec:	2b00      	cmp	r3, #0
 800abee:	d002      	beq.n	800abf6 <PCD_EP_ISR_Handler+0x2ba>
 800abf0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800abf2:	3301      	adds	r3, #1
 800abf4:	647b      	str	r3, [r7, #68]	; 0x44
 800abf6:	697b      	ldr	r3, [r7, #20]
 800abf8:	881b      	ldrh	r3, [r3, #0]
 800abfa:	b29a      	uxth	r2, r3
 800abfc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800abfe:	b29b      	uxth	r3, r3
 800ac00:	029b      	lsls	r3, r3, #10
 800ac02:	b29b      	uxth	r3, r3
 800ac04:	4313      	orrs	r3, r2
 800ac06:	b29a      	uxth	r2, r3
 800ac08:	697b      	ldr	r3, [r7, #20]
 800ac0a:	801a      	strh	r2, [r3, #0]
            PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 800ac0c:	687b      	ldr	r3, [r7, #4]
 800ac0e:	681b      	ldr	r3, [r3, #0]
 800ac10:	881b      	ldrh	r3, [r3, #0]
 800ac12:	b29b      	uxth	r3, r3
 800ac14:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800ac18:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ac1c:	827b      	strh	r3, [r7, #18]
 800ac1e:	8a7b      	ldrh	r3, [r7, #18]
 800ac20:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800ac24:	827b      	strh	r3, [r7, #18]
 800ac26:	8a7b      	ldrh	r3, [r7, #18]
 800ac28:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800ac2c:	827b      	strh	r3, [r7, #18]
 800ac2e:	687b      	ldr	r3, [r7, #4]
 800ac30:	681a      	ldr	r2, [r3, #0]
 800ac32:	8a7b      	ldrh	r3, [r7, #18]
 800ac34:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800ac38:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800ac3c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800ac40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ac44:	b29b      	uxth	r3, r3
 800ac46:	8013      	strh	r3, [r2, #0]
 800ac48:	e22c      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
    }
    else
    {
      /* Decode and service non control endpoints interrupt */
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 800ac4a:	687b      	ldr	r3, [r7, #4]
 800ac4c:	681b      	ldr	r3, [r3, #0]
 800ac4e:	461a      	mov	r2, r3
 800ac50:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800ac54:	009b      	lsls	r3, r3, #2
 800ac56:	4413      	add	r3, r2
 800ac58:	881b      	ldrh	r3, [r3, #0]
 800ac5a:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a

      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800ac5e:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 800ac62:	2b00      	cmp	r3, #0
 800ac64:	f280 80f6 	bge.w	800ae54 <PCD_EP_ISR_Handler+0x518>
      {
        /* clear int flag */
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 800ac68:	687b      	ldr	r3, [r7, #4]
 800ac6a:	681b      	ldr	r3, [r3, #0]
 800ac6c:	461a      	mov	r2, r3
 800ac6e:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800ac72:	009b      	lsls	r3, r3, #2
 800ac74:	4413      	add	r3, r2
 800ac76:	881b      	ldrh	r3, [r3, #0]
 800ac78:	b29a      	uxth	r2, r3
 800ac7a:	f640 738f 	movw	r3, #3983	; 0xf8f
 800ac7e:	4013      	ands	r3, r2
 800ac80:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
 800ac84:	687b      	ldr	r3, [r7, #4]
 800ac86:	681b      	ldr	r3, [r3, #0]
 800ac88:	461a      	mov	r2, r3
 800ac8a:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800ac8e:	009b      	lsls	r3, r3, #2
 800ac90:	4413      	add	r3, r2
 800ac92:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 800ac96:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ac9a:	b292      	uxth	r2, r2
 800ac9c:	801a      	strh	r2, [r3, #0]
        ep = &hpcd->OUT_ep[epindex];
 800ac9e:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 800aca2:	4613      	mov	r3, r2
 800aca4:	009b      	lsls	r3, r3, #2
 800aca6:	4413      	add	r3, r2
 800aca8:	00db      	lsls	r3, r3, #3
 800acaa:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800acae:	687a      	ldr	r2, [r7, #4]
 800acb0:	4413      	add	r3, r2
 800acb2:	657b      	str	r3, [r7, #84]	; 0x54

        /* OUT Single Buffering */
        if (ep->doublebuffer == 0U)
 800acb4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800acb6:	7b1b      	ldrb	r3, [r3, #12]
 800acb8:	2b00      	cmp	r3, #0
 800acba:	d123      	bne.n	800ad04 <PCD_EP_ISR_Handler+0x3c8>
        {
          count = (uint16_t)PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800acbc:	687b      	ldr	r3, [r7, #4]
 800acbe:	681b      	ldr	r3, [r3, #0]
 800acc0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800acc4:	b29b      	uxth	r3, r3
 800acc6:	461a      	mov	r2, r3
 800acc8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800acca:	781b      	ldrb	r3, [r3, #0]
 800accc:	00db      	lsls	r3, r3, #3
 800acce:	4413      	add	r3, r2
 800acd0:	687a      	ldr	r2, [r7, #4]
 800acd2:	6812      	ldr	r2, [r2, #0]
 800acd4:	4413      	add	r3, r2
 800acd6:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800acda:	881b      	ldrh	r3, [r3, #0]
 800acdc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800ace0:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50

          if (count != 0U)
 800ace4:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800ace8:	2b00      	cmp	r3, #0
 800acea:	f000 808e 	beq.w	800ae0a <PCD_EP_ISR_Handler+0x4ce>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 800acee:	687b      	ldr	r3, [r7, #4]
 800acf0:	6818      	ldr	r0, [r3, #0]
 800acf2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800acf4:	6959      	ldr	r1, [r3, #20]
 800acf6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800acf8:	88da      	ldrh	r2, [r3, #6]
 800acfa:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800acfe:	f006 fc85 	bl	801160c <USB_ReadPMA>
 800ad02:	e082      	b.n	800ae0a <PCD_EP_ISR_Handler+0x4ce>
        }
#if (USE_USB_DOUBLE_BUFFER == 1U)
        else
        {
          /* manage double buffer bulk out */
          if (ep->type == EP_TYPE_BULK)
 800ad04:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad06:	78db      	ldrb	r3, [r3, #3]
 800ad08:	2b02      	cmp	r3, #2
 800ad0a:	d10a      	bne.n	800ad22 <PCD_EP_ISR_Handler+0x3e6>
          {
            count = HAL_PCD_EP_DB_Receive(hpcd, ep, wEPVal);
 800ad0c:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800ad10:	461a      	mov	r2, r3
 800ad12:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800ad14:	6878      	ldr	r0, [r7, #4]
 800ad16:	f000 f9d3 	bl	800b0c0 <HAL_PCD_EP_DB_Receive>
 800ad1a:	4603      	mov	r3, r0
 800ad1c:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
 800ad20:	e073      	b.n	800ae0a <PCD_EP_ISR_Handler+0x4ce>
          }
          else /* manage double buffer iso out */
          {
            /* free EP OUT Buffer */
            PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 0U);
 800ad22:	687b      	ldr	r3, [r7, #4]
 800ad24:	681b      	ldr	r3, [r3, #0]
 800ad26:	461a      	mov	r2, r3
 800ad28:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad2a:	781b      	ldrb	r3, [r3, #0]
 800ad2c:	009b      	lsls	r3, r3, #2
 800ad2e:	4413      	add	r3, r2
 800ad30:	881b      	ldrh	r3, [r3, #0]
 800ad32:	b29b      	uxth	r3, r3
 800ad34:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800ad38:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ad3c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
 800ad40:	687b      	ldr	r3, [r7, #4]
 800ad42:	681b      	ldr	r3, [r3, #0]
 800ad44:	461a      	mov	r2, r3
 800ad46:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad48:	781b      	ldrb	r3, [r3, #0]
 800ad4a:	009b      	lsls	r3, r3, #2
 800ad4c:	441a      	add	r2, r3
 800ad4e:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800ad52:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800ad56:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800ad5a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800ad5e:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800ad62:	b29b      	uxth	r3, r3
 800ad64:	8013      	strh	r3, [r2, #0]

            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 800ad66:	687b      	ldr	r3, [r7, #4]
 800ad68:	681b      	ldr	r3, [r3, #0]
 800ad6a:	461a      	mov	r2, r3
 800ad6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad6e:	781b      	ldrb	r3, [r3, #0]
 800ad70:	009b      	lsls	r3, r3, #2
 800ad72:	4413      	add	r3, r2
 800ad74:	881b      	ldrh	r3, [r3, #0]
 800ad76:	b29b      	uxth	r3, r3
 800ad78:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800ad7c:	2b00      	cmp	r3, #0
 800ad7e:	d022      	beq.n	800adc6 <PCD_EP_ISR_Handler+0x48a>
            {
              /* read from endpoint BUF0Addr buffer */
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800ad80:	687b      	ldr	r3, [r7, #4]
 800ad82:	681b      	ldr	r3, [r3, #0]
 800ad84:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800ad88:	b29b      	uxth	r3, r3
 800ad8a:	461a      	mov	r2, r3
 800ad8c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad8e:	781b      	ldrb	r3, [r3, #0]
 800ad90:	00db      	lsls	r3, r3, #3
 800ad92:	4413      	add	r3, r2
 800ad94:	687a      	ldr	r2, [r7, #4]
 800ad96:	6812      	ldr	r2, [r2, #0]
 800ad98:	4413      	add	r3, r2
 800ad9a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800ad9e:	881b      	ldrh	r3, [r3, #0]
 800ada0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800ada4:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50

              if (count != 0U)
 800ada8:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800adac:	2b00      	cmp	r3, #0
 800adae:	d02c      	beq.n	800ae0a <PCD_EP_ISR_Handler+0x4ce>
              {
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800adb0:	687b      	ldr	r3, [r7, #4]
 800adb2:	6818      	ldr	r0, [r3, #0]
 800adb4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adb6:	6959      	ldr	r1, [r3, #20]
 800adb8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adba:	891a      	ldrh	r2, [r3, #8]
 800adbc:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800adc0:	f006 fc24 	bl	801160c <USB_ReadPMA>
 800adc4:	e021      	b.n	800ae0a <PCD_EP_ISR_Handler+0x4ce>
              }
            }
            else
            {
              /* read from endpoint BUF1Addr buffer */
              count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800adc6:	687b      	ldr	r3, [r7, #4]
 800adc8:	681b      	ldr	r3, [r3, #0]
 800adca:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800adce:	b29b      	uxth	r3, r3
 800add0:	461a      	mov	r2, r3
 800add2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800add4:	781b      	ldrb	r3, [r3, #0]
 800add6:	00db      	lsls	r3, r3, #3
 800add8:	4413      	add	r3, r2
 800adda:	687a      	ldr	r2, [r7, #4]
 800addc:	6812      	ldr	r2, [r2, #0]
 800adde:	4413      	add	r3, r2
 800ade0:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800ade4:	881b      	ldrh	r3, [r3, #0]
 800ade6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800adea:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50

              if (count != 0U)
 800adee:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800adf2:	2b00      	cmp	r3, #0
 800adf4:	d009      	beq.n	800ae0a <PCD_EP_ISR_Handler+0x4ce>
              {
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800adf6:	687b      	ldr	r3, [r7, #4]
 800adf8:	6818      	ldr	r0, [r3, #0]
 800adfa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adfc:	6959      	ldr	r1, [r3, #20]
 800adfe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae00:	895a      	ldrh	r2, [r3, #10]
 800ae02:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800ae06:	f006 fc01 	bl	801160c <USB_ReadPMA>
          }
        }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

        /* multi-packet on the NON control OUT endpoint */
        ep->xfer_count += count;
 800ae0a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae0c:	69da      	ldr	r2, [r3, #28]
 800ae0e:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800ae12:	441a      	add	r2, r3
 800ae14:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae16:	61da      	str	r2, [r3, #28]
        ep->xfer_buff += count;
 800ae18:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae1a:	695a      	ldr	r2, [r3, #20]
 800ae1c:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800ae20:	441a      	add	r2, r3
 800ae22:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae24:	615a      	str	r2, [r3, #20]

        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 800ae26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae28:	699b      	ldr	r3, [r3, #24]
 800ae2a:	2b00      	cmp	r3, #0
 800ae2c:	d005      	beq.n	800ae3a <PCD_EP_ISR_Handler+0x4fe>
 800ae2e:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 800ae32:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae34:	691b      	ldr	r3, [r3, #16]
 800ae36:	429a      	cmp	r2, r3
 800ae38:	d206      	bcs.n	800ae48 <PCD_EP_ISR_Handler+0x50c>
        {
          /* RX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataOutStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 800ae3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ae3c:	781b      	ldrb	r3, [r3, #0]
 800ae3e:	4619      	mov	r1, r3
 800ae40:	6878      	ldr	r0, [r7, #4]
 800ae42:	f008 fffd 	bl	8013e40 <HAL_PCD_DataOutStageCallback>
 800ae46:	e005      	b.n	800ae54 <PCD_EP_ISR_Handler+0x518>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        {
          (void)USB_EPStartXfer(hpcd->Instance, ep);
 800ae48:	687b      	ldr	r3, [r7, #4]
 800ae4a:	681b      	ldr	r3, [r3, #0]
 800ae4c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800ae4e:	4618      	mov	r0, r3
 800ae50:	f004 feaf 	bl	800fbb2 <USB_EPStartXfer>
        }
      }

      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 800ae54:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800ae58:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ae5c:	2b00      	cmp	r3, #0
 800ae5e:	f000 8121 	beq.w	800b0a4 <PCD_EP_ISR_Handler+0x768>
      {
        ep = &hpcd->IN_ep[epindex];
 800ae62:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 800ae66:	4613      	mov	r3, r2
 800ae68:	009b      	lsls	r3, r3, #2
 800ae6a:	4413      	add	r3, r2
 800ae6c:	00db      	lsls	r3, r3, #3
 800ae6e:	3310      	adds	r3, #16
 800ae70:	687a      	ldr	r2, [r7, #4]
 800ae72:	4413      	add	r3, r2
 800ae74:	657b      	str	r3, [r7, #84]	; 0x54

        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 800ae76:	687b      	ldr	r3, [r7, #4]
 800ae78:	681b      	ldr	r3, [r3, #0]
 800ae7a:	461a      	mov	r2, r3
 800ae7c:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800ae80:	009b      	lsls	r3, r3, #2
 800ae82:	4413      	add	r3, r2
 800ae84:	881b      	ldrh	r3, [r3, #0]
 800ae86:	b29b      	uxth	r3, r3
 800ae88:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 800ae8c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ae90:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 800ae94:	687b      	ldr	r3, [r7, #4]
 800ae96:	681b      	ldr	r3, [r3, #0]
 800ae98:	461a      	mov	r2, r3
 800ae9a:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800ae9e:	009b      	lsls	r3, r3, #2
 800aea0:	441a      	add	r2, r3
 800aea2:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 800aea6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800aeaa:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800aeae:	b29b      	uxth	r3, r3
 800aeb0:	8013      	strh	r3, [r2, #0]

        if (ep->type == EP_TYPE_ISOC)
 800aeb2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aeb4:	78db      	ldrb	r3, [r3, #3]
 800aeb6:	2b01      	cmp	r3, #1
 800aeb8:	f040 80a2 	bne.w	800b000 <PCD_EP_ISR_Handler+0x6c4>
        {
          ep->xfer_len = 0U;
 800aebc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aebe:	2200      	movs	r2, #0
 800aec0:	619a      	str	r2, [r3, #24]

#if (USE_USB_DOUBLE_BUFFER == 1U)
          if (ep->doublebuffer != 0U)
 800aec2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aec4:	7b1b      	ldrb	r3, [r3, #12]
 800aec6:	2b00      	cmp	r3, #0
 800aec8:	f000 8093 	beq.w	800aff2 <PCD_EP_ISR_Handler+0x6b6>
          {
            if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800aecc:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800aed0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800aed4:	2b00      	cmp	r3, #0
 800aed6:	d046      	beq.n	800af66 <PCD_EP_ISR_Handler+0x62a>
            {
              PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800aed8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aeda:	785b      	ldrb	r3, [r3, #1]
 800aedc:	2b00      	cmp	r3, #0
 800aede:	d126      	bne.n	800af2e <PCD_EP_ISR_Handler+0x5f2>
 800aee0:	687b      	ldr	r3, [r7, #4]
 800aee2:	681b      	ldr	r3, [r3, #0]
 800aee4:	627b      	str	r3, [r7, #36]	; 0x24
 800aee6:	687b      	ldr	r3, [r7, #4]
 800aee8:	681b      	ldr	r3, [r3, #0]
 800aeea:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800aeee:	b29b      	uxth	r3, r3
 800aef0:	461a      	mov	r2, r3
 800aef2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aef4:	4413      	add	r3, r2
 800aef6:	627b      	str	r3, [r7, #36]	; 0x24
 800aef8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aefa:	781b      	ldrb	r3, [r3, #0]
 800aefc:	00da      	lsls	r2, r3, #3
 800aefe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af00:	4413      	add	r3, r2
 800af02:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800af06:	623b      	str	r3, [r7, #32]
 800af08:	6a3b      	ldr	r3, [r7, #32]
 800af0a:	881b      	ldrh	r3, [r3, #0]
 800af0c:	b29b      	uxth	r3, r3
 800af0e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800af12:	b29a      	uxth	r2, r3
 800af14:	6a3b      	ldr	r3, [r7, #32]
 800af16:	801a      	strh	r2, [r3, #0]
 800af18:	6a3b      	ldr	r3, [r7, #32]
 800af1a:	881b      	ldrh	r3, [r3, #0]
 800af1c:	b29b      	uxth	r3, r3
 800af1e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800af22:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800af26:	b29a      	uxth	r2, r3
 800af28:	6a3b      	ldr	r3, [r7, #32]
 800af2a:	801a      	strh	r2, [r3, #0]
 800af2c:	e061      	b.n	800aff2 <PCD_EP_ISR_Handler+0x6b6>
 800af2e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800af30:	785b      	ldrb	r3, [r3, #1]
 800af32:	2b01      	cmp	r3, #1
 800af34:	d15d      	bne.n	800aff2 <PCD_EP_ISR_Handler+0x6b6>
 800af36:	687b      	ldr	r3, [r7, #4]
 800af38:	681b      	ldr	r3, [r3, #0]
 800af3a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800af3c:	687b      	ldr	r3, [r7, #4]
 800af3e:	681b      	ldr	r3, [r3, #0]
 800af40:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800af44:	b29b      	uxth	r3, r3
 800af46:	461a      	mov	r2, r3
 800af48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af4a:	4413      	add	r3, r2
 800af4c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800af4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800af50:	781b      	ldrb	r3, [r3, #0]
 800af52:	00da      	lsls	r2, r3, #3
 800af54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af56:	4413      	add	r3, r2
 800af58:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800af5c:	62bb      	str	r3, [r7, #40]	; 0x28
 800af5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af60:	2200      	movs	r2, #0
 800af62:	801a      	strh	r2, [r3, #0]
 800af64:	e045      	b.n	800aff2 <PCD_EP_ISR_Handler+0x6b6>
            }
            else
            {
              PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800af66:	687b      	ldr	r3, [r7, #4]
 800af68:	681b      	ldr	r3, [r3, #0]
 800af6a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800af6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800af6e:	785b      	ldrb	r3, [r3, #1]
 800af70:	2b00      	cmp	r3, #0
 800af72:	d126      	bne.n	800afc2 <PCD_EP_ISR_Handler+0x686>
 800af74:	687b      	ldr	r3, [r7, #4]
 800af76:	681b      	ldr	r3, [r3, #0]
 800af78:	637b      	str	r3, [r7, #52]	; 0x34
 800af7a:	687b      	ldr	r3, [r7, #4]
 800af7c:	681b      	ldr	r3, [r3, #0]
 800af7e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800af82:	b29b      	uxth	r3, r3
 800af84:	461a      	mov	r2, r3
 800af86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800af88:	4413      	add	r3, r2
 800af8a:	637b      	str	r3, [r7, #52]	; 0x34
 800af8c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800af8e:	781b      	ldrb	r3, [r3, #0]
 800af90:	00da      	lsls	r2, r3, #3
 800af92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800af94:	4413      	add	r3, r2
 800af96:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800af9a:	633b      	str	r3, [r7, #48]	; 0x30
 800af9c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800af9e:	881b      	ldrh	r3, [r3, #0]
 800afa0:	b29b      	uxth	r3, r3
 800afa2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800afa6:	b29a      	uxth	r2, r3
 800afa8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800afaa:	801a      	strh	r2, [r3, #0]
 800afac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800afae:	881b      	ldrh	r3, [r3, #0]
 800afb0:	b29b      	uxth	r3, r3
 800afb2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800afb6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800afba:	b29a      	uxth	r2, r3
 800afbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800afbe:	801a      	strh	r2, [r3, #0]
 800afc0:	e017      	b.n	800aff2 <PCD_EP_ISR_Handler+0x6b6>
 800afc2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800afc4:	785b      	ldrb	r3, [r3, #1]
 800afc6:	2b01      	cmp	r3, #1
 800afc8:	d113      	bne.n	800aff2 <PCD_EP_ISR_Handler+0x6b6>
 800afca:	687b      	ldr	r3, [r7, #4]
 800afcc:	681b      	ldr	r3, [r3, #0]
 800afce:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800afd2:	b29b      	uxth	r3, r3
 800afd4:	461a      	mov	r2, r3
 800afd6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800afd8:	4413      	add	r3, r2
 800afda:	63fb      	str	r3, [r7, #60]	; 0x3c
 800afdc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800afde:	781b      	ldrb	r3, [r3, #0]
 800afe0:	00da      	lsls	r2, r3, #3
 800afe2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800afe4:	4413      	add	r3, r2
 800afe6:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800afea:	63bb      	str	r3, [r7, #56]	; 0x38
 800afec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800afee:	2200      	movs	r2, #0
 800aff0:	801a      	strh	r2, [r3, #0]

          /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataInStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800aff2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aff4:	781b      	ldrb	r3, [r3, #0]
 800aff6:	4619      	mov	r1, r3
 800aff8:	6878      	ldr	r0, [r7, #4]
 800affa:	f008 ff3c 	bl	8013e76 <HAL_PCD_DataInStageCallback>
 800affe:	e051      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        {
          /* Manage Single Buffer Transaction */
          if ((wEPVal & USB_EP_KIND) == 0U)
 800b000:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800b004:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b008:	2b00      	cmp	r3, #0
 800b00a:	d144      	bne.n	800b096 <PCD_EP_ISR_Handler+0x75a>
          {
            /* multi-packet on the NON control IN endpoint */
            TxPctSize = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b00c:	687b      	ldr	r3, [r7, #4]
 800b00e:	681b      	ldr	r3, [r3, #0]
 800b010:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b014:	b29b      	uxth	r3, r3
 800b016:	461a      	mov	r2, r3
 800b018:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b01a:	781b      	ldrb	r3, [r3, #0]
 800b01c:	00db      	lsls	r3, r3, #3
 800b01e:	4413      	add	r3, r2
 800b020:	687a      	ldr	r2, [r7, #4]
 800b022:	6812      	ldr	r2, [r2, #0]
 800b024:	4413      	add	r3, r2
 800b026:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b02a:	881b      	ldrh	r3, [r3, #0]
 800b02c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b030:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40

            if (ep->xfer_len > TxPctSize)
 800b034:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b036:	699a      	ldr	r2, [r3, #24]
 800b038:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800b03c:	429a      	cmp	r2, r3
 800b03e:	d907      	bls.n	800b050 <PCD_EP_ISR_Handler+0x714>
            {
              ep->xfer_len -= TxPctSize;
 800b040:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b042:	699a      	ldr	r2, [r3, #24]
 800b044:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800b048:	1ad2      	subs	r2, r2, r3
 800b04a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b04c:	619a      	str	r2, [r3, #24]
 800b04e:	e002      	b.n	800b056 <PCD_EP_ISR_Handler+0x71a>
            }
            else
            {
              ep->xfer_len = 0U;
 800b050:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b052:	2200      	movs	r2, #0
 800b054:	619a      	str	r2, [r3, #24]
            }

            /* Zero Length Packet? */
            if (ep->xfer_len == 0U)
 800b056:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b058:	699b      	ldr	r3, [r3, #24]
 800b05a:	2b00      	cmp	r3, #0
 800b05c:	d106      	bne.n	800b06c <PCD_EP_ISR_Handler+0x730>
            {
              /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->DataInStageCallback(hpcd, ep->num);
#else
              HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800b05e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b060:	781b      	ldrb	r3, [r3, #0]
 800b062:	4619      	mov	r1, r3
 800b064:	6878      	ldr	r0, [r7, #4]
 800b066:	f008 ff06 	bl	8013e76 <HAL_PCD_DataInStageCallback>
 800b06a:	e01b      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }
            else
            {
              /* Transfer is not yet Done */
              ep->xfer_buff += TxPctSize;
 800b06c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b06e:	695a      	ldr	r2, [r3, #20]
 800b070:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800b074:	441a      	add	r2, r3
 800b076:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b078:	615a      	str	r2, [r3, #20]
              ep->xfer_count += TxPctSize;
 800b07a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b07c:	69da      	ldr	r2, [r3, #28]
 800b07e:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800b082:	441a      	add	r2, r3
 800b084:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b086:	61da      	str	r2, [r3, #28]
              (void)USB_EPStartXfer(hpcd->Instance, ep);
 800b088:	687b      	ldr	r3, [r7, #4]
 800b08a:	681b      	ldr	r3, [r3, #0]
 800b08c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800b08e:	4618      	mov	r0, r3
 800b090:	f004 fd8f 	bl	800fbb2 <USB_EPStartXfer>
 800b094:	e006      	b.n	800b0a4 <PCD_EP_ISR_Handler+0x768>
          }
#if (USE_USB_DOUBLE_BUFFER == 1U)
          /* Double Buffer bulk IN (bulk transfer Len > Ep_Mps) */
          else
          {
            (void)HAL_PCD_EP_DB_Transmit(hpcd, ep, wEPVal);
 800b096:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800b09a:	461a      	mov	r2, r3
 800b09c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800b09e:	6878      	ldr	r0, [r7, #4]
 800b0a0:	f000 f917 	bl	800b2d2 <HAL_PCD_EP_DB_Transmit>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800b0a4:	687b      	ldr	r3, [r7, #4]
 800b0a6:	681b      	ldr	r3, [r3, #0]
 800b0a8:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800b0ac:	b29b      	uxth	r3, r3
 800b0ae:	b21b      	sxth	r3, r3
 800b0b0:	2b00      	cmp	r3, #0
 800b0b2:	f6ff ac48 	blt.w	800a946 <PCD_EP_ISR_Handler+0xa>
        }
      }
    }
  }

  return HAL_OK;
 800b0b6:	2300      	movs	r3, #0
}
 800b0b8:	4618      	mov	r0, r3
 800b0ba:	3758      	adds	r7, #88	; 0x58
 800b0bc:	46bd      	mov	sp, r7
 800b0be:	bd80      	pop	{r7, pc}

0800b0c0 <HAL_PCD_EP_DB_Receive>:
  * @param  wEPVal Last snapshot of EPRx register value taken in ISR
  * @retval HAL status
  */
static uint16_t HAL_PCD_EP_DB_Receive(PCD_HandleTypeDef *hpcd,
                                      PCD_EPTypeDef *ep, uint16_t wEPVal)
{
 800b0c0:	b580      	push	{r7, lr}
 800b0c2:	b088      	sub	sp, #32
 800b0c4:	af00      	add	r7, sp, #0
 800b0c6:	60f8      	str	r0, [r7, #12]
 800b0c8:	60b9      	str	r1, [r7, #8]
 800b0ca:	4613      	mov	r3, r2
 800b0cc:	80fb      	strh	r3, [r7, #6]
  uint16_t count;

  /* Manage Buffer0 OUT */
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b0ce:	88fb      	ldrh	r3, [r7, #6]
 800b0d0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800b0d4:	2b00      	cmp	r3, #0
 800b0d6:	d07c      	beq.n	800b1d2 <HAL_PCD_EP_DB_Receive+0x112>
  {
    /* Get count of received Data on buffer0 */
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b0d8:	68fb      	ldr	r3, [r7, #12]
 800b0da:	681b      	ldr	r3, [r3, #0]
 800b0dc:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b0e0:	b29b      	uxth	r3, r3
 800b0e2:	461a      	mov	r2, r3
 800b0e4:	68bb      	ldr	r3, [r7, #8]
 800b0e6:	781b      	ldrb	r3, [r3, #0]
 800b0e8:	00db      	lsls	r3, r3, #3
 800b0ea:	4413      	add	r3, r2
 800b0ec:	68fa      	ldr	r2, [r7, #12]
 800b0ee:	6812      	ldr	r2, [r2, #0]
 800b0f0:	4413      	add	r3, r2
 800b0f2:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b0f6:	881b      	ldrh	r3, [r3, #0]
 800b0f8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b0fc:	837b      	strh	r3, [r7, #26]

    if (ep->xfer_len >= count)
 800b0fe:	68bb      	ldr	r3, [r7, #8]
 800b100:	699a      	ldr	r2, [r3, #24]
 800b102:	8b7b      	ldrh	r3, [r7, #26]
 800b104:	429a      	cmp	r2, r3
 800b106:	d306      	bcc.n	800b116 <HAL_PCD_EP_DB_Receive+0x56>
    {
      ep->xfer_len -= count;
 800b108:	68bb      	ldr	r3, [r7, #8]
 800b10a:	699a      	ldr	r2, [r3, #24]
 800b10c:	8b7b      	ldrh	r3, [r7, #26]
 800b10e:	1ad2      	subs	r2, r2, r3
 800b110:	68bb      	ldr	r3, [r7, #8]
 800b112:	619a      	str	r2, [r3, #24]
 800b114:	e002      	b.n	800b11c <HAL_PCD_EP_DB_Receive+0x5c>
    }
    else
    {
      ep->xfer_len = 0U;
 800b116:	68bb      	ldr	r3, [r7, #8]
 800b118:	2200      	movs	r2, #0
 800b11a:	619a      	str	r2, [r3, #24]
    }

    if (ep->xfer_len == 0U)
 800b11c:	68bb      	ldr	r3, [r7, #8]
 800b11e:	699b      	ldr	r3, [r3, #24]
 800b120:	2b00      	cmp	r3, #0
 800b122:	d123      	bne.n	800b16c <HAL_PCD_EP_DB_Receive+0xac>
    {
      /* set NAK to OUT endpoint since double buffer is enabled */
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 800b124:	68fb      	ldr	r3, [r7, #12]
 800b126:	681b      	ldr	r3, [r3, #0]
 800b128:	461a      	mov	r2, r3
 800b12a:	68bb      	ldr	r3, [r7, #8]
 800b12c:	781b      	ldrb	r3, [r3, #0]
 800b12e:	009b      	lsls	r3, r3, #2
 800b130:	4413      	add	r3, r2
 800b132:	881b      	ldrh	r3, [r3, #0]
 800b134:	b29b      	uxth	r3, r3
 800b136:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800b13a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b13e:	833b      	strh	r3, [r7, #24]
 800b140:	8b3b      	ldrh	r3, [r7, #24]
 800b142:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800b146:	833b      	strh	r3, [r7, #24]
 800b148:	68fb      	ldr	r3, [r7, #12]
 800b14a:	681b      	ldr	r3, [r3, #0]
 800b14c:	461a      	mov	r2, r3
 800b14e:	68bb      	ldr	r3, [r7, #8]
 800b150:	781b      	ldrb	r3, [r3, #0]
 800b152:	009b      	lsls	r3, r3, #2
 800b154:	441a      	add	r2, r3
 800b156:	8b3b      	ldrh	r3, [r7, #24]
 800b158:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b15c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b160:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800b164:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b168:	b29b      	uxth	r3, r3
 800b16a:	8013      	strh	r3, [r2, #0]
    }

    /* Check if Buffer1 is in blocked state which requires to toggle */
    if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800b16c:	88fb      	ldrh	r3, [r7, #6]
 800b16e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b172:	2b00      	cmp	r3, #0
 800b174:	d01f      	beq.n	800b1b6 <HAL_PCD_EP_DB_Receive+0xf6>
    {
      PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 0U);
 800b176:	68fb      	ldr	r3, [r7, #12]
 800b178:	681b      	ldr	r3, [r3, #0]
 800b17a:	461a      	mov	r2, r3
 800b17c:	68bb      	ldr	r3, [r7, #8]
 800b17e:	781b      	ldrb	r3, [r3, #0]
 800b180:	009b      	lsls	r3, r3, #2
 800b182:	4413      	add	r3, r2
 800b184:	881b      	ldrh	r3, [r3, #0]
 800b186:	b29b      	uxth	r3, r3
 800b188:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800b18c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b190:	82fb      	strh	r3, [r7, #22]
 800b192:	68fb      	ldr	r3, [r7, #12]
 800b194:	681b      	ldr	r3, [r3, #0]
 800b196:	461a      	mov	r2, r3
 800b198:	68bb      	ldr	r3, [r7, #8]
 800b19a:	781b      	ldrb	r3, [r3, #0]
 800b19c:	009b      	lsls	r3, r3, #2
 800b19e:	441a      	add	r2, r3
 800b1a0:	8afb      	ldrh	r3, [r7, #22]
 800b1a2:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b1a6:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b1aa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800b1ae:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800b1b2:	b29b      	uxth	r3, r3
 800b1b4:	8013      	strh	r3, [r2, #0]
    }

    if (count != 0U)
 800b1b6:	8b7b      	ldrh	r3, [r7, #26]
 800b1b8:	2b00      	cmp	r3, #0
 800b1ba:	f000 8085 	beq.w	800b2c8 <HAL_PCD_EP_DB_Receive+0x208>
    {
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800b1be:	68fb      	ldr	r3, [r7, #12]
 800b1c0:	6818      	ldr	r0, [r3, #0]
 800b1c2:	68bb      	ldr	r3, [r7, #8]
 800b1c4:	6959      	ldr	r1, [r3, #20]
 800b1c6:	68bb      	ldr	r3, [r7, #8]
 800b1c8:	891a      	ldrh	r2, [r3, #8]
 800b1ca:	8b7b      	ldrh	r3, [r7, #26]
 800b1cc:	f006 fa1e 	bl	801160c <USB_ReadPMA>
 800b1d0:	e07a      	b.n	800b2c8 <HAL_PCD_EP_DB_Receive+0x208>
  }
  /* Manage Buffer 1 DTOG_RX=0 */
  else
  {
    /* Get count of received data */
    count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800b1d2:	68fb      	ldr	r3, [r7, #12]
 800b1d4:	681b      	ldr	r3, [r3, #0]
 800b1d6:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b1da:	b29b      	uxth	r3, r3
 800b1dc:	461a      	mov	r2, r3
 800b1de:	68bb      	ldr	r3, [r7, #8]
 800b1e0:	781b      	ldrb	r3, [r3, #0]
 800b1e2:	00db      	lsls	r3, r3, #3
 800b1e4:	4413      	add	r3, r2
 800b1e6:	68fa      	ldr	r2, [r7, #12]
 800b1e8:	6812      	ldr	r2, [r2, #0]
 800b1ea:	4413      	add	r3, r2
 800b1ec:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b1f0:	881b      	ldrh	r3, [r3, #0]
 800b1f2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b1f6:	837b      	strh	r3, [r7, #26]

    if (ep->xfer_len >= count)
 800b1f8:	68bb      	ldr	r3, [r7, #8]
 800b1fa:	699a      	ldr	r2, [r3, #24]
 800b1fc:	8b7b      	ldrh	r3, [r7, #26]
 800b1fe:	429a      	cmp	r2, r3
 800b200:	d306      	bcc.n	800b210 <HAL_PCD_EP_DB_Receive+0x150>
    {
      ep->xfer_len -= count;
 800b202:	68bb      	ldr	r3, [r7, #8]
 800b204:	699a      	ldr	r2, [r3, #24]
 800b206:	8b7b      	ldrh	r3, [r7, #26]
 800b208:	1ad2      	subs	r2, r2, r3
 800b20a:	68bb      	ldr	r3, [r7, #8]
 800b20c:	619a      	str	r2, [r3, #24]
 800b20e:	e002      	b.n	800b216 <HAL_PCD_EP_DB_Receive+0x156>
    }
    else
    {
      ep->xfer_len = 0U;
 800b210:	68bb      	ldr	r3, [r7, #8]
 800b212:	2200      	movs	r2, #0
 800b214:	619a      	str	r2, [r3, #24]
    }

    if (ep->xfer_len == 0U)
 800b216:	68bb      	ldr	r3, [r7, #8]
 800b218:	699b      	ldr	r3, [r3, #24]
 800b21a:	2b00      	cmp	r3, #0
 800b21c:	d123      	bne.n	800b266 <HAL_PCD_EP_DB_Receive+0x1a6>
    {
      /* set NAK on the current endpoint */
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 800b21e:	68fb      	ldr	r3, [r7, #12]
 800b220:	681b      	ldr	r3, [r3, #0]
 800b222:	461a      	mov	r2, r3
 800b224:	68bb      	ldr	r3, [r7, #8]
 800b226:	781b      	ldrb	r3, [r3, #0]
 800b228:	009b      	lsls	r3, r3, #2
 800b22a:	4413      	add	r3, r2
 800b22c:	881b      	ldrh	r3, [r3, #0]
 800b22e:	b29b      	uxth	r3, r3
 800b230:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800b234:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b238:	83fb      	strh	r3, [r7, #30]
 800b23a:	8bfb      	ldrh	r3, [r7, #30]
 800b23c:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800b240:	83fb      	strh	r3, [r7, #30]
 800b242:	68fb      	ldr	r3, [r7, #12]
 800b244:	681b      	ldr	r3, [r3, #0]
 800b246:	461a      	mov	r2, r3
 800b248:	68bb      	ldr	r3, [r7, #8]
 800b24a:	781b      	ldrb	r3, [r3, #0]
 800b24c:	009b      	lsls	r3, r3, #2
 800b24e:	441a      	add	r2, r3
 800b250:	8bfb      	ldrh	r3, [r7, #30]
 800b252:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b256:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b25a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800b25e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b262:	b29b      	uxth	r3, r3
 800b264:	8013      	strh	r3, [r2, #0]
    }

    /*Need to FreeUser Buffer*/
    if ((wEPVal & USB_EP_DTOG_TX) == 0U)
 800b266:	88fb      	ldrh	r3, [r7, #6]
 800b268:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b26c:	2b00      	cmp	r3, #0
 800b26e:	d11f      	bne.n	800b2b0 <HAL_PCD_EP_DB_Receive+0x1f0>
    {
      PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 0U);
 800b270:	68fb      	ldr	r3, [r7, #12]
 800b272:	681b      	ldr	r3, [r3, #0]
 800b274:	461a      	mov	r2, r3
 800b276:	68bb      	ldr	r3, [r7, #8]
 800b278:	781b      	ldrb	r3, [r3, #0]
 800b27a:	009b      	lsls	r3, r3, #2
 800b27c:	4413      	add	r3, r2
 800b27e:	881b      	ldrh	r3, [r3, #0]
 800b280:	b29b      	uxth	r3, r3
 800b282:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800b286:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b28a:	83bb      	strh	r3, [r7, #28]
 800b28c:	68fb      	ldr	r3, [r7, #12]
 800b28e:	681b      	ldr	r3, [r3, #0]
 800b290:	461a      	mov	r2, r3
 800b292:	68bb      	ldr	r3, [r7, #8]
 800b294:	781b      	ldrb	r3, [r3, #0]
 800b296:	009b      	lsls	r3, r3, #2
 800b298:	441a      	add	r2, r3
 800b29a:	8bbb      	ldrh	r3, [r7, #28]
 800b29c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b2a0:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b2a4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800b2a8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800b2ac:	b29b      	uxth	r3, r3
 800b2ae:	8013      	strh	r3, [r2, #0]
    }

    if (count != 0U)
 800b2b0:	8b7b      	ldrh	r3, [r7, #26]
 800b2b2:	2b00      	cmp	r3, #0
 800b2b4:	d008      	beq.n	800b2c8 <HAL_PCD_EP_DB_Receive+0x208>
    {
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800b2b6:	68fb      	ldr	r3, [r7, #12]
 800b2b8:	6818      	ldr	r0, [r3, #0]
 800b2ba:	68bb      	ldr	r3, [r7, #8]
 800b2bc:	6959      	ldr	r1, [r3, #20]
 800b2be:	68bb      	ldr	r3, [r7, #8]
 800b2c0:	895a      	ldrh	r2, [r3, #10]
 800b2c2:	8b7b      	ldrh	r3, [r7, #26]
 800b2c4:	f006 f9a2 	bl	801160c <USB_ReadPMA>
    }
  }

  return count;
 800b2c8:	8b7b      	ldrh	r3, [r7, #26]
}
 800b2ca:	4618      	mov	r0, r3
 800b2cc:	3720      	adds	r7, #32
 800b2ce:	46bd      	mov	sp, r7
 800b2d0:	bd80      	pop	{r7, pc}

0800b2d2 <HAL_PCD_EP_DB_Transmit>:
  * @param  wEPVal Last snapshot of EPRx register value taken in ISR
  * @retval HAL status
  */
static HAL_StatusTypeDef HAL_PCD_EP_DB_Transmit(PCD_HandleTypeDef *hpcd,
                                                PCD_EPTypeDef *ep, uint16_t wEPVal)
{
 800b2d2:	b580      	push	{r7, lr}
 800b2d4:	b0a4      	sub	sp, #144	; 0x90
 800b2d6:	af00      	add	r7, sp, #0
 800b2d8:	60f8      	str	r0, [r7, #12]
 800b2da:	60b9      	str	r1, [r7, #8]
 800b2dc:	4613      	mov	r3, r2
 800b2de:	80fb      	strh	r3, [r7, #6]
  uint32_t len;
  uint16_t TxPctSize;

  /* Data Buffer0 ACK received */
  if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800b2e0:	88fb      	ldrh	r3, [r7, #6]
 800b2e2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b2e6:	2b00      	cmp	r3, #0
 800b2e8:	f000 81db 	beq.w	800b6a2 <HAL_PCD_EP_DB_Transmit+0x3d0>
  {
    /* multi-packet on the NON control IN endpoint */
    TxPctSize = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b2ec:	68fb      	ldr	r3, [r7, #12]
 800b2ee:	681b      	ldr	r3, [r3, #0]
 800b2f0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b2f4:	b29b      	uxth	r3, r3
 800b2f6:	461a      	mov	r2, r3
 800b2f8:	68bb      	ldr	r3, [r7, #8]
 800b2fa:	781b      	ldrb	r3, [r3, #0]
 800b2fc:	00db      	lsls	r3, r3, #3
 800b2fe:	4413      	add	r3, r2
 800b300:	68fa      	ldr	r2, [r7, #12]
 800b302:	6812      	ldr	r2, [r2, #0]
 800b304:	4413      	add	r3, r2
 800b306:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b30a:	881b      	ldrh	r3, [r3, #0]
 800b30c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b310:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86

    if (ep->xfer_len > TxPctSize)
 800b314:	68bb      	ldr	r3, [r7, #8]
 800b316:	699a      	ldr	r2, [r3, #24]
 800b318:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b31c:	429a      	cmp	r2, r3
 800b31e:	d907      	bls.n	800b330 <HAL_PCD_EP_DB_Transmit+0x5e>
    {
      ep->xfer_len -= TxPctSize;
 800b320:	68bb      	ldr	r3, [r7, #8]
 800b322:	699a      	ldr	r2, [r3, #24]
 800b324:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b328:	1ad2      	subs	r2, r2, r3
 800b32a:	68bb      	ldr	r3, [r7, #8]
 800b32c:	619a      	str	r2, [r3, #24]
 800b32e:	e002      	b.n	800b336 <HAL_PCD_EP_DB_Transmit+0x64>
    }
    else
    {
      ep->xfer_len = 0U;
 800b330:	68bb      	ldr	r3, [r7, #8]
 800b332:	2200      	movs	r2, #0
 800b334:	619a      	str	r2, [r3, #24]
    }

    /* Transfer is completed */
    if (ep->xfer_len == 0U)
 800b336:	68bb      	ldr	r3, [r7, #8]
 800b338:	699b      	ldr	r3, [r3, #24]
 800b33a:	2b00      	cmp	r3, #0
 800b33c:	f040 80b9 	bne.w	800b4b2 <HAL_PCD_EP_DB_Transmit+0x1e0>
    {
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800b340:	68bb      	ldr	r3, [r7, #8]
 800b342:	785b      	ldrb	r3, [r3, #1]
 800b344:	2b00      	cmp	r3, #0
 800b346:	d126      	bne.n	800b396 <HAL_PCD_EP_DB_Transmit+0xc4>
 800b348:	68fb      	ldr	r3, [r7, #12]
 800b34a:	681b      	ldr	r3, [r3, #0]
 800b34c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b34e:	68fb      	ldr	r3, [r7, #12]
 800b350:	681b      	ldr	r3, [r3, #0]
 800b352:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b356:	b29b      	uxth	r3, r3
 800b358:	461a      	mov	r2, r3
 800b35a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b35c:	4413      	add	r3, r2
 800b35e:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b360:	68bb      	ldr	r3, [r7, #8]
 800b362:	781b      	ldrb	r3, [r3, #0]
 800b364:	00da      	lsls	r2, r3, #3
 800b366:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b368:	4413      	add	r3, r2
 800b36a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b36e:	62bb      	str	r3, [r7, #40]	; 0x28
 800b370:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b372:	881b      	ldrh	r3, [r3, #0]
 800b374:	b29b      	uxth	r3, r3
 800b376:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b37a:	b29a      	uxth	r2, r3
 800b37c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b37e:	801a      	strh	r2, [r3, #0]
 800b380:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b382:	881b      	ldrh	r3, [r3, #0]
 800b384:	b29b      	uxth	r3, r3
 800b386:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b38a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b38e:	b29a      	uxth	r2, r3
 800b390:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b392:	801a      	strh	r2, [r3, #0]
 800b394:	e01a      	b.n	800b3cc <HAL_PCD_EP_DB_Transmit+0xfa>
 800b396:	68bb      	ldr	r3, [r7, #8]
 800b398:	785b      	ldrb	r3, [r3, #1]
 800b39a:	2b01      	cmp	r3, #1
 800b39c:	d116      	bne.n	800b3cc <HAL_PCD_EP_DB_Transmit+0xfa>
 800b39e:	68fb      	ldr	r3, [r7, #12]
 800b3a0:	681b      	ldr	r3, [r3, #0]
 800b3a2:	637b      	str	r3, [r7, #52]	; 0x34
 800b3a4:	68fb      	ldr	r3, [r7, #12]
 800b3a6:	681b      	ldr	r3, [r3, #0]
 800b3a8:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b3ac:	b29b      	uxth	r3, r3
 800b3ae:	461a      	mov	r2, r3
 800b3b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b3b2:	4413      	add	r3, r2
 800b3b4:	637b      	str	r3, [r7, #52]	; 0x34
 800b3b6:	68bb      	ldr	r3, [r7, #8]
 800b3b8:	781b      	ldrb	r3, [r3, #0]
 800b3ba:	00da      	lsls	r2, r3, #3
 800b3bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b3be:	4413      	add	r3, r2
 800b3c0:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b3c4:	633b      	str	r3, [r7, #48]	; 0x30
 800b3c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b3c8:	2200      	movs	r2, #0
 800b3ca:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800b3cc:	68fb      	ldr	r3, [r7, #12]
 800b3ce:	681b      	ldr	r3, [r3, #0]
 800b3d0:	627b      	str	r3, [r7, #36]	; 0x24
 800b3d2:	68bb      	ldr	r3, [r7, #8]
 800b3d4:	785b      	ldrb	r3, [r3, #1]
 800b3d6:	2b00      	cmp	r3, #0
 800b3d8:	d126      	bne.n	800b428 <HAL_PCD_EP_DB_Transmit+0x156>
 800b3da:	68fb      	ldr	r3, [r7, #12]
 800b3dc:	681b      	ldr	r3, [r3, #0]
 800b3de:	61fb      	str	r3, [r7, #28]
 800b3e0:	68fb      	ldr	r3, [r7, #12]
 800b3e2:	681b      	ldr	r3, [r3, #0]
 800b3e4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b3e8:	b29b      	uxth	r3, r3
 800b3ea:	461a      	mov	r2, r3
 800b3ec:	69fb      	ldr	r3, [r7, #28]
 800b3ee:	4413      	add	r3, r2
 800b3f0:	61fb      	str	r3, [r7, #28]
 800b3f2:	68bb      	ldr	r3, [r7, #8]
 800b3f4:	781b      	ldrb	r3, [r3, #0]
 800b3f6:	00da      	lsls	r2, r3, #3
 800b3f8:	69fb      	ldr	r3, [r7, #28]
 800b3fa:	4413      	add	r3, r2
 800b3fc:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b400:	61bb      	str	r3, [r7, #24]
 800b402:	69bb      	ldr	r3, [r7, #24]
 800b404:	881b      	ldrh	r3, [r3, #0]
 800b406:	b29b      	uxth	r3, r3
 800b408:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b40c:	b29a      	uxth	r2, r3
 800b40e:	69bb      	ldr	r3, [r7, #24]
 800b410:	801a      	strh	r2, [r3, #0]
 800b412:	69bb      	ldr	r3, [r7, #24]
 800b414:	881b      	ldrh	r3, [r3, #0]
 800b416:	b29b      	uxth	r3, r3
 800b418:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b41c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b420:	b29a      	uxth	r2, r3
 800b422:	69bb      	ldr	r3, [r7, #24]
 800b424:	801a      	strh	r2, [r3, #0]
 800b426:	e017      	b.n	800b458 <HAL_PCD_EP_DB_Transmit+0x186>
 800b428:	68bb      	ldr	r3, [r7, #8]
 800b42a:	785b      	ldrb	r3, [r3, #1]
 800b42c:	2b01      	cmp	r3, #1
 800b42e:	d113      	bne.n	800b458 <HAL_PCD_EP_DB_Transmit+0x186>
 800b430:	68fb      	ldr	r3, [r7, #12]
 800b432:	681b      	ldr	r3, [r3, #0]
 800b434:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b438:	b29b      	uxth	r3, r3
 800b43a:	461a      	mov	r2, r3
 800b43c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b43e:	4413      	add	r3, r2
 800b440:	627b      	str	r3, [r7, #36]	; 0x24
 800b442:	68bb      	ldr	r3, [r7, #8]
 800b444:	781b      	ldrb	r3, [r3, #0]
 800b446:	00da      	lsls	r2, r3, #3
 800b448:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b44a:	4413      	add	r3, r2
 800b44c:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b450:	623b      	str	r3, [r7, #32]
 800b452:	6a3b      	ldr	r3, [r7, #32]
 800b454:	2200      	movs	r2, #0
 800b456:	801a      	strh	r2, [r3, #0]

      /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataInStageCallback(hpcd, ep->num);
#else
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800b458:	68bb      	ldr	r3, [r7, #8]
 800b45a:	781b      	ldrb	r3, [r3, #0]
 800b45c:	4619      	mov	r1, r3
 800b45e:	68f8      	ldr	r0, [r7, #12]
 800b460:	f008 fd09 	bl	8013e76 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b464:	88fb      	ldrh	r3, [r7, #6]
 800b466:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800b46a:	2b00      	cmp	r3, #0
 800b46c:	f000 82fa 	beq.w	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 800b470:	68fb      	ldr	r3, [r7, #12]
 800b472:	681b      	ldr	r3, [r3, #0]
 800b474:	461a      	mov	r2, r3
 800b476:	68bb      	ldr	r3, [r7, #8]
 800b478:	781b      	ldrb	r3, [r3, #0]
 800b47a:	009b      	lsls	r3, r3, #2
 800b47c:	4413      	add	r3, r2
 800b47e:	881b      	ldrh	r3, [r3, #0]
 800b480:	b29b      	uxth	r3, r3
 800b482:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800b486:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b48a:	82fb      	strh	r3, [r7, #22]
 800b48c:	68fb      	ldr	r3, [r7, #12]
 800b48e:	681b      	ldr	r3, [r3, #0]
 800b490:	461a      	mov	r2, r3
 800b492:	68bb      	ldr	r3, [r7, #8]
 800b494:	781b      	ldrb	r3, [r3, #0]
 800b496:	009b      	lsls	r3, r3, #2
 800b498:	441a      	add	r2, r3
 800b49a:	8afb      	ldrh	r3, [r7, #22]
 800b49c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b4a0:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b4a4:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800b4a8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b4ac:	b29b      	uxth	r3, r3
 800b4ae:	8013      	strh	r3, [r2, #0]
 800b4b0:	e2d8      	b.n	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
      }
    }
    else /* Transfer is not yet Done */
    {
      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b4b2:	88fb      	ldrh	r3, [r7, #6]
 800b4b4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800b4b8:	2b00      	cmp	r3, #0
 800b4ba:	d021      	beq.n	800b500 <HAL_PCD_EP_DB_Transmit+0x22e>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 800b4bc:	68fb      	ldr	r3, [r7, #12]
 800b4be:	681b      	ldr	r3, [r3, #0]
 800b4c0:	461a      	mov	r2, r3
 800b4c2:	68bb      	ldr	r3, [r7, #8]
 800b4c4:	781b      	ldrb	r3, [r3, #0]
 800b4c6:	009b      	lsls	r3, r3, #2
 800b4c8:	4413      	add	r3, r2
 800b4ca:	881b      	ldrh	r3, [r3, #0]
 800b4cc:	b29b      	uxth	r3, r3
 800b4ce:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800b4d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b4d6:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 800b4da:	68fb      	ldr	r3, [r7, #12]
 800b4dc:	681b      	ldr	r3, [r3, #0]
 800b4de:	461a      	mov	r2, r3
 800b4e0:	68bb      	ldr	r3, [r7, #8]
 800b4e2:	781b      	ldrb	r3, [r3, #0]
 800b4e4:	009b      	lsls	r3, r3, #2
 800b4e6:	441a      	add	r2, r3
 800b4e8:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 800b4ec:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b4f0:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b4f4:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800b4f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b4fc:	b29b      	uxth	r3, r3
 800b4fe:	8013      	strh	r3, [r2, #0]
      }

      /* Still there is data to Fill in the next Buffer */
      if (ep->xfer_fill_db == 1U)
 800b500:	68bb      	ldr	r3, [r7, #8]
 800b502:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800b506:	2b01      	cmp	r3, #1
 800b508:	f040 82ac 	bne.w	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
      {
        ep->xfer_buff += TxPctSize;
 800b50c:	68bb      	ldr	r3, [r7, #8]
 800b50e:	695a      	ldr	r2, [r3, #20]
 800b510:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b514:	441a      	add	r2, r3
 800b516:	68bb      	ldr	r3, [r7, #8]
 800b518:	615a      	str	r2, [r3, #20]
        ep->xfer_count += TxPctSize;
 800b51a:	68bb      	ldr	r3, [r7, #8]
 800b51c:	69da      	ldr	r2, [r3, #28]
 800b51e:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b522:	441a      	add	r2, r3
 800b524:	68bb      	ldr	r3, [r7, #8]
 800b526:	61da      	str	r2, [r3, #28]

        /* Calculate the len of the new buffer to fill */
        if (ep->xfer_len_db >= ep->maxpacket)
 800b528:	68bb      	ldr	r3, [r7, #8]
 800b52a:	6a1a      	ldr	r2, [r3, #32]
 800b52c:	68bb      	ldr	r3, [r7, #8]
 800b52e:	691b      	ldr	r3, [r3, #16]
 800b530:	429a      	cmp	r2, r3
 800b532:	d30b      	bcc.n	800b54c <HAL_PCD_EP_DB_Transmit+0x27a>
        {
          len = ep->maxpacket;
 800b534:	68bb      	ldr	r3, [r7, #8]
 800b536:	691b      	ldr	r3, [r3, #16]
 800b538:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          ep->xfer_len_db -= len;
 800b53c:	68bb      	ldr	r3, [r7, #8]
 800b53e:	6a1a      	ldr	r2, [r3, #32]
 800b540:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b544:	1ad2      	subs	r2, r2, r3
 800b546:	68bb      	ldr	r3, [r7, #8]
 800b548:	621a      	str	r2, [r3, #32]
 800b54a:	e017      	b.n	800b57c <HAL_PCD_EP_DB_Transmit+0x2aa>
        }
        else if (ep->xfer_len_db == 0U)
 800b54c:	68bb      	ldr	r3, [r7, #8]
 800b54e:	6a1b      	ldr	r3, [r3, #32]
 800b550:	2b00      	cmp	r3, #0
 800b552:	d108      	bne.n	800b566 <HAL_PCD_EP_DB_Transmit+0x294>
        {
          len = TxPctSize;
 800b554:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b558:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          ep->xfer_fill_db = 0U;
 800b55c:	68bb      	ldr	r3, [r7, #8]
 800b55e:	2200      	movs	r2, #0
 800b560:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 800b564:	e00a      	b.n	800b57c <HAL_PCD_EP_DB_Transmit+0x2aa>
        }
        else
        {
          ep->xfer_fill_db = 0U;
 800b566:	68bb      	ldr	r3, [r7, #8]
 800b568:	2200      	movs	r2, #0
 800b56a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          len = ep->xfer_len_db;
 800b56e:	68bb      	ldr	r3, [r7, #8]
 800b570:	6a1b      	ldr	r3, [r3, #32]
 800b572:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          ep->xfer_len_db = 0U;
 800b576:	68bb      	ldr	r3, [r7, #8]
 800b578:	2200      	movs	r2, #0
 800b57a:	621a      	str	r2, [r3, #32]
        }

        /* Write remaining Data to Buffer */
        /* Set the Double buffer counter for pma buffer1 */
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b57c:	68bb      	ldr	r3, [r7, #8]
 800b57e:	785b      	ldrb	r3, [r3, #1]
 800b580:	2b00      	cmp	r3, #0
 800b582:	d165      	bne.n	800b650 <HAL_PCD_EP_DB_Transmit+0x37e>
 800b584:	68fb      	ldr	r3, [r7, #12]
 800b586:	681b      	ldr	r3, [r3, #0]
 800b588:	63fb      	str	r3, [r7, #60]	; 0x3c
 800b58a:	68fb      	ldr	r3, [r7, #12]
 800b58c:	681b      	ldr	r3, [r3, #0]
 800b58e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b592:	b29b      	uxth	r3, r3
 800b594:	461a      	mov	r2, r3
 800b596:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b598:	4413      	add	r3, r2
 800b59a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800b59c:	68bb      	ldr	r3, [r7, #8]
 800b59e:	781b      	ldrb	r3, [r3, #0]
 800b5a0:	00da      	lsls	r2, r3, #3
 800b5a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b5a4:	4413      	add	r3, r2
 800b5a6:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b5aa:	63bb      	str	r3, [r7, #56]	; 0x38
 800b5ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5ae:	881b      	ldrh	r3, [r3, #0]
 800b5b0:	b29b      	uxth	r3, r3
 800b5b2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b5b6:	b29a      	uxth	r2, r3
 800b5b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5ba:	801a      	strh	r2, [r3, #0]
 800b5bc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b5c0:	2b3e      	cmp	r3, #62	; 0x3e
 800b5c2:	d91d      	bls.n	800b600 <HAL_PCD_EP_DB_Transmit+0x32e>
 800b5c4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b5c8:	095b      	lsrs	r3, r3, #5
 800b5ca:	64bb      	str	r3, [r7, #72]	; 0x48
 800b5cc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b5d0:	f003 031f 	and.w	r3, r3, #31
 800b5d4:	2b00      	cmp	r3, #0
 800b5d6:	d102      	bne.n	800b5de <HAL_PCD_EP_DB_Transmit+0x30c>
 800b5d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5da:	3b01      	subs	r3, #1
 800b5dc:	64bb      	str	r3, [r7, #72]	; 0x48
 800b5de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5e0:	881b      	ldrh	r3, [r3, #0]
 800b5e2:	b29a      	uxth	r2, r3
 800b5e4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5e6:	b29b      	uxth	r3, r3
 800b5e8:	029b      	lsls	r3, r3, #10
 800b5ea:	b29b      	uxth	r3, r3
 800b5ec:	4313      	orrs	r3, r2
 800b5ee:	b29b      	uxth	r3, r3
 800b5f0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b5f4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b5f8:	b29a      	uxth	r2, r3
 800b5fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b5fc:	801a      	strh	r2, [r3, #0]
 800b5fe:	e044      	b.n	800b68a <HAL_PCD_EP_DB_Transmit+0x3b8>
 800b600:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b604:	2b00      	cmp	r3, #0
 800b606:	d10a      	bne.n	800b61e <HAL_PCD_EP_DB_Transmit+0x34c>
 800b608:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b60a:	881b      	ldrh	r3, [r3, #0]
 800b60c:	b29b      	uxth	r3, r3
 800b60e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b612:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b616:	b29a      	uxth	r2, r3
 800b618:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b61a:	801a      	strh	r2, [r3, #0]
 800b61c:	e035      	b.n	800b68a <HAL_PCD_EP_DB_Transmit+0x3b8>
 800b61e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b622:	085b      	lsrs	r3, r3, #1
 800b624:	64bb      	str	r3, [r7, #72]	; 0x48
 800b626:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b62a:	f003 0301 	and.w	r3, r3, #1
 800b62e:	2b00      	cmp	r3, #0
 800b630:	d002      	beq.n	800b638 <HAL_PCD_EP_DB_Transmit+0x366>
 800b632:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b634:	3301      	adds	r3, #1
 800b636:	64bb      	str	r3, [r7, #72]	; 0x48
 800b638:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b63a:	881b      	ldrh	r3, [r3, #0]
 800b63c:	b29a      	uxth	r2, r3
 800b63e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b640:	b29b      	uxth	r3, r3
 800b642:	029b      	lsls	r3, r3, #10
 800b644:	b29b      	uxth	r3, r3
 800b646:	4313      	orrs	r3, r2
 800b648:	b29a      	uxth	r2, r3
 800b64a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b64c:	801a      	strh	r2, [r3, #0]
 800b64e:	e01c      	b.n	800b68a <HAL_PCD_EP_DB_Transmit+0x3b8>
 800b650:	68bb      	ldr	r3, [r7, #8]
 800b652:	785b      	ldrb	r3, [r3, #1]
 800b654:	2b01      	cmp	r3, #1
 800b656:	d118      	bne.n	800b68a <HAL_PCD_EP_DB_Transmit+0x3b8>
 800b658:	68fb      	ldr	r3, [r7, #12]
 800b65a:	681b      	ldr	r3, [r3, #0]
 800b65c:	647b      	str	r3, [r7, #68]	; 0x44
 800b65e:	68fb      	ldr	r3, [r7, #12]
 800b660:	681b      	ldr	r3, [r3, #0]
 800b662:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b666:	b29b      	uxth	r3, r3
 800b668:	461a      	mov	r2, r3
 800b66a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b66c:	4413      	add	r3, r2
 800b66e:	647b      	str	r3, [r7, #68]	; 0x44
 800b670:	68bb      	ldr	r3, [r7, #8]
 800b672:	781b      	ldrb	r3, [r3, #0]
 800b674:	00da      	lsls	r2, r3, #3
 800b676:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b678:	4413      	add	r3, r2
 800b67a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b67e:	643b      	str	r3, [r7, #64]	; 0x40
 800b680:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b684:	b29a      	uxth	r2, r3
 800b686:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b688:	801a      	strh	r2, [r3, #0]

        /* Copy user buffer to USB PMA */
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 800b68a:	68fb      	ldr	r3, [r7, #12]
 800b68c:	6818      	ldr	r0, [r3, #0]
 800b68e:	68bb      	ldr	r3, [r7, #8]
 800b690:	6959      	ldr	r1, [r3, #20]
 800b692:	68bb      	ldr	r3, [r7, #8]
 800b694:	891a      	ldrh	r2, [r3, #8]
 800b696:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b69a:	b29b      	uxth	r3, r3
 800b69c:	f005 ff74 	bl	8011588 <USB_WritePMA>
 800b6a0:	e1e0      	b.n	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
    }
  }
  else /* Data Buffer1 ACK received */
  {
    /* multi-packet on the NON control IN endpoint */
    TxPctSize = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800b6a2:	68fb      	ldr	r3, [r7, #12]
 800b6a4:	681b      	ldr	r3, [r3, #0]
 800b6a6:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b6aa:	b29b      	uxth	r3, r3
 800b6ac:	461a      	mov	r2, r3
 800b6ae:	68bb      	ldr	r3, [r7, #8]
 800b6b0:	781b      	ldrb	r3, [r3, #0]
 800b6b2:	00db      	lsls	r3, r3, #3
 800b6b4:	4413      	add	r3, r2
 800b6b6:	68fa      	ldr	r2, [r7, #12]
 800b6b8:	6812      	ldr	r2, [r2, #0]
 800b6ba:	4413      	add	r3, r2
 800b6bc:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b6c0:	881b      	ldrh	r3, [r3, #0]
 800b6c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b6c6:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86

    if (ep->xfer_len >= TxPctSize)
 800b6ca:	68bb      	ldr	r3, [r7, #8]
 800b6cc:	699a      	ldr	r2, [r3, #24]
 800b6ce:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b6d2:	429a      	cmp	r2, r3
 800b6d4:	d307      	bcc.n	800b6e6 <HAL_PCD_EP_DB_Transmit+0x414>
    {
      ep->xfer_len -= TxPctSize;
 800b6d6:	68bb      	ldr	r3, [r7, #8]
 800b6d8:	699a      	ldr	r2, [r3, #24]
 800b6da:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b6de:	1ad2      	subs	r2, r2, r3
 800b6e0:	68bb      	ldr	r3, [r7, #8]
 800b6e2:	619a      	str	r2, [r3, #24]
 800b6e4:	e002      	b.n	800b6ec <HAL_PCD_EP_DB_Transmit+0x41a>
    }
    else
    {
      ep->xfer_len = 0U;
 800b6e6:	68bb      	ldr	r3, [r7, #8]
 800b6e8:	2200      	movs	r2, #0
 800b6ea:	619a      	str	r2, [r3, #24]
    }

    /* Transfer is completed */
    if (ep->xfer_len == 0U)
 800b6ec:	68bb      	ldr	r3, [r7, #8]
 800b6ee:	699b      	ldr	r3, [r3, #24]
 800b6f0:	2b00      	cmp	r3, #0
 800b6f2:	f040 80c0 	bne.w	800b876 <HAL_PCD_EP_DB_Transmit+0x5a4>
    {
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800b6f6:	68bb      	ldr	r3, [r7, #8]
 800b6f8:	785b      	ldrb	r3, [r3, #1]
 800b6fa:	2b00      	cmp	r3, #0
 800b6fc:	d126      	bne.n	800b74c <HAL_PCD_EP_DB_Transmit+0x47a>
 800b6fe:	68fb      	ldr	r3, [r7, #12]
 800b700:	681b      	ldr	r3, [r3, #0]
 800b702:	67fb      	str	r3, [r7, #124]	; 0x7c
 800b704:	68fb      	ldr	r3, [r7, #12]
 800b706:	681b      	ldr	r3, [r3, #0]
 800b708:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b70c:	b29b      	uxth	r3, r3
 800b70e:	461a      	mov	r2, r3
 800b710:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b712:	4413      	add	r3, r2
 800b714:	67fb      	str	r3, [r7, #124]	; 0x7c
 800b716:	68bb      	ldr	r3, [r7, #8]
 800b718:	781b      	ldrb	r3, [r3, #0]
 800b71a:	00da      	lsls	r2, r3, #3
 800b71c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b71e:	4413      	add	r3, r2
 800b720:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b724:	67bb      	str	r3, [r7, #120]	; 0x78
 800b726:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800b728:	881b      	ldrh	r3, [r3, #0]
 800b72a:	b29b      	uxth	r3, r3
 800b72c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b730:	b29a      	uxth	r2, r3
 800b732:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800b734:	801a      	strh	r2, [r3, #0]
 800b736:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800b738:	881b      	ldrh	r3, [r3, #0]
 800b73a:	b29b      	uxth	r3, r3
 800b73c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b740:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b744:	b29a      	uxth	r2, r3
 800b746:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800b748:	801a      	strh	r2, [r3, #0]
 800b74a:	e01a      	b.n	800b782 <HAL_PCD_EP_DB_Transmit+0x4b0>
 800b74c:	68bb      	ldr	r3, [r7, #8]
 800b74e:	785b      	ldrb	r3, [r3, #1]
 800b750:	2b01      	cmp	r3, #1
 800b752:	d116      	bne.n	800b782 <HAL_PCD_EP_DB_Transmit+0x4b0>
 800b754:	68fb      	ldr	r3, [r7, #12]
 800b756:	681b      	ldr	r3, [r3, #0]
 800b758:	667b      	str	r3, [r7, #100]	; 0x64
 800b75a:	68fb      	ldr	r3, [r7, #12]
 800b75c:	681b      	ldr	r3, [r3, #0]
 800b75e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b762:	b29b      	uxth	r3, r3
 800b764:	461a      	mov	r2, r3
 800b766:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b768:	4413      	add	r3, r2
 800b76a:	667b      	str	r3, [r7, #100]	; 0x64
 800b76c:	68bb      	ldr	r3, [r7, #8]
 800b76e:	781b      	ldrb	r3, [r3, #0]
 800b770:	00da      	lsls	r2, r3, #3
 800b772:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b774:	4413      	add	r3, r2
 800b776:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800b77a:	663b      	str	r3, [r7, #96]	; 0x60
 800b77c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b77e:	2200      	movs	r2, #0
 800b780:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 800b782:	68fb      	ldr	r3, [r7, #12]
 800b784:	681b      	ldr	r3, [r3, #0]
 800b786:	677b      	str	r3, [r7, #116]	; 0x74
 800b788:	68bb      	ldr	r3, [r7, #8]
 800b78a:	785b      	ldrb	r3, [r3, #1]
 800b78c:	2b00      	cmp	r3, #0
 800b78e:	d12b      	bne.n	800b7e8 <HAL_PCD_EP_DB_Transmit+0x516>
 800b790:	68fb      	ldr	r3, [r7, #12]
 800b792:	681b      	ldr	r3, [r3, #0]
 800b794:	66fb      	str	r3, [r7, #108]	; 0x6c
 800b796:	68fb      	ldr	r3, [r7, #12]
 800b798:	681b      	ldr	r3, [r3, #0]
 800b79a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b79e:	b29b      	uxth	r3, r3
 800b7a0:	461a      	mov	r2, r3
 800b7a2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b7a4:	4413      	add	r3, r2
 800b7a6:	66fb      	str	r3, [r7, #108]	; 0x6c
 800b7a8:	68bb      	ldr	r3, [r7, #8]
 800b7aa:	781b      	ldrb	r3, [r3, #0]
 800b7ac:	00da      	lsls	r2, r3, #3
 800b7ae:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b7b0:	4413      	add	r3, r2
 800b7b2:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b7b6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800b7ba:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b7be:	881b      	ldrh	r3, [r3, #0]
 800b7c0:	b29b      	uxth	r3, r3
 800b7c2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b7c6:	b29a      	uxth	r2, r3
 800b7c8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b7cc:	801a      	strh	r2, [r3, #0]
 800b7ce:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b7d2:	881b      	ldrh	r3, [r3, #0]
 800b7d4:	b29b      	uxth	r3, r3
 800b7d6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b7da:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b7de:	b29a      	uxth	r2, r3
 800b7e0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b7e4:	801a      	strh	r2, [r3, #0]
 800b7e6:	e017      	b.n	800b818 <HAL_PCD_EP_DB_Transmit+0x546>
 800b7e8:	68bb      	ldr	r3, [r7, #8]
 800b7ea:	785b      	ldrb	r3, [r3, #1]
 800b7ec:	2b01      	cmp	r3, #1
 800b7ee:	d113      	bne.n	800b818 <HAL_PCD_EP_DB_Transmit+0x546>
 800b7f0:	68fb      	ldr	r3, [r7, #12]
 800b7f2:	681b      	ldr	r3, [r3, #0]
 800b7f4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b7f8:	b29b      	uxth	r3, r3
 800b7fa:	461a      	mov	r2, r3
 800b7fc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b7fe:	4413      	add	r3, r2
 800b800:	677b      	str	r3, [r7, #116]	; 0x74
 800b802:	68bb      	ldr	r3, [r7, #8]
 800b804:	781b      	ldrb	r3, [r3, #0]
 800b806:	00da      	lsls	r2, r3, #3
 800b808:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800b80a:	4413      	add	r3, r2
 800b80c:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b810:	673b      	str	r3, [r7, #112]	; 0x70
 800b812:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800b814:	2200      	movs	r2, #0
 800b816:	801a      	strh	r2, [r3, #0]

      /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataInStageCallback(hpcd, ep->num);
#else
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800b818:	68bb      	ldr	r3, [r7, #8]
 800b81a:	781b      	ldrb	r3, [r3, #0]
 800b81c:	4619      	mov	r1, r3
 800b81e:	68f8      	ldr	r0, [r7, #12]
 800b820:	f008 fb29 	bl	8013e76 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 800b824:	88fb      	ldrh	r3, [r7, #6]
 800b826:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800b82a:	2b00      	cmp	r3, #0
 800b82c:	f040 811a 	bne.w	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 800b830:	68fb      	ldr	r3, [r7, #12]
 800b832:	681b      	ldr	r3, [r3, #0]
 800b834:	461a      	mov	r2, r3
 800b836:	68bb      	ldr	r3, [r7, #8]
 800b838:	781b      	ldrb	r3, [r3, #0]
 800b83a:	009b      	lsls	r3, r3, #2
 800b83c:	4413      	add	r3, r2
 800b83e:	881b      	ldrh	r3, [r3, #0]
 800b840:	b29b      	uxth	r3, r3
 800b842:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800b846:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b84a:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88
 800b84e:	68fb      	ldr	r3, [r7, #12]
 800b850:	681b      	ldr	r3, [r3, #0]
 800b852:	461a      	mov	r2, r3
 800b854:	68bb      	ldr	r3, [r7, #8]
 800b856:	781b      	ldrb	r3, [r3, #0]
 800b858:	009b      	lsls	r3, r3, #2
 800b85a:	441a      	add	r2, r3
 800b85c:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
 800b860:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b864:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b868:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800b86c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b870:	b29b      	uxth	r3, r3
 800b872:	8013      	strh	r3, [r2, #0]
 800b874:	e0f6      	b.n	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
      }
    }
    else /* Transfer is not yet Done */
    {
      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 800b876:	88fb      	ldrh	r3, [r7, #6]
 800b878:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800b87c:	2b00      	cmp	r3, #0
 800b87e:	d121      	bne.n	800b8c4 <HAL_PCD_EP_DB_Transmit+0x5f2>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 800b880:	68fb      	ldr	r3, [r7, #12]
 800b882:	681b      	ldr	r3, [r3, #0]
 800b884:	461a      	mov	r2, r3
 800b886:	68bb      	ldr	r3, [r7, #8]
 800b888:	781b      	ldrb	r3, [r3, #0]
 800b88a:	009b      	lsls	r3, r3, #2
 800b88c:	4413      	add	r3, r2
 800b88e:	881b      	ldrh	r3, [r3, #0]
 800b890:	b29b      	uxth	r3, r3
 800b892:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800b896:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800b89a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 800b89e:	68fb      	ldr	r3, [r7, #12]
 800b8a0:	681b      	ldr	r3, [r3, #0]
 800b8a2:	461a      	mov	r2, r3
 800b8a4:	68bb      	ldr	r3, [r7, #8]
 800b8a6:	781b      	ldrb	r3, [r3, #0]
 800b8a8:	009b      	lsls	r3, r3, #2
 800b8aa:	441a      	add	r2, r3
 800b8ac:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800b8b0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800b8b4:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800b8b8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800b8bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b8c0:	b29b      	uxth	r3, r3
 800b8c2:	8013      	strh	r3, [r2, #0]
      }

      /* Still there is data to Fill in the next Buffer */
      if (ep->xfer_fill_db == 1U)
 800b8c4:	68bb      	ldr	r3, [r7, #8]
 800b8c6:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800b8ca:	2b01      	cmp	r3, #1
 800b8cc:	f040 80ca 	bne.w	800ba64 <HAL_PCD_EP_DB_Transmit+0x792>
      {
        ep->xfer_buff += TxPctSize;
 800b8d0:	68bb      	ldr	r3, [r7, #8]
 800b8d2:	695a      	ldr	r2, [r3, #20]
 800b8d4:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b8d8:	441a      	add	r2, r3
 800b8da:	68bb      	ldr	r3, [r7, #8]
 800b8dc:	615a      	str	r2, [r3, #20]
        ep->xfer_count += TxPctSize;
 800b8de:	68bb      	ldr	r3, [r7, #8]
 800b8e0:	69da      	ldr	r2, [r3, #28]
 800b8e2:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b8e6:	441a      	add	r2, r3
 800b8e8:	68bb      	ldr	r3, [r7, #8]
 800b8ea:	61da      	str	r2, [r3, #28]

        /* Calculate the len of the new buffer to fill */
        if (ep->xfer_len_db >= ep->maxpacket)
 800b8ec:	68bb      	ldr	r3, [r7, #8]
 800b8ee:	6a1a      	ldr	r2, [r3, #32]
 800b8f0:	68bb      	ldr	r3, [r7, #8]
 800b8f2:	691b      	ldr	r3, [r3, #16]
 800b8f4:	429a      	cmp	r2, r3
 800b8f6:	d30b      	bcc.n	800b910 <HAL_PCD_EP_DB_Transmit+0x63e>
        {
          len = ep->maxpacket;
 800b8f8:	68bb      	ldr	r3, [r7, #8]
 800b8fa:	691b      	ldr	r3, [r3, #16]
 800b8fc:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          ep->xfer_len_db -= len;
 800b900:	68bb      	ldr	r3, [r7, #8]
 800b902:	6a1a      	ldr	r2, [r3, #32]
 800b904:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b908:	1ad2      	subs	r2, r2, r3
 800b90a:	68bb      	ldr	r3, [r7, #8]
 800b90c:	621a      	str	r2, [r3, #32]
 800b90e:	e017      	b.n	800b940 <HAL_PCD_EP_DB_Transmit+0x66e>
        }
        else if (ep->xfer_len_db == 0U)
 800b910:	68bb      	ldr	r3, [r7, #8]
 800b912:	6a1b      	ldr	r3, [r3, #32]
 800b914:	2b00      	cmp	r3, #0
 800b916:	d108      	bne.n	800b92a <HAL_PCD_EP_DB_Transmit+0x658>
        {
          len = TxPctSize;
 800b918:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 800b91c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          ep->xfer_fill_db = 0U;
 800b920:	68bb      	ldr	r3, [r7, #8]
 800b922:	2200      	movs	r2, #0
 800b924:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 800b928:	e00a      	b.n	800b940 <HAL_PCD_EP_DB_Transmit+0x66e>
        }
        else
        {
          len = ep->xfer_len_db;
 800b92a:	68bb      	ldr	r3, [r7, #8]
 800b92c:	6a1b      	ldr	r3, [r3, #32]
 800b92e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          ep->xfer_len_db = 0U;
 800b932:	68bb      	ldr	r3, [r7, #8]
 800b934:	2200      	movs	r2, #0
 800b936:	621a      	str	r2, [r3, #32]
          ep->xfer_fill_db = 0;
 800b938:	68bb      	ldr	r3, [r7, #8]
 800b93a:	2200      	movs	r2, #0
 800b93c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
        }

        /* Set the Double buffer counter for pmabuffer1 */
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b940:	68fb      	ldr	r3, [r7, #12]
 800b942:	681b      	ldr	r3, [r3, #0]
 800b944:	657b      	str	r3, [r7, #84]	; 0x54
 800b946:	68bb      	ldr	r3, [r7, #8]
 800b948:	785b      	ldrb	r3, [r3, #1]
 800b94a:	2b00      	cmp	r3, #0
 800b94c:	d165      	bne.n	800ba1a <HAL_PCD_EP_DB_Transmit+0x748>
 800b94e:	68fb      	ldr	r3, [r7, #12]
 800b950:	681b      	ldr	r3, [r3, #0]
 800b952:	65fb      	str	r3, [r7, #92]	; 0x5c
 800b954:	68fb      	ldr	r3, [r7, #12]
 800b956:	681b      	ldr	r3, [r3, #0]
 800b958:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800b95c:	b29b      	uxth	r3, r3
 800b95e:	461a      	mov	r2, r3
 800b960:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b962:	4413      	add	r3, r2
 800b964:	65fb      	str	r3, [r7, #92]	; 0x5c
 800b966:	68bb      	ldr	r3, [r7, #8]
 800b968:	781b      	ldrb	r3, [r3, #0]
 800b96a:	00da      	lsls	r2, r3, #3
 800b96c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b96e:	4413      	add	r3, r2
 800b970:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800b974:	65bb      	str	r3, [r7, #88]	; 0x58
 800b976:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b978:	881b      	ldrh	r3, [r3, #0]
 800b97a:	b29b      	uxth	r3, r3
 800b97c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b980:	b29a      	uxth	r2, r3
 800b982:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b984:	801a      	strh	r2, [r3, #0]
 800b986:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b98a:	2b3e      	cmp	r3, #62	; 0x3e
 800b98c:	d91d      	bls.n	800b9ca <HAL_PCD_EP_DB_Transmit+0x6f8>
 800b98e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b992:	095b      	lsrs	r3, r3, #5
 800b994:	66bb      	str	r3, [r7, #104]	; 0x68
 800b996:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b99a:	f003 031f 	and.w	r3, r3, #31
 800b99e:	2b00      	cmp	r3, #0
 800b9a0:	d102      	bne.n	800b9a8 <HAL_PCD_EP_DB_Transmit+0x6d6>
 800b9a2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b9a4:	3b01      	subs	r3, #1
 800b9a6:	66bb      	str	r3, [r7, #104]	; 0x68
 800b9a8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b9aa:	881b      	ldrh	r3, [r3, #0]
 800b9ac:	b29a      	uxth	r2, r3
 800b9ae:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b9b0:	b29b      	uxth	r3, r3
 800b9b2:	029b      	lsls	r3, r3, #10
 800b9b4:	b29b      	uxth	r3, r3
 800b9b6:	4313      	orrs	r3, r2
 800b9b8:	b29b      	uxth	r3, r3
 800b9ba:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b9be:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b9c2:	b29a      	uxth	r2, r3
 800b9c4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b9c6:	801a      	strh	r2, [r3, #0]
 800b9c8:	e041      	b.n	800ba4e <HAL_PCD_EP_DB_Transmit+0x77c>
 800b9ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b9ce:	2b00      	cmp	r3, #0
 800b9d0:	d10a      	bne.n	800b9e8 <HAL_PCD_EP_DB_Transmit+0x716>
 800b9d2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b9d4:	881b      	ldrh	r3, [r3, #0]
 800b9d6:	b29b      	uxth	r3, r3
 800b9d8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800b9dc:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800b9e0:	b29a      	uxth	r2, r3
 800b9e2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b9e4:	801a      	strh	r2, [r3, #0]
 800b9e6:	e032      	b.n	800ba4e <HAL_PCD_EP_DB_Transmit+0x77c>
 800b9e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b9ec:	085b      	lsrs	r3, r3, #1
 800b9ee:	66bb      	str	r3, [r7, #104]	; 0x68
 800b9f0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800b9f4:	f003 0301 	and.w	r3, r3, #1
 800b9f8:	2b00      	cmp	r3, #0
 800b9fa:	d002      	beq.n	800ba02 <HAL_PCD_EP_DB_Transmit+0x730>
 800b9fc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b9fe:	3301      	adds	r3, #1
 800ba00:	66bb      	str	r3, [r7, #104]	; 0x68
 800ba02:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ba04:	881b      	ldrh	r3, [r3, #0]
 800ba06:	b29a      	uxth	r2, r3
 800ba08:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ba0a:	b29b      	uxth	r3, r3
 800ba0c:	029b      	lsls	r3, r3, #10
 800ba0e:	b29b      	uxth	r3, r3
 800ba10:	4313      	orrs	r3, r2
 800ba12:	b29a      	uxth	r2, r3
 800ba14:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ba16:	801a      	strh	r2, [r3, #0]
 800ba18:	e019      	b.n	800ba4e <HAL_PCD_EP_DB_Transmit+0x77c>
 800ba1a:	68bb      	ldr	r3, [r7, #8]
 800ba1c:	785b      	ldrb	r3, [r3, #1]
 800ba1e:	2b01      	cmp	r3, #1
 800ba20:	d115      	bne.n	800ba4e <HAL_PCD_EP_DB_Transmit+0x77c>
 800ba22:	68fb      	ldr	r3, [r7, #12]
 800ba24:	681b      	ldr	r3, [r3, #0]
 800ba26:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800ba2a:	b29b      	uxth	r3, r3
 800ba2c:	461a      	mov	r2, r3
 800ba2e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ba30:	4413      	add	r3, r2
 800ba32:	657b      	str	r3, [r7, #84]	; 0x54
 800ba34:	68bb      	ldr	r3, [r7, #8]
 800ba36:	781b      	ldrb	r3, [r3, #0]
 800ba38:	00da      	lsls	r2, r3, #3
 800ba3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ba3c:	4413      	add	r3, r2
 800ba3e:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800ba42:	653b      	str	r3, [r7, #80]	; 0x50
 800ba44:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800ba48:	b29a      	uxth	r2, r3
 800ba4a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ba4c:	801a      	strh	r2, [r3, #0]

        /* Copy the user buffer to USB PMA */
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 800ba4e:	68fb      	ldr	r3, [r7, #12]
 800ba50:	6818      	ldr	r0, [r3, #0]
 800ba52:	68bb      	ldr	r3, [r7, #8]
 800ba54:	6959      	ldr	r1, [r3, #20]
 800ba56:	68bb      	ldr	r3, [r7, #8]
 800ba58:	895a      	ldrh	r2, [r3, #10]
 800ba5a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800ba5e:	b29b      	uxth	r3, r3
 800ba60:	f005 fd92 	bl	8011588 <USB_WritePMA>
      }
    }
  }

  /*enable endpoint IN*/
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 800ba64:	68fb      	ldr	r3, [r7, #12]
 800ba66:	681b      	ldr	r3, [r3, #0]
 800ba68:	461a      	mov	r2, r3
 800ba6a:	68bb      	ldr	r3, [r7, #8]
 800ba6c:	781b      	ldrb	r3, [r3, #0]
 800ba6e:	009b      	lsls	r3, r3, #2
 800ba70:	4413      	add	r3, r2
 800ba72:	881b      	ldrh	r3, [r3, #0]
 800ba74:	b29b      	uxth	r3, r3
 800ba76:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800ba7a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800ba7e:	82bb      	strh	r3, [r7, #20]
 800ba80:	8abb      	ldrh	r3, [r7, #20]
 800ba82:	f083 0310 	eor.w	r3, r3, #16
 800ba86:	82bb      	strh	r3, [r7, #20]
 800ba88:	8abb      	ldrh	r3, [r7, #20]
 800ba8a:	f083 0320 	eor.w	r3, r3, #32
 800ba8e:	82bb      	strh	r3, [r7, #20]
 800ba90:	68fb      	ldr	r3, [r7, #12]
 800ba92:	681b      	ldr	r3, [r3, #0]
 800ba94:	461a      	mov	r2, r3
 800ba96:	68bb      	ldr	r3, [r7, #8]
 800ba98:	781b      	ldrb	r3, [r3, #0]
 800ba9a:	009b      	lsls	r3, r3, #2
 800ba9c:	441a      	add	r2, r3
 800ba9e:	8abb      	ldrh	r3, [r7, #20]
 800baa0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800baa4:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800baa8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800baac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800bab0:	b29b      	uxth	r3, r3
 800bab2:	8013      	strh	r3, [r2, #0]

  return HAL_OK;
 800bab4:	2300      	movs	r3, #0
}
 800bab6:	4618      	mov	r0, r3
 800bab8:	3790      	adds	r7, #144	; 0x90
 800baba:	46bd      	mov	sp, r7
 800babc:	bd80      	pop	{r7, pc}

0800babe <HAL_PCDEx_PMAConfig>:
  * @retval HAL status
  */

HAL_StatusTypeDef  HAL_PCDEx_PMAConfig(PCD_HandleTypeDef *hpcd, uint16_t ep_addr,
                                       uint16_t ep_kind, uint32_t pmaadress)
{
 800babe:	b480      	push	{r7}
 800bac0:	b087      	sub	sp, #28
 800bac2:	af00      	add	r7, sp, #0
 800bac4:	60f8      	str	r0, [r7, #12]
 800bac6:	607b      	str	r3, [r7, #4]
 800bac8:	460b      	mov	r3, r1
 800baca:	817b      	strh	r3, [r7, #10]
 800bacc:	4613      	mov	r3, r2
 800bace:	813b      	strh	r3, [r7, #8]
  PCD_EPTypeDef *ep;

  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 800bad0:	897b      	ldrh	r3, [r7, #10]
 800bad2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800bad6:	b29b      	uxth	r3, r3
 800bad8:	2b00      	cmp	r3, #0
 800bada:	d00b      	beq.n	800baf4 <HAL_PCDEx_PMAConfig+0x36>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800badc:	897b      	ldrh	r3, [r7, #10]
 800bade:	f003 0207 	and.w	r2, r3, #7
 800bae2:	4613      	mov	r3, r2
 800bae4:	009b      	lsls	r3, r3, #2
 800bae6:	4413      	add	r3, r2
 800bae8:	00db      	lsls	r3, r3, #3
 800baea:	3310      	adds	r3, #16
 800baec:	68fa      	ldr	r2, [r7, #12]
 800baee:	4413      	add	r3, r2
 800baf0:	617b      	str	r3, [r7, #20]
 800baf2:	e009      	b.n	800bb08 <HAL_PCDEx_PMAConfig+0x4a>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800baf4:	897a      	ldrh	r2, [r7, #10]
 800baf6:	4613      	mov	r3, r2
 800baf8:	009b      	lsls	r3, r3, #2
 800bafa:	4413      	add	r3, r2
 800bafc:	00db      	lsls	r3, r3, #3
 800bafe:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 800bb02:	68fa      	ldr	r2, [r7, #12]
 800bb04:	4413      	add	r3, r2
 800bb06:	617b      	str	r3, [r7, #20]
  }

  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 800bb08:	893b      	ldrh	r3, [r7, #8]
 800bb0a:	2b00      	cmp	r3, #0
 800bb0c:	d107      	bne.n	800bb1e <HAL_PCDEx_PMAConfig+0x60>
  {
    /* Single Buffer */
    ep->doublebuffer = 0U;
 800bb0e:	697b      	ldr	r3, [r7, #20]
 800bb10:	2200      	movs	r2, #0
 800bb12:	731a      	strb	r2, [r3, #12]
    /* Configure the PMA */
    ep->pmaadress = (uint16_t)pmaadress;
 800bb14:	687b      	ldr	r3, [r7, #4]
 800bb16:	b29a      	uxth	r2, r3
 800bb18:	697b      	ldr	r3, [r7, #20]
 800bb1a:	80da      	strh	r2, [r3, #6]
 800bb1c:	e00b      	b.n	800bb36 <HAL_PCDEx_PMAConfig+0x78>
  }
#if (USE_USB_DOUBLE_BUFFER == 1U)
  else /* USB_DBL_BUF */
  {
    /* Double Buffer Endpoint */
    ep->doublebuffer = 1U;
 800bb1e:	697b      	ldr	r3, [r7, #20]
 800bb20:	2201      	movs	r2, #1
 800bb22:	731a      	strb	r2, [r3, #12]
    /* Configure the PMA */
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
 800bb24:	687b      	ldr	r3, [r7, #4]
 800bb26:	b29a      	uxth	r2, r3
 800bb28:	697b      	ldr	r3, [r7, #20]
 800bb2a:	811a      	strh	r2, [r3, #8]
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	0c1b      	lsrs	r3, r3, #16
 800bb30:	b29a      	uxth	r2, r3
 800bb32:	697b      	ldr	r3, [r7, #20]
 800bb34:	815a      	strh	r2, [r3, #10]
  }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  return HAL_OK;
 800bb36:	2300      	movs	r3, #0
}
 800bb38:	4618      	mov	r0, r3
 800bb3a:	371c      	adds	r7, #28
 800bb3c:	46bd      	mov	sp, r7
 800bb3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb42:	4770      	bx	lr

0800bb44 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 800bb44:	b480      	push	{r7}
 800bb46:	b085      	sub	sp, #20
 800bb48:	af00      	add	r7, sp, #0
 800bb4a:	6078      	str	r0, [r7, #4]

  USB_TypeDef *USBx = hpcd->Instance;
 800bb4c:	687b      	ldr	r3, [r7, #4]
 800bb4e:	681b      	ldr	r3, [r3, #0]
 800bb50:	60fb      	str	r3, [r7, #12]
  hpcd->lpm_active = 1U;
 800bb52:	687b      	ldr	r3, [r7, #4]
 800bb54:	2201      	movs	r2, #1
 800bb56:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
  hpcd->LPM_State = LPM_L0;
 800bb5a:	687b      	ldr	r3, [r7, #4]
 800bb5c:	2200      	movs	r2, #0
 800bb5e:	f883 22c8 	strb.w	r2, [r3, #712]	; 0x2c8

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 800bb62:	68fb      	ldr	r3, [r7, #12]
 800bb64:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 800bb68:	b29b      	uxth	r3, r3
 800bb6a:	f043 0301 	orr.w	r3, r3, #1
 800bb6e:	b29a      	uxth	r2, r3
 800bb70:	68fb      	ldr	r3, [r7, #12]
 800bb72:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 800bb76:	68fb      	ldr	r3, [r7, #12]
 800bb78:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 800bb7c:	b29b      	uxth	r3, r3
 800bb7e:	f043 0302 	orr.w	r3, r3, #2
 800bb82:	b29a      	uxth	r2, r3
 800bb84:	68fb      	ldr	r3, [r7, #12]
 800bb86:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

  return HAL_OK;
 800bb8a:	2300      	movs	r3, #0
}
 800bb8c:	4618      	mov	r0, r3
 800bb8e:	3714      	adds	r7, #20
 800bb90:	46bd      	mov	sp, r7
 800bb92:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb96:	4770      	bx	lr

0800bb98 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 800bb98:	b480      	push	{r7}
 800bb9a:	b083      	sub	sp, #12
 800bb9c:	af00      	add	r7, sp, #0
 800bb9e:	6078      	str	r0, [r7, #4]
 800bba0:	460b      	mov	r3, r1
 800bba2:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800bba4:	bf00      	nop
 800bba6:	370c      	adds	r7, #12
 800bba8:	46bd      	mov	sp, r7
 800bbaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbae:	4770      	bx	lr

0800bbb0 <HAL_PWR_EnableBkUpAccess>:
  * @note   LSEON bit that switches on and off the LSE crystal belongs as well to the
  *         back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 800bbb0:	b480      	push	{r7}
 800bbb2:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800bbb4:	4b05      	ldr	r3, [pc, #20]	; (800bbcc <HAL_PWR_EnableBkUpAccess+0x1c>)
 800bbb6:	681b      	ldr	r3, [r3, #0]
 800bbb8:	4a04      	ldr	r2, [pc, #16]	; (800bbcc <HAL_PWR_EnableBkUpAccess+0x1c>)
 800bbba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800bbbe:	6013      	str	r3, [r2, #0]
}
 800bbc0:	bf00      	nop
 800bbc2:	46bd      	mov	sp, r7
 800bbc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbc8:	4770      	bx	lr
 800bbca:	bf00      	nop
 800bbcc:	58000400 	.word	0x58000400

0800bbd0 <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
 800bbd0:	b480      	push	{r7}
 800bbd2:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
 800bbd4:	bf00      	nop
 800bbd6:	46bd      	mov	sp, r7
 800bbd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbdc:	4770      	bx	lr
	...

0800bbe0 <LL_EXTI_ReadFlag_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval @note This bit is set when the selected edge event arrives on the interrupt
  */
__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
{
 800bbe0:	b480      	push	{r7}
 800bbe2:	b083      	sub	sp, #12
 800bbe4:	af00      	add	r7, sp, #0
 800bbe6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(EXTI->PR1, ExtiLine));
 800bbe8:	4b04      	ldr	r3, [pc, #16]	; (800bbfc <LL_EXTI_ReadFlag_0_31+0x1c>)
 800bbea:	68da      	ldr	r2, [r3, #12]
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	4013      	ands	r3, r2
}
 800bbf0:	4618      	mov	r0, r3
 800bbf2:	370c      	adds	r7, #12
 800bbf4:	46bd      	mov	sp, r7
 800bbf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbfa:	4770      	bx	lr
 800bbfc:	58000800 	.word	0x58000800

0800bc00 <LL_EXTI_ReadFlag_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval @note This bit is set when the selected edge event arrives on the interrupt
  */
__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_32_63(uint32_t ExtiLine)
{
 800bc00:	b480      	push	{r7}
 800bc02:	b083      	sub	sp, #12
 800bc04:	af00      	add	r7, sp, #0
 800bc06:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(EXTI->PR2, ExtiLine));
 800bc08:	4b04      	ldr	r3, [pc, #16]	; (800bc1c <LL_EXTI_ReadFlag_32_63+0x1c>)
 800bc0a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bc0c:	687b      	ldr	r3, [r7, #4]
 800bc0e:	4013      	ands	r3, r2
}
 800bc10:	4618      	mov	r0, r3
 800bc12:	370c      	adds	r7, #12
 800bc14:	46bd      	mov	sp, r7
 800bc16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc1a:	4770      	bx	lr
 800bc1c:	58000800 	.word	0x58000800

0800bc20 <LL_EXTI_ClearFlag_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
 800bc20:	b480      	push	{r7}
 800bc22:	b083      	sub	sp, #12
 800bc24:	af00      	add	r7, sp, #0
 800bc26:	6078      	str	r0, [r7, #4]
  WRITE_REG(EXTI->PR1, ExtiLine);
 800bc28:	4a04      	ldr	r2, [pc, #16]	; (800bc3c <LL_EXTI_ClearFlag_0_31+0x1c>)
 800bc2a:	687b      	ldr	r3, [r7, #4]
 800bc2c:	60d3      	str	r3, [r2, #12]
}
 800bc2e:	bf00      	nop
 800bc30:	370c      	adds	r7, #12
 800bc32:	46bd      	mov	sp, r7
 800bc34:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc38:	4770      	bx	lr
 800bc3a:	bf00      	nop
 800bc3c:	58000800 	.word	0x58000800

0800bc40 <LL_EXTI_ClearFlag_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_32_63(uint32_t ExtiLine)
{
 800bc40:	b480      	push	{r7}
 800bc42:	b083      	sub	sp, #12
 800bc44:	af00      	add	r7, sp, #0
 800bc46:	6078      	str	r0, [r7, #4]
  WRITE_REG(EXTI->PR2, ExtiLine);
 800bc48:	4a04      	ldr	r2, [pc, #16]	; (800bc5c <LL_EXTI_ClearFlag_32_63+0x1c>)
 800bc4a:	687b      	ldr	r3, [r7, #4]
 800bc4c:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 800bc4e:	bf00      	nop
 800bc50:	370c      	adds	r7, #12
 800bc52:	46bd      	mov	sp, r7
 800bc54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc58:	4770      	bx	lr
 800bc5a:	bf00      	nop
 800bc5c:	58000800 	.word	0x58000800

0800bc60 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 800bc60:	b480      	push	{r7}
 800bc62:	af00      	add	r7, sp, #0
  return (PWR->CR1 & PWR_CR1_VOS);
 800bc64:	4b04      	ldr	r3, [pc, #16]	; (800bc78 <HAL_PWREx_GetVoltageRange+0x18>)
 800bc66:	681b      	ldr	r3, [r3, #0]
 800bc68:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
}
 800bc6c:	4618      	mov	r0, r3
 800bc6e:	46bd      	mov	sp, r7
 800bc70:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc74:	4770      	bx	lr
 800bc76:	bf00      	nop
 800bc78:	58000400 	.word	0x58000400

0800bc7c <HAL_PWREx_EnableVddUSB>:
  * @brief Enable VDDUSB supply.
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
 800bc7c:	b480      	push	{r7}
 800bc7e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 800bc80:	4b05      	ldr	r3, [pc, #20]	; (800bc98 <HAL_PWREx_EnableVddUSB+0x1c>)
 800bc82:	685b      	ldr	r3, [r3, #4]
 800bc84:	4a04      	ldr	r2, [pc, #16]	; (800bc98 <HAL_PWREx_EnableVddUSB+0x1c>)
 800bc86:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800bc8a:	6053      	str	r3, [r2, #4]
}
 800bc8c:	bf00      	nop
 800bc8e:	46bd      	mov	sp, r7
 800bc90:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc94:	4770      	bx	lr
 800bc96:	bf00      	nop
 800bc98:	58000400 	.word	0x58000400

0800bc9c <HAL_PWREx_PVD_PVM_IRQHandler>:
  * @brief This function handles the PWR PVD/PVMx interrupt request.
  * @note This API should be called under the PVD_PVM_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_PVM_IRQHandler(void)
{
 800bc9c:	b580      	push	{r7, lr}
 800bc9e:	af00      	add	r7, sp, #0
  /* Check PWR exti flag */
  if (__HAL_PWR_PVD_EXTI_GET_FLAG() != 0U)
 800bca0:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800bca4:	f7ff ff9c 	bl	800bbe0 <LL_EXTI_ReadFlag_0_31>
 800bca8:	4603      	mov	r3, r0
 800bcaa:	2b00      	cmp	r3, #0
 800bcac:	d005      	beq.n	800bcba <HAL_PWREx_PVD_PVM_IRQHandler+0x1e>
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
 800bcae:	f7ff ff8f 	bl	800bbd0 <HAL_PWR_PVDCallback>

    /* Clear PVD exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 800bcb2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800bcb6:	f7ff ffb3 	bl	800bc20 <LL_EXTI_ClearFlag_0_31>
  }

#if defined(PWR_CR2_PVME1)
  /* Next, successively check PVMx exti flags */
  if (__HAL_PWR_PVM1_EXTI_GET_FLAG() != 0U)
 800bcba:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800bcbe:	f7ff ff8f 	bl	800bbe0 <LL_EXTI_ReadFlag_0_31>
 800bcc2:	4603      	mov	r3, r0
 800bcc4:	2b00      	cmp	r3, #0
 800bcc6:	d005      	beq.n	800bcd4 <HAL_PWREx_PVD_PVM_IRQHandler+0x38>
  {
    /* PWR PVM1 interrupt user callback */
    HAL_PWREx_PVM1Callback();
 800bcc8:	f000 f811 	bl	800bcee <HAL_PWREx_PVM1Callback>

    /* Clear PVM1 exti pending bit */
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
 800bccc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800bcd0:	f7ff ffa6 	bl	800bc20 <LL_EXTI_ClearFlag_0_31>
  }
#endif /* PWR_CR2_PVME1 */

  if (__HAL_PWR_PVM3_EXTI_GET_FLAG() != 0U)
 800bcd4:	2002      	movs	r0, #2
 800bcd6:	f7ff ff93 	bl	800bc00 <LL_EXTI_ReadFlag_32_63>
 800bcda:	4603      	mov	r3, r0
 800bcdc:	2b00      	cmp	r3, #0
 800bcde:	d004      	beq.n	800bcea <HAL_PWREx_PVD_PVM_IRQHandler+0x4e>
  {
    /* PWR PVM3 interrupt user callback */
    HAL_PWREx_PVM3Callback();
 800bce0:	f000 f80c 	bl	800bcfc <HAL_PWREx_PVM3Callback>

    /* Clear PVM3 exti pending bit */
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
 800bce4:	2002      	movs	r0, #2
 800bce6:	f7ff ffab 	bl	800bc40 <LL_EXTI_ClearFlag_32_63>
  }
}
 800bcea:	bf00      	nop
 800bcec:	bd80      	pop	{r7, pc}

0800bcee <HAL_PWREx_PVM1Callback>:
/**
  * @brief PWR PVM1 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM1Callback(void)
{
 800bcee:	b480      	push	{r7}
 800bcf0:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM1Callback() API can be implemented in the user file
   */
}
 800bcf2:	bf00      	nop
 800bcf4:	46bd      	mov	sp, r7
 800bcf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bcfa:	4770      	bx	lr

0800bcfc <HAL_PWREx_PVM3Callback>:
/**
  * @brief PWR PVM3 interrupt callback
  * @retval None
  */
__weak void HAL_PWREx_PVM3Callback(void)
{
 800bcfc:	b480      	push	{r7}
 800bcfe:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM3Callback() API can be implemented in the user file
   */
}
 800bd00:	bf00      	nop
 800bd02:	46bd      	mov	sp, r7
 800bd04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd08:	4770      	bx	lr

0800bd0a <LL_RCC_HSE_IsEnabledDiv2>:
{
 800bd0a:	b480      	push	{r7}
 800bd0c:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800bd0e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd12:	681b      	ldr	r3, [r3, #0]
 800bd14:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800bd18:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800bd1c:	d101      	bne.n	800bd22 <LL_RCC_HSE_IsEnabledDiv2+0x18>
 800bd1e:	2301      	movs	r3, #1
 800bd20:	e000      	b.n	800bd24 <LL_RCC_HSE_IsEnabledDiv2+0x1a>
 800bd22:	2300      	movs	r3, #0
}
 800bd24:	4618      	mov	r0, r3
 800bd26:	46bd      	mov	sp, r7
 800bd28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd2c:	4770      	bx	lr

0800bd2e <LL_RCC_HSE_Enable>:
{
 800bd2e:	b480      	push	{r7}
 800bd30:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 800bd32:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd36:	681b      	ldr	r3, [r3, #0]
 800bd38:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bd3c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800bd40:	6013      	str	r3, [r2, #0]
}
 800bd42:	bf00      	nop
 800bd44:	46bd      	mov	sp, r7
 800bd46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd4a:	4770      	bx	lr

0800bd4c <LL_RCC_HSE_Disable>:
{
 800bd4c:	b480      	push	{r7}
 800bd4e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 800bd50:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd54:	681b      	ldr	r3, [r3, #0]
 800bd56:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bd5a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800bd5e:	6013      	str	r3, [r2, #0]
}
 800bd60:	bf00      	nop
 800bd62:	46bd      	mov	sp, r7
 800bd64:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd68:	4770      	bx	lr

0800bd6a <LL_RCC_HSE_IsReady>:
{
 800bd6a:	b480      	push	{r7}
 800bd6c:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800bd6e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd72:	681b      	ldr	r3, [r3, #0]
 800bd74:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800bd78:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800bd7c:	d101      	bne.n	800bd82 <LL_RCC_HSE_IsReady+0x18>
 800bd7e:	2301      	movs	r3, #1
 800bd80:	e000      	b.n	800bd84 <LL_RCC_HSE_IsReady+0x1a>
 800bd82:	2300      	movs	r3, #0
}
 800bd84:	4618      	mov	r0, r3
 800bd86:	46bd      	mov	sp, r7
 800bd88:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd8c:	4770      	bx	lr

0800bd8e <LL_RCC_HSI_Enable>:
{
 800bd8e:	b480      	push	{r7}
 800bd90:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 800bd92:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd96:	681b      	ldr	r3, [r3, #0]
 800bd98:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bd9c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800bda0:	6013      	str	r3, [r2, #0]
}
 800bda2:	bf00      	nop
 800bda4:	46bd      	mov	sp, r7
 800bda6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bdaa:	4770      	bx	lr

0800bdac <LL_RCC_HSI_Disable>:
{
 800bdac:	b480      	push	{r7}
 800bdae:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 800bdb0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bdb4:	681b      	ldr	r3, [r3, #0]
 800bdb6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bdba:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800bdbe:	6013      	str	r3, [r2, #0]
}
 800bdc0:	bf00      	nop
 800bdc2:	46bd      	mov	sp, r7
 800bdc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bdc8:	4770      	bx	lr

0800bdca <LL_RCC_HSI_IsReady>:
{
 800bdca:	b480      	push	{r7}
 800bdcc:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 800bdce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bdd2:	681b      	ldr	r3, [r3, #0]
 800bdd4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800bdd8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800bddc:	d101      	bne.n	800bde2 <LL_RCC_HSI_IsReady+0x18>
 800bdde:	2301      	movs	r3, #1
 800bde0:	e000      	b.n	800bde4 <LL_RCC_HSI_IsReady+0x1a>
 800bde2:	2300      	movs	r3, #0
}
 800bde4:	4618      	mov	r0, r3
 800bde6:	46bd      	mov	sp, r7
 800bde8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bdec:	4770      	bx	lr

0800bdee <LL_RCC_HSI_SetCalibTrimming>:
{
 800bdee:	b480      	push	{r7}
 800bdf0:	b083      	sub	sp, #12
 800bdf2:	af00      	add	r7, sp, #0
 800bdf4:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 800bdf6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bdfa:	685b      	ldr	r3, [r3, #4]
 800bdfc:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	061b      	lsls	r3, r3, #24
 800be04:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800be08:	4313      	orrs	r3, r2
 800be0a:	604b      	str	r3, [r1, #4]
}
 800be0c:	bf00      	nop
 800be0e:	370c      	adds	r7, #12
 800be10:	46bd      	mov	sp, r7
 800be12:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be16:	4770      	bx	lr

0800be18 <LL_RCC_HSI48_Enable>:
{
 800be18:	b480      	push	{r7}
 800be1a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 800be1c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800be20:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800be24:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800be28:	f043 0301 	orr.w	r3, r3, #1
 800be2c:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 800be30:	bf00      	nop
 800be32:	46bd      	mov	sp, r7
 800be34:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be38:	4770      	bx	lr

0800be3a <LL_RCC_HSI48_Disable>:
{
 800be3a:	b480      	push	{r7}
 800be3c:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 800be3e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800be42:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800be46:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800be4a:	f023 0301 	bic.w	r3, r3, #1
 800be4e:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 800be52:	bf00      	nop
 800be54:	46bd      	mov	sp, r7
 800be56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be5a:	4770      	bx	lr

0800be5c <LL_RCC_HSI48_IsReady>:
{
 800be5c:	b480      	push	{r7}
 800be5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 800be60:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800be64:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800be68:	f003 0302 	and.w	r3, r3, #2
 800be6c:	2b02      	cmp	r3, #2
 800be6e:	d101      	bne.n	800be74 <LL_RCC_HSI48_IsReady+0x18>
 800be70:	2301      	movs	r3, #1
 800be72:	e000      	b.n	800be76 <LL_RCC_HSI48_IsReady+0x1a>
 800be74:	2300      	movs	r3, #0
}
 800be76:	4618      	mov	r0, r3
 800be78:	46bd      	mov	sp, r7
 800be7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800be7e:	4770      	bx	lr

0800be80 <LL_RCC_LSE_Enable>:
{
 800be80:	b480      	push	{r7}
 800be82:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800be84:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800be88:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800be8c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800be90:	f043 0301 	orr.w	r3, r3, #1
 800be94:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800be98:	bf00      	nop
 800be9a:	46bd      	mov	sp, r7
 800be9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bea0:	4770      	bx	lr

0800bea2 <LL_RCC_LSE_Disable>:
{
 800bea2:	b480      	push	{r7}
 800bea4:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800bea6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800beaa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800beae:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800beb2:	f023 0301 	bic.w	r3, r3, #1
 800beb6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800beba:	bf00      	nop
 800bebc:	46bd      	mov	sp, r7
 800bebe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bec2:	4770      	bx	lr

0800bec4 <LL_RCC_LSE_EnableBypass>:
{
 800bec4:	b480      	push	{r7}
 800bec6:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800bec8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800becc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bed0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bed4:	f043 0304 	orr.w	r3, r3, #4
 800bed8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800bedc:	bf00      	nop
 800bede:	46bd      	mov	sp, r7
 800bee0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bee4:	4770      	bx	lr

0800bee6 <LL_RCC_LSE_DisableBypass>:
{
 800bee6:	b480      	push	{r7}
 800bee8:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800beea:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800beee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bef2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bef6:	f023 0304 	bic.w	r3, r3, #4
 800befa:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800befe:	bf00      	nop
 800bf00:	46bd      	mov	sp, r7
 800bf02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf06:	4770      	bx	lr

0800bf08 <LL_RCC_LSE_IsReady>:
{
 800bf08:	b480      	push	{r7}
 800bf0a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 800bf0c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf10:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bf14:	f003 0302 	and.w	r3, r3, #2
 800bf18:	2b02      	cmp	r3, #2
 800bf1a:	d101      	bne.n	800bf20 <LL_RCC_LSE_IsReady+0x18>
 800bf1c:	2301      	movs	r3, #1
 800bf1e:	e000      	b.n	800bf22 <LL_RCC_LSE_IsReady+0x1a>
 800bf20:	2300      	movs	r3, #0
}
 800bf22:	4618      	mov	r0, r3
 800bf24:	46bd      	mov	sp, r7
 800bf26:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf2a:	4770      	bx	lr

0800bf2c <LL_RCC_LSI1_Enable>:
{
 800bf2c:	b480      	push	{r7}
 800bf2e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 800bf30:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf34:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800bf38:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bf3c:	f043 0301 	orr.w	r3, r3, #1
 800bf40:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800bf44:	bf00      	nop
 800bf46:	46bd      	mov	sp, r7
 800bf48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf4c:	4770      	bx	lr

0800bf4e <LL_RCC_LSI1_Disable>:
{
 800bf4e:	b480      	push	{r7}
 800bf50:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 800bf52:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf56:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800bf5a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bf5e:	f023 0301 	bic.w	r3, r3, #1
 800bf62:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800bf66:	bf00      	nop
 800bf68:	46bd      	mov	sp, r7
 800bf6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf6e:	4770      	bx	lr

0800bf70 <LL_RCC_LSI1_IsReady>:
{
 800bf70:	b480      	push	{r7}
 800bf72:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 800bf74:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf78:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800bf7c:	f003 0302 	and.w	r3, r3, #2
 800bf80:	2b02      	cmp	r3, #2
 800bf82:	d101      	bne.n	800bf88 <LL_RCC_LSI1_IsReady+0x18>
 800bf84:	2301      	movs	r3, #1
 800bf86:	e000      	b.n	800bf8a <LL_RCC_LSI1_IsReady+0x1a>
 800bf88:	2300      	movs	r3, #0
}
 800bf8a:	4618      	mov	r0, r3
 800bf8c:	46bd      	mov	sp, r7
 800bf8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf92:	4770      	bx	lr

0800bf94 <LL_RCC_LSI2_Enable>:
{
 800bf94:	b480      	push	{r7}
 800bf96:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 800bf98:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf9c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800bfa0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bfa4:	f043 0304 	orr.w	r3, r3, #4
 800bfa8:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800bfac:	bf00      	nop
 800bfae:	46bd      	mov	sp, r7
 800bfb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfb4:	4770      	bx	lr

0800bfb6 <LL_RCC_LSI2_Disable>:
{
 800bfb6:	b480      	push	{r7}
 800bfb8:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 800bfba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bfbe:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800bfc2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800bfc6:	f023 0304 	bic.w	r3, r3, #4
 800bfca:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800bfce:	bf00      	nop
 800bfd0:	46bd      	mov	sp, r7
 800bfd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfd6:	4770      	bx	lr

0800bfd8 <LL_RCC_LSI2_IsReady>:
{
 800bfd8:	b480      	push	{r7}
 800bfda:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 800bfdc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bfe0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800bfe4:	f003 0308 	and.w	r3, r3, #8
 800bfe8:	2b08      	cmp	r3, #8
 800bfea:	d101      	bne.n	800bff0 <LL_RCC_LSI2_IsReady+0x18>
 800bfec:	2301      	movs	r3, #1
 800bfee:	e000      	b.n	800bff2 <LL_RCC_LSI2_IsReady+0x1a>
 800bff0:	2300      	movs	r3, #0
}
 800bff2:	4618      	mov	r0, r3
 800bff4:	46bd      	mov	sp, r7
 800bff6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bffa:	4770      	bx	lr

0800bffc <LL_RCC_LSI2_SetTrimming>:
{
 800bffc:	b480      	push	{r7}
 800bffe:	b083      	sub	sp, #12
 800c000:	af00      	add	r7, sp, #0
 800c002:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_LSI2TRIM, Value << RCC_CSR_LSI2TRIM_Pos);
 800c004:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c008:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800c00c:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	021b      	lsls	r3, r3, #8
 800c014:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c018:	4313      	orrs	r3, r2
 800c01a:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 800c01e:	bf00      	nop
 800c020:	370c      	adds	r7, #12
 800c022:	46bd      	mov	sp, r7
 800c024:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c028:	4770      	bx	lr

0800c02a <LL_RCC_MSI_Enable>:
{
 800c02a:	b480      	push	{r7}
 800c02c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSION);
 800c02e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c032:	681b      	ldr	r3, [r3, #0]
 800c034:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c038:	f043 0301 	orr.w	r3, r3, #1
 800c03c:	6013      	str	r3, [r2, #0]
}
 800c03e:	bf00      	nop
 800c040:	46bd      	mov	sp, r7
 800c042:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c046:	4770      	bx	lr

0800c048 <LL_RCC_MSI_Disable>:
{
 800c048:	b480      	push	{r7}
 800c04a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 800c04c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c050:	681b      	ldr	r3, [r3, #0]
 800c052:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c056:	f023 0301 	bic.w	r3, r3, #1
 800c05a:	6013      	str	r3, [r2, #0]
}
 800c05c:	bf00      	nop
 800c05e:	46bd      	mov	sp, r7
 800c060:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c064:	4770      	bx	lr

0800c066 <LL_RCC_MSI_IsReady>:
{
 800c066:	b480      	push	{r7}
 800c068:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 800c06a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c06e:	681b      	ldr	r3, [r3, #0]
 800c070:	f003 0302 	and.w	r3, r3, #2
 800c074:	2b02      	cmp	r3, #2
 800c076:	d101      	bne.n	800c07c <LL_RCC_MSI_IsReady+0x16>
 800c078:	2301      	movs	r3, #1
 800c07a:	e000      	b.n	800c07e <LL_RCC_MSI_IsReady+0x18>
 800c07c:	2300      	movs	r3, #0
}
 800c07e:	4618      	mov	r0, r3
 800c080:	46bd      	mov	sp, r7
 800c082:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c086:	4770      	bx	lr

0800c088 <LL_RCC_MSI_SetRange>:
{
 800c088:	b480      	push	{r7}
 800c08a:	b083      	sub	sp, #12
 800c08c:	af00      	add	r7, sp, #0
 800c08e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 800c090:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c094:	681b      	ldr	r3, [r3, #0]
 800c096:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800c09a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c09e:	687b      	ldr	r3, [r7, #4]
 800c0a0:	4313      	orrs	r3, r2
 800c0a2:	600b      	str	r3, [r1, #0]
}
 800c0a4:	bf00      	nop
 800c0a6:	370c      	adds	r7, #12
 800c0a8:	46bd      	mov	sp, r7
 800c0aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0ae:	4770      	bx	lr

0800c0b0 <LL_RCC_MSI_GetRange>:
{
 800c0b0:	b480      	push	{r7}
 800c0b2:	b083      	sub	sp, #12
 800c0b4:	af00      	add	r7, sp, #0
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 800c0b6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c0ba:	681b      	ldr	r3, [r3, #0]
 800c0bc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800c0c0:	607b      	str	r3, [r7, #4]
  if (msiRange > LL_RCC_MSIRANGE_11)
 800c0c2:	687b      	ldr	r3, [r7, #4]
 800c0c4:	2bb0      	cmp	r3, #176	; 0xb0
 800c0c6:	d901      	bls.n	800c0cc <LL_RCC_MSI_GetRange+0x1c>
    msiRange = LL_RCC_MSIRANGE_11;
 800c0c8:	23b0      	movs	r3, #176	; 0xb0
 800c0ca:	607b      	str	r3, [r7, #4]
  return msiRange;
 800c0cc:	687b      	ldr	r3, [r7, #4]
}
 800c0ce:	4618      	mov	r0, r3
 800c0d0:	370c      	adds	r7, #12
 800c0d2:	46bd      	mov	sp, r7
 800c0d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0d8:	4770      	bx	lr

0800c0da <LL_RCC_MSI_SetCalibTrimming>:
{
 800c0da:	b480      	push	{r7}
 800c0dc:	b083      	sub	sp, #12
 800c0de:	af00      	add	r7, sp, #0
 800c0e0:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 800c0e2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c0e6:	685b      	ldr	r3, [r3, #4]
 800c0e8:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 800c0ec:	687b      	ldr	r3, [r7, #4]
 800c0ee:	021b      	lsls	r3, r3, #8
 800c0f0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c0f4:	4313      	orrs	r3, r2
 800c0f6:	604b      	str	r3, [r1, #4]
}
 800c0f8:	bf00      	nop
 800c0fa:	370c      	adds	r7, #12
 800c0fc:	46bd      	mov	sp, r7
 800c0fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c102:	4770      	bx	lr

0800c104 <LL_RCC_SetSysClkSource>:
{
 800c104:	b480      	push	{r7}
 800c106:	b083      	sub	sp, #12
 800c108:	af00      	add	r7, sp, #0
 800c10a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 800c10c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c110:	689b      	ldr	r3, [r3, #8]
 800c112:	f023 0203 	bic.w	r2, r3, #3
 800c116:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c11a:	687b      	ldr	r3, [r7, #4]
 800c11c:	4313      	orrs	r3, r2
 800c11e:	608b      	str	r3, [r1, #8]
}
 800c120:	bf00      	nop
 800c122:	370c      	adds	r7, #12
 800c124:	46bd      	mov	sp, r7
 800c126:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c12a:	4770      	bx	lr

0800c12c <LL_RCC_GetSysClkSource>:
{
 800c12c:	b480      	push	{r7}
 800c12e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800c130:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c134:	689b      	ldr	r3, [r3, #8]
 800c136:	f003 030c 	and.w	r3, r3, #12
}
 800c13a:	4618      	mov	r0, r3
 800c13c:	46bd      	mov	sp, r7
 800c13e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c142:	4770      	bx	lr

0800c144 <LL_RCC_SetAHBPrescaler>:
{
 800c144:	b480      	push	{r7}
 800c146:	b083      	sub	sp, #12
 800c148:	af00      	add	r7, sp, #0
 800c14a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800c14c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c150:	689b      	ldr	r3, [r3, #8]
 800c152:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800c156:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c15a:	687b      	ldr	r3, [r7, #4]
 800c15c:	4313      	orrs	r3, r2
 800c15e:	608b      	str	r3, [r1, #8]
}
 800c160:	bf00      	nop
 800c162:	370c      	adds	r7, #12
 800c164:	46bd      	mov	sp, r7
 800c166:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c16a:	4770      	bx	lr

0800c16c <LL_C2_RCC_SetAHBPrescaler>:
{
 800c16c:	b480      	push	{r7}
 800c16e:	b083      	sub	sp, #12
 800c170:	af00      	add	r7, sp, #0
 800c172:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 800c174:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c178:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800c17c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800c180:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c184:	687b      	ldr	r3, [r7, #4]
 800c186:	4313      	orrs	r3, r2
 800c188:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 800c18c:	bf00      	nop
 800c18e:	370c      	adds	r7, #12
 800c190:	46bd      	mov	sp, r7
 800c192:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c196:	4770      	bx	lr

0800c198 <LL_RCC_SetAHB4Prescaler>:
{
 800c198:	b480      	push	{r7}
 800c19a:	b083      	sub	sp, #12
 800c19c:	af00      	add	r7, sp, #0
 800c19e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 800c1a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c1a4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800c1a8:	f023 020f 	bic.w	r2, r3, #15
 800c1ac:	687b      	ldr	r3, [r7, #4]
 800c1ae:	091b      	lsrs	r3, r3, #4
 800c1b0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c1b4:	4313      	orrs	r3, r2
 800c1b6:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 800c1ba:	bf00      	nop
 800c1bc:	370c      	adds	r7, #12
 800c1be:	46bd      	mov	sp, r7
 800c1c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1c4:	4770      	bx	lr

0800c1c6 <LL_RCC_SetAPB1Prescaler>:
{
 800c1c6:	b480      	push	{r7}
 800c1c8:	b083      	sub	sp, #12
 800c1ca:	af00      	add	r7, sp, #0
 800c1cc:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800c1ce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c1d2:	689b      	ldr	r3, [r3, #8]
 800c1d4:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 800c1d8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c1dc:	687b      	ldr	r3, [r7, #4]
 800c1de:	4313      	orrs	r3, r2
 800c1e0:	608b      	str	r3, [r1, #8]
}
 800c1e2:	bf00      	nop
 800c1e4:	370c      	adds	r7, #12
 800c1e6:	46bd      	mov	sp, r7
 800c1e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c1ec:	4770      	bx	lr

0800c1ee <LL_RCC_SetAPB2Prescaler>:
{
 800c1ee:	b480      	push	{r7}
 800c1f0:	b083      	sub	sp, #12
 800c1f2:	af00      	add	r7, sp, #0
 800c1f4:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 800c1f6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c1fa:	689b      	ldr	r3, [r3, #8]
 800c1fc:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 800c200:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c204:	687b      	ldr	r3, [r7, #4]
 800c206:	4313      	orrs	r3, r2
 800c208:	608b      	str	r3, [r1, #8]
}
 800c20a:	bf00      	nop
 800c20c:	370c      	adds	r7, #12
 800c20e:	46bd      	mov	sp, r7
 800c210:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c214:	4770      	bx	lr

0800c216 <LL_RCC_GetAHBPrescaler>:
{
 800c216:	b480      	push	{r7}
 800c218:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 800c21a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c21e:	689b      	ldr	r3, [r3, #8]
 800c220:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 800c224:	4618      	mov	r0, r3
 800c226:	46bd      	mov	sp, r7
 800c228:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c22c:	4770      	bx	lr

0800c22e <LL_RCC_GetAHB4Prescaler>:
{
 800c22e:	b480      	push	{r7}
 800c230:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 800c232:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c236:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800c23a:	011b      	lsls	r3, r3, #4
 800c23c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 800c240:	4618      	mov	r0, r3
 800c242:	46bd      	mov	sp, r7
 800c244:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c248:	4770      	bx	lr

0800c24a <LL_RCC_PLL_Enable>:
{
 800c24a:	b480      	push	{r7}
 800c24c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 800c24e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c252:	681b      	ldr	r3, [r3, #0]
 800c254:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c258:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800c25c:	6013      	str	r3, [r2, #0]
}
 800c25e:	bf00      	nop
 800c260:	46bd      	mov	sp, r7
 800c262:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c266:	4770      	bx	lr

0800c268 <LL_RCC_PLL_Disable>:
{
 800c268:	b480      	push	{r7}
 800c26a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 800c26c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c270:	681b      	ldr	r3, [r3, #0]
 800c272:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c276:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800c27a:	6013      	str	r3, [r2, #0]
}
 800c27c:	bf00      	nop
 800c27e:	46bd      	mov	sp, r7
 800c280:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c284:	4770      	bx	lr

0800c286 <LL_RCC_PLL_IsReady>:
{
 800c286:	b480      	push	{r7}
 800c288:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 800c28a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c28e:	681b      	ldr	r3, [r3, #0]
 800c290:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800c294:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800c298:	d101      	bne.n	800c29e <LL_RCC_PLL_IsReady+0x18>
 800c29a:	2301      	movs	r3, #1
 800c29c:	e000      	b.n	800c2a0 <LL_RCC_PLL_IsReady+0x1a>
 800c29e:	2300      	movs	r3, #0
}
 800c2a0:	4618      	mov	r0, r3
 800c2a2:	46bd      	mov	sp, r7
 800c2a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2a8:	4770      	bx	lr

0800c2aa <LL_RCC_PLL_GetN>:
{
 800c2aa:	b480      	push	{r7}
 800c2ac:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 800c2ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c2b2:	68db      	ldr	r3, [r3, #12]
 800c2b4:	0a1b      	lsrs	r3, r3, #8
 800c2b6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 800c2ba:	4618      	mov	r0, r3
 800c2bc:	46bd      	mov	sp, r7
 800c2be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2c2:	4770      	bx	lr

0800c2c4 <LL_RCC_PLL_GetR>:
{
 800c2c4:	b480      	push	{r7}
 800c2c6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 800c2c8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c2cc:	68db      	ldr	r3, [r3, #12]
 800c2ce:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
}
 800c2d2:	4618      	mov	r0, r3
 800c2d4:	46bd      	mov	sp, r7
 800c2d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2da:	4770      	bx	lr

0800c2dc <LL_RCC_PLL_GetDivider>:
{
 800c2dc:	b480      	push	{r7}
 800c2de:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 800c2e0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c2e4:	68db      	ldr	r3, [r3, #12]
 800c2e6:	f003 0370 	and.w	r3, r3, #112	; 0x70
}
 800c2ea:	4618      	mov	r0, r3
 800c2ec:	46bd      	mov	sp, r7
 800c2ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2f2:	4770      	bx	lr

0800c2f4 <LL_RCC_PLL_GetMainSource>:
{
 800c2f4:	b480      	push	{r7}
 800c2f6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800c2f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c2fc:	68db      	ldr	r3, [r3, #12]
 800c2fe:	f003 0303 	and.w	r3, r3, #3
}
 800c302:	4618      	mov	r0, r3
 800c304:	46bd      	mov	sp, r7
 800c306:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c30a:	4770      	bx	lr

0800c30c <LL_RCC_IsActiveFlag_HPRE>:
{
 800c30c:	b480      	push	{r7}
 800c30e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 800c310:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c314:	689b      	ldr	r3, [r3, #8]
 800c316:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800c31a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c31e:	d101      	bne.n	800c324 <LL_RCC_IsActiveFlag_HPRE+0x18>
 800c320:	2301      	movs	r3, #1
 800c322:	e000      	b.n	800c326 <LL_RCC_IsActiveFlag_HPRE+0x1a>
 800c324:	2300      	movs	r3, #0
}
 800c326:	4618      	mov	r0, r3
 800c328:	46bd      	mov	sp, r7
 800c32a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c32e:	4770      	bx	lr

0800c330 <LL_RCC_IsActiveFlag_C2HPRE>:
{
 800c330:	b480      	push	{r7}
 800c332:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 800c334:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c338:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800c33c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c340:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800c344:	d101      	bne.n	800c34a <LL_RCC_IsActiveFlag_C2HPRE+0x1a>
 800c346:	2301      	movs	r3, #1
 800c348:	e000      	b.n	800c34c <LL_RCC_IsActiveFlag_C2HPRE+0x1c>
 800c34a:	2300      	movs	r3, #0
}
 800c34c:	4618      	mov	r0, r3
 800c34e:	46bd      	mov	sp, r7
 800c350:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c354:	4770      	bx	lr

0800c356 <LL_RCC_IsActiveFlag_SHDHPRE>:
{
 800c356:	b480      	push	{r7}
 800c358:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 800c35a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c35e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800c362:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800c366:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c36a:	d101      	bne.n	800c370 <LL_RCC_IsActiveFlag_SHDHPRE+0x1a>
 800c36c:	2301      	movs	r3, #1
 800c36e:	e000      	b.n	800c372 <LL_RCC_IsActiveFlag_SHDHPRE+0x1c>
 800c370:	2300      	movs	r3, #0
}
 800c372:	4618      	mov	r0, r3
 800c374:	46bd      	mov	sp, r7
 800c376:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c37a:	4770      	bx	lr

0800c37c <LL_RCC_IsActiveFlag_PPRE1>:
{
 800c37c:	b480      	push	{r7}
 800c37e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 800c380:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c384:	689b      	ldr	r3, [r3, #8]
 800c386:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800c38a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800c38e:	d101      	bne.n	800c394 <LL_RCC_IsActiveFlag_PPRE1+0x18>
 800c390:	2301      	movs	r3, #1
 800c392:	e000      	b.n	800c396 <LL_RCC_IsActiveFlag_PPRE1+0x1a>
 800c394:	2300      	movs	r3, #0
}
 800c396:	4618      	mov	r0, r3
 800c398:	46bd      	mov	sp, r7
 800c39a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c39e:	4770      	bx	lr

0800c3a0 <LL_RCC_IsActiveFlag_PPRE2>:
{
 800c3a0:	b480      	push	{r7}
 800c3a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 800c3a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c3a8:	689b      	ldr	r3, [r3, #8]
 800c3aa:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800c3ae:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800c3b2:	d101      	bne.n	800c3b8 <LL_RCC_IsActiveFlag_PPRE2+0x18>
 800c3b4:	2301      	movs	r3, #1
 800c3b6:	e000      	b.n	800c3ba <LL_RCC_IsActiveFlag_PPRE2+0x1a>
 800c3b8:	2300      	movs	r3, #0
}
 800c3ba:	4618      	mov	r0, r3
 800c3bc:	46bd      	mov	sp, r7
 800c3be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c3c2:	4770      	bx	lr

0800c3c4 <HAL_RCC_OscConfig>:
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL source is not updated when used as PLLSAI1 clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800c3c4:	b590      	push	{r4, r7, lr}
 800c3c6:	b08d      	sub	sp, #52	; 0x34
 800c3c8:	af00      	add	r7, sp, #0
 800c3ca:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800c3cc:	687b      	ldr	r3, [r7, #4]
 800c3ce:	2b00      	cmp	r3, #0
 800c3d0:	d101      	bne.n	800c3d6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800c3d2:	2301      	movs	r3, #1
 800c3d4:	e363      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800c3d6:	687b      	ldr	r3, [r7, #4]
 800c3d8:	681b      	ldr	r3, [r3, #0]
 800c3da:	f003 0320 	and.w	r3, r3, #32
 800c3de:	2b00      	cmp	r3, #0
 800c3e0:	f000 808d 	beq.w	800c4fe <HAL_RCC_OscConfig+0x13a>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c3e4:	f7ff fea2 	bl	800c12c <LL_RCC_GetSysClkSource>
 800c3e8:	62f8      	str	r0, [r7, #44]	; 0x2c
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 800c3ea:	f7ff ff83 	bl	800c2f4 <LL_RCC_PLL_GetMainSource>
 800c3ee:	62b8      	str	r0, [r7, #40]	; 0x28
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800c3f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c3f2:	2b00      	cmp	r3, #0
 800c3f4:	d005      	beq.n	800c402 <HAL_RCC_OscConfig+0x3e>
 800c3f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c3f8:	2b0c      	cmp	r3, #12
 800c3fa:	d147      	bne.n	800c48c <HAL_RCC_OscConfig+0xc8>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_MSI)))
 800c3fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c3fe:	2b01      	cmp	r3, #1
 800c400:	d144      	bne.n	800c48c <HAL_RCC_OscConfig+0xc8>
    {
      if (RCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 800c402:	687b      	ldr	r3, [r7, #4]
 800c404:	69db      	ldr	r3, [r3, #28]
 800c406:	2b00      	cmp	r3, #0
 800c408:	d101      	bne.n	800c40e <HAL_RCC_OscConfig+0x4a>
      {
        return HAL_ERROR;
 800c40a:	2301      	movs	r3, #1
 800c40c:	e347      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the AHB4 clock
           and the supply voltage of the device. */
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 800c40e:	687b      	ldr	r3, [r7, #4]
 800c410:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800c412:	f7ff fe4d 	bl	800c0b0 <LL_RCC_MSI_GetRange>
 800c416:	4603      	mov	r3, r0
 800c418:	429c      	cmp	r4, r3
 800c41a:	d914      	bls.n	800c446 <HAL_RCC_OscConfig+0x82>
        {
          /* First increase number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800c41c:	687b      	ldr	r3, [r7, #4]
 800c41e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c420:	4618      	mov	r0, r3
 800c422:	f000 fd03 	bl	800ce2c <RCC_SetFlashLatencyFromMSIRange>
 800c426:	4603      	mov	r3, r0
 800c428:	2b00      	cmp	r3, #0
 800c42a:	d001      	beq.n	800c430 <HAL_RCC_OscConfig+0x6c>
          {
            return HAL_ERROR;
 800c42c:	2301      	movs	r3, #1
 800c42e:	e336      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c434:	4618      	mov	r0, r3
 800c436:	f7ff fe27 	bl	800c088 <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800c43a:	687b      	ldr	r3, [r7, #4]
 800c43c:	6a1b      	ldr	r3, [r3, #32]
 800c43e:	4618      	mov	r0, r3
 800c440:	f7ff fe4b 	bl	800c0da <LL_RCC_MSI_SetCalibTrimming>
 800c444:	e013      	b.n	800c46e <HAL_RCC_OscConfig+0xaa>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800c446:	687b      	ldr	r3, [r7, #4]
 800c448:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c44a:	4618      	mov	r0, r3
 800c44c:	f7ff fe1c 	bl	800c088 <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800c450:	687b      	ldr	r3, [r7, #4]
 800c452:	6a1b      	ldr	r3, [r3, #32]
 800c454:	4618      	mov	r0, r3
 800c456:	f7ff fe40 	bl	800c0da <LL_RCC_MSI_SetCalibTrimming>

          /* Decrease number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800c45a:	687b      	ldr	r3, [r7, #4]
 800c45c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c45e:	4618      	mov	r0, r3
 800c460:	f000 fce4 	bl	800ce2c <RCC_SetFlashLatencyFromMSIRange>
 800c464:	4603      	mov	r3, r0
 800c466:	2b00      	cmp	r3, #0
 800c468:	d001      	beq.n	800c46e <HAL_RCC_OscConfig+0xaa>
          {
            return HAL_ERROR;
 800c46a:	2301      	movs	r3, #1
 800c46c:	e317      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800c46e:	f000 fcc9 	bl	800ce04 <HAL_RCC_GetHCLKFreq>
 800c472:	4603      	mov	r3, r0
 800c474:	4aa4      	ldr	r2, [pc, #656]	; (800c708 <HAL_RCC_OscConfig+0x344>)
 800c476:	6013      	str	r3, [r2, #0]

        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 800c478:	4ba4      	ldr	r3, [pc, #656]	; (800c70c <HAL_RCC_OscConfig+0x348>)
 800c47a:	681b      	ldr	r3, [r3, #0]
 800c47c:	4618      	mov	r0, r3
 800c47e:	f7fd f827 	bl	80094d0 <HAL_InitTick>
 800c482:	4603      	mov	r3, r0
 800c484:	2b00      	cmp	r3, #0
 800c486:	d039      	beq.n	800c4fc <HAL_RCC_OscConfig+0x138>
        {
          return HAL_ERROR;
 800c488:	2301      	movs	r3, #1
 800c48a:	e308      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      }
    }
    else
    {
      /* Check the MSI State */
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800c48c:	687b      	ldr	r3, [r7, #4]
 800c48e:	69db      	ldr	r3, [r3, #28]
 800c490:	2b00      	cmp	r3, #0
 800c492:	d01e      	beq.n	800c4d2 <HAL_RCC_OscConfig+0x10e>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 800c494:	f7ff fdc9 	bl	800c02a <LL_RCC_MSI_Enable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 800c498:	f7fd f868 	bl	800956c <HAL_GetTick>
 800c49c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
 800c49e:	e008      	b.n	800c4b2 <HAL_RCC_OscConfig+0xee>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800c4a0:	f7fd f864 	bl	800956c <HAL_GetTick>
 800c4a4:	4602      	mov	r2, r0
 800c4a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4a8:	1ad3      	subs	r3, r2, r3
 800c4aa:	2b02      	cmp	r3, #2
 800c4ac:	d901      	bls.n	800c4b2 <HAL_RCC_OscConfig+0xee>
          {
            return HAL_TIMEOUT;
 800c4ae:	2303      	movs	r3, #3
 800c4b0:	e2f5      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_MSI_IsReady() == 0U)
 800c4b2:	f7ff fdd8 	bl	800c066 <LL_RCC_MSI_IsReady>
 800c4b6:	4603      	mov	r3, r0
 800c4b8:	2b00      	cmp	r3, #0
 800c4ba:	d0f1      	beq.n	800c4a0 <HAL_RCC_OscConfig+0xdc>
          }
        }

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800c4bc:	687b      	ldr	r3, [r7, #4]
 800c4be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c4c0:	4618      	mov	r0, r3
 800c4c2:	f7ff fde1 	bl	800c088 <LL_RCC_MSI_SetRange>
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800c4c6:	687b      	ldr	r3, [r7, #4]
 800c4c8:	6a1b      	ldr	r3, [r3, #32]
 800c4ca:	4618      	mov	r0, r3
 800c4cc:	f7ff fe05 	bl	800c0da <LL_RCC_MSI_SetCalibTrimming>
 800c4d0:	e015      	b.n	800c4fe <HAL_RCC_OscConfig+0x13a>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 800c4d2:	f7ff fdb9 	bl	800c048 <LL_RCC_MSI_Disable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 800c4d6:	f7fd f849 	bl	800956c <HAL_GetTick>
 800c4da:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
 800c4dc:	e008      	b.n	800c4f0 <HAL_RCC_OscConfig+0x12c>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800c4de:	f7fd f845 	bl	800956c <HAL_GetTick>
 800c4e2:	4602      	mov	r2, r0
 800c4e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4e6:	1ad3      	subs	r3, r2, r3
 800c4e8:	2b02      	cmp	r3, #2
 800c4ea:	d901      	bls.n	800c4f0 <HAL_RCC_OscConfig+0x12c>
          {
            return HAL_TIMEOUT;
 800c4ec:	2303      	movs	r3, #3
 800c4ee:	e2d6      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_MSI_IsReady() != 0U)
 800c4f0:	f7ff fdb9 	bl	800c066 <LL_RCC_MSI_IsReady>
 800c4f4:	4603      	mov	r3, r0
 800c4f6:	2b00      	cmp	r3, #0
 800c4f8:	d1f1      	bne.n	800c4de <HAL_RCC_OscConfig+0x11a>
 800c4fa:	e000      	b.n	800c4fe <HAL_RCC_OscConfig+0x13a>
      if (RCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 800c4fc:	bf00      	nop
      }
    }
  }

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800c4fe:	687b      	ldr	r3, [r7, #4]
 800c500:	681b      	ldr	r3, [r3, #0]
 800c502:	f003 0301 	and.w	r3, r3, #1
 800c506:	2b00      	cmp	r3, #0
 800c508:	d047      	beq.n	800c59a <HAL_RCC_OscConfig+0x1d6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c50a:	f7ff fe0f 	bl	800c12c <LL_RCC_GetSysClkSource>
 800c50e:	6238      	str	r0, [r7, #32]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 800c510:	f7ff fef0 	bl	800c2f4 <LL_RCC_PLL_GetMainSource>
 800c514:	61f8      	str	r0, [r7, #28]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 800c516:	6a3b      	ldr	r3, [r7, #32]
 800c518:	2b08      	cmp	r3, #8
 800c51a:	d005      	beq.n	800c528 <HAL_RCC_OscConfig+0x164>
 800c51c:	6a3b      	ldr	r3, [r7, #32]
 800c51e:	2b0c      	cmp	r3, #12
 800c520:	d108      	bne.n	800c534 <HAL_RCC_OscConfig+0x170>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSE)))
 800c522:	69fb      	ldr	r3, [r7, #28]
 800c524:	2b03      	cmp	r3, #3
 800c526:	d105      	bne.n	800c534 <HAL_RCC_OscConfig+0x170>
    {
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 800c528:	687b      	ldr	r3, [r7, #4]
 800c52a:	685b      	ldr	r3, [r3, #4]
 800c52c:	2b00      	cmp	r3, #0
 800c52e:	d134      	bne.n	800c59a <HAL_RCC_OscConfig+0x1d6>
      {
        return HAL_ERROR;
 800c530:	2301      	movs	r3, #1
 800c532:	e2b4      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	685b      	ldr	r3, [r3, #4]
 800c538:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800c53c:	d102      	bne.n	800c544 <HAL_RCC_OscConfig+0x180>
 800c53e:	f7ff fbf6 	bl	800bd2e <LL_RCC_HSE_Enable>
 800c542:	e001      	b.n	800c548 <HAL_RCC_OscConfig+0x184>
 800c544:	f7ff fc02 	bl	800bd4c <LL_RCC_HSE_Disable>

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800c548:	687b      	ldr	r3, [r7, #4]
 800c54a:	685b      	ldr	r3, [r3, #4]
 800c54c:	2b00      	cmp	r3, #0
 800c54e:	d012      	beq.n	800c576 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c550:	f7fd f80c 	bl	800956c <HAL_GetTick>
 800c554:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while (LL_RCC_HSE_IsReady() == 0U)
 800c556:	e008      	b.n	800c56a <HAL_RCC_OscConfig+0x1a6>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800c558:	f7fd f808 	bl	800956c <HAL_GetTick>
 800c55c:	4602      	mov	r2, r0
 800c55e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c560:	1ad3      	subs	r3, r2, r3
 800c562:	2b64      	cmp	r3, #100	; 0x64
 800c564:	d901      	bls.n	800c56a <HAL_RCC_OscConfig+0x1a6>
          {
            return HAL_TIMEOUT;
 800c566:	2303      	movs	r3, #3
 800c568:	e299      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSE_IsReady() == 0U)
 800c56a:	f7ff fbfe 	bl	800bd6a <LL_RCC_HSE_IsReady>
 800c56e:	4603      	mov	r3, r0
 800c570:	2b00      	cmp	r3, #0
 800c572:	d0f1      	beq.n	800c558 <HAL_RCC_OscConfig+0x194>
 800c574:	e011      	b.n	800c59a <HAL_RCC_OscConfig+0x1d6>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c576:	f7fc fff9 	bl	800956c <HAL_GetTick>
 800c57a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while (LL_RCC_HSE_IsReady() != 0U)
 800c57c:	e008      	b.n	800c590 <HAL_RCC_OscConfig+0x1cc>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800c57e:	f7fc fff5 	bl	800956c <HAL_GetTick>
 800c582:	4602      	mov	r2, r0
 800c584:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c586:	1ad3      	subs	r3, r2, r3
 800c588:	2b64      	cmp	r3, #100	; 0x64
 800c58a:	d901      	bls.n	800c590 <HAL_RCC_OscConfig+0x1cc>
          {
            return HAL_TIMEOUT;
 800c58c:	2303      	movs	r3, #3
 800c58e:	e286      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSE_IsReady() != 0U)
 800c590:	f7ff fbeb 	bl	800bd6a <LL_RCC_HSE_IsReady>
 800c594:	4603      	mov	r3, r0
 800c596:	2b00      	cmp	r3, #0
 800c598:	d1f1      	bne.n	800c57e <HAL_RCC_OscConfig+0x1ba>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800c59a:	687b      	ldr	r3, [r7, #4]
 800c59c:	681b      	ldr	r3, [r3, #0]
 800c59e:	f003 0302 	and.w	r3, r3, #2
 800c5a2:	2b00      	cmp	r3, #0
 800c5a4:	d04c      	beq.n	800c640 <HAL_RCC_OscConfig+0x27c>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c5a6:	f7ff fdc1 	bl	800c12c <LL_RCC_GetSysClkSource>
 800c5aa:	61b8      	str	r0, [r7, #24]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 800c5ac:	f7ff fea2 	bl	800c2f4 <LL_RCC_PLL_GetMainSource>
 800c5b0:	6178      	str	r0, [r7, #20]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 800c5b2:	69bb      	ldr	r3, [r7, #24]
 800c5b4:	2b04      	cmp	r3, #4
 800c5b6:	d005      	beq.n	800c5c4 <HAL_RCC_OscConfig+0x200>
 800c5b8:	69bb      	ldr	r3, [r7, #24]
 800c5ba:	2b0c      	cmp	r3, #12
 800c5bc:	d10e      	bne.n	800c5dc <HAL_RCC_OscConfig+0x218>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSI)))
 800c5be:	697b      	ldr	r3, [r7, #20]
 800c5c0:	2b02      	cmp	r3, #2
 800c5c2:	d10b      	bne.n	800c5dc <HAL_RCC_OscConfig+0x218>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 800c5c4:	687b      	ldr	r3, [r7, #4]
 800c5c6:	68db      	ldr	r3, [r3, #12]
 800c5c8:	2b00      	cmp	r3, #0
 800c5ca:	d101      	bne.n	800c5d0 <HAL_RCC_OscConfig+0x20c>
      {
        return HAL_ERROR;
 800c5cc:	2301      	movs	r3, #1
 800c5ce:	e266      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800c5d0:	687b      	ldr	r3, [r7, #4]
 800c5d2:	691b      	ldr	r3, [r3, #16]
 800c5d4:	4618      	mov	r0, r3
 800c5d6:	f7ff fc0a 	bl	800bdee <LL_RCC_HSI_SetCalibTrimming>
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 800c5da:	e031      	b.n	800c640 <HAL_RCC_OscConfig+0x27c>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800c5dc:	687b      	ldr	r3, [r7, #4]
 800c5de:	68db      	ldr	r3, [r3, #12]
 800c5e0:	2b00      	cmp	r3, #0
 800c5e2:	d019      	beq.n	800c618 <HAL_RCC_OscConfig+0x254>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800c5e4:	f7ff fbd3 	bl	800bd8e <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c5e8:	f7fc ffc0 	bl	800956c <HAL_GetTick>
 800c5ec:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
 800c5ee:	e008      	b.n	800c602 <HAL_RCC_OscConfig+0x23e>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c5f0:	f7fc ffbc 	bl	800956c <HAL_GetTick>
 800c5f4:	4602      	mov	r2, r0
 800c5f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c5f8:	1ad3      	subs	r3, r2, r3
 800c5fa:	2b02      	cmp	r3, #2
 800c5fc:	d901      	bls.n	800c602 <HAL_RCC_OscConfig+0x23e>
          {
            return HAL_TIMEOUT;
 800c5fe:	2303      	movs	r3, #3
 800c600:	e24d      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSI_IsReady() == 0U)
 800c602:	f7ff fbe2 	bl	800bdca <LL_RCC_HSI_IsReady>
 800c606:	4603      	mov	r3, r0
 800c608:	2b00      	cmp	r3, #0
 800c60a:	d0f1      	beq.n	800c5f0 <HAL_RCC_OscConfig+0x22c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800c60c:	687b      	ldr	r3, [r7, #4]
 800c60e:	691b      	ldr	r3, [r3, #16]
 800c610:	4618      	mov	r0, r3
 800c612:	f7ff fbec 	bl	800bdee <LL_RCC_HSI_SetCalibTrimming>
 800c616:	e013      	b.n	800c640 <HAL_RCC_OscConfig+0x27c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800c618:	f7ff fbc8 	bl	800bdac <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c61c:	f7fc ffa6 	bl	800956c <HAL_GetTick>
 800c620:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
 800c622:	e008      	b.n	800c636 <HAL_RCC_OscConfig+0x272>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800c624:	f7fc ffa2 	bl	800956c <HAL_GetTick>
 800c628:	4602      	mov	r2, r0
 800c62a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c62c:	1ad3      	subs	r3, r2, r3
 800c62e:	2b02      	cmp	r3, #2
 800c630:	d901      	bls.n	800c636 <HAL_RCC_OscConfig+0x272>
          {
            return HAL_TIMEOUT;
 800c632:	2303      	movs	r3, #3
 800c634:	e233      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSI_IsReady() != 0U)
 800c636:	f7ff fbc8 	bl	800bdca <LL_RCC_HSI_IsReady>
 800c63a:	4603      	mov	r3, r0
 800c63c:	2b00      	cmp	r3, #0
 800c63e:	d1f1      	bne.n	800c624 <HAL_RCC_OscConfig+0x260>
      }
    }
  }
  /*------------------------------ LSI Configuration (LSI1 or LSI2) -------------------------*/

  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 800c640:	687b      	ldr	r3, [r7, #4]
 800c642:	681b      	ldr	r3, [r3, #0]
 800c644:	f003 0308 	and.w	r3, r3, #8
 800c648:	2b00      	cmp	r3, #0
 800c64a:	d106      	bne.n	800c65a <HAL_RCC_OscConfig+0x296>
      (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2))
 800c64c:	687b      	ldr	r3, [r7, #4]
 800c64e:	681b      	ldr	r3, [r3, #0]
 800c650:	f003 0310 	and.w	r3, r3, #16
  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 800c654:	2b00      	cmp	r3, #0
 800c656:	f000 80a3 	beq.w	800c7a0 <HAL_RCC_OscConfig+0x3dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800c65a:	687b      	ldr	r3, [r7, #4]
 800c65c:	695b      	ldr	r3, [r3, #20]
 800c65e:	2b00      	cmp	r3, #0
 800c660:	d076      	beq.n	800c750 <HAL_RCC_OscConfig+0x38c>
    {
      /*------------------------------ LSI2 selected by default (when Switch ON) -------------------------*/
      if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2)
 800c662:	687b      	ldr	r3, [r7, #4]
 800c664:	681b      	ldr	r3, [r3, #0]
 800c666:	f003 0310 	and.w	r3, r3, #16
 800c66a:	2b00      	cmp	r3, #0
 800c66c:	d046      	beq.n	800c6fc <HAL_RCC_OscConfig+0x338>
      {
        assert_param(IS_RCC_LSI2_CALIBRATION_VALUE(RCC_OscInitStruct->LSI2CalibrationValue));

        /* 1. Check LSI1 state and enable if required */
        if (LL_RCC_LSI1_IsReady() == 0U)
 800c66e:	f7ff fc7f 	bl	800bf70 <LL_RCC_LSI1_IsReady>
 800c672:	4603      	mov	r3, r0
 800c674:	2b00      	cmp	r3, #0
 800c676:	d113      	bne.n	800c6a0 <HAL_RCC_OscConfig+0x2dc>
        {
          /* This is required to enable LSI1 before enabling LSI2 */
          __HAL_RCC_LSI1_ENABLE();
 800c678:	f7ff fc58 	bl	800bf2c <LL_RCC_LSI1_Enable>

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 800c67c:	f7fc ff76 	bl	800956c <HAL_GetTick>
 800c680:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till LSI1 is ready */
          while (LL_RCC_LSI1_IsReady() == 0U)
 800c682:	e008      	b.n	800c696 <HAL_RCC_OscConfig+0x2d2>
          {
            if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 800c684:	f7fc ff72 	bl	800956c <HAL_GetTick>
 800c688:	4602      	mov	r2, r0
 800c68a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c68c:	1ad3      	subs	r3, r2, r3
 800c68e:	2b02      	cmp	r3, #2
 800c690:	d901      	bls.n	800c696 <HAL_RCC_OscConfig+0x2d2>
            {
              return HAL_TIMEOUT;
 800c692:	2303      	movs	r3, #3
 800c694:	e203      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
          while (LL_RCC_LSI1_IsReady() == 0U)
 800c696:	f7ff fc6b 	bl	800bf70 <LL_RCC_LSI1_IsReady>
 800c69a:	4603      	mov	r3, r0
 800c69c:	2b00      	cmp	r3, #0
 800c69e:	d0f1      	beq.n	800c684 <HAL_RCC_OscConfig+0x2c0>
            }
          }
        }

        /* 2. Enable the Internal Low Speed oscillator (LSI2) and set trimming value */
        __HAL_RCC_LSI2_ENABLE();
 800c6a0:	f7ff fc78 	bl	800bf94 <LL_RCC_LSI2_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c6a4:	f7fc ff62 	bl	800956c <HAL_GetTick>
 800c6a8:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI2 is ready */
        while (LL_RCC_LSI2_IsReady() == 0U)
 800c6aa:	e008      	b.n	800c6be <HAL_RCC_OscConfig+0x2fa>
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 800c6ac:	f7fc ff5e 	bl	800956c <HAL_GetTick>
 800c6b0:	4602      	mov	r2, r0
 800c6b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6b4:	1ad3      	subs	r3, r2, r3
 800c6b6:	2b03      	cmp	r3, #3
 800c6b8:	d901      	bls.n	800c6be <HAL_RCC_OscConfig+0x2fa>
          {
            return HAL_TIMEOUT;
 800c6ba:	2303      	movs	r3, #3
 800c6bc:	e1ef      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI2_IsReady() == 0U)
 800c6be:	f7ff fc8b 	bl	800bfd8 <LL_RCC_LSI2_IsReady>
 800c6c2:	4603      	mov	r3, r0
 800c6c4:	2b00      	cmp	r3, #0
 800c6c6:	d0f1      	beq.n	800c6ac <HAL_RCC_OscConfig+0x2e8>
          }
        }
        /* Adjusts the Internal Low Spee oscillator (LSI2) calibration value */
        __HAL_RCC_LSI2_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->LSI2CalibrationValue);
 800c6c8:	687b      	ldr	r3, [r7, #4]
 800c6ca:	699b      	ldr	r3, [r3, #24]
 800c6cc:	4618      	mov	r0, r3
 800c6ce:	f7ff fc95 	bl	800bffc <LL_RCC_LSI2_SetTrimming>

        /* 3. Disable LSI1 */

        /* LSI1 was initially not enable, require to disable it */
        __HAL_RCC_LSI1_DISABLE();
 800c6d2:	f7ff fc3c 	bl	800bf4e <LL_RCC_LSI1_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c6d6:	f7fc ff49 	bl	800956c <HAL_GetTick>
 800c6da:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is disabled */
        while (LL_RCC_LSI1_IsReady() != 0U)
 800c6dc:	e008      	b.n	800c6f0 <HAL_RCC_OscConfig+0x32c>
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 800c6de:	f7fc ff45 	bl	800956c <HAL_GetTick>
 800c6e2:	4602      	mov	r2, r0
 800c6e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c6e6:	1ad3      	subs	r3, r2, r3
 800c6e8:	2b02      	cmp	r3, #2
 800c6ea:	d901      	bls.n	800c6f0 <HAL_RCC_OscConfig+0x32c>
          {
            return HAL_TIMEOUT;
 800c6ec:	2303      	movs	r3, #3
 800c6ee:	e1d6      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI1_IsReady() != 0U)
 800c6f0:	f7ff fc3e 	bl	800bf70 <LL_RCC_LSI1_IsReady>
 800c6f4:	4603      	mov	r3, r0
 800c6f6:	2b00      	cmp	r3, #0
 800c6f8:	d1f1      	bne.n	800c6de <HAL_RCC_OscConfig+0x31a>
 800c6fa:	e051      	b.n	800c7a0 <HAL_RCC_OscConfig+0x3dc>
      else
      {
        /*------------------------------ LSI1 selected (only if LSI2 OFF)-------------------------*/

        /* 1. Enable the Internal Low Speed oscillator (LSI1). */
        __HAL_RCC_LSI1_ENABLE();
 800c6fc:	f7ff fc16 	bl	800bf2c <LL_RCC_LSI1_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800c700:	f7fc ff34 	bl	800956c <HAL_GetTick>
 800c704:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is ready */
        while (LL_RCC_LSI1_IsReady() == 0U)
 800c706:	e00c      	b.n	800c722 <HAL_RCC_OscConfig+0x35e>
 800c708:	20000018 	.word	0x20000018
 800c70c:	2000001c 	.word	0x2000001c
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 800c710:	f7fc ff2c 	bl	800956c <HAL_GetTick>
 800c714:	4602      	mov	r2, r0
 800c716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c718:	1ad3      	subs	r3, r2, r3
 800c71a:	2b02      	cmp	r3, #2
 800c71c:	d901      	bls.n	800c722 <HAL_RCC_OscConfig+0x35e>
          {
            return HAL_TIMEOUT;
 800c71e:	2303      	movs	r3, #3
 800c720:	e1bd      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI1_IsReady() == 0U)
 800c722:	f7ff fc25 	bl	800bf70 <LL_RCC_LSI1_IsReady>
 800c726:	4603      	mov	r3, r0
 800c728:	2b00      	cmp	r3, #0
 800c72a:	d0f1      	beq.n	800c710 <HAL_RCC_OscConfig+0x34c>
          }
        }
        /*2. Switch OFF LSI2*/

        /* Disable the Internal Low Speed oscillator (LSI2). */
        __HAL_RCC_LSI2_DISABLE();
 800c72c:	f7ff fc43 	bl	800bfb6 <LL_RCC_LSI2_Disable>

        /* Wait till LSI2 is disabled */
        while (LL_RCC_LSI2_IsReady() != 0U)
 800c730:	e008      	b.n	800c744 <HAL_RCC_OscConfig+0x380>
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 800c732:	f7fc ff1b 	bl	800956c <HAL_GetTick>
 800c736:	4602      	mov	r2, r0
 800c738:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c73a:	1ad3      	subs	r3, r2, r3
 800c73c:	2b03      	cmp	r3, #3
 800c73e:	d901      	bls.n	800c744 <HAL_RCC_OscConfig+0x380>
          {
            return HAL_TIMEOUT;
 800c740:	2303      	movs	r3, #3
 800c742:	e1ac      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI2_IsReady() != 0U)
 800c744:	f7ff fc48 	bl	800bfd8 <LL_RCC_LSI2_IsReady>
 800c748:	4603      	mov	r3, r0
 800c74a:	2b00      	cmp	r3, #0
 800c74c:	d1f1      	bne.n	800c732 <HAL_RCC_OscConfig+0x36e>
 800c74e:	e027      	b.n	800c7a0 <HAL_RCC_OscConfig+0x3dc>
    }
    else
    {

      /* Disable the Internal Low Speed oscillator (LSI2). */
      __HAL_RCC_LSI2_DISABLE();
 800c750:	f7ff fc31 	bl	800bfb6 <LL_RCC_LSI2_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800c754:	f7fc ff0a 	bl	800956c <HAL_GetTick>
 800c758:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI2 is disabled */
      while (LL_RCC_LSI2_IsReady() != 0U)
 800c75a:	e008      	b.n	800c76e <HAL_RCC_OscConfig+0x3aa>
      {
        if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 800c75c:	f7fc ff06 	bl	800956c <HAL_GetTick>
 800c760:	4602      	mov	r2, r0
 800c762:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c764:	1ad3      	subs	r3, r2, r3
 800c766:	2b03      	cmp	r3, #3
 800c768:	d901      	bls.n	800c76e <HAL_RCC_OscConfig+0x3aa>
        {
          return HAL_TIMEOUT;
 800c76a:	2303      	movs	r3, #3
 800c76c:	e197      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSI2_IsReady() != 0U)
 800c76e:	f7ff fc33 	bl	800bfd8 <LL_RCC_LSI2_IsReady>
 800c772:	4603      	mov	r3, r0
 800c774:	2b00      	cmp	r3, #0
 800c776:	d1f1      	bne.n	800c75c <HAL_RCC_OscConfig+0x398>
        }
      }

      /* Disable the Internal Low Speed oscillator (LSI1). */
      __HAL_RCC_LSI1_DISABLE();
 800c778:	f7ff fbe9 	bl	800bf4e <LL_RCC_LSI1_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800c77c:	f7fc fef6 	bl	800956c <HAL_GetTick>
 800c780:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI1 is disabled */
      while (LL_RCC_LSI1_IsReady() != 0U)
 800c782:	e008      	b.n	800c796 <HAL_RCC_OscConfig+0x3d2>
      {
        if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 800c784:	f7fc fef2 	bl	800956c <HAL_GetTick>
 800c788:	4602      	mov	r2, r0
 800c78a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c78c:	1ad3      	subs	r3, r2, r3
 800c78e:	2b02      	cmp	r3, #2
 800c790:	d901      	bls.n	800c796 <HAL_RCC_OscConfig+0x3d2>
        {
          return HAL_TIMEOUT;
 800c792:	2303      	movs	r3, #3
 800c794:	e183      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSI1_IsReady() != 0U)
 800c796:	f7ff fbeb 	bl	800bf70 <LL_RCC_LSI1_IsReady>
 800c79a:	4603      	mov	r3, r0
 800c79c:	2b00      	cmp	r3, #0
 800c79e:	d1f1      	bne.n	800c784 <HAL_RCC_OscConfig+0x3c0>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800c7a0:	687b      	ldr	r3, [r7, #4]
 800c7a2:	681b      	ldr	r3, [r3, #0]
 800c7a4:	f003 0304 	and.w	r3, r3, #4
 800c7a8:	2b00      	cmp	r3, #0
 800c7aa:	d05b      	beq.n	800c864 <HAL_RCC_OscConfig+0x4a0>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800c7ac:	4ba7      	ldr	r3, [pc, #668]	; (800ca4c <HAL_RCC_OscConfig+0x688>)
 800c7ae:	681b      	ldr	r3, [r3, #0]
 800c7b0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c7b4:	2b00      	cmp	r3, #0
 800c7b6:	d114      	bne.n	800c7e2 <HAL_RCC_OscConfig+0x41e>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 800c7b8:	f7ff f9fa 	bl	800bbb0 <HAL_PWR_EnableBkUpAccess>

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800c7bc:	f7fc fed6 	bl	800956c <HAL_GetTick>
 800c7c0:	6278      	str	r0, [r7, #36]	; 0x24

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800c7c2:	e008      	b.n	800c7d6 <HAL_RCC_OscConfig+0x412>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c7c4:	f7fc fed2 	bl	800956c <HAL_GetTick>
 800c7c8:	4602      	mov	r2, r0
 800c7ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7cc:	1ad3      	subs	r3, r2, r3
 800c7ce:	2b02      	cmp	r3, #2
 800c7d0:	d901      	bls.n	800c7d6 <HAL_RCC_OscConfig+0x412>
        {
          return HAL_TIMEOUT;
 800c7d2:	2303      	movs	r3, #3
 800c7d4:	e163      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800c7d6:	4b9d      	ldr	r3, [pc, #628]	; (800ca4c <HAL_RCC_OscConfig+0x688>)
 800c7d8:	681b      	ldr	r3, [r3, #0]
 800c7da:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c7de:	2b00      	cmp	r3, #0
 800c7e0:	d0f0      	beq.n	800c7c4 <HAL_RCC_OscConfig+0x400>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c7e2:	687b      	ldr	r3, [r7, #4]
 800c7e4:	689b      	ldr	r3, [r3, #8]
 800c7e6:	2b01      	cmp	r3, #1
 800c7e8:	d102      	bne.n	800c7f0 <HAL_RCC_OscConfig+0x42c>
 800c7ea:	f7ff fb49 	bl	800be80 <LL_RCC_LSE_Enable>
 800c7ee:	e00c      	b.n	800c80a <HAL_RCC_OscConfig+0x446>
 800c7f0:	687b      	ldr	r3, [r7, #4]
 800c7f2:	689b      	ldr	r3, [r3, #8]
 800c7f4:	2b05      	cmp	r3, #5
 800c7f6:	d104      	bne.n	800c802 <HAL_RCC_OscConfig+0x43e>
 800c7f8:	f7ff fb64 	bl	800bec4 <LL_RCC_LSE_EnableBypass>
 800c7fc:	f7ff fb40 	bl	800be80 <LL_RCC_LSE_Enable>
 800c800:	e003      	b.n	800c80a <HAL_RCC_OscConfig+0x446>
 800c802:	f7ff fb4e 	bl	800bea2 <LL_RCC_LSE_Disable>
 800c806:	f7ff fb6e 	bl	800bee6 <LL_RCC_LSE_DisableBypass>

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	689b      	ldr	r3, [r3, #8]
 800c80e:	2b00      	cmp	r3, #0
 800c810:	d014      	beq.n	800c83c <HAL_RCC_OscConfig+0x478>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800c812:	f7fc feab 	bl	800956c <HAL_GetTick>
 800c816:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
 800c818:	e00a      	b.n	800c830 <HAL_RCC_OscConfig+0x46c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c81a:	f7fc fea7 	bl	800956c <HAL_GetTick>
 800c81e:	4602      	mov	r2, r0
 800c820:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c822:	1ad3      	subs	r3, r2, r3
 800c824:	f241 3288 	movw	r2, #5000	; 0x1388
 800c828:	4293      	cmp	r3, r2
 800c82a:	d901      	bls.n	800c830 <HAL_RCC_OscConfig+0x46c>
        {
          return HAL_TIMEOUT;
 800c82c:	2303      	movs	r3, #3
 800c82e:	e136      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSE_IsReady() == 0U)
 800c830:	f7ff fb6a 	bl	800bf08 <LL_RCC_LSE_IsReady>
 800c834:	4603      	mov	r3, r0
 800c836:	2b00      	cmp	r3, #0
 800c838:	d0ef      	beq.n	800c81a <HAL_RCC_OscConfig+0x456>
 800c83a:	e013      	b.n	800c864 <HAL_RCC_OscConfig+0x4a0>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800c83c:	f7fc fe96 	bl	800956c <HAL_GetTick>
 800c840:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
 800c842:	e00a      	b.n	800c85a <HAL_RCC_OscConfig+0x496>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c844:	f7fc fe92 	bl	800956c <HAL_GetTick>
 800c848:	4602      	mov	r2, r0
 800c84a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c84c:	1ad3      	subs	r3, r2, r3
 800c84e:	f241 3288 	movw	r2, #5000	; 0x1388
 800c852:	4293      	cmp	r3, r2
 800c854:	d901      	bls.n	800c85a <HAL_RCC_OscConfig+0x496>
        {
          return HAL_TIMEOUT;
 800c856:	2303      	movs	r3, #3
 800c858:	e121      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSE_IsReady() != 0U)
 800c85a:	f7ff fb55 	bl	800bf08 <LL_RCC_LSE_IsReady>
 800c85e:	4603      	mov	r3, r0
 800c860:	2b00      	cmp	r3, #0
 800c862:	d1ef      	bne.n	800c844 <HAL_RCC_OscConfig+0x480>
    }

  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	681b      	ldr	r3, [r3, #0]
 800c868:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c86c:	2b00      	cmp	r3, #0
 800c86e:	d02c      	beq.n	800c8ca <HAL_RCC_OscConfig+0x506>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI State */
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800c870:	687b      	ldr	r3, [r7, #4]
 800c872:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c874:	2b00      	cmp	r3, #0
 800c876:	d014      	beq.n	800c8a2 <HAL_RCC_OscConfig+0x4de>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800c878:	f7ff face 	bl	800be18 <LL_RCC_HSI48_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800c87c:	f7fc fe76 	bl	800956c <HAL_GetTick>
 800c880:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while (LL_RCC_HSI48_IsReady() == 0U)
 800c882:	e008      	b.n	800c896 <HAL_RCC_OscConfig+0x4d2>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800c884:	f7fc fe72 	bl	800956c <HAL_GetTick>
 800c888:	4602      	mov	r2, r0
 800c88a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c88c:	1ad3      	subs	r3, r2, r3
 800c88e:	2b02      	cmp	r3, #2
 800c890:	d901      	bls.n	800c896 <HAL_RCC_OscConfig+0x4d2>
        {
          return HAL_TIMEOUT;
 800c892:	2303      	movs	r3, #3
 800c894:	e103      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_HSI48_IsReady() == 0U)
 800c896:	f7ff fae1 	bl	800be5c <LL_RCC_HSI48_IsReady>
 800c89a:	4603      	mov	r3, r0
 800c89c:	2b00      	cmp	r3, #0
 800c89e:	d0f1      	beq.n	800c884 <HAL_RCC_OscConfig+0x4c0>
 800c8a0:	e013      	b.n	800c8ca <HAL_RCC_OscConfig+0x506>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 800c8a2:	f7ff faca 	bl	800be3a <LL_RCC_HSI48_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800c8a6:	f7fc fe61 	bl	800956c <HAL_GetTick>
 800c8aa:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is disabled */
      while (LL_RCC_HSI48_IsReady() != 0U)
 800c8ac:	e008      	b.n	800c8c0 <HAL_RCC_OscConfig+0x4fc>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800c8ae:	f7fc fe5d 	bl	800956c <HAL_GetTick>
 800c8b2:	4602      	mov	r2, r0
 800c8b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8b6:	1ad3      	subs	r3, r2, r3
 800c8b8:	2b02      	cmp	r3, #2
 800c8ba:	d901      	bls.n	800c8c0 <HAL_RCC_OscConfig+0x4fc>
        {
          return HAL_TIMEOUT;
 800c8bc:	2303      	movs	r3, #3
 800c8be:	e0ee      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_HSI48_IsReady() != 0U)
 800c8c0:	f7ff facc 	bl	800be5c <LL_RCC_HSI48_IsReady>
 800c8c4:	4603      	mov	r3, r0
 800c8c6:	2b00      	cmp	r3, #0
 800c8c8:	d1f1      	bne.n	800c8ae <HAL_RCC_OscConfig+0x4ea>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800c8ca:	687b      	ldr	r3, [r7, #4]
 800c8cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c8ce:	2b00      	cmp	r3, #0
 800c8d0:	f000 80e4 	beq.w	800ca9c <HAL_RCC_OscConfig+0x6d8>
  {
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800c8d4:	f7ff fc2a 	bl	800c12c <LL_RCC_GetSysClkSource>
 800c8d8:	6138      	str	r0, [r7, #16]
    const uint32_t temp_pllconfig = RCC->PLLCFGR;
 800c8da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c8de:	68db      	ldr	r3, [r3, #12]
 800c8e0:	60fb      	str	r3, [r7, #12]

    /* PLL On ? */
    if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800c8e2:	687b      	ldr	r3, [r7, #4]
 800c8e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c8e6:	2b02      	cmp	r3, #2
 800c8e8:	f040 80b4 	bne.w	800ca54 <HAL_RCC_OscConfig+0x690>
      assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is unchanged */
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800c8ec:	68fb      	ldr	r3, [r7, #12]
 800c8ee:	f003 0203 	and.w	r2, r3, #3
 800c8f2:	687b      	ldr	r3, [r7, #4]
 800c8f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c8f6:	429a      	cmp	r2, r3
 800c8f8:	d123      	bne.n	800c942 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800c8fa:	68fb      	ldr	r3, [r7, #12]
 800c8fc:	f003 0270 	and.w	r2, r3, #112	; 0x70
 800c900:	687b      	ldr	r3, [r7, #4]
 800c902:	6b5b      	ldr	r3, [r3, #52]	; 0x34
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800c904:	429a      	cmp	r2, r3
 800c906:	d11c      	bne.n	800c942 <HAL_RCC_OscConfig+0x57e>
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 800c908:	68fb      	ldr	r3, [r7, #12]
 800c90a:	0a1b      	lsrs	r3, r3, #8
 800c90c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 800c910:	687b      	ldr	r3, [r7, #4]
 800c912:	6b9b      	ldr	r3, [r3, #56]	; 0x38
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800c914:	429a      	cmp	r2, r3
 800c916:	d114      	bne.n	800c942 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 800c918:	68fb      	ldr	r3, [r7, #12]
 800c91a:	f403 1278 	and.w	r2, r3, #4063232	; 0x3e0000
 800c91e:	687b      	ldr	r3, [r7, #4]
 800c920:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 800c922:	429a      	cmp	r2, r3
 800c924:	d10d      	bne.n	800c942 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 800c926:	68fb      	ldr	r3, [r7, #12]
 800c928:	f003 6260 	and.w	r2, r3, #234881024	; 0xe000000
 800c92c:	687b      	ldr	r3, [r7, #4]
 800c92e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 800c930:	429a      	cmp	r2, r3
 800c932:	d106      	bne.n	800c942 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLR) != RCC_OscInitStruct->PLL.PLLR))
 800c934:	68fb      	ldr	r3, [r7, #12]
 800c936:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800c93a:	687b      	ldr	r3, [r7, #4]
 800c93c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 800c93e:	429a      	cmp	r2, r3
 800c940:	d05d      	beq.n	800c9fe <HAL_RCC_OscConfig+0x63a>
      {
        /* Check if the PLL is used as system clock or not */
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800c942:	693b      	ldr	r3, [r7, #16]
 800c944:	2b0c      	cmp	r3, #12
 800c946:	d058      	beq.n	800c9fa <HAL_RCC_OscConfig+0x636>
        {
#if defined(SAI1)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if (READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 800c948:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c94c:	681b      	ldr	r3, [r3, #0]
 800c94e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800c952:	2b00      	cmp	r3, #0
 800c954:	d001      	beq.n	800c95a <HAL_RCC_OscConfig+0x596>

          {
            return HAL_ERROR;
 800c956:	2301      	movs	r3, #1
 800c958:	e0a1      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
          }
          else
#endif /* SAI1 */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 800c95a:	f7ff fc85 	bl	800c268 <LL_RCC_PLL_Disable>

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 800c95e:	f7fc fe05 	bl	800956c <HAL_GetTick>
 800c962:	6278      	str	r0, [r7, #36]	; 0x24

            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800c964:	e008      	b.n	800c978 <HAL_RCC_OscConfig+0x5b4>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c966:	f7fc fe01 	bl	800956c <HAL_GetTick>
 800c96a:	4602      	mov	r2, r0
 800c96c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c96e:	1ad3      	subs	r3, r2, r3
 800c970:	2b02      	cmp	r3, #2
 800c972:	d901      	bls.n	800c978 <HAL_RCC_OscConfig+0x5b4>
              {
                return HAL_TIMEOUT;
 800c974:	2303      	movs	r3, #3
 800c976:	e092      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800c978:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c97c:	681b      	ldr	r3, [r3, #0]
 800c97e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800c982:	2b00      	cmp	r3, #0
 800c984:	d1ef      	bne.n	800c966 <HAL_RCC_OscConfig+0x5a2>
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800c986:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c98a:	68da      	ldr	r2, [r3, #12]
 800c98c:	4b30      	ldr	r3, [pc, #192]	; (800ca50 <HAL_RCC_OscConfig+0x68c>)
 800c98e:	4013      	ands	r3, r2
 800c990:	687a      	ldr	r2, [r7, #4]
 800c992:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800c994:	687a      	ldr	r2, [r7, #4]
 800c996:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800c998:	4311      	orrs	r1, r2
 800c99a:	687a      	ldr	r2, [r7, #4]
 800c99c:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800c99e:	0212      	lsls	r2, r2, #8
 800c9a0:	4311      	orrs	r1, r2
 800c9a2:	687a      	ldr	r2, [r7, #4]
 800c9a4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800c9a6:	4311      	orrs	r1, r2
 800c9a8:	687a      	ldr	r2, [r7, #4]
 800c9aa:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800c9ac:	4311      	orrs	r1, r2
 800c9ae:	687a      	ldr	r2, [r7, #4]
 800c9b0:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800c9b2:	430a      	orrs	r2, r1
 800c9b4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c9b8:	4313      	orrs	r3, r2
 800c9ba:	60cb      	str	r3, [r1, #12]
                                 RCC_OscInitStruct->PLL.PLLP,
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 800c9bc:	f7ff fc45 	bl	800c24a <LL_RCC_PLL_Enable>

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800c9c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c9c4:	68db      	ldr	r3, [r3, #12]
 800c9c6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c9ca:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c9ce:	60d3      	str	r3, [r2, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 800c9d0:	f7fc fdcc 	bl	800956c <HAL_GetTick>
 800c9d4:	6278      	str	r0, [r7, #36]	; 0x24

            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800c9d6:	e008      	b.n	800c9ea <HAL_RCC_OscConfig+0x626>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800c9d8:	f7fc fdc8 	bl	800956c <HAL_GetTick>
 800c9dc:	4602      	mov	r2, r0
 800c9de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c9e0:	1ad3      	subs	r3, r2, r3
 800c9e2:	2b02      	cmp	r3, #2
 800c9e4:	d901      	bls.n	800c9ea <HAL_RCC_OscConfig+0x626>
              {
                return HAL_TIMEOUT;
 800c9e6:	2303      	movs	r3, #3
 800c9e8:	e059      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800c9ea:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c9ee:	681b      	ldr	r3, [r3, #0]
 800c9f0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800c9f4:	2b00      	cmp	r3, #0
 800c9f6:	d0ef      	beq.n	800c9d8 <HAL_RCC_OscConfig+0x614>
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800c9f8:	e050      	b.n	800ca9c <HAL_RCC_OscConfig+0x6d8>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 800c9fa:	2301      	movs	r3, #1
 800c9fc:	e04f      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800c9fe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ca02:	681b      	ldr	r3, [r3, #0]
 800ca04:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ca08:	2b00      	cmp	r3, #0
 800ca0a:	d147      	bne.n	800ca9c <HAL_RCC_OscConfig+0x6d8>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 800ca0c:	f7ff fc1d 	bl	800c24a <LL_RCC_PLL_Enable>

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800ca10:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ca14:	68db      	ldr	r3, [r3, #12]
 800ca16:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800ca1a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800ca1e:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 800ca20:	f7fc fda4 	bl	800956c <HAL_GetTick>
 800ca24:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till PLL is ready */
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800ca26:	e008      	b.n	800ca3a <HAL_RCC_OscConfig+0x676>
          {
            if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800ca28:	f7fc fda0 	bl	800956c <HAL_GetTick>
 800ca2c:	4602      	mov	r2, r0
 800ca2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ca30:	1ad3      	subs	r3, r2, r3
 800ca32:	2b02      	cmp	r3, #2
 800ca34:	d901      	bls.n	800ca3a <HAL_RCC_OscConfig+0x676>
            {
              return HAL_TIMEOUT;
 800ca36:	2303      	movs	r3, #3
 800ca38:	e031      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800ca3a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ca3e:	681b      	ldr	r3, [r3, #0]
 800ca40:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ca44:	2b00      	cmp	r3, #0
 800ca46:	d0ef      	beq.n	800ca28 <HAL_RCC_OscConfig+0x664>
 800ca48:	e028      	b.n	800ca9c <HAL_RCC_OscConfig+0x6d8>
 800ca4a:	bf00      	nop
 800ca4c:	58000400 	.word	0x58000400
 800ca50:	11c1808c 	.word	0x11c1808c
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800ca54:	693b      	ldr	r3, [r7, #16]
 800ca56:	2b0c      	cmp	r3, #12
 800ca58:	d01e      	beq.n	800ca98 <HAL_RCC_OscConfig+0x6d4>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800ca5a:	f7ff fc05 	bl	800c268 <LL_RCC_PLL_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800ca5e:	f7fc fd85 	bl	800956c <HAL_GetTick>
 800ca62:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800ca64:	e008      	b.n	800ca78 <HAL_RCC_OscConfig+0x6b4>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800ca66:	f7fc fd81 	bl	800956c <HAL_GetTick>
 800ca6a:	4602      	mov	r2, r0
 800ca6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ca6e:	1ad3      	subs	r3, r2, r3
 800ca70:	2b02      	cmp	r3, #2
 800ca72:	d901      	bls.n	800ca78 <HAL_RCC_OscConfig+0x6b4>
          {
            return HAL_TIMEOUT;
 800ca74:	2303      	movs	r3, #3
 800ca76:	e012      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800ca78:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ca7c:	681b      	ldr	r3, [r3, #0]
 800ca7e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ca82:	2b00      	cmp	r3, #0
 800ca84:	d1ef      	bne.n	800ca66 <HAL_RCC_OscConfig+0x6a2>
          }
        }

        /* Disable the PLL source and outputs to save power when PLL is off */
#if defined(SAI1) && defined(USB)
        CLEAR_BIT(RCC->PLLCFGR, (RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLPEN | RCC_PLLCFGR_PLLQEN | RCC_PLLCFGR_PLLREN));
 800ca86:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ca8a:	68da      	ldr	r2, [r3, #12]
 800ca8c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ca90:	4b05      	ldr	r3, [pc, #20]	; (800caa8 <HAL_RCC_OscConfig+0x6e4>)
 800ca92:	4013      	ands	r3, r2
 800ca94:	60cb      	str	r3, [r1, #12]
 800ca96:	e001      	b.n	800ca9c <HAL_RCC_OscConfig+0x6d8>
#endif /* SAI1 && USB */
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 800ca98:	2301      	movs	r3, #1
 800ca9a:	e000      	b.n	800ca9e <HAL_RCC_OscConfig+0x6da>
      }
    }
  }
  return HAL_OK;
 800ca9c:	2300      	movs	r3, #0
}
 800ca9e:	4618      	mov	r0, r3
 800caa0:	3734      	adds	r7, #52	; 0x34
 800caa2:	46bd      	mov	sp, r7
 800caa4:	bd90      	pop	{r4, r7, pc}
 800caa6:	bf00      	nop
 800caa8:	eefefffc 	.word	0xeefefffc

0800caac <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK1 not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800caac:	b580      	push	{r7, lr}
 800caae:	b084      	sub	sp, #16
 800cab0:	af00      	add	r7, sp, #0
 800cab2:	6078      	str	r0, [r7, #4]
 800cab4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800cab6:	687b      	ldr	r3, [r7, #4]
 800cab8:	2b00      	cmp	r3, #0
 800caba:	d101      	bne.n	800cac0 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800cabc:	2301      	movs	r3, #1
 800cabe:	e12d      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the FLASH clock
    (HCLK4) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800cac0:	4b98      	ldr	r3, [pc, #608]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800cac2:	681b      	ldr	r3, [r3, #0]
 800cac4:	f003 0307 	and.w	r3, r3, #7
 800cac8:	683a      	ldr	r2, [r7, #0]
 800caca:	429a      	cmp	r2, r3
 800cacc:	d91b      	bls.n	800cb06 <HAL_RCC_ClockConfig+0x5a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800cace:	4b95      	ldr	r3, [pc, #596]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800cad0:	681b      	ldr	r3, [r3, #0]
 800cad2:	f023 0207 	bic.w	r2, r3, #7
 800cad6:	4993      	ldr	r1, [pc, #588]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800cad8:	683b      	ldr	r3, [r7, #0]
 800cada:	4313      	orrs	r3, r2
 800cadc:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cade:	f7fc fd45 	bl	800956c <HAL_GetTick>
 800cae2:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800cae4:	e008      	b.n	800caf8 <HAL_RCC_ClockConfig+0x4c>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 800cae6:	f7fc fd41 	bl	800956c <HAL_GetTick>
 800caea:	4602      	mov	r2, r0
 800caec:	68fb      	ldr	r3, [r7, #12]
 800caee:	1ad3      	subs	r3, r2, r3
 800caf0:	2b02      	cmp	r3, #2
 800caf2:	d901      	bls.n	800caf8 <HAL_RCC_ClockConfig+0x4c>
      {
        return HAL_TIMEOUT;
 800caf4:	2303      	movs	r3, #3
 800caf6:	e111      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800caf8:	4b8a      	ldr	r3, [pc, #552]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800cafa:	681b      	ldr	r3, [r3, #0]
 800cafc:	f003 0307 	and.w	r3, r3, #7
 800cb00:	683a      	ldr	r2, [r7, #0]
 800cb02:	429a      	cmp	r2, r3
 800cb04:	d1ef      	bne.n	800cae6 <HAL_RCC_ClockConfig+0x3a>
      }
    }
  }

  /*-------------------------- HCLK1 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800cb06:	687b      	ldr	r3, [r7, #4]
 800cb08:	681b      	ldr	r3, [r3, #0]
 800cb0a:	f003 0302 	and.w	r3, r3, #2
 800cb0e:	2b00      	cmp	r3, #0
 800cb10:	d016      	beq.n	800cb40 <HAL_RCC_ClockConfig+0x94>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLKDivider));
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 800cb12:	687b      	ldr	r3, [r7, #4]
 800cb14:	689b      	ldr	r3, [r3, #8]
 800cb16:	4618      	mov	r0, r3
 800cb18:	f7ff fb14 	bl	800c144 <LL_RCC_SetAHBPrescaler>

    /* HCLK1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 800cb1c:	f7fc fd26 	bl	800956c <HAL_GetTick>
 800cb20:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 800cb22:	e008      	b.n	800cb36 <HAL_RCC_ClockConfig+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800cb24:	f7fc fd22 	bl	800956c <HAL_GetTick>
 800cb28:	4602      	mov	r2, r0
 800cb2a:	68fb      	ldr	r3, [r7, #12]
 800cb2c:	1ad3      	subs	r3, r2, r3
 800cb2e:	2b02      	cmp	r3, #2
 800cb30:	d901      	bls.n	800cb36 <HAL_RCC_ClockConfig+0x8a>
      {
        return HAL_TIMEOUT;
 800cb32:	2303      	movs	r3, #3
 800cb34:	e0f2      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 800cb36:	f7ff fbe9 	bl	800c30c <LL_RCC_IsActiveFlag_HPRE>
 800cb3a:	4603      	mov	r3, r0
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	d0f1      	beq.n	800cb24 <HAL_RCC_ClockConfig+0x78>
      }
    }
  }

  /*-------------------------- HCLK2 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 800cb40:	687b      	ldr	r3, [r7, #4]
 800cb42:	681b      	ldr	r3, [r3, #0]
 800cb44:	f003 0320 	and.w	r3, r3, #32
 800cb48:	2b00      	cmp	r3, #0
 800cb4a:	d016      	beq.n	800cb7a <HAL_RCC_ClockConfig+0xce>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK2Divider));
    LL_C2_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLK2Divider);
 800cb4c:	687b      	ldr	r3, [r7, #4]
 800cb4e:	695b      	ldr	r3, [r3, #20]
 800cb50:	4618      	mov	r0, r3
 800cb52:	f7ff fb0b 	bl	800c16c <LL_C2_RCC_SetAHBPrescaler>

    /* HCLK2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 800cb56:	f7fc fd09 	bl	800956c <HAL_GetTick>
 800cb5a:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 800cb5c:	e008      	b.n	800cb70 <HAL_RCC_ClockConfig+0xc4>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800cb5e:	f7fc fd05 	bl	800956c <HAL_GetTick>
 800cb62:	4602      	mov	r2, r0
 800cb64:	68fb      	ldr	r3, [r7, #12]
 800cb66:	1ad3      	subs	r3, r2, r3
 800cb68:	2b02      	cmp	r3, #2
 800cb6a:	d901      	bls.n	800cb70 <HAL_RCC_ClockConfig+0xc4>
      {
        return HAL_TIMEOUT;
 800cb6c:	2303      	movs	r3, #3
 800cb6e:	e0d5      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 800cb70:	f7ff fbde 	bl	800c330 <LL_RCC_IsActiveFlag_C2HPRE>
 800cb74:	4603      	mov	r3, r0
 800cb76:	2b00      	cmp	r3, #0
 800cb78:	d0f1      	beq.n	800cb5e <HAL_RCC_ClockConfig+0xb2>
      }
    }
  }
  /*-------------------------- HCLK4 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK4) == RCC_CLOCKTYPE_HCLK4)
 800cb7a:	687b      	ldr	r3, [r7, #4]
 800cb7c:	681b      	ldr	r3, [r3, #0]
 800cb7e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800cb82:	2b00      	cmp	r3, #0
 800cb84:	d016      	beq.n	800cbb4 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK4Divider));
    LL_RCC_SetAHB4Prescaler(RCC_ClkInitStruct->AHBCLK4Divider);
 800cb86:	687b      	ldr	r3, [r7, #4]
 800cb88:	699b      	ldr	r3, [r3, #24]
 800cb8a:	4618      	mov	r0, r3
 800cb8c:	f7ff fb04 	bl	800c198 <LL_RCC_SetAHB4Prescaler>

    /* AHB shared prescaler flag when value applied */
    tickstart = HAL_GetTick();
 800cb90:	f7fc fcec 	bl	800956c <HAL_GetTick>
 800cb94:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 800cb96:	e008      	b.n	800cbaa <HAL_RCC_ClockConfig+0xfe>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800cb98:	f7fc fce8 	bl	800956c <HAL_GetTick>
 800cb9c:	4602      	mov	r2, r0
 800cb9e:	68fb      	ldr	r3, [r7, #12]
 800cba0:	1ad3      	subs	r3, r2, r3
 800cba2:	2b02      	cmp	r3, #2
 800cba4:	d901      	bls.n	800cbaa <HAL_RCC_ClockConfig+0xfe>
      {
        return HAL_TIMEOUT;
 800cba6:	2303      	movs	r3, #3
 800cba8:	e0b8      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 800cbaa:	f7ff fbd4 	bl	800c356 <LL_RCC_IsActiveFlag_SHDHPRE>
 800cbae:	4603      	mov	r3, r0
 800cbb0:	2b00      	cmp	r3, #0
 800cbb2:	d0f1      	beq.n	800cb98 <HAL_RCC_ClockConfig+0xec>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800cbb4:	687b      	ldr	r3, [r7, #4]
 800cbb6:	681b      	ldr	r3, [r3, #0]
 800cbb8:	f003 0304 	and.w	r3, r3, #4
 800cbbc:	2b00      	cmp	r3, #0
 800cbbe:	d016      	beq.n	800cbee <HAL_RCC_ClockConfig+0x142>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB1CLKDivider));
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 800cbc0:	687b      	ldr	r3, [r7, #4]
 800cbc2:	68db      	ldr	r3, [r3, #12]
 800cbc4:	4618      	mov	r0, r3
 800cbc6:	f7ff fafe 	bl	800c1c6 <LL_RCC_SetAPB1Prescaler>

    /* APB1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 800cbca:	f7fc fccf 	bl	800956c <HAL_GetTick>
 800cbce:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 800cbd0:	e008      	b.n	800cbe4 <HAL_RCC_ClockConfig+0x138>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800cbd2:	f7fc fccb 	bl	800956c <HAL_GetTick>
 800cbd6:	4602      	mov	r2, r0
 800cbd8:	68fb      	ldr	r3, [r7, #12]
 800cbda:	1ad3      	subs	r3, r2, r3
 800cbdc:	2b02      	cmp	r3, #2
 800cbde:	d901      	bls.n	800cbe4 <HAL_RCC_ClockConfig+0x138>
      {
        return HAL_TIMEOUT;
 800cbe0:	2303      	movs	r3, #3
 800cbe2:	e09b      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 800cbe4:	f7ff fbca 	bl	800c37c <LL_RCC_IsActiveFlag_PPRE1>
 800cbe8:	4603      	mov	r3, r0
 800cbea:	2b00      	cmp	r3, #0
 800cbec:	d0f1      	beq.n	800cbd2 <HAL_RCC_ClockConfig+0x126>
      }
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800cbee:	687b      	ldr	r3, [r7, #4]
 800cbf0:	681b      	ldr	r3, [r3, #0]
 800cbf2:	f003 0308 	and.w	r3, r3, #8
 800cbf6:	2b00      	cmp	r3, #0
 800cbf8:	d017      	beq.n	800cc2a <HAL_RCC_ClockConfig+0x17e>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB2CLKDivider));
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 800cbfa:	687b      	ldr	r3, [r7, #4]
 800cbfc:	691b      	ldr	r3, [r3, #16]
 800cbfe:	00db      	lsls	r3, r3, #3
 800cc00:	4618      	mov	r0, r3
 800cc02:	f7ff faf4 	bl	800c1ee <LL_RCC_SetAPB2Prescaler>

    /* APB2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 800cc06:	f7fc fcb1 	bl	800956c <HAL_GetTick>
 800cc0a:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 800cc0c:	e008      	b.n	800cc20 <HAL_RCC_ClockConfig+0x174>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800cc0e:	f7fc fcad 	bl	800956c <HAL_GetTick>
 800cc12:	4602      	mov	r2, r0
 800cc14:	68fb      	ldr	r3, [r7, #12]
 800cc16:	1ad3      	subs	r3, r2, r3
 800cc18:	2b02      	cmp	r3, #2
 800cc1a:	d901      	bls.n	800cc20 <HAL_RCC_ClockConfig+0x174>
      {
        return HAL_TIMEOUT;
 800cc1c:	2303      	movs	r3, #3
 800cc1e:	e07d      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 800cc20:	f7ff fbbe 	bl	800c3a0 <LL_RCC_IsActiveFlag_PPRE2>
 800cc24:	4603      	mov	r3, r0
 800cc26:	2b00      	cmp	r3, #0
 800cc28:	d0f1      	beq.n	800cc0e <HAL_RCC_ClockConfig+0x162>
      }
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800cc2a:	687b      	ldr	r3, [r7, #4]
 800cc2c:	681b      	ldr	r3, [r3, #0]
 800cc2e:	f003 0301 	and.w	r3, r3, #1
 800cc32:	2b00      	cmp	r3, #0
 800cc34:	d043      	beq.n	800ccbe <HAL_RCC_ClockConfig+0x212>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800cc36:	687b      	ldr	r3, [r7, #4]
 800cc38:	685b      	ldr	r3, [r3, #4]
 800cc3a:	2b02      	cmp	r3, #2
 800cc3c:	d106      	bne.n	800cc4c <HAL_RCC_ClockConfig+0x1a0>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
 800cc3e:	f7ff f894 	bl	800bd6a <LL_RCC_HSE_IsReady>
 800cc42:	4603      	mov	r3, r0
 800cc44:	2b00      	cmp	r3, #0
 800cc46:	d11e      	bne.n	800cc86 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 800cc48:	2301      	movs	r3, #1
 800cc4a:	e067      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800cc4c:	687b      	ldr	r3, [r7, #4]
 800cc4e:	685b      	ldr	r3, [r3, #4]
 800cc50:	2b03      	cmp	r3, #3
 800cc52:	d106      	bne.n	800cc62 <HAL_RCC_ClockConfig+0x1b6>
    {
      /* Check the PLL ready flag */
      if (LL_RCC_PLL_IsReady() == 0U)
 800cc54:	f7ff fb17 	bl	800c286 <LL_RCC_PLL_IsReady>
 800cc58:	4603      	mov	r3, r0
 800cc5a:	2b00      	cmp	r3, #0
 800cc5c:	d113      	bne.n	800cc86 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 800cc5e:	2301      	movs	r3, #1
 800cc60:	e05c      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* MSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800cc62:	687b      	ldr	r3, [r7, #4]
 800cc64:	685b      	ldr	r3, [r3, #4]
 800cc66:	2b00      	cmp	r3, #0
 800cc68:	d106      	bne.n	800cc78 <HAL_RCC_ClockConfig+0x1cc>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
 800cc6a:	f7ff f9fc 	bl	800c066 <LL_RCC_MSI_IsReady>
 800cc6e:	4603      	mov	r3, r0
 800cc70:	2b00      	cmp	r3, #0
 800cc72:	d108      	bne.n	800cc86 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 800cc74:	2301      	movs	r3, #1
 800cc76:	e051      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
 800cc78:	f7ff f8a7 	bl	800bdca <LL_RCC_HSI_IsReady>
 800cc7c:	4603      	mov	r3, r0
 800cc7e:	2b00      	cmp	r3, #0
 800cc80:	d101      	bne.n	800cc86 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 800cc82:	2301      	movs	r3, #1
 800cc84:	e04a      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
      }

    }

    /* apply system clock switch */
    LL_RCC_SetSysClkSource(RCC_ClkInitStruct->SYSCLKSource);
 800cc86:	687b      	ldr	r3, [r7, #4]
 800cc88:	685b      	ldr	r3, [r3, #4]
 800cc8a:	4618      	mov	r0, r3
 800cc8c:	f7ff fa3a 	bl	800c104 <LL_RCC_SetSysClkSource>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cc90:	f7fc fc6c 	bl	800956c <HAL_GetTick>
 800cc94:	60f8      	str	r0, [r7, #12]

    /* check system clock source switch status */
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800cc96:	e00a      	b.n	800ccae <HAL_RCC_ClockConfig+0x202>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800cc98:	f7fc fc68 	bl	800956c <HAL_GetTick>
 800cc9c:	4602      	mov	r2, r0
 800cc9e:	68fb      	ldr	r3, [r7, #12]
 800cca0:	1ad3      	subs	r3, r2, r3
 800cca2:	f241 3288 	movw	r2, #5000	; 0x1388
 800cca6:	4293      	cmp	r3, r2
 800cca8:	d901      	bls.n	800ccae <HAL_RCC_ClockConfig+0x202>
      {
        return HAL_TIMEOUT;
 800ccaa:	2303      	movs	r3, #3
 800ccac:	e036      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800ccae:	f7ff fa3d 	bl	800c12c <LL_RCC_GetSysClkSource>
 800ccb2:	4602      	mov	r2, r0
 800ccb4:	687b      	ldr	r3, [r7, #4]
 800ccb6:	685b      	ldr	r3, [r3, #4]
 800ccb8:	009b      	lsls	r3, r3, #2
 800ccba:	429a      	cmp	r2, r3
 800ccbc:	d1ec      	bne.n	800cc98 <HAL_RCC_ClockConfig+0x1ec>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800ccbe:	4b19      	ldr	r3, [pc, #100]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800ccc0:	681b      	ldr	r3, [r3, #0]
 800ccc2:	f003 0307 	and.w	r3, r3, #7
 800ccc6:	683a      	ldr	r2, [r7, #0]
 800ccc8:	429a      	cmp	r2, r3
 800ccca:	d21b      	bcs.n	800cd04 <HAL_RCC_ClockConfig+0x258>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800cccc:	4b15      	ldr	r3, [pc, #84]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800ccce:	681b      	ldr	r3, [r3, #0]
 800ccd0:	f023 0207 	bic.w	r2, r3, #7
 800ccd4:	4913      	ldr	r1, [pc, #76]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800ccd6:	683b      	ldr	r3, [r7, #0]
 800ccd8:	4313      	orrs	r3, r2
 800ccda:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800ccdc:	f7fc fc46 	bl	800956c <HAL_GetTick>
 800cce0:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800cce2:	e008      	b.n	800ccf6 <HAL_RCC_ClockConfig+0x24a>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 800cce4:	f7fc fc42 	bl	800956c <HAL_GetTick>
 800cce8:	4602      	mov	r2, r0
 800ccea:	68fb      	ldr	r3, [r7, #12]
 800ccec:	1ad3      	subs	r3, r2, r3
 800ccee:	2b02      	cmp	r3, #2
 800ccf0:	d901      	bls.n	800ccf6 <HAL_RCC_ClockConfig+0x24a>
      {
        return HAL_TIMEOUT;
 800ccf2:	2303      	movs	r3, #3
 800ccf4:	e012      	b.n	800cd1c <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800ccf6:	4b0b      	ldr	r3, [pc, #44]	; (800cd24 <HAL_RCC_ClockConfig+0x278>)
 800ccf8:	681b      	ldr	r3, [r3, #0]
 800ccfa:	f003 0307 	and.w	r3, r3, #7
 800ccfe:	683a      	ldr	r2, [r7, #0]
 800cd00:	429a      	cmp	r2, r3
 800cd02:	d1ef      	bne.n	800cce4 <HAL_RCC_ClockConfig+0x238>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800cd04:	f000 f87e 	bl	800ce04 <HAL_RCC_GetHCLKFreq>
 800cd08:	4603      	mov	r3, r0
 800cd0a:	4a07      	ldr	r2, [pc, #28]	; (800cd28 <HAL_RCC_ClockConfig+0x27c>)
 800cd0c:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
 800cd0e:	f7fc fc39 	bl	8009584 <HAL_GetTickPrio>
 800cd12:	4603      	mov	r3, r0
 800cd14:	4618      	mov	r0, r3
 800cd16:	f7fc fbdb 	bl	80094d0 <HAL_InitTick>
 800cd1a:	4603      	mov	r3, r0
}
 800cd1c:	4618      	mov	r0, r3
 800cd1e:	3710      	adds	r7, #16
 800cd20:	46bd      	mov	sp, r7
 800cd22:	bd80      	pop	{r7, pc}
 800cd24:	58004000 	.word	0x58004000
 800cd28:	20000018 	.word	0x20000018

0800cd2c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800cd2c:	b590      	push	{r4, r7, lr}
 800cd2e:	b085      	sub	sp, #20
 800cd30:	af00      	add	r7, sp, #0
  uint32_t pllsource;
  uint32_t sysclockfreq;
  uint32_t pllinputfreq;
  const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800cd32:	f7ff f9fb 	bl	800c12c <LL_RCC_GetSysClkSource>
 800cd36:	6078      	str	r0, [r7, #4]

  if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI)
 800cd38:	687b      	ldr	r3, [r7, #4]
 800cd3a:	2b00      	cmp	r3, #0
 800cd3c:	d10a      	bne.n	800cd54 <HAL_RCC_GetSysClockFreq+0x28>
  {
    /* Retrieve MSI frequency range in HZ*/
    /* MSI used as system clock source */
    sysclockfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 800cd3e:	f7ff f9b7 	bl	800c0b0 <LL_RCC_MSI_GetRange>
 800cd42:	4603      	mov	r3, r0
 800cd44:	091b      	lsrs	r3, r3, #4
 800cd46:	f003 030f 	and.w	r3, r3, #15
 800cd4a:	4a2b      	ldr	r2, [pc, #172]	; (800cdf8 <HAL_RCC_GetSysClockFreq+0xcc>)
 800cd4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cd50:	60fb      	str	r3, [r7, #12]
 800cd52:	e04b      	b.n	800cdec <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
 800cd54:	687b      	ldr	r3, [r7, #4]
 800cd56:	2b04      	cmp	r3, #4
 800cd58:	d102      	bne.n	800cd60 <HAL_RCC_GetSysClockFreq+0x34>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 800cd5a:	4b28      	ldr	r3, [pc, #160]	; (800cdfc <HAL_RCC_GetSysClockFreq+0xd0>)
 800cd5c:	60fb      	str	r3, [r7, #12]
 800cd5e:	e045      	b.n	800cdec <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE)
 800cd60:	687b      	ldr	r3, [r7, #4]
 800cd62:	2b08      	cmp	r3, #8
 800cd64:	d10a      	bne.n	800cd7c <HAL_RCC_GetSysClockFreq+0x50>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 800cd66:	f7fe ffd0 	bl	800bd0a <LL_RCC_HSE_IsEnabledDiv2>
 800cd6a:	4603      	mov	r3, r0
 800cd6c:	2b01      	cmp	r3, #1
 800cd6e:	d102      	bne.n	800cd76 <HAL_RCC_GetSysClockFreq+0x4a>
    {
      sysclockfreq = HSE_VALUE / 2U;
 800cd70:	4b22      	ldr	r3, [pc, #136]	; (800cdfc <HAL_RCC_GetSysClockFreq+0xd0>)
 800cd72:	60fb      	str	r3, [r7, #12]
 800cd74:	e03a      	b.n	800cdec <HAL_RCC_GetSysClockFreq+0xc0>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 800cd76:	4b22      	ldr	r3, [pc, #136]	; (800ce00 <HAL_RCC_GetSysClockFreq+0xd4>)
 800cd78:	60fb      	str	r3, [r7, #12]
 800cd7a:	e037      	b.n	800cdec <HAL_RCC_GetSysClockFreq+0xc0>
    }
  }
  else
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 800cd7c:	f7ff faba 	bl	800c2f4 <LL_RCC_PLL_GetMainSource>
 800cd80:	6038      	str	r0, [r7, #0]
    switch (pllsource)
 800cd82:	683b      	ldr	r3, [r7, #0]
 800cd84:	2b02      	cmp	r3, #2
 800cd86:	d003      	beq.n	800cd90 <HAL_RCC_GetSysClockFreq+0x64>
 800cd88:	683b      	ldr	r3, [r7, #0]
 800cd8a:	2b03      	cmp	r3, #3
 800cd8c:	d003      	beq.n	800cd96 <HAL_RCC_GetSysClockFreq+0x6a>
 800cd8e:	e00d      	b.n	800cdac <HAL_RCC_GetSysClockFreq+0x80>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 800cd90:	4b1a      	ldr	r3, [pc, #104]	; (800cdfc <HAL_RCC_GetSysClockFreq+0xd0>)
 800cd92:	60bb      	str	r3, [r7, #8]
        break;
 800cd94:	e015      	b.n	800cdc2 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 800cd96:	f7fe ffb8 	bl	800bd0a <LL_RCC_HSE_IsEnabledDiv2>
 800cd9a:	4603      	mov	r3, r0
 800cd9c:	2b01      	cmp	r3, #1
 800cd9e:	d102      	bne.n	800cda6 <HAL_RCC_GetSysClockFreq+0x7a>
        {
          pllinputfreq = HSE_VALUE / 2U;
 800cda0:	4b16      	ldr	r3, [pc, #88]	; (800cdfc <HAL_RCC_GetSysClockFreq+0xd0>)
 800cda2:	60bb      	str	r3, [r7, #8]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 800cda4:	e00d      	b.n	800cdc2 <HAL_RCC_GetSysClockFreq+0x96>
          pllinputfreq = HSE_VALUE;
 800cda6:	4b16      	ldr	r3, [pc, #88]	; (800ce00 <HAL_RCC_GetSysClockFreq+0xd4>)
 800cda8:	60bb      	str	r3, [r7, #8]
        break;
 800cdaa:	e00a      	b.n	800cdc2 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 800cdac:	f7ff f980 	bl	800c0b0 <LL_RCC_MSI_GetRange>
 800cdb0:	4603      	mov	r3, r0
 800cdb2:	091b      	lsrs	r3, r3, #4
 800cdb4:	f003 030f 	and.w	r3, r3, #15
 800cdb8:	4a0f      	ldr	r2, [pc, #60]	; (800cdf8 <HAL_RCC_GetSysClockFreq+0xcc>)
 800cdba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800cdbe:	60bb      	str	r3, [r7, #8]
        break;
 800cdc0:	bf00      	nop
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(), LL_RCC_PLL_GetN(),
 800cdc2:	f7ff fa72 	bl	800c2aa <LL_RCC_PLL_GetN>
 800cdc6:	4602      	mov	r2, r0
 800cdc8:	68bb      	ldr	r3, [r7, #8]
 800cdca:	fb03 f402 	mul.w	r4, r3, r2
 800cdce:	f7ff fa85 	bl	800c2dc <LL_RCC_PLL_GetDivider>
 800cdd2:	4603      	mov	r3, r0
 800cdd4:	091b      	lsrs	r3, r3, #4
 800cdd6:	3301      	adds	r3, #1
 800cdd8:	fbb4 f4f3 	udiv	r4, r4, r3
 800cddc:	f7ff fa72 	bl	800c2c4 <LL_RCC_PLL_GetR>
 800cde0:	4603      	mov	r3, r0
 800cde2:	0f5b      	lsrs	r3, r3, #29
 800cde4:	3301      	adds	r3, #1
 800cde6:	fbb4 f3f3 	udiv	r3, r4, r3
 800cdea:	60fb      	str	r3, [r7, #12]
                                             LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
 800cdec:	68fb      	ldr	r3, [r7, #12]
}
 800cdee:	4618      	mov	r0, r3
 800cdf0:	3714      	adds	r7, #20
 800cdf2:	46bd      	mov	sp, r7
 800cdf4:	bd90      	pop	{r4, r7, pc}
 800cdf6:	bf00      	nop
 800cdf8:	08019a48 	.word	0x08019a48
 800cdfc:	00f42400 	.word	0x00f42400
 800ce00:	01e84800 	.word	0x01e84800

0800ce04 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800ce04:	b598      	push	{r3, r4, r7, lr}
 800ce06:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK1 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800ce08:	f7ff ff90 	bl	800cd2c <HAL_RCC_GetSysClockFreq>
 800ce0c:	4604      	mov	r4, r0
 800ce0e:	f7ff fa02 	bl	800c216 <LL_RCC_GetAHBPrescaler>
 800ce12:	4603      	mov	r3, r0
 800ce14:	091b      	lsrs	r3, r3, #4
 800ce16:	f003 030f 	and.w	r3, r3, #15
 800ce1a:	4a03      	ldr	r2, [pc, #12]	; (800ce28 <HAL_RCC_GetHCLKFreq+0x24>)
 800ce1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ce20:	fbb4 f3f3 	udiv	r3, r4, r3
}
 800ce24:	4618      	mov	r0, r3
 800ce26:	bd98      	pop	{r3, r4, r7, pc}
 800ce28:	08019a08 	.word	0x08019a08

0800ce2c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 800ce2c:	b590      	push	{r4, r7, lr}
 800ce2e:	b085      	sub	sp, #20
 800ce30:	af00      	add	r7, sp, #0
 800ce32:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_MSI_CLOCK_RANGE(MSI_Range));

  /* MSI frequency range in Hz */
  if (MSI_Range > RCC_MSIRANGE_11)
 800ce34:	687b      	ldr	r3, [r7, #4]
 800ce36:	2bb0      	cmp	r3, #176	; 0xb0
 800ce38:	d903      	bls.n	800ce42 <RCC_SetFlashLatencyFromMSIRange+0x16>
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(RCC_MSIRANGE_11);
 800ce3a:	4b15      	ldr	r3, [pc, #84]	; (800ce90 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 800ce3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ce3e:	60fb      	str	r3, [r7, #12]
 800ce40:	e007      	b.n	800ce52 <RCC_SetFlashLatencyFromMSIRange+0x26>
  }
  else
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(MSI_Range);
 800ce42:	687b      	ldr	r3, [r7, #4]
 800ce44:	091b      	lsrs	r3, r3, #4
 800ce46:	f003 030f 	and.w	r3, r3, #15
 800ce4a:	4a11      	ldr	r2, [pc, #68]	; (800ce90 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 800ce4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ce50:	60fb      	str	r3, [r7, #12]
  }

  flash_clksrcfreq = __LL_RCC_CALC_HCLK4_FREQ(msifreq, LL_RCC_GetAHB4Prescaler());
 800ce52:	f7ff f9ec 	bl	800c22e <LL_RCC_GetAHB4Prescaler>
 800ce56:	4603      	mov	r3, r0
 800ce58:	091b      	lsrs	r3, r3, #4
 800ce5a:	f003 030f 	and.w	r3, r3, #15
 800ce5e:	4a0d      	ldr	r2, [pc, #52]	; (800ce94 <RCC_SetFlashLatencyFromMSIRange+0x68>)
 800ce60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ce64:	68fa      	ldr	r2, [r7, #12]
 800ce66:	fbb2 f3f3 	udiv	r3, r2, r3
 800ce6a:	60bb      	str	r3, [r7, #8]

#if defined(PWR_CR1_VOS)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 800ce6c:	68bb      	ldr	r3, [r7, #8]
 800ce6e:	4a0a      	ldr	r2, [pc, #40]	; (800ce98 <RCC_SetFlashLatencyFromMSIRange+0x6c>)
 800ce70:	fba2 2303 	umull	r2, r3, r2, r3
 800ce74:	0c9c      	lsrs	r4, r3, #18
 800ce76:	f7fe fef3 	bl	800bc60 <HAL_PWREx_GetVoltageRange>
 800ce7a:	4603      	mov	r3, r0
 800ce7c:	4619      	mov	r1, r3
 800ce7e:	4620      	mov	r0, r4
 800ce80:	f000 f80c 	bl	800ce9c <RCC_SetFlashLatency>
 800ce84:	4603      	mov	r3, r0
#else
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), PWR_REGULATOR_VOLTAGE_SCALE1);
#endif /* PWR_CR1_VOS */
}
 800ce86:	4618      	mov	r0, r3
 800ce88:	3714      	adds	r7, #20
 800ce8a:	46bd      	mov	sp, r7
 800ce8c:	bd90      	pop	{r4, r7, pc}
 800ce8e:	bf00      	nop
 800ce90:	08019a48 	.word	0x08019a48
 800ce94:	08019a08 	.word	0x08019a08
 800ce98:	431bde83 	.word	0x431bde83

0800ce9c <RCC_SetFlashLatency>:
  * @param  Flash_ClkSrcFreq  Flash Clock Source (in MHz)
  * @param  VCORE_Voltage     Current Vcore voltage (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 800ce9c:	b590      	push	{r4, r7, lr}
 800ce9e:	b093      	sub	sp, #76	; 0x4c
 800cea0:	af00      	add	r7, sp, #0
 800cea2:	6078      	str	r0, [r7, #4]
 800cea4:	6039      	str	r1, [r7, #0]
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range1 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS1[] = {18UL, 36UL, 54UL, 64UL};
 800cea6:	4b37      	ldr	r3, [pc, #220]	; (800cf84 <RCC_SetFlashLatency+0xe8>)
 800cea8:	f107 0428 	add.w	r4, r7, #40	; 0x28
 800ceac:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800ceae:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
#if defined(PWR_CR1_VOS)
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range2 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS2[] = {6UL, 12UL, 16UL};
 800ceb2:	4a35      	ldr	r2, [pc, #212]	; (800cf88 <RCC_SetFlashLatency+0xec>)
 800ceb4:	f107 031c 	add.w	r3, r7, #28
 800ceb8:	ca07      	ldmia	r2, {r0, r1, r2}
 800ceba:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#endif /* PWR_CR1_VOS */
  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2, FLASH_LATENCY_3};
 800cebe:	4b33      	ldr	r3, [pc, #204]	; (800cf8c <RCC_SetFlashLatency+0xf0>)
 800cec0:	f107 040c 	add.w	r4, r7, #12
 800cec4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cec6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 800ceca:	2300      	movs	r3, #0
 800cecc:	647b      	str	r3, [r7, #68]	; 0x44
  uint32_t tickstart;

#if defined(PWR_CR1_VOS)
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 800cece:	683b      	ldr	r3, [r7, #0]
 800ced0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ced4:	d11a      	bne.n	800cf0c <RCC_SetFlashLatency+0x70>
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 800ced6:	2300      	movs	r3, #0
 800ced8:	643b      	str	r3, [r7, #64]	; 0x40
 800ceda:	e013      	b.n	800cf04 <RCC_SetFlashLatency+0x68>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 800cedc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cede:	009b      	lsls	r3, r3, #2
 800cee0:	3348      	adds	r3, #72	; 0x48
 800cee2:	443b      	add	r3, r7
 800cee4:	f853 3c20 	ldr.w	r3, [r3, #-32]
 800cee8:	687a      	ldr	r2, [r7, #4]
 800ceea:	429a      	cmp	r2, r3
 800ceec:	d807      	bhi.n	800cefe <RCC_SetFlashLatency+0x62>
      {
        latency = FLASH_LATENCY_RANGE[index];
 800ceee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cef0:	009b      	lsls	r3, r3, #2
 800cef2:	3348      	adds	r3, #72	; 0x48
 800cef4:	443b      	add	r3, r7
 800cef6:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 800cefa:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 800cefc:	e020      	b.n	800cf40 <RCC_SetFlashLatency+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 800cefe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cf00:	3301      	adds	r3, #1
 800cf02:	643b      	str	r3, [r7, #64]	; 0x40
 800cf04:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cf06:	2b03      	cmp	r3, #3
 800cf08:	d9e8      	bls.n	800cedc <RCC_SetFlashLatency+0x40>
 800cf0a:	e019      	b.n	800cf40 <RCC_SetFlashLatency+0xa4>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800cf0c:	2300      	movs	r3, #0
 800cf0e:	63fb      	str	r3, [r7, #60]	; 0x3c
 800cf10:	e013      	b.n	800cf3a <RCC_SetFlashLatency+0x9e>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 800cf12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800cf14:	009b      	lsls	r3, r3, #2
 800cf16:	3348      	adds	r3, #72	; 0x48
 800cf18:	443b      	add	r3, r7
 800cf1a:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 800cf1e:	687a      	ldr	r2, [r7, #4]
 800cf20:	429a      	cmp	r2, r3
 800cf22:	d807      	bhi.n	800cf34 <RCC_SetFlashLatency+0x98>
      {
        latency = FLASH_LATENCY_RANGE[index];
 800cf24:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800cf26:	009b      	lsls	r3, r3, #2
 800cf28:	3348      	adds	r3, #72	; 0x48
 800cf2a:	443b      	add	r3, r7
 800cf2c:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 800cf30:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 800cf32:	e005      	b.n	800cf40 <RCC_SetFlashLatency+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800cf34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800cf36:	3301      	adds	r3, #1
 800cf38:	63fb      	str	r3, [r7, #60]	; 0x3c
 800cf3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800cf3c:	2b02      	cmp	r3, #2
 800cf3e:	d9e8      	bls.n	800cf12 <RCC_SetFlashLatency+0x76>
      break;
    }
  }
#endif /* PWR_CR1_VOS */

  __HAL_FLASH_SET_LATENCY(latency);
 800cf40:	4b13      	ldr	r3, [pc, #76]	; (800cf90 <RCC_SetFlashLatency+0xf4>)
 800cf42:	681b      	ldr	r3, [r3, #0]
 800cf44:	f023 0207 	bic.w	r2, r3, #7
 800cf48:	4911      	ldr	r1, [pc, #68]	; (800cf90 <RCC_SetFlashLatency+0xf4>)
 800cf4a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800cf4c:	4313      	orrs	r3, r2
 800cf4e:	600b      	str	r3, [r1, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800cf50:	f7fc fb0c 	bl	800956c <HAL_GetTick>
 800cf54:	63b8      	str	r0, [r7, #56]	; 0x38

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800cf56:	e008      	b.n	800cf6a <RCC_SetFlashLatency+0xce>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 800cf58:	f7fc fb08 	bl	800956c <HAL_GetTick>
 800cf5c:	4602      	mov	r2, r0
 800cf5e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cf60:	1ad3      	subs	r3, r2, r3
 800cf62:	2b02      	cmp	r3, #2
 800cf64:	d901      	bls.n	800cf6a <RCC_SetFlashLatency+0xce>
    {
      return HAL_TIMEOUT;
 800cf66:	2303      	movs	r3, #3
 800cf68:	e007      	b.n	800cf7a <RCC_SetFlashLatency+0xde>
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800cf6a:	4b09      	ldr	r3, [pc, #36]	; (800cf90 <RCC_SetFlashLatency+0xf4>)
 800cf6c:	681b      	ldr	r3, [r3, #0]
 800cf6e:	f003 0307 	and.w	r3, r3, #7
 800cf72:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800cf74:	429a      	cmp	r2, r3
 800cf76:	d1ef      	bne.n	800cf58 <RCC_SetFlashLatency+0xbc>
    }
  }
  return HAL_OK;
 800cf78:	2300      	movs	r3, #0
}
 800cf7a:	4618      	mov	r0, r3
 800cf7c:	374c      	adds	r7, #76	; 0x4c
 800cf7e:	46bd      	mov	sp, r7
 800cf80:	bd90      	pop	{r4, r7, pc}
 800cf82:	bf00      	nop
 800cf84:	080197c8 	.word	0x080197c8
 800cf88:	080197d8 	.word	0x080197d8
 800cf8c:	080197e4 	.word	0x080197e4
 800cf90:	58004000 	.word	0x58004000

0800cf94 <LL_RCC_LSE_IsEnabled>:
{
 800cf94:	b480      	push	{r7}
 800cf96:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == (RCC_BDCR_LSEON)) ? 1UL : 0UL);
 800cf98:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cf9c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800cfa0:	f003 0301 	and.w	r3, r3, #1
 800cfa4:	2b01      	cmp	r3, #1
 800cfa6:	d101      	bne.n	800cfac <LL_RCC_LSE_IsEnabled+0x18>
 800cfa8:	2301      	movs	r3, #1
 800cfaa:	e000      	b.n	800cfae <LL_RCC_LSE_IsEnabled+0x1a>
 800cfac:	2300      	movs	r3, #0
}
 800cfae:	4618      	mov	r0, r3
 800cfb0:	46bd      	mov	sp, r7
 800cfb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfb6:	4770      	bx	lr

0800cfb8 <LL_RCC_LSE_IsReady>:
{
 800cfb8:	b480      	push	{r7}
 800cfba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 800cfbc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cfc0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800cfc4:	f003 0302 	and.w	r3, r3, #2
 800cfc8:	2b02      	cmp	r3, #2
 800cfca:	d101      	bne.n	800cfd0 <LL_RCC_LSE_IsReady+0x18>
 800cfcc:	2301      	movs	r3, #1
 800cfce:	e000      	b.n	800cfd2 <LL_RCC_LSE_IsReady+0x1a>
 800cfd0:	2300      	movs	r3, #0
}
 800cfd2:	4618      	mov	r0, r3
 800cfd4:	46bd      	mov	sp, r7
 800cfd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfda:	4770      	bx	lr

0800cfdc <LL_RCC_SetRFWKPClockSource>:
{
 800cfdc:	b480      	push	{r7}
 800cfde:	b083      	sub	sp, #12
 800cfe0:	af00      	add	r7, sp, #0
 800cfe2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_RFWKPSEL, Source);
 800cfe4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cfe8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800cfec:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 800cff0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800cff4:	687b      	ldr	r3, [r7, #4]
 800cff6:	4313      	orrs	r3, r2
 800cff8:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 800cffc:	bf00      	nop
 800cffe:	370c      	adds	r7, #12
 800d000:	46bd      	mov	sp, r7
 800d002:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d006:	4770      	bx	lr

0800d008 <LL_RCC_SetSMPSClockSource>:
{
 800d008:	b480      	push	{r7}
 800d00a:	b083      	sub	sp, #12
 800d00c:	af00      	add	r7, sp, #0
 800d00e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSSEL, SMPSSource);
 800d010:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d014:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d016:	f023 0203 	bic.w	r2, r3, #3
 800d01a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d01e:	687b      	ldr	r3, [r7, #4]
 800d020:	4313      	orrs	r3, r2
 800d022:	624b      	str	r3, [r1, #36]	; 0x24
}
 800d024:	bf00      	nop
 800d026:	370c      	adds	r7, #12
 800d028:	46bd      	mov	sp, r7
 800d02a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d02e:	4770      	bx	lr

0800d030 <LL_RCC_SetSMPSPrescaler>:
{
 800d030:	b480      	push	{r7}
 800d032:	b083      	sub	sp, #12
 800d034:	af00      	add	r7, sp, #0
 800d036:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSDIV, Prescaler);
 800d038:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d03c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d03e:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 800d042:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d046:	687b      	ldr	r3, [r7, #4]
 800d048:	4313      	orrs	r3, r2
 800d04a:	624b      	str	r3, [r1, #36]	; 0x24
}
 800d04c:	bf00      	nop
 800d04e:	370c      	adds	r7, #12
 800d050:	46bd      	mov	sp, r7
 800d052:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d056:	4770      	bx	lr

0800d058 <LL_RCC_SetUSARTClockSource>:
{
 800d058:	b480      	push	{r7}
 800d05a:	b083      	sub	sp, #12
 800d05c:	af00      	add	r7, sp, #0
 800d05e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART1SEL, USARTxSource);
 800d060:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d064:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d068:	f023 0203 	bic.w	r2, r3, #3
 800d06c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d070:	687b      	ldr	r3, [r7, #4]
 800d072:	4313      	orrs	r3, r2
 800d074:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d078:	bf00      	nop
 800d07a:	370c      	adds	r7, #12
 800d07c:	46bd      	mov	sp, r7
 800d07e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d082:	4770      	bx	lr

0800d084 <LL_RCC_SetLPUARTClockSource>:
{
 800d084:	b480      	push	{r7}
 800d086:	b083      	sub	sp, #12
 800d088:	af00      	add	r7, sp, #0
 800d08a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 800d08c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d090:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d094:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 800d098:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d09c:	687b      	ldr	r3, [r7, #4]
 800d09e:	4313      	orrs	r3, r2
 800d0a0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d0a4:	bf00      	nop
 800d0a6:	370c      	adds	r7, #12
 800d0a8:	46bd      	mov	sp, r7
 800d0aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0ae:	4770      	bx	lr

0800d0b0 <LL_RCC_SetI2CClockSource>:
{
 800d0b0:	b480      	push	{r7}
 800d0b2:	b083      	sub	sp, #12
 800d0b4:	af00      	add	r7, sp, #0
 800d0b6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 800d0b8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d0bc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800d0c0:	687b      	ldr	r3, [r7, #4]
 800d0c2:	091b      	lsrs	r3, r3, #4
 800d0c4:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 800d0c8:	43db      	mvns	r3, r3
 800d0ca:	401a      	ands	r2, r3
 800d0cc:	687b      	ldr	r3, [r7, #4]
 800d0ce:	011b      	lsls	r3, r3, #4
 800d0d0:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 800d0d4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d0d8:	4313      	orrs	r3, r2
 800d0da:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d0de:	bf00      	nop
 800d0e0:	370c      	adds	r7, #12
 800d0e2:	46bd      	mov	sp, r7
 800d0e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0e8:	4770      	bx	lr

0800d0ea <LL_RCC_SetLPTIMClockSource>:
{
 800d0ea:	b480      	push	{r7}
 800d0ec:	b083      	sub	sp, #12
 800d0ee:	af00      	add	r7, sp, #0
 800d0f0:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 800d0f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d0f6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800d0fa:	687b      	ldr	r3, [r7, #4]
 800d0fc:	0c1b      	lsrs	r3, r3, #16
 800d0fe:	041b      	lsls	r3, r3, #16
 800d100:	43db      	mvns	r3, r3
 800d102:	401a      	ands	r2, r3
 800d104:	687b      	ldr	r3, [r7, #4]
 800d106:	041b      	lsls	r3, r3, #16
 800d108:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d10c:	4313      	orrs	r3, r2
 800d10e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d112:	bf00      	nop
 800d114:	370c      	adds	r7, #12
 800d116:	46bd      	mov	sp, r7
 800d118:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d11c:	4770      	bx	lr

0800d11e <LL_RCC_SetSAIClockSource>:
{
 800d11e:	b480      	push	{r7}
 800d120:	b083      	sub	sp, #12
 800d122:	af00      	add	r7, sp, #0
 800d124:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SAI1SEL, SAIxSource);
 800d126:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d12a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d12e:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 800d132:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d136:	687b      	ldr	r3, [r7, #4]
 800d138:	4313      	orrs	r3, r2
 800d13a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d13e:	bf00      	nop
 800d140:	370c      	adds	r7, #12
 800d142:	46bd      	mov	sp, r7
 800d144:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d148:	4770      	bx	lr

0800d14a <LL_RCC_SetRNGClockSource>:
{
 800d14a:	b480      	push	{r7}
 800d14c:	b083      	sub	sp, #12
 800d14e:	af00      	add	r7, sp, #0
 800d150:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 800d152:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d156:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d15a:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
 800d15e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d162:	687b      	ldr	r3, [r7, #4]
 800d164:	4313      	orrs	r3, r2
 800d166:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d16a:	bf00      	nop
 800d16c:	370c      	adds	r7, #12
 800d16e:	46bd      	mov	sp, r7
 800d170:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d174:	4770      	bx	lr

0800d176 <LL_RCC_SetCLK48ClockSource>:
{
 800d176:	b480      	push	{r7}
 800d178:	b083      	sub	sp, #12
 800d17a:	af00      	add	r7, sp, #0
 800d17c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, CLK48xSource);
 800d17e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d182:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d186:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 800d18a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d18e:	687b      	ldr	r3, [r7, #4]
 800d190:	4313      	orrs	r3, r2
 800d192:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d196:	bf00      	nop
 800d198:	370c      	adds	r7, #12
 800d19a:	46bd      	mov	sp, r7
 800d19c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1a0:	4770      	bx	lr

0800d1a2 <LL_RCC_SetUSBClockSource>:
{
 800d1a2:	b580      	push	{r7, lr}
 800d1a4:	b082      	sub	sp, #8
 800d1a6:	af00      	add	r7, sp, #0
 800d1a8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetCLK48ClockSource(USBxSource);
 800d1aa:	6878      	ldr	r0, [r7, #4]
 800d1ac:	f7ff ffe3 	bl	800d176 <LL_RCC_SetCLK48ClockSource>
}
 800d1b0:	bf00      	nop
 800d1b2:	3708      	adds	r7, #8
 800d1b4:	46bd      	mov	sp, r7
 800d1b6:	bd80      	pop	{r7, pc}

0800d1b8 <LL_RCC_SetADCClockSource>:
{
 800d1b8:	b480      	push	{r7}
 800d1ba:	b083      	sub	sp, #12
 800d1bc:	af00      	add	r7, sp, #0
 800d1be:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 800d1c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1c4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d1c8:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 800d1cc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d1d0:	687b      	ldr	r3, [r7, #4]
 800d1d2:	4313      	orrs	r3, r2
 800d1d4:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800d1d8:	bf00      	nop
 800d1da:	370c      	adds	r7, #12
 800d1dc:	46bd      	mov	sp, r7
 800d1de:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1e2:	4770      	bx	lr

0800d1e4 <LL_RCC_SetRTCClockSource>:
{
 800d1e4:	b480      	push	{r7}
 800d1e6:	b083      	sub	sp, #12
 800d1e8:	af00      	add	r7, sp, #0
 800d1ea:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 800d1ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1f0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800d1f4:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800d1f8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d1fc:	687b      	ldr	r3, [r7, #4]
 800d1fe:	4313      	orrs	r3, r2
 800d200:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 800d204:	bf00      	nop
 800d206:	370c      	adds	r7, #12
 800d208:	46bd      	mov	sp, r7
 800d20a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d20e:	4770      	bx	lr

0800d210 <LL_RCC_GetRTCClockSource>:
{
 800d210:	b480      	push	{r7}
 800d212:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 800d214:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d218:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800d21c:	f403 7340 	and.w	r3, r3, #768	; 0x300
}
 800d220:	4618      	mov	r0, r3
 800d222:	46bd      	mov	sp, r7
 800d224:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d228:	4770      	bx	lr

0800d22a <LL_RCC_ForceBackupDomainReset>:
{
 800d22a:	b480      	push	{r7}
 800d22c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 800d22e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d232:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800d236:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d23a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d23e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800d242:	bf00      	nop
 800d244:	46bd      	mov	sp, r7
 800d246:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d24a:	4770      	bx	lr

0800d24c <LL_RCC_ReleaseBackupDomainReset>:
{
 800d24c:	b480      	push	{r7}
 800d24e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 800d250:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d254:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800d258:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d25c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800d260:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800d264:	bf00      	nop
 800d266:	46bd      	mov	sp, r7
 800d268:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d26c:	4770      	bx	lr

0800d26e <LL_RCC_PLLSAI1_Enable>:
{
 800d26e:	b480      	push	{r7}
 800d270:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 800d272:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d276:	681b      	ldr	r3, [r3, #0]
 800d278:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d27c:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800d280:	6013      	str	r3, [r2, #0]
}
 800d282:	bf00      	nop
 800d284:	46bd      	mov	sp, r7
 800d286:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d28a:	4770      	bx	lr

0800d28c <LL_RCC_PLLSAI1_Disable>:
{
 800d28c:	b480      	push	{r7}
 800d28e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 800d290:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d294:	681b      	ldr	r3, [r3, #0]
 800d296:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d29a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800d29e:	6013      	str	r3, [r2, #0]
}
 800d2a0:	bf00      	nop
 800d2a2:	46bd      	mov	sp, r7
 800d2a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2a8:	4770      	bx	lr

0800d2aa <LL_RCC_PLLSAI1_IsReady>:
{
 800d2aa:	b480      	push	{r7}
 800d2ac:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 800d2ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d2b2:	681b      	ldr	r3, [r3, #0]
 800d2b4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800d2b8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800d2bc:	d101      	bne.n	800d2c2 <LL_RCC_PLLSAI1_IsReady+0x18>
 800d2be:	2301      	movs	r3, #1
 800d2c0:	e000      	b.n	800d2c4 <LL_RCC_PLLSAI1_IsReady+0x1a>
 800d2c2:	2300      	movs	r3, #0
}
 800d2c4:	4618      	mov	r0, r3
 800d2c6:	46bd      	mov	sp, r7
 800d2c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2cc:	4770      	bx	lr

0800d2ce <LL_APB1_GRP1_ForceReset>:
{
 800d2ce:	b480      	push	{r7}
 800d2d0:	b083      	sub	sp, #12
 800d2d2:	af00      	add	r7, sp, #0
 800d2d4:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1RSTR1, Periphs);
 800d2d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d2da:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d2dc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d2e0:	687b      	ldr	r3, [r7, #4]
 800d2e2:	4313      	orrs	r3, r2
 800d2e4:	638b      	str	r3, [r1, #56]	; 0x38
}
 800d2e6:	bf00      	nop
 800d2e8:	370c      	adds	r7, #12
 800d2ea:	46bd      	mov	sp, r7
 800d2ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2f0:	4770      	bx	lr

0800d2f2 <LL_APB1_GRP1_ReleaseReset>:
{
 800d2f2:	b480      	push	{r7}
 800d2f4:	b083      	sub	sp, #12
 800d2f6:	af00      	add	r7, sp, #0
 800d2f8:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 800d2fa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d2fe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d300:	687b      	ldr	r3, [r7, #4]
 800d302:	43db      	mvns	r3, r3
 800d304:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d308:	4013      	ands	r3, r2
 800d30a:	638b      	str	r3, [r1, #56]	; 0x38
}
 800d30c:	bf00      	nop
 800d30e:	370c      	adds	r7, #12
 800d310:	46bd      	mov	sp, r7
 800d312:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d316:	4770      	bx	lr

0800d318 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800d318:	b580      	push	{r7, lr}
 800d31a:	b088      	sub	sp, #32
 800d31c:	af00      	add	r7, sp, #0
 800d31e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 800d320:	2300      	movs	r3, #0
 800d322:	77fb      	strb	r3, [r7, #31]
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 800d324:	2300      	movs	r3, #0
 800d326:	77bb      	strb	r3, [r7, #30]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 800d328:	687b      	ldr	r3, [r7, #4]
 800d32a:	681b      	ldr	r3, [r3, #0]
 800d32c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800d330:	2b00      	cmp	r3, #0
 800d332:	d034      	beq.n	800d39e <HAL_RCCEx_PeriphCLKConfig+0x86>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
 800d334:	687b      	ldr	r3, [r7, #4]
 800d336:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d338:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 800d33c:	d021      	beq.n	800d382 <HAL_RCCEx_PeriphCLKConfig+0x6a>
 800d33e:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 800d342:	d81b      	bhi.n	800d37c <HAL_RCCEx_PeriphCLKConfig+0x64>
 800d344:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800d348:	d01d      	beq.n	800d386 <HAL_RCCEx_PeriphCLKConfig+0x6e>
 800d34a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800d34e:	d815      	bhi.n	800d37c <HAL_RCCEx_PeriphCLKConfig+0x64>
 800d350:	2b00      	cmp	r3, #0
 800d352:	d00b      	beq.n	800d36c <HAL_RCCEx_PeriphCLKConfig+0x54>
 800d354:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800d358:	d110      	bne.n	800d37c <HAL_RCCEx_PeriphCLKConfig+0x64>
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1 */
        /* Enable SAI1 Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI1CLK);
 800d35a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d35e:	68db      	ldr	r3, [r3, #12]
 800d360:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d364:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d368:	60d3      	str	r3, [r2, #12]

        /* SAI1 clock source config set later after clock selection check */
        break;
 800d36a:	e00d      	b.n	800d388 <HAL_RCCEx_PeriphCLKConfig+0x70>

      case RCC_SAI1CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI1 */
        /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 800d36c:	687b      	ldr	r3, [r7, #4]
 800d36e:	3304      	adds	r3, #4
 800d370:	4618      	mov	r0, r3
 800d372:	f000 f981 	bl	800d678 <RCCEx_PLLSAI1_ConfigNP>
 800d376:	4603      	mov	r3, r0
 800d378:	77fb      	strb	r3, [r7, #31]
        /* SAI1 clock source config set later after clock selection check */
        break;
 800d37a:	e005      	b.n	800d388 <HAL_RCCEx_PeriphCLKConfig+0x70>
      case RCC_SAI1CLKSOURCE_HSI:

        break;

      default:
        ret = HAL_ERROR;
 800d37c:	2301      	movs	r3, #1
 800d37e:	77fb      	strb	r3, [r7, #31]
        break;
 800d380:	e002      	b.n	800d388 <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 800d382:	bf00      	nop
 800d384:	e000      	b.n	800d388 <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 800d386:	bf00      	nop
    }

    if (ret == HAL_OK)
 800d388:	7ffb      	ldrb	r3, [r7, #31]
 800d38a:	2b00      	cmp	r3, #0
 800d38c:	d105      	bne.n	800d39a <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800d38e:	687b      	ldr	r3, [r7, #4]
 800d390:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d392:	4618      	mov	r0, r3
 800d394:	f7ff fec3 	bl	800d11e <LL_RCC_SetSAIClockSource>
 800d398:	e001      	b.n	800d39e <HAL_RCCEx_PeriphCLKConfig+0x86>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800d39a:	7ffb      	ldrb	r3, [r7, #31]
 800d39c:	77bb      	strb	r3, [r7, #30]
    }
  }
#endif /* SAI1 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800d39e:	687b      	ldr	r3, [r7, #4]
 800d3a0:	681b      	ldr	r3, [r3, #0]
 800d3a2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800d3a6:	2b00      	cmp	r3, #0
 800d3a8:	d046      	beq.n	800d438 <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    uint32_t rtcclocksource = LL_RCC_GetRTCClockSource();
 800d3aa:	f7ff ff31 	bl	800d210 <LL_RCC_GetRTCClockSource>
 800d3ae:	61b8      	str	r0, [r7, #24]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Configure the clock source only if a different source is expected */
    if (rtcclocksource != PeriphClkInit->RTCClockSelection)
 800d3b0:	687b      	ldr	r3, [r7, #4]
 800d3b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d3b4:	69ba      	ldr	r2, [r7, #24]
 800d3b6:	429a      	cmp	r2, r3
 800d3b8:	d03c      	beq.n	800d434 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 800d3ba:	f7fe fbf9 	bl	800bbb0 <HAL_PWR_EnableBkUpAccess>

      /* If a clock source is not yet selected */
      if (rtcclocksource == RCC_RTCCLKSOURCE_NONE)
 800d3be:	69bb      	ldr	r3, [r7, #24]
 800d3c0:	2b00      	cmp	r3, #0
 800d3c2:	d105      	bne.n	800d3d0 <HAL_RCCEx_PeriphCLKConfig+0xb8>
      {
        /* Directly set the configuration of the clock source selection */
        LL_RCC_SetRTCClockSource(PeriphClkInit->RTCClockSelection);
 800d3c4:	687b      	ldr	r3, [r7, #4]
 800d3c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d3c8:	4618      	mov	r0, r3
 800d3ca:	f7ff ff0b 	bl	800d1e4 <LL_RCC_SetRTCClockSource>
 800d3ce:	e02e      	b.n	800d42e <HAL_RCCEx_PeriphCLKConfig+0x116>
      }
      else /* A clock source is already selected */
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        uint32_t bdcr = LL_RCC_ReadReg(BDCR);
 800d3d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d3d4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800d3d8:	617b      	str	r3, [r7, #20]

        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        LL_RCC_ForceBackupDomainReset();
 800d3da:	f7ff ff26 	bl	800d22a <LL_RCC_ForceBackupDomainReset>
        LL_RCC_ReleaseBackupDomainReset();
 800d3de:	f7ff ff35 	bl	800d24c <LL_RCC_ReleaseBackupDomainReset>

        /* Set the value of the clock source selection */
        MODIFY_REG(bdcr, RCC_BDCR_RTCSEL, PeriphClkInit->RTCClockSelection);
 800d3e2:	697b      	ldr	r3, [r7, #20]
 800d3e4:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800d3e8:	687b      	ldr	r3, [r7, #4]
 800d3ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d3ec:	4313      	orrs	r3, r2
 800d3ee:	617b      	str	r3, [r7, #20]

        /* Restore the content of BDCR register */
        LL_RCC_WriteReg(BDCR, bdcr);
 800d3f0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d3f4:	697b      	ldr	r3, [r7, #20]
 800d3f6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

        /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
        if (LL_RCC_LSE_IsEnabled() == 1U)
 800d3fa:	f7ff fdcb 	bl	800cf94 <LL_RCC_LSE_IsEnabled>
 800d3fe:	4603      	mov	r3, r0
 800d400:	2b01      	cmp	r3, #1
 800d402:	d114      	bne.n	800d42e <HAL_RCCEx_PeriphCLKConfig+0x116>
        {
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 800d404:	f7fc f8b2 	bl	800956c <HAL_GetTick>
 800d408:	6138      	str	r0, [r7, #16]

          /* Wait till LSE is ready */
          while (LL_RCC_LSE_IsReady() != 1U)
 800d40a:	e00b      	b.n	800d424 <HAL_RCCEx_PeriphCLKConfig+0x10c>
          {
            if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800d40c:	f7fc f8ae 	bl	800956c <HAL_GetTick>
 800d410:	4602      	mov	r2, r0
 800d412:	693b      	ldr	r3, [r7, #16]
 800d414:	1ad3      	subs	r3, r2, r3
 800d416:	f241 3288 	movw	r2, #5000	; 0x1388
 800d41a:	4293      	cmp	r3, r2
 800d41c:	d902      	bls.n	800d424 <HAL_RCCEx_PeriphCLKConfig+0x10c>
            {
              ret = HAL_TIMEOUT;
 800d41e:	2303      	movs	r3, #3
 800d420:	77fb      	strb	r3, [r7, #31]
              break;
 800d422:	e004      	b.n	800d42e <HAL_RCCEx_PeriphCLKConfig+0x116>
          while (LL_RCC_LSE_IsReady() != 1U)
 800d424:	f7ff fdc8 	bl	800cfb8 <LL_RCC_LSE_IsReady>
 800d428:	4603      	mov	r3, r0
 800d42a:	2b01      	cmp	r3, #1
 800d42c:	d1ee      	bne.n	800d40c <HAL_RCCEx_PeriphCLKConfig+0xf4>
          }
        }
      }

      /* set overall return value */
      status = ret;
 800d42e:	7ffb      	ldrb	r3, [r7, #31]
 800d430:	77bb      	strb	r3, [r7, #30]
 800d432:	e001      	b.n	800d438 <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800d434:	7ffb      	ldrb	r3, [r7, #31]
 800d436:	77bb      	strb	r3, [r7, #30]
    }

  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800d438:	687b      	ldr	r3, [r7, #4]
 800d43a:	681b      	ldr	r3, [r3, #0]
 800d43c:	f003 0301 	and.w	r3, r3, #1
 800d440:	2b00      	cmp	r3, #0
 800d442:	d004      	beq.n	800d44e <HAL_RCCEx_PeriphCLKConfig+0x136>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800d444:	687b      	ldr	r3, [r7, #4]
 800d446:	699b      	ldr	r3, [r3, #24]
 800d448:	4618      	mov	r0, r3
 800d44a:	f7ff fe05 	bl	800d058 <LL_RCC_SetUSARTClockSource>
  }

#if defined(LPUART1)
  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800d44e:	687b      	ldr	r3, [r7, #4]
 800d450:	681b      	ldr	r3, [r3, #0]
 800d452:	f003 0302 	and.w	r3, r3, #2
 800d456:	2b00      	cmp	r3, #0
 800d458:	d004      	beq.n	800d464 <HAL_RCCEx_PeriphCLKConfig+0x14c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800d45a:	687b      	ldr	r3, [r7, #4]
 800d45c:	69db      	ldr	r3, [r3, #28]
 800d45e:	4618      	mov	r0, r3
 800d460:	f7ff fe10 	bl	800d084 <LL_RCC_SetLPUARTClockSource>
  }
#endif /* LPUART1 */

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800d464:	687b      	ldr	r3, [r7, #4]
 800d466:	681b      	ldr	r3, [r3, #0]
 800d468:	f003 0310 	and.w	r3, r3, #16
 800d46c:	2b00      	cmp	r3, #0
 800d46e:	d004      	beq.n	800d47a <HAL_RCCEx_PeriphCLKConfig+0x162>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800d470:	687b      	ldr	r3, [r7, #4]
 800d472:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d474:	4618      	mov	r0, r3
 800d476:	f7ff fe38 	bl	800d0ea <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 800d47a:	687b      	ldr	r3, [r7, #4]
 800d47c:	681b      	ldr	r3, [r3, #0]
 800d47e:	f003 0320 	and.w	r3, r3, #32
 800d482:	2b00      	cmp	r3, #0
 800d484:	d004      	beq.n	800d490 <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800d486:	687b      	ldr	r3, [r7, #4]
 800d488:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d48a:	4618      	mov	r0, r3
 800d48c:	f7ff fe2d 	bl	800d0ea <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800d490:	687b      	ldr	r3, [r7, #4]
 800d492:	681b      	ldr	r3, [r3, #0]
 800d494:	f003 0304 	and.w	r3, r3, #4
 800d498:	2b00      	cmp	r3, #0
 800d49a:	d004      	beq.n	800d4a6 <HAL_RCCEx_PeriphCLKConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800d49c:	687b      	ldr	r3, [r7, #4]
 800d49e:	6a1b      	ldr	r3, [r3, #32]
 800d4a0:	4618      	mov	r0, r3
 800d4a2:	f7ff fe05 	bl	800d0b0 <LL_RCC_SetI2CClockSource>
  }

#if defined(I2C3)
  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800d4a6:	687b      	ldr	r3, [r7, #4]
 800d4a8:	681b      	ldr	r3, [r3, #0]
 800d4aa:	f003 0308 	and.w	r3, r3, #8
 800d4ae:	2b00      	cmp	r3, #0
 800d4b0:	d004      	beq.n	800d4bc <HAL_RCCEx_PeriphCLKConfig+0x1a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800d4b2:	687b      	ldr	r3, [r7, #4]
 800d4b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d4b6:	4618      	mov	r0, r3
 800d4b8:	f7ff fdfa 	bl	800d0b0 <LL_RCC_SetI2CClockSource>
  }
#endif /* I2C3 */

#if defined(USB)
  /*-------------------------- USB clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800d4bc:	687b      	ldr	r3, [r7, #4]
 800d4be:	681b      	ldr	r3, [r3, #0]
 800d4c0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800d4c4:	2b00      	cmp	r3, #0
 800d4c6:	d022      	beq.n	800d50e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800d4c8:	687b      	ldr	r3, [r7, #4]
 800d4ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d4cc:	4618      	mov	r0, r3
 800d4ce:	f7ff fe68 	bl	800d1a2 <LL_RCC_SetUSBClockSource>

    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800d4d2:	687b      	ldr	r3, [r7, #4]
 800d4d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d4d6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800d4da:	d107      	bne.n	800d4ec <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_USBCLK);
 800d4dc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d4e0:	68db      	ldr	r3, [r3, #12]
 800d4e2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d4e6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800d4ea:	60d3      	str	r3, [r2, #12]
    }
#if defined(SAI1)
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 800d4ec:	687b      	ldr	r3, [r7, #4]
 800d4ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d4f0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800d4f4:	d10b      	bne.n	800d50e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 800d4f6:	687b      	ldr	r3, [r7, #4]
 800d4f8:	3304      	adds	r3, #4
 800d4fa:	4618      	mov	r0, r3
 800d4fc:	f000 f917 	bl	800d72e <RCCEx_PLLSAI1_ConfigNQ>
 800d500:	4603      	mov	r3, r0
 800d502:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 800d504:	7ffb      	ldrb	r3, [r7, #31]
 800d506:	2b00      	cmp	r3, #0
 800d508:	d001      	beq.n	800d50e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
      {
        /* set overall return value */
        status = ret;
 800d50a:	7ffb      	ldrb	r3, [r7, #31]
 800d50c:	77bb      	strb	r3, [r7, #30]
#endif /* SAI1 */
  }
#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 800d50e:	687b      	ldr	r3, [r7, #4]
 800d510:	681b      	ldr	r3, [r3, #0]
 800d512:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800d516:	2b00      	cmp	r3, #0
 800d518:	d02b      	beq.n	800d572 <HAL_RCCEx_PeriphCLKConfig+0x25a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));

    /* Configure the RNG clock source */
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800d51a:	687b      	ldr	r3, [r7, #4]
 800d51c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d51e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800d522:	d008      	beq.n	800d536 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 800d524:	687b      	ldr	r3, [r7, #4]
 800d526:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d528:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800d52c:	d003      	beq.n	800d536 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 800d52e:	687b      	ldr	r3, [r7, #4]
 800d530:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d532:	2b00      	cmp	r3, #0
 800d534:	d105      	bne.n	800d542 <HAL_RCCEx_PeriphCLKConfig+0x22a>
 800d536:	687b      	ldr	r3, [r7, #4]
 800d538:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d53a:	4618      	mov	r0, r3
 800d53c:	f7ff fe05 	bl	800d14a <LL_RCC_SetRNGClockSource>
 800d540:	e00a      	b.n	800d558 <HAL_RCCEx_PeriphCLKConfig+0x240>
 800d542:	687b      	ldr	r3, [r7, #4]
 800d544:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d546:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800d54a:	60fb      	str	r3, [r7, #12]
 800d54c:	2000      	movs	r0, #0
 800d54e:	f7ff fdfc 	bl	800d14a <LL_RCC_SetRNGClockSource>
 800d552:	68f8      	ldr	r0, [r7, #12]
 800d554:	f7ff fe0f 	bl	800d176 <LL_RCC_SetCLK48ClockSource>

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800d558:	687b      	ldr	r3, [r7, #4]
 800d55a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d55c:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
 800d560:	d107      	bne.n	800d572 <HAL_RCCEx_PeriphCLKConfig+0x25a>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 800d562:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d566:	68db      	ldr	r3, [r3, #12]
 800d568:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d56c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800d570:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800d572:	687b      	ldr	r3, [r7, #4]
 800d574:	681b      	ldr	r3, [r3, #0]
 800d576:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800d57a:	2b00      	cmp	r3, #0
 800d57c:	d022      	beq.n	800d5c4 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800d57e:	687b      	ldr	r3, [r7, #4]
 800d580:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d582:	4618      	mov	r0, r3
 800d584:	f7ff fe18 	bl	800d1b8 <LL_RCC_SetADCClockSource>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 800d588:	687b      	ldr	r3, [r7, #4]
 800d58a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d58c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800d590:	d107      	bne.n	800d5a2 <HAL_RCCEx_PeriphCLKConfig+0x28a>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 800d592:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d596:	68db      	ldr	r3, [r3, #12]
 800d598:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d59c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800d5a0:	60d3      	str	r3, [r2, #12]
    }

#if defined(SAI1)
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 800d5a2:	687b      	ldr	r3, [r7, #4]
 800d5a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d5a6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800d5aa:	d10b      	bne.n	800d5c4 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    {
      /* PLLSAI1 parameters N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNR(&(PeriphClkInit->PLLSAI1));
 800d5ac:	687b      	ldr	r3, [r7, #4]
 800d5ae:	3304      	adds	r3, #4
 800d5b0:	4618      	mov	r0, r3
 800d5b2:	f000 f917 	bl	800d7e4 <RCCEx_PLLSAI1_ConfigNR>
 800d5b6:	4603      	mov	r3, r0
 800d5b8:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 800d5ba:	7ffb      	ldrb	r3, [r7, #31]
 800d5bc:	2b00      	cmp	r3, #0
 800d5be:	d001      	beq.n	800d5c4 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
      {
        /* set overall return value */
        status = ret;
 800d5c0:	7ffb      	ldrb	r3, [r7, #31]
 800d5c2:	77bb      	strb	r3, [r7, #30]
    }
#endif /* SAI1 */
  }

  /*-------------------------- RFWKP clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RFWAKEUP) == RCC_PERIPHCLK_RFWAKEUP)
 800d5c4:	687b      	ldr	r3, [r7, #4]
 800d5c6:	681b      	ldr	r3, [r3, #0]
 800d5c8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800d5cc:	2b00      	cmp	r3, #0
 800d5ce:	d004      	beq.n	800d5da <HAL_RCCEx_PeriphCLKConfig+0x2c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RFWKPCLKSOURCE(PeriphClkInit->RFWakeUpClockSelection));

    /* Configure the RFWKP interface clock source */
    __HAL_RCC_RFWAKEUP_CONFIG(PeriphClkInit->RFWakeUpClockSelection);
 800d5d0:	687b      	ldr	r3, [r7, #4]
 800d5d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d5d4:	4618      	mov	r0, r3
 800d5d6:	f7ff fd01 	bl	800cfdc <LL_RCC_SetRFWKPClockSource>

  }

#if defined(RCC_SMPS_SUPPORT)
  /*-------------------------- SMPS clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS)
 800d5da:	687b      	ldr	r3, [r7, #4]
 800d5dc:	681b      	ldr	r3, [r3, #0]
 800d5de:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800d5e2:	2b00      	cmp	r3, #0
 800d5e4:	d009      	beq.n	800d5fa <HAL_RCCEx_PeriphCLKConfig+0x2e2>
    /* Check the parameters */
    assert_param(IS_RCC_SMPSCLKDIV(PeriphClkInit->SmpsDivSelection));
    assert_param(IS_RCC_SMPSCLKSOURCE(PeriphClkInit->SmpsClockSelection));

    /* Configure the SMPS interface clock division factor */
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
 800d5e6:	687b      	ldr	r3, [r7, #4]
 800d5e8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800d5ea:	4618      	mov	r0, r3
 800d5ec:	f7ff fd20 	bl	800d030 <LL_RCC_SetSMPSPrescaler>

    /* Configure the SMPS interface clock source */
    __HAL_RCC_SMPS_CONFIG(PeriphClkInit->SmpsClockSelection);
 800d5f0:	687b      	ldr	r3, [r7, #4]
 800d5f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d5f4:	4618      	mov	r0, r3
 800d5f6:	f7ff fd07 	bl	800d008 <LL_RCC_SetSMPSClockSource>
  }
#endif /* RCC_SMPS_SUPPORT */

  return status;
 800d5fa:	7fbb      	ldrb	r3, [r7, #30]
}
 800d5fc:	4618      	mov	r0, r3
 800d5fe:	3720      	adds	r7, #32
 800d600:	46bd      	mov	sp, r7
 800d602:	bd80      	pop	{r7, pc}

0800d604 <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
 800d604:	b580      	push	{r7, lr}
 800d606:	b084      	sub	sp, #16
 800d608:	af00      	add	r7, sp, #0
 800d60a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
 800d60c:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 800d610:	f7ff fe5d 	bl	800d2ce <LL_APB1_GRP1_ForceReset>
  __HAL_RCC_CRS_RELEASE_RESET();
 800d614:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 800d618:	f7ff fe6b 	bl	800d2f2 <LL_APB1_GRP1_ReleaseReset>

  /* Set the SYNCDIV[2:0] bits according to Prescaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
 800d61c:	687b      	ldr	r3, [r7, #4]
 800d61e:	681a      	ldr	r2, [r3, #0]
 800d620:	687b      	ldr	r3, [r7, #4]
 800d622:	685b      	ldr	r3, [r3, #4]
 800d624:	431a      	orrs	r2, r3
 800d626:	687b      	ldr	r3, [r7, #4]
 800d628:	689b      	ldr	r3, [r3, #8]
 800d62a:	4313      	orrs	r3, r2
 800d62c:	60fb      	str	r3, [r7, #12]
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
 800d62e:	687b      	ldr	r3, [r7, #4]
 800d630:	68db      	ldr	r3, [r3, #12]
 800d632:	68fa      	ldr	r2, [r7, #12]
 800d634:	4313      	orrs	r3, r2
 800d636:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
 800d638:	687b      	ldr	r3, [r7, #4]
 800d63a:	691b      	ldr	r3, [r3, #16]
 800d63c:	041b      	lsls	r3, r3, #16
 800d63e:	68fa      	ldr	r2, [r7, #12]
 800d640:	4313      	orrs	r3, r2
 800d642:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
 800d644:	4a0b      	ldr	r2, [pc, #44]	; (800d674 <HAL_RCCEx_CRSConfig+0x70>)
 800d646:	68fb      	ldr	r3, [r7, #12]
 800d648:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
 800d64a:	4b0a      	ldr	r3, [pc, #40]	; (800d674 <HAL_RCCEx_CRSConfig+0x70>)
 800d64c:	681b      	ldr	r3, [r3, #0]
 800d64e:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
 800d652:	687b      	ldr	r3, [r7, #4]
 800d654:	695b      	ldr	r3, [r3, #20]
 800d656:	021b      	lsls	r3, r3, #8
 800d658:	4906      	ldr	r1, [pc, #24]	; (800d674 <HAL_RCCEx_CRSConfig+0x70>)
 800d65a:	4313      	orrs	r3, r2
 800d65c:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
 800d65e:	4b05      	ldr	r3, [pc, #20]	; (800d674 <HAL_RCCEx_CRSConfig+0x70>)
 800d660:	681b      	ldr	r3, [r3, #0]
 800d662:	4a04      	ldr	r2, [pc, #16]	; (800d674 <HAL_RCCEx_CRSConfig+0x70>)
 800d664:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800d668:	6013      	str	r3, [r2, #0]
}
 800d66a:	bf00      	nop
 800d66c:	3710      	adds	r7, #16
 800d66e:	46bd      	mov	sp, r7
 800d670:	bd80      	pop	{r7, pc}
 800d672:	bf00      	nop
 800d674:	40006000 	.word	0x40006000

0800d678 <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 800d678:	b580      	push	{r7, lr}
 800d67a:	b084      	sub	sp, #16
 800d67c:	af00      	add	r7, sp, #0
 800d67e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800d680:	2300      	movs	r3, #0
 800d682:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLSAI1->PLLP));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 800d684:	f7ff fe02 	bl	800d28c <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800d688:	f7fb ff70 	bl	800956c <HAL_GetTick>
 800d68c:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800d68e:	e009      	b.n	800d6a4 <RCCEx_PLLSAI1_ConfigNP+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800d690:	f7fb ff6c 	bl	800956c <HAL_GetTick>
 800d694:	4602      	mov	r2, r0
 800d696:	68bb      	ldr	r3, [r7, #8]
 800d698:	1ad3      	subs	r3, r2, r3
 800d69a:	2b02      	cmp	r3, #2
 800d69c:	d902      	bls.n	800d6a4 <RCCEx_PLLSAI1_ConfigNP+0x2c>
    {
      status = HAL_TIMEOUT;
 800d69e:	2303      	movs	r3, #3
 800d6a0:	73fb      	strb	r3, [r7, #15]
      break;
 800d6a2:	e004      	b.n	800d6ae <RCCEx_PLLSAI1_ConfigNP+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800d6a4:	f7ff fe01 	bl	800d2aa <LL_RCC_PLLSAI1_IsReady>
 800d6a8:	4603      	mov	r3, r0
 800d6aa:	2b00      	cmp	r3, #0
 800d6ac:	d1f0      	bne.n	800d690 <RCCEx_PLLSAI1_ConfigNP+0x18>
    }
  }

  if (status == HAL_OK)
 800d6ae:	7bfb      	ldrb	r3, [r7, #15]
 800d6b0:	2b00      	cmp	r3, #0
 800d6b2:	d137      	bne.n	800d724 <RCCEx_PLLSAI1_ConfigNP+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 800d6b4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d6b8:	691b      	ldr	r3, [r3, #16]
 800d6ba:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 800d6be:	687b      	ldr	r3, [r7, #4]
 800d6c0:	681b      	ldr	r3, [r3, #0]
 800d6c2:	021b      	lsls	r3, r3, #8
 800d6c4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d6c8:	4313      	orrs	r3, r2
 800d6ca:	610b      	str	r3, [r1, #16]

    /* Configure the PLLSAI1 Division factor P */
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PLLSAI1->PLLP);
 800d6cc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d6d0:	691b      	ldr	r3, [r3, #16]
 800d6d2:	f423 1278 	bic.w	r2, r3, #4063232	; 0x3e0000
 800d6d6:	687b      	ldr	r3, [r7, #4]
 800d6d8:	685b      	ldr	r3, [r3, #4]
 800d6da:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d6de:	4313      	orrs	r3, r2
 800d6e0:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 800d6e2:	f7ff fdc4 	bl	800d26e <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800d6e6:	f7fb ff41 	bl	800956c <HAL_GetTick>
 800d6ea:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800d6ec:	e009      	b.n	800d702 <RCCEx_PLLSAI1_ConfigNP+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800d6ee:	f7fb ff3d 	bl	800956c <HAL_GetTick>
 800d6f2:	4602      	mov	r2, r0
 800d6f4:	68bb      	ldr	r3, [r7, #8]
 800d6f6:	1ad3      	subs	r3, r2, r3
 800d6f8:	2b02      	cmp	r3, #2
 800d6fa:	d902      	bls.n	800d702 <RCCEx_PLLSAI1_ConfigNP+0x8a>
      {
        status = HAL_TIMEOUT;
 800d6fc:	2303      	movs	r3, #3
 800d6fe:	73fb      	strb	r3, [r7, #15]
        break;
 800d700:	e004      	b.n	800d70c <RCCEx_PLLSAI1_ConfigNP+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800d702:	f7ff fdd2 	bl	800d2aa <LL_RCC_PLLSAI1_IsReady>
 800d706:	4603      	mov	r3, r0
 800d708:	2b01      	cmp	r3, #1
 800d70a:	d1f0      	bne.n	800d6ee <RCCEx_PLLSAI1_ConfigNP+0x76>
      }
    }

    if (status == HAL_OK)
 800d70c:	7bfb      	ldrb	r3, [r7, #15]
 800d70e:	2b00      	cmp	r3, #0
 800d710:	d108      	bne.n	800d724 <RCCEx_PLLSAI1_ConfigNP+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 800d712:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d716:	691a      	ldr	r2, [r3, #16]
 800d718:	687b      	ldr	r3, [r7, #4]
 800d71a:	691b      	ldr	r3, [r3, #16]
 800d71c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d720:	4313      	orrs	r3, r2
 800d722:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 800d724:	7bfb      	ldrb	r3, [r7, #15]
}
 800d726:	4618      	mov	r0, r3
 800d728:	3710      	adds	r7, #16
 800d72a:	46bd      	mov	sp, r7
 800d72c:	bd80      	pop	{r7, pc}

0800d72e <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 800d72e:	b580      	push	{r7, lr}
 800d730:	b084      	sub	sp, #16
 800d732:	af00      	add	r7, sp, #0
 800d734:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800d736:	2300      	movs	r3, #0
 800d738:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLQ_VALUE(PLLSAI1->PLLQ));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 800d73a:	f7ff fda7 	bl	800d28c <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800d73e:	f7fb ff15 	bl	800956c <HAL_GetTick>
 800d742:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800d744:	e009      	b.n	800d75a <RCCEx_PLLSAI1_ConfigNQ+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800d746:	f7fb ff11 	bl	800956c <HAL_GetTick>
 800d74a:	4602      	mov	r2, r0
 800d74c:	68bb      	ldr	r3, [r7, #8]
 800d74e:	1ad3      	subs	r3, r2, r3
 800d750:	2b02      	cmp	r3, #2
 800d752:	d902      	bls.n	800d75a <RCCEx_PLLSAI1_ConfigNQ+0x2c>
    {
      status = HAL_TIMEOUT;
 800d754:	2303      	movs	r3, #3
 800d756:	73fb      	strb	r3, [r7, #15]
      break;
 800d758:	e004      	b.n	800d764 <RCCEx_PLLSAI1_ConfigNQ+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800d75a:	f7ff fda6 	bl	800d2aa <LL_RCC_PLLSAI1_IsReady>
 800d75e:	4603      	mov	r3, r0
 800d760:	2b00      	cmp	r3, #0
 800d762:	d1f0      	bne.n	800d746 <RCCEx_PLLSAI1_ConfigNQ+0x18>
    }
  }

  if (status == HAL_OK)
 800d764:	7bfb      	ldrb	r3, [r7, #15]
 800d766:	2b00      	cmp	r3, #0
 800d768:	d137      	bne.n	800d7da <RCCEx_PLLSAI1_ConfigNQ+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 800d76a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d76e:	691b      	ldr	r3, [r3, #16]
 800d770:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 800d774:	687b      	ldr	r3, [r7, #4]
 800d776:	681b      	ldr	r3, [r3, #0]
 800d778:	021b      	lsls	r3, r3, #8
 800d77a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d77e:	4313      	orrs	r3, r2
 800d780:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor Q */
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PLLSAI1->PLLQ);
 800d782:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d786:	691b      	ldr	r3, [r3, #16]
 800d788:	f023 6260 	bic.w	r2, r3, #234881024	; 0xe000000
 800d78c:	687b      	ldr	r3, [r7, #4]
 800d78e:	689b      	ldr	r3, [r3, #8]
 800d790:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d794:	4313      	orrs	r3, r2
 800d796:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 800d798:	f7ff fd69 	bl	800d26e <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800d79c:	f7fb fee6 	bl	800956c <HAL_GetTick>
 800d7a0:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800d7a2:	e009      	b.n	800d7b8 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800d7a4:	f7fb fee2 	bl	800956c <HAL_GetTick>
 800d7a8:	4602      	mov	r2, r0
 800d7aa:	68bb      	ldr	r3, [r7, #8]
 800d7ac:	1ad3      	subs	r3, r2, r3
 800d7ae:	2b02      	cmp	r3, #2
 800d7b0:	d902      	bls.n	800d7b8 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
      {
        status = HAL_TIMEOUT;
 800d7b2:	2303      	movs	r3, #3
 800d7b4:	73fb      	strb	r3, [r7, #15]
        break;
 800d7b6:	e004      	b.n	800d7c2 <RCCEx_PLLSAI1_ConfigNQ+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800d7b8:	f7ff fd77 	bl	800d2aa <LL_RCC_PLLSAI1_IsReady>
 800d7bc:	4603      	mov	r3, r0
 800d7be:	2b01      	cmp	r3, #1
 800d7c0:	d1f0      	bne.n	800d7a4 <RCCEx_PLLSAI1_ConfigNQ+0x76>
      }
    }

    if (status == HAL_OK)
 800d7c2:	7bfb      	ldrb	r3, [r7, #15]
 800d7c4:	2b00      	cmp	r3, #0
 800d7c6:	d108      	bne.n	800d7da <RCCEx_PLLSAI1_ConfigNQ+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 800d7c8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d7cc:	691a      	ldr	r2, [r3, #16]
 800d7ce:	687b      	ldr	r3, [r7, #4]
 800d7d0:	691b      	ldr	r3, [r3, #16]
 800d7d2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d7d6:	4313      	orrs	r3, r2
 800d7d8:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 800d7da:	7bfb      	ldrb	r3, [r7, #15]
}
 800d7dc:	4618      	mov	r0, r3
 800d7de:	3710      	adds	r7, #16
 800d7e0:	46bd      	mov	sp, r7
 800d7e2:	bd80      	pop	{r7, pc}

0800d7e4 <RCCEx_PLLSAI1_ConfigNR>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNR(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 800d7e4:	b580      	push	{r7, lr}
 800d7e6:	b084      	sub	sp, #16
 800d7e8:	af00      	add	r7, sp, #0
 800d7ea:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800d7ec:	2300      	movs	r3, #0
 800d7ee:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLR_VALUE(PLLSAI1->PLLR));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 800d7f0:	f7ff fd4c 	bl	800d28c <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800d7f4:	f7fb feba 	bl	800956c <HAL_GetTick>
 800d7f8:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800d7fa:	e009      	b.n	800d810 <RCCEx_PLLSAI1_ConfigNR+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800d7fc:	f7fb feb6 	bl	800956c <HAL_GetTick>
 800d800:	4602      	mov	r2, r0
 800d802:	68bb      	ldr	r3, [r7, #8]
 800d804:	1ad3      	subs	r3, r2, r3
 800d806:	2b02      	cmp	r3, #2
 800d808:	d902      	bls.n	800d810 <RCCEx_PLLSAI1_ConfigNR+0x2c>
    {
      status = HAL_TIMEOUT;
 800d80a:	2303      	movs	r3, #3
 800d80c:	73fb      	strb	r3, [r7, #15]
      break;
 800d80e:	e004      	b.n	800d81a <RCCEx_PLLSAI1_ConfigNR+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800d810:	f7ff fd4b 	bl	800d2aa <LL_RCC_PLLSAI1_IsReady>
 800d814:	4603      	mov	r3, r0
 800d816:	2b00      	cmp	r3, #0
 800d818:	d1f0      	bne.n	800d7fc <RCCEx_PLLSAI1_ConfigNR+0x18>
    }
  }

  if (status == HAL_OK)
 800d81a:	7bfb      	ldrb	r3, [r7, #15]
 800d81c:	2b00      	cmp	r3, #0
 800d81e:	d137      	bne.n	800d890 <RCCEx_PLLSAI1_ConfigNR+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 800d820:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d824:	691b      	ldr	r3, [r3, #16]
 800d826:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 800d82a:	687b      	ldr	r3, [r7, #4]
 800d82c:	681b      	ldr	r3, [r3, #0]
 800d82e:	021b      	lsls	r3, r3, #8
 800d830:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d834:	4313      	orrs	r3, r2
 800d836:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor R */
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PLLSAI1->PLLR);
 800d838:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d83c:	691b      	ldr	r3, [r3, #16]
 800d83e:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 800d842:	687b      	ldr	r3, [r7, #4]
 800d844:	68db      	ldr	r3, [r3, #12]
 800d846:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d84a:	4313      	orrs	r3, r2
 800d84c:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 800d84e:	f7ff fd0e 	bl	800d26e <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800d852:	f7fb fe8b 	bl	800956c <HAL_GetTick>
 800d856:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800d858:	e009      	b.n	800d86e <RCCEx_PLLSAI1_ConfigNR+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800d85a:	f7fb fe87 	bl	800956c <HAL_GetTick>
 800d85e:	4602      	mov	r2, r0
 800d860:	68bb      	ldr	r3, [r7, #8]
 800d862:	1ad3      	subs	r3, r2, r3
 800d864:	2b02      	cmp	r3, #2
 800d866:	d902      	bls.n	800d86e <RCCEx_PLLSAI1_ConfigNR+0x8a>
      {
        status = HAL_TIMEOUT;
 800d868:	2303      	movs	r3, #3
 800d86a:	73fb      	strb	r3, [r7, #15]
        break;
 800d86c:	e004      	b.n	800d878 <RCCEx_PLLSAI1_ConfigNR+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800d86e:	f7ff fd1c 	bl	800d2aa <LL_RCC_PLLSAI1_IsReady>
 800d872:	4603      	mov	r3, r0
 800d874:	2b01      	cmp	r3, #1
 800d876:	d1f0      	bne.n	800d85a <RCCEx_PLLSAI1_ConfigNR+0x76>
      }
    }

    if (status == HAL_OK)
 800d878:	7bfb      	ldrb	r3, [r7, #15]
 800d87a:	2b00      	cmp	r3, #0
 800d87c:	d108      	bne.n	800d890 <RCCEx_PLLSAI1_ConfigNR+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 800d87e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d882:	691a      	ldr	r2, [r3, #16]
 800d884:	687b      	ldr	r3, [r7, #4]
 800d886:	691b      	ldr	r3, [r3, #16]
 800d888:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d88c:	4313      	orrs	r3, r2
 800d88e:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 800d890:	7bfb      	ldrb	r3, [r7, #15]
}
 800d892:	4618      	mov	r0, r3
 800d894:	3710      	adds	r7, #16
 800d896:	46bd      	mov	sp, r7
 800d898:	bd80      	pop	{r7, pc}
	...

0800d89c <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 800d89c:	b580      	push	{r7, lr}
 800d89e:	b084      	sub	sp, #16
 800d8a0:	af00      	add	r7, sp, #0
 800d8a2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the RTC peripheral state */
  if (hrtc == NULL)
 800d8a4:	687b      	ldr	r3, [r7, #4]
 800d8a6:	2b00      	cmp	r3, #0
 800d8a8:	d101      	bne.n	800d8ae <HAL_RTC_Init+0x12>
  {
    return HAL_ERROR;
 800d8aa:	2301      	movs	r3, #1
 800d8ac:	e09f      	b.n	800d9ee <HAL_RTC_Init+0x152>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else
  if (hrtc->State == HAL_RTC_STATE_RESET)
 800d8ae:	687b      	ldr	r3, [r7, #4]
 800d8b0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800d8b4:	b2db      	uxtb	r3, r3
 800d8b6:	2b00      	cmp	r3, #0
 800d8b8:	d106      	bne.n	800d8c8 <HAL_RTC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 800d8ba:	687b      	ldr	r3, [r7, #4]
 800d8bc:	2200      	movs	r2, #0
 800d8be:	f883 2020 	strb.w	r2, [r3, #32]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 800d8c2:	6878      	ldr	r0, [r7, #4]
 800d8c4:	f7fa fad2 	bl	8007e6c <HAL_RTC_MspInit>
  }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 800d8c8:	687b      	ldr	r3, [r7, #4]
 800d8ca:	2202      	movs	r2, #2
 800d8cc:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

  /* Check if the calendar has been not initialized */
  if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 800d8d0:	4b49      	ldr	r3, [pc, #292]	; (800d9f8 <HAL_RTC_Init+0x15c>)
 800d8d2:	68db      	ldr	r3, [r3, #12]
 800d8d4:	f003 0310 	and.w	r3, r3, #16
 800d8d8:	2b10      	cmp	r3, #16
 800d8da:	d07e      	beq.n	800d9da <HAL_RTC_Init+0x13e>
  {
    /* Disable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800d8dc:	687b      	ldr	r3, [r7, #4]
 800d8de:	681b      	ldr	r3, [r3, #0]
 800d8e0:	22ca      	movs	r2, #202	; 0xca
 800d8e2:	625a      	str	r2, [r3, #36]	; 0x24
 800d8e4:	687b      	ldr	r3, [r7, #4]
 800d8e6:	681b      	ldr	r3, [r3, #0]
 800d8e8:	2253      	movs	r2, #83	; 0x53
 800d8ea:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set Initialization mode */
    if (RTC_EnterInitMode(hrtc) != HAL_OK)
 800d8ec:	6878      	ldr	r0, [r7, #4]
 800d8ee:	f000 f8ab 	bl	800da48 <RTC_EnterInitMode>
 800d8f2:	4603      	mov	r3, r0
 800d8f4:	2b00      	cmp	r3, #0
 800d8f6:	d00a      	beq.n	800d90e <HAL_RTC_Init+0x72>
    {
      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800d8f8:	687b      	ldr	r3, [r7, #4]
 800d8fa:	681b      	ldr	r3, [r3, #0]
 800d8fc:	22ff      	movs	r2, #255	; 0xff
 800d8fe:	625a      	str	r2, [r3, #36]	; 0x24

      /* Set RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 800d900:	687b      	ldr	r3, [r7, #4]
 800d902:	2204      	movs	r2, #4
 800d904:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

      status = HAL_ERROR;
 800d908:	2301      	movs	r3, #1
 800d90a:	73fb      	strb	r3, [r7, #15]
 800d90c:	e067      	b.n	800d9de <HAL_RTC_Init+0x142>
    }
    else
    {
      /* Clear RTC_CR FMT, OSEL and POL Bits */
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 800d90e:	687b      	ldr	r3, [r7, #4]
 800d910:	681b      	ldr	r3, [r3, #0]
 800d912:	689b      	ldr	r3, [r3, #8]
 800d914:	687a      	ldr	r2, [r7, #4]
 800d916:	6812      	ldr	r2, [r2, #0]
 800d918:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 800d91c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800d920:	6093      	str	r3, [r2, #8]
      /* Set RTC_CR register */
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 800d922:	687b      	ldr	r3, [r7, #4]
 800d924:	681b      	ldr	r3, [r3, #0]
 800d926:	6899      	ldr	r1, [r3, #8]
 800d928:	687b      	ldr	r3, [r7, #4]
 800d92a:	685a      	ldr	r2, [r3, #4]
 800d92c:	687b      	ldr	r3, [r7, #4]
 800d92e:	691b      	ldr	r3, [r3, #16]
 800d930:	431a      	orrs	r2, r3
 800d932:	687b      	ldr	r3, [r7, #4]
 800d934:	699b      	ldr	r3, [r3, #24]
 800d936:	431a      	orrs	r2, r3
 800d938:	687b      	ldr	r3, [r7, #4]
 800d93a:	681b      	ldr	r3, [r3, #0]
 800d93c:	430a      	orrs	r2, r1
 800d93e:	609a      	str	r2, [r3, #8]

      /* Configure the RTC PRER */
      hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 800d940:	687b      	ldr	r3, [r7, #4]
 800d942:	681b      	ldr	r3, [r3, #0]
 800d944:	687a      	ldr	r2, [r7, #4]
 800d946:	68d2      	ldr	r2, [r2, #12]
 800d948:	611a      	str	r2, [r3, #16]
      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 800d94a:	687b      	ldr	r3, [r7, #4]
 800d94c:	681b      	ldr	r3, [r3, #0]
 800d94e:	6919      	ldr	r1, [r3, #16]
 800d950:	687b      	ldr	r3, [r7, #4]
 800d952:	689b      	ldr	r3, [r3, #8]
 800d954:	041a      	lsls	r2, r3, #16
 800d956:	687b      	ldr	r3, [r7, #4]
 800d958:	681b      	ldr	r3, [r3, #0]
 800d95a:	430a      	orrs	r2, r1
 800d95c:	611a      	str	r2, [r3, #16]

      /* Exit Initialization mode */
      hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 800d95e:	687b      	ldr	r3, [r7, #4]
 800d960:	681b      	ldr	r3, [r3, #0]
 800d962:	68da      	ldr	r2, [r3, #12]
 800d964:	687b      	ldr	r3, [r7, #4]
 800d966:	681b      	ldr	r3, [r3, #0]
 800d968:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800d96c:	60da      	str	r2, [r3, #12]

#if defined(RTC_OR_ALARMOUTTYPE)
      hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 800d96e:	687b      	ldr	r3, [r7, #4]
 800d970:	681b      	ldr	r3, [r3, #0]
 800d972:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d974:	687b      	ldr	r3, [r7, #4]
 800d976:	681b      	ldr	r3, [r3, #0]
 800d978:	f022 0203 	bic.w	r2, r2, #3
 800d97c:	64da      	str	r2, [r3, #76]	; 0x4c
#else
      hrtc->Instance->OR &= (uint32_t)~(RTC_OR_OUT_RMP);
#endif /* RTC_OR_ALARMOUTTYPE */
      hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 800d97e:	687b      	ldr	r3, [r7, #4]
 800d980:	681b      	ldr	r3, [r3, #0]
 800d982:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 800d984:	687b      	ldr	r3, [r7, #4]
 800d986:	69da      	ldr	r2, [r3, #28]
 800d988:	687b      	ldr	r3, [r7, #4]
 800d98a:	695b      	ldr	r3, [r3, #20]
 800d98c:	431a      	orrs	r2, r3
 800d98e:	687b      	ldr	r3, [r7, #4]
 800d990:	681b      	ldr	r3, [r3, #0]
 800d992:	430a      	orrs	r2, r1
 800d994:	64da      	str	r2, [r3, #76]	; 0x4c

      /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
      if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
 800d996:	687b      	ldr	r3, [r7, #4]
 800d998:	681b      	ldr	r3, [r3, #0]
 800d99a:	689b      	ldr	r3, [r3, #8]
 800d99c:	f003 0320 	and.w	r3, r3, #32
 800d9a0:	2b00      	cmp	r3, #0
 800d9a2:	d113      	bne.n	800d9cc <HAL_RTC_Init+0x130>
      {
        if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800d9a4:	6878      	ldr	r0, [r7, #4]
 800d9a6:	f000 f829 	bl	800d9fc <HAL_RTC_WaitForSynchro>
 800d9aa:	4603      	mov	r3, r0
 800d9ac:	2b00      	cmp	r3, #0
 800d9ae:	d00d      	beq.n	800d9cc <HAL_RTC_Init+0x130>
        {
          /* Enable the write protection for RTC registers */
          __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800d9b0:	687b      	ldr	r3, [r7, #4]
 800d9b2:	681b      	ldr	r3, [r3, #0]
 800d9b4:	22ff      	movs	r2, #255	; 0xff
 800d9b6:	625a      	str	r2, [r3, #36]	; 0x24

          hrtc->State = HAL_RTC_STATE_ERROR;
 800d9b8:	687b      	ldr	r3, [r7, #4]
 800d9ba:	2204      	movs	r2, #4
 800d9bc:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

          /* Process Unlocked */
          __HAL_UNLOCK(hrtc);
 800d9c0:	687b      	ldr	r3, [r7, #4]
 800d9c2:	2200      	movs	r2, #0
 800d9c4:	f883 2020 	strb.w	r2, [r3, #32]

          return HAL_ERROR;
 800d9c8:	2301      	movs	r3, #1
 800d9ca:	e010      	b.n	800d9ee <HAL_RTC_Init+0x152>
        }
      }

      /* Enable the write protection for RTC registers */
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800d9cc:	687b      	ldr	r3, [r7, #4]
 800d9ce:	681b      	ldr	r3, [r3, #0]
 800d9d0:	22ff      	movs	r2, #255	; 0xff
 800d9d2:	625a      	str	r2, [r3, #36]	; 0x24

      /* Set RTC state */
      status = HAL_OK;
 800d9d4:	2300      	movs	r3, #0
 800d9d6:	73fb      	strb	r3, [r7, #15]
 800d9d8:	e001      	b.n	800d9de <HAL_RTC_Init+0x142>
  }
  else
  {
    /* Calendar is already initialized */
    /* Set flag to OK */
    status = HAL_OK;
 800d9da:	2300      	movs	r3, #0
 800d9dc:	73fb      	strb	r3, [r7, #15]
  }

  if (status == HAL_OK)
 800d9de:	7bfb      	ldrb	r3, [r7, #15]
 800d9e0:	2b00      	cmp	r3, #0
 800d9e2:	d103      	bne.n	800d9ec <HAL_RTC_Init+0x150>
  {
    /* Change RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 800d9e4:	687b      	ldr	r3, [r7, #4]
 800d9e6:	2201      	movs	r2, #1
 800d9e8:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  }

  return status;
 800d9ec:	7bfb      	ldrb	r3, [r7, #15]
}
 800d9ee:	4618      	mov	r0, r3
 800d9f0:	3710      	adds	r7, #16
 800d9f2:	46bd      	mov	sp, r7
 800d9f4:	bd80      	pop	{r7, pc}
 800d9f6:	bf00      	nop
 800d9f8:	40002800 	.word	0x40002800

0800d9fc <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 800d9fc:	b580      	push	{r7, lr}
 800d9fe:	b084      	sub	sp, #16
 800da00:	af00      	add	r7, sp, #0
 800da02:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 800da04:	687b      	ldr	r3, [r7, #4]
 800da06:	681b      	ldr	r3, [r3, #0]
 800da08:	68da      	ldr	r2, [r3, #12]
 800da0a:	687b      	ldr	r3, [r7, #4]
 800da0c:	681b      	ldr	r3, [r3, #0]
 800da0e:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800da12:	60da      	str	r2, [r3, #12]

  tickstart = HAL_GetTick();
 800da14:	f7fb fdaa 	bl	800956c <HAL_GetTick>
 800da18:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800da1a:	e009      	b.n	800da30 <HAL_RTC_WaitForSynchro+0x34>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 800da1c:	f7fb fda6 	bl	800956c <HAL_GetTick>
 800da20:	4602      	mov	r2, r0
 800da22:	68fb      	ldr	r3, [r7, #12]
 800da24:	1ad3      	subs	r3, r2, r3
 800da26:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800da2a:	d901      	bls.n	800da30 <HAL_RTC_WaitForSynchro+0x34>
    {
      return HAL_TIMEOUT;
 800da2c:	2303      	movs	r3, #3
 800da2e:	e007      	b.n	800da40 <HAL_RTC_WaitForSynchro+0x44>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800da30:	687b      	ldr	r3, [r7, #4]
 800da32:	681b      	ldr	r3, [r3, #0]
 800da34:	68db      	ldr	r3, [r3, #12]
 800da36:	f003 0320 	and.w	r3, r3, #32
 800da3a:	2b00      	cmp	r3, #0
 800da3c:	d0ee      	beq.n	800da1c <HAL_RTC_WaitForSynchro+0x20>
    }
  }

  return HAL_OK;
 800da3e:	2300      	movs	r3, #0
}
 800da40:	4618      	mov	r0, r3
 800da42:	3710      	adds	r7, #16
 800da44:	46bd      	mov	sp, r7
 800da46:	bd80      	pop	{r7, pc}

0800da48 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 800da48:	b580      	push	{r7, lr}
 800da4a:	b084      	sub	sp, #16
 800da4c:	af00      	add	r7, sp, #0
 800da4e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check if the Initialization mode is set */
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800da50:	687b      	ldr	r3, [r7, #4]
 800da52:	681b      	ldr	r3, [r3, #0]
 800da54:	68db      	ldr	r3, [r3, #12]
 800da56:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800da5a:	2b00      	cmp	r3, #0
 800da5c:	d119      	bne.n	800da92 <RTC_EnterInitMode+0x4a>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 800da5e:	687b      	ldr	r3, [r7, #4]
 800da60:	681b      	ldr	r3, [r3, #0]
 800da62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800da66:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 800da68:	f7fb fd80 	bl	800956c <HAL_GetTick>
 800da6c:	60f8      	str	r0, [r7, #12]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800da6e:	e009      	b.n	800da84 <RTC_EnterInitMode+0x3c>
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 800da70:	f7fb fd7c 	bl	800956c <HAL_GetTick>
 800da74:	4602      	mov	r2, r0
 800da76:	68fb      	ldr	r3, [r7, #12]
 800da78:	1ad3      	subs	r3, r2, r3
 800da7a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800da7e:	d901      	bls.n	800da84 <RTC_EnterInitMode+0x3c>
      {
        return HAL_TIMEOUT;
 800da80:	2303      	movs	r3, #3
 800da82:	e007      	b.n	800da94 <RTC_EnterInitMode+0x4c>
    while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800da84:	687b      	ldr	r3, [r7, #4]
 800da86:	681b      	ldr	r3, [r3, #0]
 800da88:	68db      	ldr	r3, [r3, #12]
 800da8a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800da8e:	2b00      	cmp	r3, #0
 800da90:	d0ee      	beq.n	800da70 <RTC_EnterInitMode+0x28>
      }
    }
  }

  return HAL_OK;
 800da92:	2300      	movs	r3, #0
}
 800da94:	4618      	mov	r0, r3
 800da96:	3710      	adds	r7, #16
 800da98:	46bd      	mov	sp, r7
 800da9a:	bd80      	pop	{r7, pc}

0800da9c <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800da9c:	b580      	push	{r7, lr}
 800da9e:	b08a      	sub	sp, #40	; 0x28
 800daa0:	af00      	add	r7, sp, #0
 800daa2:	60f8      	str	r0, [r7, #12]
 800daa4:	60b9      	str	r1, [r7, #8]
 800daa6:	4613      	mov	r3, r2
 800daa8:	80fb      	strh	r3, [r7, #6]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 800daaa:	68fb      	ldr	r3, [r7, #12]
 800daac:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800dab0:	2b20      	cmp	r3, #32
 800dab2:	d137      	bne.n	800db24 <HAL_UART_Receive_IT+0x88>
  {
    if ((pData == NULL) || (Size == 0U))
 800dab4:	68bb      	ldr	r3, [r7, #8]
 800dab6:	2b00      	cmp	r3, #0
 800dab8:	d002      	beq.n	800dac0 <HAL_UART_Receive_IT+0x24>
 800daba:	88fb      	ldrh	r3, [r7, #6]
 800dabc:	2b00      	cmp	r3, #0
 800dabe:	d101      	bne.n	800dac4 <HAL_UART_Receive_IT+0x28>
    {
      return HAL_ERROR;
 800dac0:	2301      	movs	r3, #1
 800dac2:	e030      	b.n	800db26 <HAL_UART_Receive_IT+0x8a>
    }

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800dac4:	68fb      	ldr	r3, [r7, #12]
 800dac6:	2200      	movs	r2, #0
 800dac8:	66da      	str	r2, [r3, #108]	; 0x6c

#if defined(LPUART1)
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800daca:	68fb      	ldr	r3, [r7, #12]
 800dacc:	681b      	ldr	r3, [r3, #0]
 800dace:	4a18      	ldr	r2, [pc, #96]	; (800db30 <HAL_UART_Receive_IT+0x94>)
 800dad0:	4293      	cmp	r3, r2
 800dad2:	d01f      	beq.n	800db14 <HAL_UART_Receive_IT+0x78>
    {
      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800dad4:	68fb      	ldr	r3, [r7, #12]
 800dad6:	681b      	ldr	r3, [r3, #0]
 800dad8:	685b      	ldr	r3, [r3, #4]
 800dada:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800dade:	2b00      	cmp	r3, #0
 800dae0:	d018      	beq.n	800db14 <HAL_UART_Receive_IT+0x78>
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800dae2:	68fb      	ldr	r3, [r7, #12]
 800dae4:	681b      	ldr	r3, [r3, #0]
 800dae6:	617b      	str	r3, [r7, #20]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800dae8:	697b      	ldr	r3, [r7, #20]
 800daea:	e853 3f00 	ldrex	r3, [r3]
 800daee:	613b      	str	r3, [r7, #16]
   return(result);
 800daf0:	693b      	ldr	r3, [r7, #16]
 800daf2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800daf6:	627b      	str	r3, [r7, #36]	; 0x24
 800daf8:	68fb      	ldr	r3, [r7, #12]
 800dafa:	681b      	ldr	r3, [r3, #0]
 800dafc:	461a      	mov	r2, r3
 800dafe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800db00:	623b      	str	r3, [r7, #32]
 800db02:	61fa      	str	r2, [r7, #28]
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800db04:	69f9      	ldr	r1, [r7, #28]
 800db06:	6a3a      	ldr	r2, [r7, #32]
 800db08:	e841 2300 	strex	r3, r2, [r1]
 800db0c:	61bb      	str	r3, [r7, #24]
   return(result);
 800db0e:	69bb      	ldr	r3, [r7, #24]
 800db10:	2b00      	cmp	r3, #0
 800db12:	d1e6      	bne.n	800dae2 <HAL_UART_Receive_IT+0x46>
      /* Enable the UART Receiver Timeout Interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
    }
#endif /* LPUART1 */

    return (UART_Start_Receive_IT(huart, pData, Size));
 800db14:	88fb      	ldrh	r3, [r7, #6]
 800db16:	461a      	mov	r2, r3
 800db18:	68b9      	ldr	r1, [r7, #8]
 800db1a:	68f8      	ldr	r0, [r7, #12]
 800db1c:	f000 fb44 	bl	800e1a8 <UART_Start_Receive_IT>
 800db20:	4603      	mov	r3, r0
 800db22:	e000      	b.n	800db26 <HAL_UART_Receive_IT+0x8a>
  }
  else
  {
    return HAL_BUSY;
 800db24:	2302      	movs	r3, #2
  }
}
 800db26:	4618      	mov	r0, r3
 800db28:	3728      	adds	r7, #40	; 0x28
 800db2a:	46bd      	mov	sp, r7
 800db2c:	bd80      	pop	{r7, pc}
 800db2e:	bf00      	nop
 800db30:	40008000 	.word	0x40008000

0800db34 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 800db34:	b580      	push	{r7, lr}
 800db36:	b0ba      	sub	sp, #232	; 0xe8
 800db38:	af00      	add	r7, sp, #0
 800db3a:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800db3c:	687b      	ldr	r3, [r7, #4]
 800db3e:	681b      	ldr	r3, [r3, #0]
 800db40:	69db      	ldr	r3, [r3, #28]
 800db42:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800db46:	687b      	ldr	r3, [r7, #4]
 800db48:	681b      	ldr	r3, [r3, #0]
 800db4a:	681b      	ldr	r3, [r3, #0]
 800db4c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800db50:	687b      	ldr	r3, [r7, #4]
 800db52:	681b      	ldr	r3, [r3, #0]
 800db54:	689b      	ldr	r3, [r3, #8]
 800db56:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 800db5a:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 800db5e:	f640 030f 	movw	r3, #2063	; 0x80f
 800db62:	4013      	ands	r3, r2
 800db64:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  if (errorflags == 0U)
 800db68:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800db6c:	2b00      	cmp	r3, #0
 800db6e:	d11b      	bne.n	800dba8 <HAL_UART_IRQHandler+0x74>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 800db70:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800db74:	f003 0320 	and.w	r3, r3, #32
 800db78:	2b00      	cmp	r3, #0
 800db7a:	d015      	beq.n	800dba8 <HAL_UART_IRQHandler+0x74>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 800db7c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800db80:	f003 0320 	and.w	r3, r3, #32
 800db84:	2b00      	cmp	r3, #0
 800db86:	d105      	bne.n	800db94 <HAL_UART_IRQHandler+0x60>
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 800db88:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800db8c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800db90:	2b00      	cmp	r3, #0
 800db92:	d009      	beq.n	800dba8 <HAL_UART_IRQHandler+0x74>
    {
      if (huart->RxISR != NULL)
 800db94:	687b      	ldr	r3, [r7, #4]
 800db96:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800db98:	2b00      	cmp	r3, #0
 800db9a:	f000 82e3 	beq.w	800e164 <HAL_UART_IRQHandler+0x630>
      {
        huart->RxISR(huart);
 800db9e:	687b      	ldr	r3, [r7, #4]
 800dba0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dba2:	6878      	ldr	r0, [r7, #4]
 800dba4:	4798      	blx	r3
      }
      return;
 800dba6:	e2dd      	b.n	800e164 <HAL_UART_IRQHandler+0x630>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 800dba8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 800dbac:	2b00      	cmp	r3, #0
 800dbae:	f000 8123 	beq.w	800ddf8 <HAL_UART_IRQHandler+0x2c4>
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 800dbb2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 800dbb6:	4b8d      	ldr	r3, [pc, #564]	; (800ddec <HAL_UART_IRQHandler+0x2b8>)
 800dbb8:	4013      	ands	r3, r2
 800dbba:	2b00      	cmp	r3, #0
 800dbbc:	d106      	bne.n	800dbcc <HAL_UART_IRQHandler+0x98>
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 800dbbe:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800dbc2:	4b8b      	ldr	r3, [pc, #556]	; (800ddf0 <HAL_UART_IRQHandler+0x2bc>)
 800dbc4:	4013      	ands	r3, r2
 800dbc6:	2b00      	cmp	r3, #0
 800dbc8:	f000 8116 	beq.w	800ddf8 <HAL_UART_IRQHandler+0x2c4>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800dbcc:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800dbd0:	f003 0301 	and.w	r3, r3, #1
 800dbd4:	2b00      	cmp	r3, #0
 800dbd6:	d011      	beq.n	800dbfc <HAL_UART_IRQHandler+0xc8>
 800dbd8:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800dbdc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800dbe0:	2b00      	cmp	r3, #0
 800dbe2:	d00b      	beq.n	800dbfc <HAL_UART_IRQHandler+0xc8>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800dbe4:	687b      	ldr	r3, [r7, #4]
 800dbe6:	681b      	ldr	r3, [r3, #0]
 800dbe8:	2201      	movs	r2, #1
 800dbea:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800dbec:	687b      	ldr	r3, [r7, #4]
 800dbee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dbf2:	f043 0201 	orr.w	r2, r3, #1
 800dbf6:	687b      	ldr	r3, [r7, #4]
 800dbf8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800dbfc:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800dc00:	f003 0302 	and.w	r3, r3, #2
 800dc04:	2b00      	cmp	r3, #0
 800dc06:	d011      	beq.n	800dc2c <HAL_UART_IRQHandler+0xf8>
 800dc08:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800dc0c:	f003 0301 	and.w	r3, r3, #1
 800dc10:	2b00      	cmp	r3, #0
 800dc12:	d00b      	beq.n	800dc2c <HAL_UART_IRQHandler+0xf8>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800dc14:	687b      	ldr	r3, [r7, #4]
 800dc16:	681b      	ldr	r3, [r3, #0]
 800dc18:	2202      	movs	r2, #2
 800dc1a:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800dc1c:	687b      	ldr	r3, [r7, #4]
 800dc1e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dc22:	f043 0204 	orr.w	r2, r3, #4
 800dc26:	687b      	ldr	r3, [r7, #4]
 800dc28:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800dc2c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800dc30:	f003 0304 	and.w	r3, r3, #4
 800dc34:	2b00      	cmp	r3, #0
 800dc36:	d011      	beq.n	800dc5c <HAL_UART_IRQHandler+0x128>
 800dc38:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800dc3c:	f003 0301 	and.w	r3, r3, #1
 800dc40:	2b00      	cmp	r3, #0
 800dc42:	d00b      	beq.n	800dc5c <HAL_UART_IRQHandler+0x128>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800dc44:	687b      	ldr	r3, [r7, #4]
 800dc46:	681b      	ldr	r3, [r3, #0]
 800dc48:	2204      	movs	r2, #4
 800dc4a:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 800dc4c:	687b      	ldr	r3, [r7, #4]
 800dc4e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dc52:	f043 0202 	orr.w	r2, r3, #2
 800dc56:	687b      	ldr	r3, [r7, #4]
 800dc58:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 800dc5c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800dc60:	f003 0308 	and.w	r3, r3, #8
 800dc64:	2b00      	cmp	r3, #0
 800dc66:	d017      	beq.n	800dc98 <HAL_UART_IRQHandler+0x164>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 800dc68:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800dc6c:	f003 0320 	and.w	r3, r3, #32
 800dc70:	2b00      	cmp	r3, #0
 800dc72:	d105      	bne.n	800dc80 <HAL_UART_IRQHandler+0x14c>
            ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))
 800dc74:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 800dc78:	4b5c      	ldr	r3, [pc, #368]	; (800ddec <HAL_UART_IRQHandler+0x2b8>)
 800dc7a:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 800dc7c:	2b00      	cmp	r3, #0
 800dc7e:	d00b      	beq.n	800dc98 <HAL_UART_IRQHandler+0x164>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800dc80:	687b      	ldr	r3, [r7, #4]
 800dc82:	681b      	ldr	r3, [r3, #0]
 800dc84:	2208      	movs	r2, #8
 800dc86:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800dc88:	687b      	ldr	r3, [r7, #4]
 800dc8a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dc8e:	f043 0208 	orr.w	r2, r3, #8
 800dc92:	687b      	ldr	r3, [r7, #4]
 800dc94:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 800dc98:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800dc9c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800dca0:	2b00      	cmp	r3, #0
 800dca2:	d012      	beq.n	800dcca <HAL_UART_IRQHandler+0x196>
 800dca4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800dca8:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800dcac:	2b00      	cmp	r3, #0
 800dcae:	d00c      	beq.n	800dcca <HAL_UART_IRQHandler+0x196>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800dcb0:	687b      	ldr	r3, [r7, #4]
 800dcb2:	681b      	ldr	r3, [r3, #0]
 800dcb4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800dcb8:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 800dcba:	687b      	ldr	r3, [r7, #4]
 800dcbc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dcc0:	f043 0220 	orr.w	r2, r3, #32
 800dcc4:	687b      	ldr	r3, [r7, #4]
 800dcc6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800dcca:	687b      	ldr	r3, [r7, #4]
 800dccc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dcd0:	2b00      	cmp	r3, #0
 800dcd2:	f000 8249 	beq.w	800e168 <HAL_UART_IRQHandler+0x634>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 800dcd6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800dcda:	f003 0320 	and.w	r3, r3, #32
 800dcde:	2b00      	cmp	r3, #0
 800dce0:	d013      	beq.n	800dd0a <HAL_UART_IRQHandler+0x1d6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 800dce2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800dce6:	f003 0320 	and.w	r3, r3, #32
 800dcea:	2b00      	cmp	r3, #0
 800dcec:	d105      	bne.n	800dcfa <HAL_UART_IRQHandler+0x1c6>
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 800dcee:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800dcf2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800dcf6:	2b00      	cmp	r3, #0
 800dcf8:	d007      	beq.n	800dd0a <HAL_UART_IRQHandler+0x1d6>
      {
        if (huart->RxISR != NULL)
 800dcfa:	687b      	ldr	r3, [r7, #4]
 800dcfc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dcfe:	2b00      	cmp	r3, #0
 800dd00:	d003      	beq.n	800dd0a <HAL_UART_IRQHandler+0x1d6>
        {
          huart->RxISR(huart);
 800dd02:	687b      	ldr	r3, [r7, #4]
 800dd04:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800dd06:	6878      	ldr	r0, [r7, #4]
 800dd08:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 800dd0a:	687b      	ldr	r3, [r7, #4]
 800dd0c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800dd10:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800dd14:	687b      	ldr	r3, [r7, #4]
 800dd16:	681b      	ldr	r3, [r3, #0]
 800dd18:	689b      	ldr	r3, [r3, #8]
 800dd1a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800dd1e:	2b40      	cmp	r3, #64	; 0x40
 800dd20:	d005      	beq.n	800dd2e <HAL_UART_IRQHandler+0x1fa>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 800dd22:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800dd26:	f003 0328 	and.w	r3, r3, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800dd2a:	2b00      	cmp	r3, #0
 800dd2c:	d054      	beq.n	800ddd8 <HAL_UART_IRQHandler+0x2a4>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 800dd2e:	6878      	ldr	r0, [r7, #4]
 800dd30:	f000 fb5c 	bl	800e3ec <UART_EndRxTransfer>

        /* Abort the UART DMA Rx channel if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800dd34:	687b      	ldr	r3, [r7, #4]
 800dd36:	681b      	ldr	r3, [r3, #0]
 800dd38:	689b      	ldr	r3, [r3, #8]
 800dd3a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800dd3e:	2b40      	cmp	r3, #64	; 0x40
 800dd40:	d146      	bne.n	800ddd0 <HAL_UART_IRQHandler+0x29c>
        {
          /* Disable the UART DMA Rx request if enabled */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800dd42:	687b      	ldr	r3, [r7, #4]
 800dd44:	681b      	ldr	r3, [r3, #0]
 800dd46:	3308      	adds	r3, #8
 800dd48:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800dd4c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800dd50:	e853 3f00 	ldrex	r3, [r3]
 800dd54:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   return(result);
 800dd58:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800dd5c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800dd60:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800dd64:	687b      	ldr	r3, [r7, #4]
 800dd66:	681b      	ldr	r3, [r3, #0]
 800dd68:	3308      	adds	r3, #8
 800dd6a:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 800dd6e:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 800dd72:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800dd76:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 800dd7a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 800dd7e:	e841 2300 	strex	r3, r2, [r1]
 800dd82:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   return(result);
 800dd86:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800dd8a:	2b00      	cmp	r3, #0
 800dd8c:	d1d9      	bne.n	800dd42 <HAL_UART_IRQHandler+0x20e>

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 800dd8e:	687b      	ldr	r3, [r7, #4]
 800dd90:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800dd94:	2b00      	cmp	r3, #0
 800dd96:	d017      	beq.n	800ddc8 <HAL_UART_IRQHandler+0x294>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800dd98:	687b      	ldr	r3, [r7, #4]
 800dd9a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800dd9e:	4a15      	ldr	r2, [pc, #84]	; (800ddf4 <HAL_UART_IRQHandler+0x2c0>)
 800dda0:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800dda2:	687b      	ldr	r3, [r7, #4]
 800dda4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800dda8:	4618      	mov	r0, r3
 800ddaa:	f7fb fdf5 	bl	8009998 <HAL_DMA_Abort_IT>
 800ddae:	4603      	mov	r3, r0
 800ddb0:	2b00      	cmp	r3, #0
 800ddb2:	d019      	beq.n	800dde8 <HAL_UART_IRQHandler+0x2b4>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800ddb4:	687b      	ldr	r3, [r7, #4]
 800ddb6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800ddba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ddbc:	687a      	ldr	r2, [r7, #4]
 800ddbe:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 800ddc2:	4610      	mov	r0, r2
 800ddc4:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800ddc6:	e00f      	b.n	800dde8 <HAL_UART_IRQHandler+0x2b4>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 800ddc8:	6878      	ldr	r0, [r7, #4]
 800ddca:	f000 f9d7 	bl	800e17c <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800ddce:	e00b      	b.n	800dde8 <HAL_UART_IRQHandler+0x2b4>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 800ddd0:	6878      	ldr	r0, [r7, #4]
 800ddd2:	f000 f9d3 	bl	800e17c <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800ddd6:	e007      	b.n	800dde8 <HAL_UART_IRQHandler+0x2b4>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 800ddd8:	6878      	ldr	r0, [r7, #4]
 800ddda:	f000 f9cf 	bl	800e17c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ddde:	687b      	ldr	r3, [r7, #4]
 800dde0:	2200      	movs	r2, #0
 800dde2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      }
    }
    return;
 800dde6:	e1bf      	b.n	800e168 <HAL_UART_IRQHandler+0x634>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800dde8:	bf00      	nop
    return;
 800ddea:	e1bd      	b.n	800e168 <HAL_UART_IRQHandler+0x634>
 800ddec:	10000001 	.word	0x10000001
 800ddf0:	04000120 	.word	0x04000120
 800ddf4:	0800e4b9 	.word	0x0800e4b9

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ddf8:	687b      	ldr	r3, [r7, #4]
 800ddfa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ddfc:	2b01      	cmp	r3, #1
 800ddfe:	f040 8153 	bne.w	800e0a8 <HAL_UART_IRQHandler+0x574>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 800de02:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800de06:	f003 0310 	and.w	r3, r3, #16
 800de0a:	2b00      	cmp	r3, #0
 800de0c:	f000 814c 	beq.w	800e0a8 <HAL_UART_IRQHandler+0x574>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 800de10:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800de14:	f003 0310 	and.w	r3, r3, #16
 800de18:	2b00      	cmp	r3, #0
 800de1a:	f000 8145 	beq.w	800e0a8 <HAL_UART_IRQHandler+0x574>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800de1e:	687b      	ldr	r3, [r7, #4]
 800de20:	681b      	ldr	r3, [r3, #0]
 800de22:	2210      	movs	r2, #16
 800de24:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800de26:	687b      	ldr	r3, [r7, #4]
 800de28:	681b      	ldr	r3, [r3, #0]
 800de2a:	689b      	ldr	r3, [r3, #8]
 800de2c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800de30:	2b40      	cmp	r3, #64	; 0x40
 800de32:	f040 80bb 	bne.w	800dfac <HAL_UART_IRQHandler+0x478>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 800de36:	687b      	ldr	r3, [r7, #4]
 800de38:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800de3c:	681b      	ldr	r3, [r3, #0]
 800de3e:	685b      	ldr	r3, [r3, #4]
 800de40:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
      if ((nb_remaining_rx_data > 0U)
 800de44:	f8b7 30be 	ldrh.w	r3, [r7, #190]	; 0xbe
 800de48:	2b00      	cmp	r3, #0
 800de4a:	f000 818f 	beq.w	800e16c <HAL_UART_IRQHandler+0x638>
          && (nb_remaining_rx_data < huart->RxXferSize))
 800de4e:	687b      	ldr	r3, [r7, #4]
 800de50:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800de54:	f8b7 20be 	ldrh.w	r2, [r7, #190]	; 0xbe
 800de58:	429a      	cmp	r2, r3
 800de5a:	f080 8187 	bcs.w	800e16c <HAL_UART_IRQHandler+0x638>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 800de5e:	687b      	ldr	r3, [r7, #4]
 800de60:	f8b7 20be 	ldrh.w	r2, [r7, #190]	; 0xbe
 800de64:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 800de68:	687b      	ldr	r3, [r7, #4]
 800de6a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800de6e:	681b      	ldr	r3, [r3, #0]
 800de70:	681b      	ldr	r3, [r3, #0]
 800de72:	f003 0320 	and.w	r3, r3, #32
 800de76:	2b00      	cmp	r3, #0
 800de78:	f040 8087 	bne.w	800df8a <HAL_UART_IRQHandler+0x456>
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800de7c:	687b      	ldr	r3, [r7, #4]
 800de7e:	681b      	ldr	r3, [r3, #0]
 800de80:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800de84:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800de88:	e853 3f00 	ldrex	r3, [r3]
 800de8c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
   return(result);
 800de90:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800de94:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800de98:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 800de9c:	687b      	ldr	r3, [r7, #4]
 800de9e:	681b      	ldr	r3, [r3, #0]
 800dea0:	461a      	mov	r2, r3
 800dea2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800dea6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800deaa:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800deae:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 800deb2:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800deb6:	e841 2300 	strex	r3, r2, [r1]
 800deba:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   return(result);
 800debe:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800dec2:	2b00      	cmp	r3, #0
 800dec4:	d1da      	bne.n	800de7c <HAL_UART_IRQHandler+0x348>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800dec6:	687b      	ldr	r3, [r7, #4]
 800dec8:	681b      	ldr	r3, [r3, #0]
 800deca:	3308      	adds	r3, #8
 800decc:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800dece:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ded0:	e853 3f00 	ldrex	r3, [r3]
 800ded4:	673b      	str	r3, [r7, #112]	; 0x70
   return(result);
 800ded6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800ded8:	f023 0301 	bic.w	r3, r3, #1
 800dedc:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 800dee0:	687b      	ldr	r3, [r7, #4]
 800dee2:	681b      	ldr	r3, [r3, #0]
 800dee4:	3308      	adds	r3, #8
 800dee6:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 800deea:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 800deee:	67fb      	str	r3, [r7, #124]	; 0x7c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800def0:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 800def2:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800def6:	e841 2300 	strex	r3, r2, [r1]
 800defa:	67bb      	str	r3, [r7, #120]	; 0x78
   return(result);
 800defc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800defe:	2b00      	cmp	r3, #0
 800df00:	d1e1      	bne.n	800dec6 <HAL_UART_IRQHandler+0x392>

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800df02:	687b      	ldr	r3, [r7, #4]
 800df04:	681b      	ldr	r3, [r3, #0]
 800df06:	3308      	adds	r3, #8
 800df08:	663b      	str	r3, [r7, #96]	; 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800df0a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800df0c:	e853 3f00 	ldrex	r3, [r3]
 800df10:	65fb      	str	r3, [r7, #92]	; 0x5c
   return(result);
 800df12:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800df14:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800df18:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 800df1c:	687b      	ldr	r3, [r7, #4]
 800df1e:	681b      	ldr	r3, [r3, #0]
 800df20:	3308      	adds	r3, #8
 800df22:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800df26:	66fa      	str	r2, [r7, #108]	; 0x6c
 800df28:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800df2a:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800df2c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800df2e:	e841 2300 	strex	r3, r2, [r1]
 800df32:	667b      	str	r3, [r7, #100]	; 0x64
   return(result);
 800df34:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800df36:	2b00      	cmp	r3, #0
 800df38:	d1e3      	bne.n	800df02 <HAL_UART_IRQHandler+0x3ce>

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 800df3a:	687b      	ldr	r3, [r7, #4]
 800df3c:	2220      	movs	r2, #32
 800df3e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800df42:	687b      	ldr	r3, [r7, #4]
 800df44:	2200      	movs	r2, #0
 800df46:	66da      	str	r2, [r3, #108]	; 0x6c

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800df48:	687b      	ldr	r3, [r7, #4]
 800df4a:	681b      	ldr	r3, [r3, #0]
 800df4c:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800df4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800df50:	e853 3f00 	ldrex	r3, [r3]
 800df54:	64bb      	str	r3, [r7, #72]	; 0x48
   return(result);
 800df56:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800df58:	f023 0310 	bic.w	r3, r3, #16
 800df5c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800df60:	687b      	ldr	r3, [r7, #4]
 800df62:	681b      	ldr	r3, [r3, #0]
 800df64:	461a      	mov	r2, r3
 800df66:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800df6a:	65bb      	str	r3, [r7, #88]	; 0x58
 800df6c:	657a      	str	r2, [r7, #84]	; 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800df6e:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800df70:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800df72:	e841 2300 	strex	r3, r2, [r1]
 800df76:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 800df78:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800df7a:	2b00      	cmp	r3, #0
 800df7c:	d1e4      	bne.n	800df48 <HAL_UART_IRQHandler+0x414>

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 800df7e:	687b      	ldr	r3, [r7, #4]
 800df80:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800df84:	4618      	mov	r0, r3
 800df86:	f7fb fca8 	bl	80098da <HAL_DMA_Abort>
        }

        /* Initialize type of RxEvent that correspond to RxEvent callback execution;
           In this case, Rx Event type is Idle Event */
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 800df8a:	687b      	ldr	r3, [r7, #4]
 800df8c:	2202      	movs	r2, #2
 800df8e:	671a      	str	r2, [r3, #112]	; 0x70
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 800df90:	687b      	ldr	r3, [r7, #4]
 800df92:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800df96:	687b      	ldr	r3, [r7, #4]
 800df98:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800df9c:	b29b      	uxth	r3, r3
 800df9e:	1ad3      	subs	r3, r2, r3
 800dfa0:	b29b      	uxth	r3, r3
 800dfa2:	4619      	mov	r1, r3
 800dfa4:	6878      	ldr	r0, [r7, #4]
 800dfa6:	f000 f8f3 	bl	800e190 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 800dfaa:	e0df      	b.n	800e16c <HAL_UART_IRQHandler+0x638>
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 800dfac:	687b      	ldr	r3, [r7, #4]
 800dfae:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 800dfb2:	687b      	ldr	r3, [r7, #4]
 800dfb4:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800dfb8:	b29b      	uxth	r3, r3
 800dfba:	1ad3      	subs	r3, r2, r3
 800dfbc:	f8a7 30ce 	strh.w	r3, [r7, #206]	; 0xce
      if ((huart->RxXferCount > 0U)
 800dfc0:	687b      	ldr	r3, [r7, #4]
 800dfc2:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800dfc6:	b29b      	uxth	r3, r3
 800dfc8:	2b00      	cmp	r3, #0
 800dfca:	f000 80d1 	beq.w	800e170 <HAL_UART_IRQHandler+0x63c>
          && (nb_rx_data > 0U))
 800dfce:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	; 0xce
 800dfd2:	2b00      	cmp	r3, #0
 800dfd4:	f000 80cc 	beq.w	800e170 <HAL_UART_IRQHandler+0x63c>
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800dfd8:	687b      	ldr	r3, [r7, #4]
 800dfda:	681b      	ldr	r3, [r3, #0]
 800dfdc:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800dfde:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800dfe0:	e853 3f00 	ldrex	r3, [r3]
 800dfe4:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 800dfe6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dfe8:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800dfec:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 800dff0:	687b      	ldr	r3, [r7, #4]
 800dff2:	681b      	ldr	r3, [r3, #0]
 800dff4:	461a      	mov	r2, r3
 800dff6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800dffa:	647b      	str	r3, [r7, #68]	; 0x44
 800dffc:	643a      	str	r2, [r7, #64]	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800dffe:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800e000:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e002:	e841 2300 	strex	r3, r2, [r1]
 800e006:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800e008:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e00a:	2b00      	cmp	r3, #0
 800e00c:	d1e4      	bne.n	800dfd8 <HAL_UART_IRQHandler+0x4a4>

        /* Disable the UART Error Interrupt:(Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800e00e:	687b      	ldr	r3, [r7, #4]
 800e010:	681b      	ldr	r3, [r3, #0]
 800e012:	3308      	adds	r3, #8
 800e014:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e016:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e018:	e853 3f00 	ldrex	r3, [r3]
 800e01c:	623b      	str	r3, [r7, #32]
   return(result);
 800e01e:	6a3b      	ldr	r3, [r7, #32]
 800e020:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800e024:	f023 0301 	bic.w	r3, r3, #1
 800e028:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 800e02c:	687b      	ldr	r3, [r7, #4]
 800e02e:	681b      	ldr	r3, [r3, #0]
 800e030:	3308      	adds	r3, #8
 800e032:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800e036:	633a      	str	r2, [r7, #48]	; 0x30
 800e038:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e03a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800e03c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e03e:	e841 2300 	strex	r3, r2, [r1]
 800e042:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800e044:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e046:	2b00      	cmp	r3, #0
 800e048:	d1e1      	bne.n	800e00e <HAL_UART_IRQHandler+0x4da>

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 800e04a:	687b      	ldr	r3, [r7, #4]
 800e04c:	2220      	movs	r2, #32
 800e04e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e052:	687b      	ldr	r3, [r7, #4]
 800e054:	2200      	movs	r2, #0
 800e056:	66da      	str	r2, [r3, #108]	; 0x6c

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 800e058:	687b      	ldr	r3, [r7, #4]
 800e05a:	2200      	movs	r2, #0
 800e05c:	675a      	str	r2, [r3, #116]	; 0x74

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	681b      	ldr	r3, [r3, #0]
 800e062:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e064:	693b      	ldr	r3, [r7, #16]
 800e066:	e853 3f00 	ldrex	r3, [r3]
 800e06a:	60fb      	str	r3, [r7, #12]
   return(result);
 800e06c:	68fb      	ldr	r3, [r7, #12]
 800e06e:	f023 0310 	bic.w	r3, r3, #16
 800e072:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 800e076:	687b      	ldr	r3, [r7, #4]
 800e078:	681b      	ldr	r3, [r3, #0]
 800e07a:	461a      	mov	r2, r3
 800e07c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800e080:	61fb      	str	r3, [r7, #28]
 800e082:	61ba      	str	r2, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e084:	69b9      	ldr	r1, [r7, #24]
 800e086:	69fa      	ldr	r2, [r7, #28]
 800e088:	e841 2300 	strex	r3, r2, [r1]
 800e08c:	617b      	str	r3, [r7, #20]
   return(result);
 800e08e:	697b      	ldr	r3, [r7, #20]
 800e090:	2b00      	cmp	r3, #0
 800e092:	d1e4      	bne.n	800e05e <HAL_UART_IRQHandler+0x52a>

        /* Initialize type of RxEvent that correspond to RxEvent callback execution;
           In this case, Rx Event type is Idle Event */
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 800e094:	687b      	ldr	r3, [r7, #4]
 800e096:	2202      	movs	r2, #2
 800e098:	671a      	str	r2, [r3, #112]	; 0x70
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 800e09a:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	; 0xce
 800e09e:	4619      	mov	r1, r3
 800e0a0:	6878      	ldr	r0, [r7, #4]
 800e0a2:	f000 f875 	bl	800e190 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 800e0a6:	e063      	b.n	800e170 <HAL_UART_IRQHandler+0x63c>
    }
  }

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 800e0a8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e0ac:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800e0b0:	2b00      	cmp	r3, #0
 800e0b2:	d00e      	beq.n	800e0d2 <HAL_UART_IRQHandler+0x59e>
 800e0b4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800e0b8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800e0bc:	2b00      	cmp	r3, #0
 800e0be:	d008      	beq.n	800e0d2 <HAL_UART_IRQHandler+0x59e>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 800e0c0:	687b      	ldr	r3, [r7, #4]
 800e0c2:	681b      	ldr	r3, [r3, #0]
 800e0c4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800e0c8:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 800e0ca:	6878      	ldr	r0, [r7, #4]
 800e0cc:	f000 ff52 	bl	800ef74 <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 800e0d0:	e051      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 800e0d2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e0d6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e0da:	2b00      	cmp	r3, #0
 800e0dc:	d014      	beq.n	800e108 <HAL_UART_IRQHandler+0x5d4>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 800e0de:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800e0e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d105      	bne.n	800e0f6 <HAL_UART_IRQHandler+0x5c2>
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 800e0ea:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800e0ee:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800e0f2:	2b00      	cmp	r3, #0
 800e0f4:	d008      	beq.n	800e108 <HAL_UART_IRQHandler+0x5d4>
  {
    if (huart->TxISR != NULL)
 800e0f6:	687b      	ldr	r3, [r7, #4]
 800e0f8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e0fa:	2b00      	cmp	r3, #0
 800e0fc:	d03a      	beq.n	800e174 <HAL_UART_IRQHandler+0x640>
    {
      huart->TxISR(huart);
 800e0fe:	687b      	ldr	r3, [r7, #4]
 800e100:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e102:	6878      	ldr	r0, [r7, #4]
 800e104:	4798      	blx	r3
    }
    return;
 800e106:	e035      	b.n	800e174 <HAL_UART_IRQHandler+0x640>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800e108:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e10c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e110:	2b00      	cmp	r3, #0
 800e112:	d009      	beq.n	800e128 <HAL_UART_IRQHandler+0x5f4>
 800e114:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800e118:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e11c:	2b00      	cmp	r3, #0
 800e11e:	d003      	beq.n	800e128 <HAL_UART_IRQHandler+0x5f4>
  {
    UART_EndTransmit_IT(huart);
 800e120:	6878      	ldr	r0, [r7, #4]
 800e122:	f000 f9df 	bl	800e4e4 <UART_EndTransmit_IT>
    return;
 800e126:	e026      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
  }

  /* UART TX Fifo Empty occurred ----------------------------------------------*/
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 800e128:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e12c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800e130:	2b00      	cmp	r3, #0
 800e132:	d009      	beq.n	800e148 <HAL_UART_IRQHandler+0x614>
 800e134:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800e138:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 800e13c:	2b00      	cmp	r3, #0
 800e13e:	d003      	beq.n	800e148 <HAL_UART_IRQHandler+0x614>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Tx Fifo Empty Callback */
    huart->TxFifoEmptyCallback(huart);
#else
    /* Call legacy weak Tx Fifo Empty Callback */
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 800e140:	6878      	ldr	r0, [r7, #4]
 800e142:	f000 ff2b 	bl	800ef9c <HAL_UARTEx_TxFifoEmptyCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 800e146:	e016      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
  }

  /* UART RX Fifo Full occurred ----------------------------------------------*/
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 800e148:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800e14c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800e150:	2b00      	cmp	r3, #0
 800e152:	d010      	beq.n	800e176 <HAL_UART_IRQHandler+0x642>
 800e154:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800e158:	2b00      	cmp	r3, #0
 800e15a:	da0c      	bge.n	800e176 <HAL_UART_IRQHandler+0x642>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Rx Fifo Full Callback */
    huart->RxFifoFullCallback(huart);
#else
    /* Call legacy weak Rx Fifo Full Callback */
    HAL_UARTEx_RxFifoFullCallback(huart);
 800e15c:	6878      	ldr	r0, [r7, #4]
 800e15e:	f000 ff13 	bl	800ef88 <HAL_UARTEx_RxFifoFullCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 800e162:	e008      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
      return;
 800e164:	bf00      	nop
 800e166:	e006      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
    return;
 800e168:	bf00      	nop
 800e16a:	e004      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
      return;
 800e16c:	bf00      	nop
 800e16e:	e002      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
      return;
 800e170:	bf00      	nop
 800e172:	e000      	b.n	800e176 <HAL_UART_IRQHandler+0x642>
    return;
 800e174:	bf00      	nop
  }
}
 800e176:	37e8      	adds	r7, #232	; 0xe8
 800e178:	46bd      	mov	sp, r7
 800e17a:	bd80      	pop	{r7, pc}

0800e17c <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 800e17c:	b480      	push	{r7}
 800e17e:	b083      	sub	sp, #12
 800e180:	af00      	add	r7, sp, #0
 800e182:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 800e184:	bf00      	nop
 800e186:	370c      	adds	r7, #12
 800e188:	46bd      	mov	sp, r7
 800e18a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e18e:	4770      	bx	lr

0800e190 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 800e190:	b480      	push	{r7}
 800e192:	b083      	sub	sp, #12
 800e194:	af00      	add	r7, sp, #0
 800e196:	6078      	str	r0, [r7, #4]
 800e198:	460b      	mov	r3, r1
 800e19a:	807b      	strh	r3, [r7, #2]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 800e19c:	bf00      	nop
 800e19e:	370c      	adds	r7, #12
 800e1a0:	46bd      	mov	sp, r7
 800e1a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e1a6:	4770      	bx	lr

0800e1a8 <UART_Start_Receive_IT>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 800e1a8:	b480      	push	{r7}
 800e1aa:	b0a3      	sub	sp, #140	; 0x8c
 800e1ac:	af00      	add	r7, sp, #0
 800e1ae:	60f8      	str	r0, [r7, #12]
 800e1b0:	60b9      	str	r1, [r7, #8]
 800e1b2:	4613      	mov	r3, r2
 800e1b4:	80fb      	strh	r3, [r7, #6]
  huart->pRxBuffPtr  = pData;
 800e1b6:	68fb      	ldr	r3, [r7, #12]
 800e1b8:	68ba      	ldr	r2, [r7, #8]
 800e1ba:	659a      	str	r2, [r3, #88]	; 0x58
  huart->RxXferSize  = Size;
 800e1bc:	68fb      	ldr	r3, [r7, #12]
 800e1be:	88fa      	ldrh	r2, [r7, #6]
 800e1c0:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
  huart->RxXferCount = Size;
 800e1c4:	68fb      	ldr	r3, [r7, #12]
 800e1c6:	88fa      	ldrh	r2, [r7, #6]
 800e1c8:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
  huart->RxISR       = NULL;
 800e1cc:	68fb      	ldr	r3, [r7, #12]
 800e1ce:	2200      	movs	r2, #0
 800e1d0:	675a      	str	r2, [r3, #116]	; 0x74

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 800e1d2:	68fb      	ldr	r3, [r7, #12]
 800e1d4:	689b      	ldr	r3, [r3, #8]
 800e1d6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e1da:	d10e      	bne.n	800e1fa <UART_Start_Receive_IT+0x52>
 800e1dc:	68fb      	ldr	r3, [r7, #12]
 800e1de:	691b      	ldr	r3, [r3, #16]
 800e1e0:	2b00      	cmp	r3, #0
 800e1e2:	d105      	bne.n	800e1f0 <UART_Start_Receive_IT+0x48>
 800e1e4:	68fb      	ldr	r3, [r7, #12]
 800e1e6:	f240 12ff 	movw	r2, #511	; 0x1ff
 800e1ea:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
 800e1ee:	e02d      	b.n	800e24c <UART_Start_Receive_IT+0xa4>
 800e1f0:	68fb      	ldr	r3, [r7, #12]
 800e1f2:	22ff      	movs	r2, #255	; 0xff
 800e1f4:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
 800e1f8:	e028      	b.n	800e24c <UART_Start_Receive_IT+0xa4>
 800e1fa:	68fb      	ldr	r3, [r7, #12]
 800e1fc:	689b      	ldr	r3, [r3, #8]
 800e1fe:	2b00      	cmp	r3, #0
 800e200:	d10d      	bne.n	800e21e <UART_Start_Receive_IT+0x76>
 800e202:	68fb      	ldr	r3, [r7, #12]
 800e204:	691b      	ldr	r3, [r3, #16]
 800e206:	2b00      	cmp	r3, #0
 800e208:	d104      	bne.n	800e214 <UART_Start_Receive_IT+0x6c>
 800e20a:	68fb      	ldr	r3, [r7, #12]
 800e20c:	22ff      	movs	r2, #255	; 0xff
 800e20e:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
 800e212:	e01b      	b.n	800e24c <UART_Start_Receive_IT+0xa4>
 800e214:	68fb      	ldr	r3, [r7, #12]
 800e216:	227f      	movs	r2, #127	; 0x7f
 800e218:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
 800e21c:	e016      	b.n	800e24c <UART_Start_Receive_IT+0xa4>
 800e21e:	68fb      	ldr	r3, [r7, #12]
 800e220:	689b      	ldr	r3, [r3, #8]
 800e222:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800e226:	d10d      	bne.n	800e244 <UART_Start_Receive_IT+0x9c>
 800e228:	68fb      	ldr	r3, [r7, #12]
 800e22a:	691b      	ldr	r3, [r3, #16]
 800e22c:	2b00      	cmp	r3, #0
 800e22e:	d104      	bne.n	800e23a <UART_Start_Receive_IT+0x92>
 800e230:	68fb      	ldr	r3, [r7, #12]
 800e232:	227f      	movs	r2, #127	; 0x7f
 800e234:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
 800e238:	e008      	b.n	800e24c <UART_Start_Receive_IT+0xa4>
 800e23a:	68fb      	ldr	r3, [r7, #12]
 800e23c:	223f      	movs	r2, #63	; 0x3f
 800e23e:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
 800e242:	e003      	b.n	800e24c <UART_Start_Receive_IT+0xa4>
 800e244:	68fb      	ldr	r3, [r7, #12]
 800e246:	2200      	movs	r2, #0
 800e248:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e24c:	68fb      	ldr	r3, [r7, #12]
 800e24e:	2200      	movs	r2, #0
 800e250:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800e254:	68fb      	ldr	r3, [r7, #12]
 800e256:	2222      	movs	r2, #34	; 0x22
 800e258:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e25c:	68fb      	ldr	r3, [r7, #12]
 800e25e:	681b      	ldr	r3, [r3, #0]
 800e260:	3308      	adds	r3, #8
 800e262:	667b      	str	r3, [r7, #100]	; 0x64
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e264:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e266:	e853 3f00 	ldrex	r3, [r3]
 800e26a:	663b      	str	r3, [r7, #96]	; 0x60
   return(result);
 800e26c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e26e:	f043 0301 	orr.w	r3, r3, #1
 800e272:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800e276:	68fb      	ldr	r3, [r7, #12]
 800e278:	681b      	ldr	r3, [r3, #0]
 800e27a:	3308      	adds	r3, #8
 800e27c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800e280:	673a      	str	r2, [r7, #112]	; 0x70
 800e282:	66fb      	str	r3, [r7, #108]	; 0x6c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e284:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800e286:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800e288:	e841 2300 	strex	r3, r2, [r1]
 800e28c:	66bb      	str	r3, [r7, #104]	; 0x68
   return(result);
 800e28e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e290:	2b00      	cmp	r3, #0
 800e292:	d1e3      	bne.n	800e25c <UART_Start_Receive_IT+0xb4>

  /* Configure Rx interrupt processing */
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 800e294:	68fb      	ldr	r3, [r7, #12]
 800e296:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800e298:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800e29c:	d14f      	bne.n	800e33e <UART_Start_Receive_IT+0x196>
 800e29e:	68fb      	ldr	r3, [r7, #12]
 800e2a0:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800e2a4:	88fa      	ldrh	r2, [r7, #6]
 800e2a6:	429a      	cmp	r2, r3
 800e2a8:	d349      	bcc.n	800e33e <UART_Start_Receive_IT+0x196>
  {
    /* Set the Rx ISR function pointer according to the data word length */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e2aa:	68fb      	ldr	r3, [r7, #12]
 800e2ac:	689b      	ldr	r3, [r3, #8]
 800e2ae:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e2b2:	d107      	bne.n	800e2c4 <UART_Start_Receive_IT+0x11c>
 800e2b4:	68fb      	ldr	r3, [r7, #12]
 800e2b6:	691b      	ldr	r3, [r3, #16]
 800e2b8:	2b00      	cmp	r3, #0
 800e2ba:	d103      	bne.n	800e2c4 <UART_Start_Receive_IT+0x11c>
    {
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 800e2bc:	68fb      	ldr	r3, [r7, #12]
 800e2be:	4a47      	ldr	r2, [pc, #284]	; (800e3dc <UART_Start_Receive_IT+0x234>)
 800e2c0:	675a      	str	r2, [r3, #116]	; 0x74
 800e2c2:	e002      	b.n	800e2ca <UART_Start_Receive_IT+0x122>
    }
    else
    {
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 800e2c4:	68fb      	ldr	r3, [r7, #12]
 800e2c6:	4a46      	ldr	r2, [pc, #280]	; (800e3e0 <UART_Start_Receive_IT+0x238>)
 800e2c8:	675a      	str	r2, [r3, #116]	; 0x74
    }

    /* Enable the UART Parity Error interrupt and RX FIFO Threshold interrupt */
    if (huart->Init.Parity != UART_PARITY_NONE)
 800e2ca:	68fb      	ldr	r3, [r7, #12]
 800e2cc:	691b      	ldr	r3, [r3, #16]
 800e2ce:	2b00      	cmp	r3, #0
 800e2d0:	d01a      	beq.n	800e308 <UART_Start_Receive_IT+0x160>
    {
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800e2d2:	68fb      	ldr	r3, [r7, #12]
 800e2d4:	681b      	ldr	r3, [r3, #0]
 800e2d6:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e2d8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e2da:	e853 3f00 	ldrex	r3, [r3]
 800e2de:	64fb      	str	r3, [r7, #76]	; 0x4c
   return(result);
 800e2e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e2e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800e2e6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e2ea:	68fb      	ldr	r3, [r7, #12]
 800e2ec:	681b      	ldr	r3, [r3, #0]
 800e2ee:	461a      	mov	r2, r3
 800e2f0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e2f4:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e2f6:	65ba      	str	r2, [r7, #88]	; 0x58
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e2f8:	6db9      	ldr	r1, [r7, #88]	; 0x58
 800e2fa:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e2fc:	e841 2300 	strex	r3, r2, [r1]
 800e300:	657b      	str	r3, [r7, #84]	; 0x54
   return(result);
 800e302:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e304:	2b00      	cmp	r3, #0
 800e306:	d1e4      	bne.n	800e2d2 <UART_Start_Receive_IT+0x12a>
    }
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 800e308:	68fb      	ldr	r3, [r7, #12]
 800e30a:	681b      	ldr	r3, [r3, #0]
 800e30c:	3308      	adds	r3, #8
 800e30e:	63fb      	str	r3, [r7, #60]	; 0x3c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e310:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e312:	e853 3f00 	ldrex	r3, [r3]
 800e316:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 800e318:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e31a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800e31e:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e320:	68fb      	ldr	r3, [r7, #12]
 800e322:	681b      	ldr	r3, [r3, #0]
 800e324:	3308      	adds	r3, #8
 800e326:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800e328:	64ba      	str	r2, [r7, #72]	; 0x48
 800e32a:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e32c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800e32e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e330:	e841 2300 	strex	r3, r2, [r1]
 800e334:	643b      	str	r3, [r7, #64]	; 0x40
   return(result);
 800e336:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e338:	2b00      	cmp	r3, #0
 800e33a:	d1e5      	bne.n	800e308 <UART_Start_Receive_IT+0x160>
 800e33c:	e046      	b.n	800e3cc <UART_Start_Receive_IT+0x224>
  }
  else
  {
    /* Set the Rx ISR function pointer according to the data word length */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800e33e:	68fb      	ldr	r3, [r7, #12]
 800e340:	689b      	ldr	r3, [r3, #8]
 800e342:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e346:	d107      	bne.n	800e358 <UART_Start_Receive_IT+0x1b0>
 800e348:	68fb      	ldr	r3, [r7, #12]
 800e34a:	691b      	ldr	r3, [r3, #16]
 800e34c:	2b00      	cmp	r3, #0
 800e34e:	d103      	bne.n	800e358 <UART_Start_Receive_IT+0x1b0>
    {
      huart->RxISR = UART_RxISR_16BIT;
 800e350:	68fb      	ldr	r3, [r7, #12]
 800e352:	4a24      	ldr	r2, [pc, #144]	; (800e3e4 <UART_Start_Receive_IT+0x23c>)
 800e354:	675a      	str	r2, [r3, #116]	; 0x74
 800e356:	e002      	b.n	800e35e <UART_Start_Receive_IT+0x1b6>
    }
    else
    {
      huart->RxISR = UART_RxISR_8BIT;
 800e358:	68fb      	ldr	r3, [r7, #12]
 800e35a:	4a23      	ldr	r2, [pc, #140]	; (800e3e8 <UART_Start_Receive_IT+0x240>)
 800e35c:	675a      	str	r2, [r3, #116]	; 0x74
    }

    /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
    if (huart->Init.Parity != UART_PARITY_NONE)
 800e35e:	68fb      	ldr	r3, [r7, #12]
 800e360:	691b      	ldr	r3, [r3, #16]
 800e362:	2b00      	cmp	r3, #0
 800e364:	d019      	beq.n	800e39a <UART_Start_Receive_IT+0x1f2>
    {
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 800e366:	68fb      	ldr	r3, [r7, #12]
 800e368:	681b      	ldr	r3, [r3, #0]
 800e36a:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e36c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e36e:	e853 3f00 	ldrex	r3, [r3]
 800e372:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 800e374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e376:	f443 7390 	orr.w	r3, r3, #288	; 0x120
 800e37a:	677b      	str	r3, [r7, #116]	; 0x74
 800e37c:	68fb      	ldr	r3, [r7, #12]
 800e37e:	681b      	ldr	r3, [r3, #0]
 800e380:	461a      	mov	r2, r3
 800e382:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e384:	637b      	str	r3, [r7, #52]	; 0x34
 800e386:	633a      	str	r2, [r7, #48]	; 0x30
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e388:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800e38a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e38c:	e841 2300 	strex	r3, r2, [r1]
 800e390:	62fb      	str	r3, [r7, #44]	; 0x2c
   return(result);
 800e392:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e394:	2b00      	cmp	r3, #0
 800e396:	d1e6      	bne.n	800e366 <UART_Start_Receive_IT+0x1be>
 800e398:	e018      	b.n	800e3cc <UART_Start_Receive_IT+0x224>
    }
    else
    {
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 800e39a:	68fb      	ldr	r3, [r7, #12]
 800e39c:	681b      	ldr	r3, [r3, #0]
 800e39e:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e3a0:	697b      	ldr	r3, [r7, #20]
 800e3a2:	e853 3f00 	ldrex	r3, [r3]
 800e3a6:	613b      	str	r3, [r7, #16]
   return(result);
 800e3a8:	693b      	ldr	r3, [r7, #16]
 800e3aa:	f043 0320 	orr.w	r3, r3, #32
 800e3ae:	67bb      	str	r3, [r7, #120]	; 0x78
 800e3b0:	68fb      	ldr	r3, [r7, #12]
 800e3b2:	681b      	ldr	r3, [r3, #0]
 800e3b4:	461a      	mov	r2, r3
 800e3b6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800e3b8:	623b      	str	r3, [r7, #32]
 800e3ba:	61fa      	str	r2, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e3bc:	69f9      	ldr	r1, [r7, #28]
 800e3be:	6a3a      	ldr	r2, [r7, #32]
 800e3c0:	e841 2300 	strex	r3, r2, [r1]
 800e3c4:	61bb      	str	r3, [r7, #24]
   return(result);
 800e3c6:	69bb      	ldr	r3, [r7, #24]
 800e3c8:	2b00      	cmp	r3, #0
 800e3ca:	d1e6      	bne.n	800e39a <UART_Start_Receive_IT+0x1f2>
    }
  }
  return HAL_OK;
 800e3cc:	2300      	movs	r3, #0
}
 800e3ce:	4618      	mov	r0, r3
 800e3d0:	378c      	adds	r7, #140	; 0x8c
 800e3d2:	46bd      	mov	sp, r7
 800e3d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e3d8:	4770      	bx	lr
 800e3da:	bf00      	nop
 800e3dc:	0800ec0d 	.word	0x0800ec0d
 800e3e0:	0800e8ad 	.word	0x0800e8ad
 800e3e4:	0800e6f5 	.word	0x0800e6f5
 800e3e8:	0800e53d 	.word	0x0800e53d

0800e3ec <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800e3ec:	b480      	push	{r7}
 800e3ee:	b095      	sub	sp, #84	; 0x54
 800e3f0:	af00      	add	r7, sp, #0
 800e3f2:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800e3f4:	687b      	ldr	r3, [r7, #4]
 800e3f6:	681b      	ldr	r3, [r3, #0]
 800e3f8:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e3fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e3fc:	e853 3f00 	ldrex	r3, [r3]
 800e400:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 800e402:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e404:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800e408:	64fb      	str	r3, [r7, #76]	; 0x4c
 800e40a:	687b      	ldr	r3, [r7, #4]
 800e40c:	681b      	ldr	r3, [r3, #0]
 800e40e:	461a      	mov	r2, r3
 800e410:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e412:	643b      	str	r3, [r7, #64]	; 0x40
 800e414:	63fa      	str	r2, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e416:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800e418:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e41a:	e841 2300 	strex	r3, r2, [r1]
 800e41e:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 800e420:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e422:	2b00      	cmp	r3, #0
 800e424:	d1e6      	bne.n	800e3f4 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800e426:	687b      	ldr	r3, [r7, #4]
 800e428:	681b      	ldr	r3, [r3, #0]
 800e42a:	3308      	adds	r3, #8
 800e42c:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e42e:	6a3b      	ldr	r3, [r7, #32]
 800e430:	e853 3f00 	ldrex	r3, [r3]
 800e434:	61fb      	str	r3, [r7, #28]
   return(result);
 800e436:	69fb      	ldr	r3, [r7, #28]
 800e438:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800e43c:	f023 0301 	bic.w	r3, r3, #1
 800e440:	64bb      	str	r3, [r7, #72]	; 0x48
 800e442:	687b      	ldr	r3, [r7, #4]
 800e444:	681b      	ldr	r3, [r3, #0]
 800e446:	3308      	adds	r3, #8
 800e448:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800e44a:	62fa      	str	r2, [r7, #44]	; 0x2c
 800e44c:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e44e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e450:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e452:	e841 2300 	strex	r3, r2, [r1]
 800e456:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 800e458:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e45a:	2b00      	cmp	r3, #0
 800e45c:	d1e3      	bne.n	800e426 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800e45e:	687b      	ldr	r3, [r7, #4]
 800e460:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e462:	2b01      	cmp	r3, #1
 800e464:	d118      	bne.n	800e498 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800e466:	687b      	ldr	r3, [r7, #4]
 800e468:	681b      	ldr	r3, [r3, #0]
 800e46a:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e46c:	68fb      	ldr	r3, [r7, #12]
 800e46e:	e853 3f00 	ldrex	r3, [r3]
 800e472:	60bb      	str	r3, [r7, #8]
   return(result);
 800e474:	68bb      	ldr	r3, [r7, #8]
 800e476:	f023 0310 	bic.w	r3, r3, #16
 800e47a:	647b      	str	r3, [r7, #68]	; 0x44
 800e47c:	687b      	ldr	r3, [r7, #4]
 800e47e:	681b      	ldr	r3, [r3, #0]
 800e480:	461a      	mov	r2, r3
 800e482:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e484:	61bb      	str	r3, [r7, #24]
 800e486:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e488:	6979      	ldr	r1, [r7, #20]
 800e48a:	69ba      	ldr	r2, [r7, #24]
 800e48c:	e841 2300 	strex	r3, r2, [r1]
 800e490:	613b      	str	r3, [r7, #16]
   return(result);
 800e492:	693b      	ldr	r3, [r7, #16]
 800e494:	2b00      	cmp	r3, #0
 800e496:	d1e6      	bne.n	800e466 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800e498:	687b      	ldr	r3, [r7, #4]
 800e49a:	2220      	movs	r2, #32
 800e49c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e4a0:	687b      	ldr	r3, [r7, #4]
 800e4a2:	2200      	movs	r2, #0
 800e4a4:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800e4a6:	687b      	ldr	r3, [r7, #4]
 800e4a8:	2200      	movs	r2, #0
 800e4aa:	675a      	str	r2, [r3, #116]	; 0x74
}
 800e4ac:	bf00      	nop
 800e4ae:	3754      	adds	r7, #84	; 0x54
 800e4b0:	46bd      	mov	sp, r7
 800e4b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4b6:	4770      	bx	lr

0800e4b8 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 800e4b8:	b580      	push	{r7, lr}
 800e4ba:	b084      	sub	sp, #16
 800e4bc:	af00      	add	r7, sp, #0
 800e4be:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800e4c0:	687b      	ldr	r3, [r7, #4]
 800e4c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e4c4:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 800e4c6:	68fb      	ldr	r3, [r7, #12]
 800e4c8:	2200      	movs	r2, #0
 800e4ca:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
  huart->TxXferCount = 0U;
 800e4ce:	68fb      	ldr	r3, [r7, #12]
 800e4d0:	2200      	movs	r2, #0
 800e4d2:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800e4d6:	68f8      	ldr	r0, [r7, #12]
 800e4d8:	f7ff fe50 	bl	800e17c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800e4dc:	bf00      	nop
 800e4de:	3710      	adds	r7, #16
 800e4e0:	46bd      	mov	sp, r7
 800e4e2:	bd80      	pop	{r7, pc}

0800e4e4 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 800e4e4:	b580      	push	{r7, lr}
 800e4e6:	b088      	sub	sp, #32
 800e4e8:	af00      	add	r7, sp, #0
 800e4ea:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800e4ec:	687b      	ldr	r3, [r7, #4]
 800e4ee:	681b      	ldr	r3, [r3, #0]
 800e4f0:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e4f2:	68fb      	ldr	r3, [r7, #12]
 800e4f4:	e853 3f00 	ldrex	r3, [r3]
 800e4f8:	60bb      	str	r3, [r7, #8]
   return(result);
 800e4fa:	68bb      	ldr	r3, [r7, #8]
 800e4fc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800e500:	61fb      	str	r3, [r7, #28]
 800e502:	687b      	ldr	r3, [r7, #4]
 800e504:	681b      	ldr	r3, [r3, #0]
 800e506:	461a      	mov	r2, r3
 800e508:	69fb      	ldr	r3, [r7, #28]
 800e50a:	61bb      	str	r3, [r7, #24]
 800e50c:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e50e:	6979      	ldr	r1, [r7, #20]
 800e510:	69ba      	ldr	r2, [r7, #24]
 800e512:	e841 2300 	strex	r3, r2, [r1]
 800e516:	613b      	str	r3, [r7, #16]
   return(result);
 800e518:	693b      	ldr	r3, [r7, #16]
 800e51a:	2b00      	cmp	r3, #0
 800e51c:	d1e6      	bne.n	800e4ec <UART_EndTransmit_IT+0x8>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800e51e:	687b      	ldr	r3, [r7, #4]
 800e520:	2220      	movs	r2, #32
 800e522:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800e526:	687b      	ldr	r3, [r7, #4]
 800e528:	2200      	movs	r2, #0
 800e52a:	679a      	str	r2, [r3, #120]	; 0x78
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800e52c:	6878      	ldr	r0, [r7, #4]
 800e52e:	f7f9 f8b7 	bl	80076a0 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800e532:	bf00      	nop
 800e534:	3720      	adds	r7, #32
 800e536:	46bd      	mov	sp, r7
 800e538:	bd80      	pop	{r7, pc}
	...

0800e53c <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 800e53c:	b580      	push	{r7, lr}
 800e53e:	b09c      	sub	sp, #112	; 0x70
 800e540:	af00      	add	r7, sp, #0
 800e542:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 800e544:	687b      	ldr	r3, [r7, #4]
 800e546:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 800e54a:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800e54e:	687b      	ldr	r3, [r7, #4]
 800e550:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800e554:	2b22      	cmp	r3, #34	; 0x22
 800e556:	f040 80be 	bne.w	800e6d6 <UART_RxISR_8BIT+0x19a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800e55a:	687b      	ldr	r3, [r7, #4]
 800e55c:	681b      	ldr	r3, [r3, #0]
 800e55e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e560:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 800e564:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 800e568:	b2d9      	uxtb	r1, r3
 800e56a:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 800e56e:	b2da      	uxtb	r2, r3
 800e570:	687b      	ldr	r3, [r7, #4]
 800e572:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e574:	400a      	ands	r2, r1
 800e576:	b2d2      	uxtb	r2, r2
 800e578:	701a      	strb	r2, [r3, #0]
    huart->pRxBuffPtr++;
 800e57a:	687b      	ldr	r3, [r7, #4]
 800e57c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e57e:	1c5a      	adds	r2, r3, #1
 800e580:	687b      	ldr	r3, [r7, #4]
 800e582:	659a      	str	r2, [r3, #88]	; 0x58
    huart->RxXferCount--;
 800e584:	687b      	ldr	r3, [r7, #4]
 800e586:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800e58a:	b29b      	uxth	r3, r3
 800e58c:	3b01      	subs	r3, #1
 800e58e:	b29a      	uxth	r2, r3
 800e590:	687b      	ldr	r3, [r7, #4]
 800e592:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800e59c:	b29b      	uxth	r3, r3
 800e59e:	2b00      	cmp	r3, #0
 800e5a0:	f040 80a1 	bne.w	800e6e6 <UART_RxISR_8BIT+0x1aa>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800e5a4:	687b      	ldr	r3, [r7, #4]
 800e5a6:	681b      	ldr	r3, [r3, #0]
 800e5a8:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e5aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e5ac:	e853 3f00 	ldrex	r3, [r3]
 800e5b0:	64bb      	str	r3, [r7, #72]	; 0x48
   return(result);
 800e5b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e5b4:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800e5b8:	66bb      	str	r3, [r7, #104]	; 0x68
 800e5ba:	687b      	ldr	r3, [r7, #4]
 800e5bc:	681b      	ldr	r3, [r3, #0]
 800e5be:	461a      	mov	r2, r3
 800e5c0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e5c2:	65bb      	str	r3, [r7, #88]	; 0x58
 800e5c4:	657a      	str	r2, [r7, #84]	; 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e5c6:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800e5c8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e5ca:	e841 2300 	strex	r3, r2, [r1]
 800e5ce:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 800e5d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5d2:	2b00      	cmp	r3, #0
 800e5d4:	d1e6      	bne.n	800e5a4 <UART_RxISR_8BIT+0x68>

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	681b      	ldr	r3, [r3, #0]
 800e5da:	3308      	adds	r3, #8
 800e5dc:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e5de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e5e0:	e853 3f00 	ldrex	r3, [r3]
 800e5e4:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 800e5e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e5e8:	f023 0301 	bic.w	r3, r3, #1
 800e5ec:	667b      	str	r3, [r7, #100]	; 0x64
 800e5ee:	687b      	ldr	r3, [r7, #4]
 800e5f0:	681b      	ldr	r3, [r3, #0]
 800e5f2:	3308      	adds	r3, #8
 800e5f4:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800e5f6:	647a      	str	r2, [r7, #68]	; 0x44
 800e5f8:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e5fa:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800e5fc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e5fe:	e841 2300 	strex	r3, r2, [r1]
 800e602:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800e604:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e606:	2b00      	cmp	r3, #0
 800e608:	d1e5      	bne.n	800e5d6 <UART_RxISR_8BIT+0x9a>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800e60a:	687b      	ldr	r3, [r7, #4]
 800e60c:	2220      	movs	r2, #32
 800e60e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800e612:	687b      	ldr	r3, [r7, #4]
 800e614:	2200      	movs	r2, #0
 800e616:	675a      	str	r2, [r3, #116]	; 0x74

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 800e618:	687b      	ldr	r3, [r7, #4]
 800e61a:	2200      	movs	r2, #0
 800e61c:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(LPUART1)
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800e61e:	687b      	ldr	r3, [r7, #4]
 800e620:	681b      	ldr	r3, [r3, #0]
 800e622:	4a33      	ldr	r2, [pc, #204]	; (800e6f0 <UART_RxISR_8BIT+0x1b4>)
 800e624:	4293      	cmp	r3, r2
 800e626:	d01f      	beq.n	800e668 <UART_RxISR_8BIT+0x12c>
      {
        /* Check that USART RTOEN bit is set */
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800e628:	687b      	ldr	r3, [r7, #4]
 800e62a:	681b      	ldr	r3, [r3, #0]
 800e62c:	685b      	ldr	r3, [r3, #4]
 800e62e:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800e632:	2b00      	cmp	r3, #0
 800e634:	d018      	beq.n	800e668 <UART_RxISR_8BIT+0x12c>
        {
          /* Enable the UART Receiver Timeout Interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800e636:	687b      	ldr	r3, [r7, #4]
 800e638:	681b      	ldr	r3, [r3, #0]
 800e63a:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e63c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e63e:	e853 3f00 	ldrex	r3, [r3]
 800e642:	623b      	str	r3, [r7, #32]
   return(result);
 800e644:	6a3b      	ldr	r3, [r7, #32]
 800e646:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800e64a:	663b      	str	r3, [r7, #96]	; 0x60
 800e64c:	687b      	ldr	r3, [r7, #4]
 800e64e:	681b      	ldr	r3, [r3, #0]
 800e650:	461a      	mov	r2, r3
 800e652:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e654:	633b      	str	r3, [r7, #48]	; 0x30
 800e656:	62fa      	str	r2, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e658:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800e65a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e65c:	e841 2300 	strex	r3, r2, [r1]
 800e660:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800e662:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e664:	2b00      	cmp	r3, #0
 800e666:	d1e6      	bne.n	800e636 <UART_RxISR_8BIT+0xfa>
      }
#endif /* LPUART1 */

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800e668:	687b      	ldr	r3, [r7, #4]
 800e66a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e66c:	2b01      	cmp	r3, #1
 800e66e:	d12e      	bne.n	800e6ce <UART_RxISR_8BIT+0x192>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e670:	687b      	ldr	r3, [r7, #4]
 800e672:	2200      	movs	r2, #0
 800e674:	66da      	str	r2, [r3, #108]	; 0x6c

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800e676:	687b      	ldr	r3, [r7, #4]
 800e678:	681b      	ldr	r3, [r3, #0]
 800e67a:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e67c:	693b      	ldr	r3, [r7, #16]
 800e67e:	e853 3f00 	ldrex	r3, [r3]
 800e682:	60fb      	str	r3, [r7, #12]
   return(result);
 800e684:	68fb      	ldr	r3, [r7, #12]
 800e686:	f023 0310 	bic.w	r3, r3, #16
 800e68a:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e68c:	687b      	ldr	r3, [r7, #4]
 800e68e:	681b      	ldr	r3, [r3, #0]
 800e690:	461a      	mov	r2, r3
 800e692:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e694:	61fb      	str	r3, [r7, #28]
 800e696:	61ba      	str	r2, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e698:	69b9      	ldr	r1, [r7, #24]
 800e69a:	69fa      	ldr	r2, [r7, #28]
 800e69c:	e841 2300 	strex	r3, r2, [r1]
 800e6a0:	617b      	str	r3, [r7, #20]
   return(result);
 800e6a2:	697b      	ldr	r3, [r7, #20]
 800e6a4:	2b00      	cmp	r3, #0
 800e6a6:	d1e6      	bne.n	800e676 <UART_RxISR_8BIT+0x13a>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800e6a8:	687b      	ldr	r3, [r7, #4]
 800e6aa:	681b      	ldr	r3, [r3, #0]
 800e6ac:	69db      	ldr	r3, [r3, #28]
 800e6ae:	f003 0310 	and.w	r3, r3, #16
 800e6b2:	2b10      	cmp	r3, #16
 800e6b4:	d103      	bne.n	800e6be <UART_RxISR_8BIT+0x182>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800e6b6:	687b      	ldr	r3, [r7, #4]
 800e6b8:	681b      	ldr	r3, [r3, #0]
 800e6ba:	2210      	movs	r2, #16
 800e6bc:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800e6be:	687b      	ldr	r3, [r7, #4]
 800e6c0:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800e6c4:	4619      	mov	r1, r3
 800e6c6:	6878      	ldr	r0, [r7, #4]
 800e6c8:	f7ff fd62 	bl	800e190 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800e6cc:	e00b      	b.n	800e6e6 <UART_RxISR_8BIT+0x1aa>
        HAL_UART_RxCpltCallback(huart);
 800e6ce:	6878      	ldr	r0, [r7, #4]
 800e6d0:	f7f8 ffb8 	bl	8007644 <HAL_UART_RxCpltCallback>
}
 800e6d4:	e007      	b.n	800e6e6 <UART_RxISR_8BIT+0x1aa>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800e6d6:	687b      	ldr	r3, [r7, #4]
 800e6d8:	681b      	ldr	r3, [r3, #0]
 800e6da:	699a      	ldr	r2, [r3, #24]
 800e6dc:	687b      	ldr	r3, [r7, #4]
 800e6de:	681b      	ldr	r3, [r3, #0]
 800e6e0:	f042 0208 	orr.w	r2, r2, #8
 800e6e4:	619a      	str	r2, [r3, #24]
}
 800e6e6:	bf00      	nop
 800e6e8:	3770      	adds	r7, #112	; 0x70
 800e6ea:	46bd      	mov	sp, r7
 800e6ec:	bd80      	pop	{r7, pc}
 800e6ee:	bf00      	nop
 800e6f0:	40008000 	.word	0x40008000

0800e6f4 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 800e6f4:	b580      	push	{r7, lr}
 800e6f6:	b09c      	sub	sp, #112	; 0x70
 800e6f8:	af00      	add	r7, sp, #0
 800e6fa:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 800e6fc:	687b      	ldr	r3, [r7, #4]
 800e6fe:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 800e702:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800e706:	687b      	ldr	r3, [r7, #4]
 800e708:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800e70c:	2b22      	cmp	r3, #34	; 0x22
 800e70e:	f040 80be 	bne.w	800e88e <UART_RxISR_16BIT+0x19a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800e712:	687b      	ldr	r3, [r7, #4]
 800e714:	681b      	ldr	r3, [r3, #0]
 800e716:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e718:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 800e71c:	687b      	ldr	r3, [r7, #4]
 800e71e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e720:	66bb      	str	r3, [r7, #104]	; 0x68
    *tmp = (uint16_t)(uhdata & uhMask);
 800e722:	f8b7 206c 	ldrh.w	r2, [r7, #108]	; 0x6c
 800e726:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 800e72a:	4013      	ands	r3, r2
 800e72c:	b29a      	uxth	r2, r3
 800e72e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e730:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 800e732:	687b      	ldr	r3, [r7, #4]
 800e734:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e736:	1c9a      	adds	r2, r3, #2
 800e738:	687b      	ldr	r3, [r7, #4]
 800e73a:	659a      	str	r2, [r3, #88]	; 0x58
    huart->RxXferCount--;
 800e73c:	687b      	ldr	r3, [r7, #4]
 800e73e:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800e742:	b29b      	uxth	r3, r3
 800e744:	3b01      	subs	r3, #1
 800e746:	b29a      	uxth	r2, r3
 800e748:	687b      	ldr	r3, [r7, #4]
 800e74a:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 800e74e:	687b      	ldr	r3, [r7, #4]
 800e750:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800e754:	b29b      	uxth	r3, r3
 800e756:	2b00      	cmp	r3, #0
 800e758:	f040 80a1 	bne.w	800e89e <UART_RxISR_16BIT+0x1aa>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800e75c:	687b      	ldr	r3, [r7, #4]
 800e75e:	681b      	ldr	r3, [r3, #0]
 800e760:	64bb      	str	r3, [r7, #72]	; 0x48
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e762:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e764:	e853 3f00 	ldrex	r3, [r3]
 800e768:	647b      	str	r3, [r7, #68]	; 0x44
   return(result);
 800e76a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e76c:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800e770:	667b      	str	r3, [r7, #100]	; 0x64
 800e772:	687b      	ldr	r3, [r7, #4]
 800e774:	681b      	ldr	r3, [r3, #0]
 800e776:	461a      	mov	r2, r3
 800e778:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e77a:	657b      	str	r3, [r7, #84]	; 0x54
 800e77c:	653a      	str	r2, [r7, #80]	; 0x50
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e77e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800e780:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e782:	e841 2300 	strex	r3, r2, [r1]
 800e786:	64fb      	str	r3, [r7, #76]	; 0x4c
   return(result);
 800e788:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e78a:	2b00      	cmp	r3, #0
 800e78c:	d1e6      	bne.n	800e75c <UART_RxISR_16BIT+0x68>

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800e78e:	687b      	ldr	r3, [r7, #4]
 800e790:	681b      	ldr	r3, [r3, #0]
 800e792:	3308      	adds	r3, #8
 800e794:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e796:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e798:	e853 3f00 	ldrex	r3, [r3]
 800e79c:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 800e79e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e7a0:	f023 0301 	bic.w	r3, r3, #1
 800e7a4:	663b      	str	r3, [r7, #96]	; 0x60
 800e7a6:	687b      	ldr	r3, [r7, #4]
 800e7a8:	681b      	ldr	r3, [r3, #0]
 800e7aa:	3308      	adds	r3, #8
 800e7ac:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800e7ae:	643a      	str	r2, [r7, #64]	; 0x40
 800e7b0:	63fb      	str	r3, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e7b2:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800e7b4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e7b6:	e841 2300 	strex	r3, r2, [r1]
 800e7ba:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 800e7bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e7be:	2b00      	cmp	r3, #0
 800e7c0:	d1e5      	bne.n	800e78e <UART_RxISR_16BIT+0x9a>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800e7c2:	687b      	ldr	r3, [r7, #4]
 800e7c4:	2220      	movs	r2, #32
 800e7c6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800e7ca:	687b      	ldr	r3, [r7, #4]
 800e7cc:	2200      	movs	r2, #0
 800e7ce:	675a      	str	r2, [r3, #116]	; 0x74

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 800e7d0:	687b      	ldr	r3, [r7, #4]
 800e7d2:	2200      	movs	r2, #0
 800e7d4:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(LPUART1)
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	681b      	ldr	r3, [r3, #0]
 800e7da:	4a33      	ldr	r2, [pc, #204]	; (800e8a8 <UART_RxISR_16BIT+0x1b4>)
 800e7dc:	4293      	cmp	r3, r2
 800e7de:	d01f      	beq.n	800e820 <UART_RxISR_16BIT+0x12c>
      {
        /* Check that USART RTOEN bit is set */
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800e7e0:	687b      	ldr	r3, [r7, #4]
 800e7e2:	681b      	ldr	r3, [r3, #0]
 800e7e4:	685b      	ldr	r3, [r3, #4]
 800e7e6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800e7ea:	2b00      	cmp	r3, #0
 800e7ec:	d018      	beq.n	800e820 <UART_RxISR_16BIT+0x12c>
        {
          /* Enable the UART Receiver Timeout Interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800e7ee:	687b      	ldr	r3, [r7, #4]
 800e7f0:	681b      	ldr	r3, [r3, #0]
 800e7f2:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e7f4:	6a3b      	ldr	r3, [r7, #32]
 800e7f6:	e853 3f00 	ldrex	r3, [r3]
 800e7fa:	61fb      	str	r3, [r7, #28]
   return(result);
 800e7fc:	69fb      	ldr	r3, [r7, #28]
 800e7fe:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800e802:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e804:	687b      	ldr	r3, [r7, #4]
 800e806:	681b      	ldr	r3, [r3, #0]
 800e808:	461a      	mov	r2, r3
 800e80a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e80c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800e80e:	62ba      	str	r2, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e810:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e812:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e814:	e841 2300 	strex	r3, r2, [r1]
 800e818:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 800e81a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e81c:	2b00      	cmp	r3, #0
 800e81e:	d1e6      	bne.n	800e7ee <UART_RxISR_16BIT+0xfa>
      }
#endif /* LPUART1 */

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800e820:	687b      	ldr	r3, [r7, #4]
 800e822:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e824:	2b01      	cmp	r3, #1
 800e826:	d12e      	bne.n	800e886 <UART_RxISR_16BIT+0x192>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800e828:	687b      	ldr	r3, [r7, #4]
 800e82a:	2200      	movs	r2, #0
 800e82c:	66da      	str	r2, [r3, #108]	; 0x6c

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800e82e:	687b      	ldr	r3, [r7, #4]
 800e830:	681b      	ldr	r3, [r3, #0]
 800e832:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800e834:	68fb      	ldr	r3, [r7, #12]
 800e836:	e853 3f00 	ldrex	r3, [r3]
 800e83a:	60bb      	str	r3, [r7, #8]
   return(result);
 800e83c:	68bb      	ldr	r3, [r7, #8]
 800e83e:	f023 0310 	bic.w	r3, r3, #16
 800e842:	65bb      	str	r3, [r7, #88]	; 0x58
 800e844:	687b      	ldr	r3, [r7, #4]
 800e846:	681b      	ldr	r3, [r3, #0]
 800e848:	461a      	mov	r2, r3
 800e84a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e84c:	61bb      	str	r3, [r7, #24]
 800e84e:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800e850:	6979      	ldr	r1, [r7, #20]
 800e852:	69ba      	ldr	r2, [r7, #24]
 800e854:	e841 2300 	strex	r3, r2, [r1]
 800e858:	613b      	str	r3, [r7, #16]
   return(result);
 800e85a:	693b      	ldr	r3, [r7, #16]
 800e85c:	2b00      	cmp	r3, #0
 800e85e:	d1e6      	bne.n	800e82e <UART_RxISR_16BIT+0x13a>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800e860:	687b      	ldr	r3, [r7, #4]
 800e862:	681b      	ldr	r3, [r3, #0]
 800e864:	69db      	ldr	r3, [r3, #28]
 800e866:	f003 0310 	and.w	r3, r3, #16
 800e86a:	2b10      	cmp	r3, #16
 800e86c:	d103      	bne.n	800e876 <UART_RxISR_16BIT+0x182>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800e86e:	687b      	ldr	r3, [r7, #4]
 800e870:	681b      	ldr	r3, [r3, #0]
 800e872:	2210      	movs	r2, #16
 800e874:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800e876:	687b      	ldr	r3, [r7, #4]
 800e878:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800e87c:	4619      	mov	r1, r3
 800e87e:	6878      	ldr	r0, [r7, #4]
 800e880:	f7ff fc86 	bl	800e190 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800e884:	e00b      	b.n	800e89e <UART_RxISR_16BIT+0x1aa>
        HAL_UART_RxCpltCallback(huart);
 800e886:	6878      	ldr	r0, [r7, #4]
 800e888:	f7f8 fedc 	bl	8007644 <HAL_UART_RxCpltCallback>
}
 800e88c:	e007      	b.n	800e89e <UART_RxISR_16BIT+0x1aa>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800e88e:	687b      	ldr	r3, [r7, #4]
 800e890:	681b      	ldr	r3, [r3, #0]
 800e892:	699a      	ldr	r2, [r3, #24]
 800e894:	687b      	ldr	r3, [r7, #4]
 800e896:	681b      	ldr	r3, [r3, #0]
 800e898:	f042 0208 	orr.w	r2, r2, #8
 800e89c:	619a      	str	r2, [r3, #24]
}
 800e89e:	bf00      	nop
 800e8a0:	3770      	adds	r7, #112	; 0x70
 800e8a2:	46bd      	mov	sp, r7
 800e8a4:	bd80      	pop	{r7, pc}
 800e8a6:	bf00      	nop
 800e8a8:	40008000 	.word	0x40008000

0800e8ac <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 800e8ac:	b580      	push	{r7, lr}
 800e8ae:	b0ac      	sub	sp, #176	; 0xb0
 800e8b0:	af00      	add	r7, sp, #0
 800e8b2:	6078      	str	r0, [r7, #4]
  uint16_t  uhMask = huart->Mask;
 800e8b4:	687b      	ldr	r3, [r7, #4]
 800e8b6:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 800e8ba:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 800e8be:	687b      	ldr	r3, [r7, #4]
 800e8c0:	681b      	ldr	r3, [r3, #0]
 800e8c2:	69db      	ldr	r3, [r3, #28]
 800e8c4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 800e8c8:	687b      	ldr	r3, [r7, #4]
 800e8ca:	681b      	ldr	r3, [r3, #0]
 800e8cc:	681b      	ldr	r3, [r3, #0]
 800e8ce:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 800e8d2:	687b      	ldr	r3, [r7, #4]
 800e8d4:	681b      	ldr	r3, [r3, #0]
 800e8d6:	689b      	ldr	r3, [r3, #8]
 800e8d8:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800e8dc:	687b      	ldr	r3, [r7, #4]
 800e8de:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800e8e2:	2b22      	cmp	r3, #34	; 0x22
 800e8e4:	f040 8182 	bne.w	800ebec <UART_RxISR_8BIT_FIFOEN+0x340>
  {
    nb_rx_data = huart->NbRxDataToProcess;
 800e8e8:	687b      	ldr	r3, [r7, #4]
 800e8ea:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800e8ee:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 800e8f2:	e125      	b.n	800eb40 <UART_RxISR_8BIT_FIFOEN+0x294>
    {
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800e8f4:	687b      	ldr	r3, [r7, #4]
 800e8f6:	681b      	ldr	r3, [r3, #0]
 800e8f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e8fa:	f8a7 309c 	strh.w	r3, [r7, #156]	; 0x9c
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 800e8fe:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 800e902:	b2d9      	uxtb	r1, r3
 800e904:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 800e908:	b2da      	uxtb	r2, r3
 800e90a:	687b      	ldr	r3, [r7, #4]
 800e90c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e90e:	400a      	ands	r2, r1
 800e910:	b2d2      	uxtb	r2, r2
 800e912:	701a      	strb	r2, [r3, #0]
      huart->pRxBuffPtr++;
 800e914:	687b      	ldr	r3, [r7, #4]
 800e916:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e918:	1c5a      	adds	r2, r3, #1
 800e91a:	687b      	ldr	r3, [r7, #4]
 800e91c:	659a      	str	r2, [r3, #88]	; 0x58
      huart->RxXferCount--;
 800e91e:	687b      	ldr	r3, [r7, #4]
 800e920:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800e924:	b29b      	uxth	r3, r3
 800e926:	3b01      	subs	r3, #1
 800e928:	b29a      	uxth	r2, r3
 800e92a:	687b      	ldr	r3, [r7, #4]
 800e92c:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 800e930:	687b      	ldr	r3, [r7, #4]
 800e932:	681b      	ldr	r3, [r3, #0]
 800e934:	69db      	ldr	r3, [r3, #28]
 800e936:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

      /* If some non blocking errors occurred */
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 800e93a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e93e:	f003 0307 	and.w	r3, r3, #7
 800e942:	2b00      	cmp	r3, #0
 800e944:	d053      	beq.n	800e9ee <UART_RxISR_8BIT_FIFOEN+0x142>
      {
        /* UART parity error interrupt occurred -------------------------------------*/
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800e946:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e94a:	f003 0301 	and.w	r3, r3, #1
 800e94e:	2b00      	cmp	r3, #0
 800e950:	d011      	beq.n	800e976 <UART_RxISR_8BIT_FIFOEN+0xca>
 800e952:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e956:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800e95a:	2b00      	cmp	r3, #0
 800e95c:	d00b      	beq.n	800e976 <UART_RxISR_8BIT_FIFOEN+0xca>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800e95e:	687b      	ldr	r3, [r7, #4]
 800e960:	681b      	ldr	r3, [r3, #0]
 800e962:	2201      	movs	r2, #1
 800e964:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_PE;
 800e966:	687b      	ldr	r3, [r7, #4]
 800e968:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e96c:	f043 0201 	orr.w	r2, r3, #1
 800e970:	687b      	ldr	r3, [r7, #4]
 800e972:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }

        /* UART frame error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800e976:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e97a:	f003 0302 	and.w	r3, r3, #2
 800e97e:	2b00      	cmp	r3, #0
 800e980:	d011      	beq.n	800e9a6 <UART_RxISR_8BIT_FIFOEN+0xfa>
 800e982:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800e986:	f003 0301 	and.w	r3, r3, #1
 800e98a:	2b00      	cmp	r3, #0
 800e98c:	d00b      	beq.n	800e9a6 <UART_RxISR_8BIT_FIFOEN+0xfa>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800e98e:	687b      	ldr	r3, [r7, #4]
 800e990:	681b      	ldr	r3, [r3, #0]
 800e992:	2202      	movs	r2, #2
 800e994:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_FE;
 800e996:	687b      	ldr	r3, [r7, #4]
 800e998:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e99c:	f043 0204 	orr.w	r2, r3, #4
 800e9a0:	687b      	ldr	r3, [r7, #4]
 800e9a2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }

        /* UART noise error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800e9a6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e9aa:	f003 0304 	and.w	r3, r3, #4
 800e9ae:	2b00      	cmp	r3, #0
 800e9b0:	d011      	beq.n	800e9d6 <UART_RxISR_8BIT_FIFOEN+0x12a>
 800e9b2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800e9b6:	f003 0301 	and.w	r3, r3, #1
 800e9ba:	2b00      	cmp	r3, #0
 800e9bc:	d00b      	beq.n	800e9d6 <UART_RxISR_8BIT_FIFOEN+0x12a>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800e9be:	687b      	ldr	r3, [r7, #4]
 800e9c0:	681b      	ldr	r3, [r3, #0]
 800e9c2:	2204      	movs	r2, #4
 800e9c4:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_NE;
 800e9c6:	687b      	ldr	r3, [r7, #4]
 800e9c8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e9cc:	f043 0202 	orr.w	r2, r3, #2
 800e9d0:	687b      	ldr	r3, [r7, #4]
 800e9d2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }

        /* Call UART Error Call back function if need be ----------------------------*/
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800e9d6:	687b      	ldr	r3, [r7, #4]
 800e9d8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800e9dc:	2b00      	cmp	r3, #0
 800e9de:	d006      	beq.n	800e9ee <UART_RxISR_8BIT_FIFOEN+0x142>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 800e9e0:	6878      	ldr	r0, [r7, #4]
 800e9e2:	f7ff fbcb 	bl	800e17c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 800e9e6:	687b      	ldr	r3, [r7, #4]
 800e9e8:	2200      	movs	r2, #0
 800e9ea:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }
      }

      if (huart->RxXferCount == 0U)
 800e9ee:	687b      	ldr	r3, [r7, #4]
 800e9f0:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800e9f4:	b29b      	uxth	r3, r3
 800e9f6:	2b00      	cmp	r3, #0
 800e9f8:	f040 80a2 	bne.w	800eb40 <UART_RxISR_8BIT_FIFOEN+0x294>
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800e9fc:	687b      	ldr	r3, [r7, #4]
 800e9fe:	681b      	ldr	r3, [r3, #0]
 800ea00:	673b      	str	r3, [r7, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ea02:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800ea04:	e853 3f00 	ldrex	r3, [r3]
 800ea08:	66fb      	str	r3, [r7, #108]	; 0x6c
   return(result);
 800ea0a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ea0c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800ea10:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800ea14:	687b      	ldr	r3, [r7, #4]
 800ea16:	681b      	ldr	r3, [r3, #0]
 800ea18:	461a      	mov	r2, r3
 800ea1a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800ea1e:	67fb      	str	r3, [r7, #124]	; 0x7c
 800ea20:	67ba      	str	r2, [r7, #120]	; 0x78
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ea22:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800ea24:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800ea26:	e841 2300 	strex	r3, r2, [r1]
 800ea2a:	677b      	str	r3, [r7, #116]	; 0x74
   return(result);
 800ea2c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ea2e:	2b00      	cmp	r3, #0
 800ea30:	d1e4      	bne.n	800e9fc <UART_RxISR_8BIT_FIFOEN+0x150>

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800ea32:	687b      	ldr	r3, [r7, #4]
 800ea34:	681b      	ldr	r3, [r3, #0]
 800ea36:	3308      	adds	r3, #8
 800ea38:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ea3a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ea3c:	e853 3f00 	ldrex	r3, [r3]
 800ea40:	65bb      	str	r3, [r7, #88]	; 0x58
   return(result);
 800ea42:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800ea44:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800ea48:	f023 0301 	bic.w	r3, r3, #1
 800ea4c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800ea50:	687b      	ldr	r3, [r7, #4]
 800ea52:	681b      	ldr	r3, [r3, #0]
 800ea54:	3308      	adds	r3, #8
 800ea56:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800ea5a:	66ba      	str	r2, [r7, #104]	; 0x68
 800ea5c:	667b      	str	r3, [r7, #100]	; 0x64
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ea5e:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800ea60:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800ea62:	e841 2300 	strex	r3, r2, [r1]
 800ea66:	663b      	str	r3, [r7, #96]	; 0x60
   return(result);
 800ea68:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ea6a:	2b00      	cmp	r3, #0
 800ea6c:	d1e1      	bne.n	800ea32 <UART_RxISR_8BIT_FIFOEN+0x186>

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 800ea6e:	687b      	ldr	r3, [r7, #4]
 800ea70:	2220      	movs	r2, #32
 800ea72:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 800ea76:	687b      	ldr	r3, [r7, #4]
 800ea78:	2200      	movs	r2, #0
 800ea7a:	675a      	str	r2, [r3, #116]	; 0x74

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 800ea7c:	687b      	ldr	r3, [r7, #4]
 800ea7e:	2200      	movs	r2, #0
 800ea80:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(LPUART1)
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800ea82:	687b      	ldr	r3, [r7, #4]
 800ea84:	681b      	ldr	r3, [r3, #0]
 800ea86:	4a5f      	ldr	r2, [pc, #380]	; (800ec04 <UART_RxISR_8BIT_FIFOEN+0x358>)
 800ea88:	4293      	cmp	r3, r2
 800ea8a:	d021      	beq.n	800ead0 <UART_RxISR_8BIT_FIFOEN+0x224>
        {
          /* Check that USART RTOEN bit is set */
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800ea8c:	687b      	ldr	r3, [r7, #4]
 800ea8e:	681b      	ldr	r3, [r3, #0]
 800ea90:	685b      	ldr	r3, [r3, #4]
 800ea92:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800ea96:	2b00      	cmp	r3, #0
 800ea98:	d01a      	beq.n	800ead0 <UART_RxISR_8BIT_FIFOEN+0x224>
          {
            /* Enable the UART Receiver Timeout Interrupt */
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800ea9a:	687b      	ldr	r3, [r7, #4]
 800ea9c:	681b      	ldr	r3, [r3, #0]
 800ea9e:	64bb      	str	r3, [r7, #72]	; 0x48
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800eaa0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800eaa2:	e853 3f00 	ldrex	r3, [r3]
 800eaa6:	647b      	str	r3, [r7, #68]	; 0x44
   return(result);
 800eaa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eaaa:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800eaae:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800eab2:	687b      	ldr	r3, [r7, #4]
 800eab4:	681b      	ldr	r3, [r3, #0]
 800eab6:	461a      	mov	r2, r3
 800eab8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800eabc:	657b      	str	r3, [r7, #84]	; 0x54
 800eabe:	653a      	str	r2, [r7, #80]	; 0x50
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800eac0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800eac2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800eac4:	e841 2300 	strex	r3, r2, [r1]
 800eac8:	64fb      	str	r3, [r7, #76]	; 0x4c
   return(result);
 800eaca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800eacc:	2b00      	cmp	r3, #0
 800eace:	d1e4      	bne.n	800ea9a <UART_RxISR_8BIT_FIFOEN+0x1ee>
        }
#endif /* LPUART1 */

        /* Check current reception Mode :
           If Reception till IDLE event has been selected : */
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ead0:	687b      	ldr	r3, [r7, #4]
 800ead2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ead4:	2b01      	cmp	r3, #1
 800ead6:	d130      	bne.n	800eb3a <UART_RxISR_8BIT_FIFOEN+0x28e>
        {
          /* Set reception type to Standard */
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ead8:	687b      	ldr	r3, [r7, #4]
 800eada:	2200      	movs	r2, #0
 800eadc:	66da      	str	r2, [r3, #108]	; 0x6c

          /* Disable IDLE interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800eade:	687b      	ldr	r3, [r7, #4]
 800eae0:	681b      	ldr	r3, [r3, #0]
 800eae2:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800eae4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eae6:	e853 3f00 	ldrex	r3, [r3]
 800eaea:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 800eaec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eaee:	f023 0310 	bic.w	r3, r3, #16
 800eaf2:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800eaf6:	687b      	ldr	r3, [r7, #4]
 800eaf8:	681b      	ldr	r3, [r3, #0]
 800eafa:	461a      	mov	r2, r3
 800eafc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800eb00:	643b      	str	r3, [r7, #64]	; 0x40
 800eb02:	63fa      	str	r2, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800eb04:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800eb06:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800eb08:	e841 2300 	strex	r3, r2, [r1]
 800eb0c:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 800eb0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb10:	2b00      	cmp	r3, #0
 800eb12:	d1e4      	bne.n	800eade <UART_RxISR_8BIT_FIFOEN+0x232>

          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800eb14:	687b      	ldr	r3, [r7, #4]
 800eb16:	681b      	ldr	r3, [r3, #0]
 800eb18:	69db      	ldr	r3, [r3, #28]
 800eb1a:	f003 0310 	and.w	r3, r3, #16
 800eb1e:	2b10      	cmp	r3, #16
 800eb20:	d103      	bne.n	800eb2a <UART_RxISR_8BIT_FIFOEN+0x27e>
          {
            /* Clear IDLE Flag */
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800eb22:	687b      	ldr	r3, [r7, #4]
 800eb24:	681b      	ldr	r3, [r3, #0]
 800eb26:	2210      	movs	r2, #16
 800eb28:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered Rx Event callback*/
          huart->RxEventCallback(huart, huart->RxXferSize);
#else
          /*Call legacy weak Rx Event callback*/
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800eb2a:	687b      	ldr	r3, [r7, #4]
 800eb2c:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800eb30:	4619      	mov	r1, r3
 800eb32:	6878      	ldr	r0, [r7, #4]
 800eb34:	f7ff fb2c 	bl	800e190 <HAL_UARTEx_RxEventCallback>
 800eb38:	e002      	b.n	800eb40 <UART_RxISR_8BIT_FIFOEN+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered Rx complete callback*/
          huart->RxCpltCallback(huart);
#else
          /*Call legacy weak Rx complete callback*/
          HAL_UART_RxCpltCallback(huart);
 800eb3a:	6878      	ldr	r0, [r7, #4]
 800eb3c:	f7f8 fd82 	bl	8007644 <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 800eb40:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 800eb44:	2b00      	cmp	r3, #0
 800eb46:	d006      	beq.n	800eb56 <UART_RxISR_8BIT_FIFOEN+0x2aa>
 800eb48:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800eb4c:	f003 0320 	and.w	r3, r3, #32
 800eb50:	2b00      	cmp	r3, #0
 800eb52:	f47f aecf 	bne.w	800e8f4 <UART_RxISR_8BIT_FIFOEN+0x48>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 800eb56:	687b      	ldr	r3, [r7, #4]
 800eb58:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800eb5c:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 800eb60:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 800eb64:	2b00      	cmp	r3, #0
 800eb66:	d049      	beq.n	800ebfc <UART_RxISR_8BIT_FIFOEN+0x350>
 800eb68:	687b      	ldr	r3, [r7, #4]
 800eb6a:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800eb6e:	f8b7 208a 	ldrh.w	r2, [r7, #138]	; 0x8a
 800eb72:	429a      	cmp	r2, r3
 800eb74:	d242      	bcs.n	800ebfc <UART_RxISR_8BIT_FIFOEN+0x350>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 800eb76:	687b      	ldr	r3, [r7, #4]
 800eb78:	681b      	ldr	r3, [r3, #0]
 800eb7a:	3308      	adds	r3, #8
 800eb7c:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800eb7e:	6a3b      	ldr	r3, [r7, #32]
 800eb80:	e853 3f00 	ldrex	r3, [r3]
 800eb84:	61fb      	str	r3, [r7, #28]
   return(result);
 800eb86:	69fb      	ldr	r3, [r7, #28]
 800eb88:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800eb8c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800eb90:	687b      	ldr	r3, [r7, #4]
 800eb92:	681b      	ldr	r3, [r3, #0]
 800eb94:	3308      	adds	r3, #8
 800eb96:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800eb9a:	62fa      	str	r2, [r7, #44]	; 0x2c
 800eb9c:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800eb9e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800eba0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800eba2:	e841 2300 	strex	r3, r2, [r1]
 800eba6:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 800eba8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	d1e3      	bne.n	800eb76 <UART_RxISR_8BIT_FIFOEN+0x2ca>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 800ebae:	687b      	ldr	r3, [r7, #4]
 800ebb0:	4a15      	ldr	r2, [pc, #84]	; (800ec08 <UART_RxISR_8BIT_FIFOEN+0x35c>)
 800ebb2:	675a      	str	r2, [r3, #116]	; 0x74

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 800ebb4:	687b      	ldr	r3, [r7, #4]
 800ebb6:	681b      	ldr	r3, [r3, #0]
 800ebb8:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ebba:	68fb      	ldr	r3, [r7, #12]
 800ebbc:	e853 3f00 	ldrex	r3, [r3]
 800ebc0:	60bb      	str	r3, [r7, #8]
   return(result);
 800ebc2:	68bb      	ldr	r3, [r7, #8]
 800ebc4:	f043 0320 	orr.w	r3, r3, #32
 800ebc8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800ebcc:	687b      	ldr	r3, [r7, #4]
 800ebce:	681b      	ldr	r3, [r3, #0]
 800ebd0:	461a      	mov	r2, r3
 800ebd2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ebd6:	61bb      	str	r3, [r7, #24]
 800ebd8:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ebda:	6979      	ldr	r1, [r7, #20]
 800ebdc:	69ba      	ldr	r2, [r7, #24]
 800ebde:	e841 2300 	strex	r3, r2, [r1]
 800ebe2:	613b      	str	r3, [r7, #16]
   return(result);
 800ebe4:	693b      	ldr	r3, [r7, #16]
 800ebe6:	2b00      	cmp	r3, #0
 800ebe8:	d1e4      	bne.n	800ebb4 <UART_RxISR_8BIT_FIFOEN+0x308>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800ebea:	e007      	b.n	800ebfc <UART_RxISR_8BIT_FIFOEN+0x350>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800ebec:	687b      	ldr	r3, [r7, #4]
 800ebee:	681b      	ldr	r3, [r3, #0]
 800ebf0:	699a      	ldr	r2, [r3, #24]
 800ebf2:	687b      	ldr	r3, [r7, #4]
 800ebf4:	681b      	ldr	r3, [r3, #0]
 800ebf6:	f042 0208 	orr.w	r2, r2, #8
 800ebfa:	619a      	str	r2, [r3, #24]
}
 800ebfc:	bf00      	nop
 800ebfe:	37b0      	adds	r7, #176	; 0xb0
 800ec00:	46bd      	mov	sp, r7
 800ec02:	bd80      	pop	{r7, pc}
 800ec04:	40008000 	.word	0x40008000
 800ec08:	0800e53d 	.word	0x0800e53d

0800ec0c <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 800ec0c:	b580      	push	{r7, lr}
 800ec0e:	b0ae      	sub	sp, #184	; 0xb8
 800ec10:	af00      	add	r7, sp, #0
 800ec12:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
 800ec14:	687b      	ldr	r3, [r7, #4]
 800ec16:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 800ec1a:	f8a7 30b2 	strh.w	r3, [r7, #178]	; 0xb2
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 800ec1e:	687b      	ldr	r3, [r7, #4]
 800ec20:	681b      	ldr	r3, [r3, #0]
 800ec22:	69db      	ldr	r3, [r3, #28]
 800ec24:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 800ec28:	687b      	ldr	r3, [r7, #4]
 800ec2a:	681b      	ldr	r3, [r3, #0]
 800ec2c:	681b      	ldr	r3, [r3, #0]
 800ec2e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 800ec32:	687b      	ldr	r3, [r7, #4]
 800ec34:	681b      	ldr	r3, [r3, #0]
 800ec36:	689b      	ldr	r3, [r3, #8]
 800ec38:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800ec3c:	687b      	ldr	r3, [r7, #4]
 800ec3e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ec42:	2b22      	cmp	r3, #34	; 0x22
 800ec44:	f040 8186 	bne.w	800ef54 <UART_RxISR_16BIT_FIFOEN+0x348>
  {
    nb_rx_data = huart->NbRxDataToProcess;
 800ec48:	687b      	ldr	r3, [r7, #4]
 800ec4a:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800ec4e:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 800ec52:	e129      	b.n	800eea8 <UART_RxISR_16BIT_FIFOEN+0x29c>
    {
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800ec54:	687b      	ldr	r3, [r7, #4]
 800ec56:	681b      	ldr	r3, [r3, #0]
 800ec58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec5a:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
      tmp = (uint16_t *) huart->pRxBuffPtr ;
 800ec5e:	687b      	ldr	r3, [r7, #4]
 800ec60:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ec62:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
      *tmp = (uint16_t)(uhdata & uhMask);
 800ec66:	f8b7 20a4 	ldrh.w	r2, [r7, #164]	; 0xa4
 800ec6a:	f8b7 30b2 	ldrh.w	r3, [r7, #178]	; 0xb2
 800ec6e:	4013      	ands	r3, r2
 800ec70:	b29a      	uxth	r2, r3
 800ec72:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800ec76:	801a      	strh	r2, [r3, #0]
      huart->pRxBuffPtr += 2U;
 800ec78:	687b      	ldr	r3, [r7, #4]
 800ec7a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ec7c:	1c9a      	adds	r2, r3, #2
 800ec7e:	687b      	ldr	r3, [r7, #4]
 800ec80:	659a      	str	r2, [r3, #88]	; 0x58
      huart->RxXferCount--;
 800ec82:	687b      	ldr	r3, [r7, #4]
 800ec84:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800ec88:	b29b      	uxth	r3, r3
 800ec8a:	3b01      	subs	r3, #1
 800ec8c:	b29a      	uxth	r2, r3
 800ec8e:	687b      	ldr	r3, [r7, #4]
 800ec90:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 800ec94:	687b      	ldr	r3, [r7, #4]
 800ec96:	681b      	ldr	r3, [r3, #0]
 800ec98:	69db      	ldr	r3, [r3, #28]
 800ec9a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

      /* If some non blocking errors occurred */
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 800ec9e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800eca2:	f003 0307 	and.w	r3, r3, #7
 800eca6:	2b00      	cmp	r3, #0
 800eca8:	d053      	beq.n	800ed52 <UART_RxISR_16BIT_FIFOEN+0x146>
      {
        /* UART parity error interrupt occurred -------------------------------------*/
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800ecaa:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800ecae:	f003 0301 	and.w	r3, r3, #1
 800ecb2:	2b00      	cmp	r3, #0
 800ecb4:	d011      	beq.n	800ecda <UART_RxISR_16BIT_FIFOEN+0xce>
 800ecb6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800ecba:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ecbe:	2b00      	cmp	r3, #0
 800ecc0:	d00b      	beq.n	800ecda <UART_RxISR_16BIT_FIFOEN+0xce>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800ecc2:	687b      	ldr	r3, [r7, #4]
 800ecc4:	681b      	ldr	r3, [r3, #0]
 800ecc6:	2201      	movs	r2, #1
 800ecc8:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_PE;
 800ecca:	687b      	ldr	r3, [r7, #4]
 800eccc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ecd0:	f043 0201 	orr.w	r2, r3, #1
 800ecd4:	687b      	ldr	r3, [r7, #4]
 800ecd6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }

        /* UART frame error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800ecda:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800ecde:	f003 0302 	and.w	r3, r3, #2
 800ece2:	2b00      	cmp	r3, #0
 800ece4:	d011      	beq.n	800ed0a <UART_RxISR_16BIT_FIFOEN+0xfe>
 800ece6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800ecea:	f003 0301 	and.w	r3, r3, #1
 800ecee:	2b00      	cmp	r3, #0
 800ecf0:	d00b      	beq.n	800ed0a <UART_RxISR_16BIT_FIFOEN+0xfe>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800ecf2:	687b      	ldr	r3, [r7, #4]
 800ecf4:	681b      	ldr	r3, [r3, #0]
 800ecf6:	2202      	movs	r2, #2
 800ecf8:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_FE;
 800ecfa:	687b      	ldr	r3, [r7, #4]
 800ecfc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ed00:	f043 0204 	orr.w	r2, r3, #4
 800ed04:	687b      	ldr	r3, [r7, #4]
 800ed06:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }

        /* UART noise error interrupt occurred --------------------------------------*/
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800ed0a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800ed0e:	f003 0304 	and.w	r3, r3, #4
 800ed12:	2b00      	cmp	r3, #0
 800ed14:	d011      	beq.n	800ed3a <UART_RxISR_16BIT_FIFOEN+0x12e>
 800ed16:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800ed1a:	f003 0301 	and.w	r3, r3, #1
 800ed1e:	2b00      	cmp	r3, #0
 800ed20:	d00b      	beq.n	800ed3a <UART_RxISR_16BIT_FIFOEN+0x12e>
        {
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800ed22:	687b      	ldr	r3, [r7, #4]
 800ed24:	681b      	ldr	r3, [r3, #0]
 800ed26:	2204      	movs	r2, #4
 800ed28:	621a      	str	r2, [r3, #32]

          huart->ErrorCode |= HAL_UART_ERROR_NE;
 800ed2a:	687b      	ldr	r3, [r7, #4]
 800ed2c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ed30:	f043 0202 	orr.w	r2, r3, #2
 800ed34:	687b      	ldr	r3, [r7, #4]
 800ed36:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }

        /* Call UART Error Call back function if need be ----------------------------*/
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800ed3a:	687b      	ldr	r3, [r7, #4]
 800ed3c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ed40:	2b00      	cmp	r3, #0
 800ed42:	d006      	beq.n	800ed52 <UART_RxISR_16BIT_FIFOEN+0x146>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 800ed44:	6878      	ldr	r0, [r7, #4]
 800ed46:	f7ff fa19 	bl	800e17c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ed4a:	687b      	ldr	r3, [r7, #4]
 800ed4c:	2200      	movs	r2, #0
 800ed4e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        }
      }

      if (huart->RxXferCount == 0U)
 800ed52:	687b      	ldr	r3, [r7, #4]
 800ed54:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800ed58:	b29b      	uxth	r3, r3
 800ed5a:	2b00      	cmp	r3, #0
 800ed5c:	f040 80a4 	bne.w	800eea8 <UART_RxISR_16BIT_FIFOEN+0x29c>
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800ed60:	687b      	ldr	r3, [r7, #4]
 800ed62:	681b      	ldr	r3, [r3, #0]
 800ed64:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ed66:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ed68:	e853 3f00 	ldrex	r3, [r3]
 800ed6c:	673b      	str	r3, [r7, #112]	; 0x70
   return(result);
 800ed6e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800ed70:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800ed74:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 800ed78:	687b      	ldr	r3, [r7, #4]
 800ed7a:	681b      	ldr	r3, [r3, #0]
 800ed7c:	461a      	mov	r2, r3
 800ed7e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800ed82:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800ed86:	67fa      	str	r2, [r7, #124]	; 0x7c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ed88:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 800ed8a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800ed8e:	e841 2300 	strex	r3, r2, [r1]
 800ed92:	67bb      	str	r3, [r7, #120]	; 0x78
   return(result);
 800ed94:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800ed96:	2b00      	cmp	r3, #0
 800ed98:	d1e2      	bne.n	800ed60 <UART_RxISR_16BIT_FIFOEN+0x154>

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800ed9a:	687b      	ldr	r3, [r7, #4]
 800ed9c:	681b      	ldr	r3, [r3, #0]
 800ed9e:	3308      	adds	r3, #8
 800eda0:	663b      	str	r3, [r7, #96]	; 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800eda2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800eda4:	e853 3f00 	ldrex	r3, [r3]
 800eda8:	65fb      	str	r3, [r7, #92]	; 0x5c
   return(result);
 800edaa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800edac:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800edb0:	f023 0301 	bic.w	r3, r3, #1
 800edb4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800edb8:	687b      	ldr	r3, [r7, #4]
 800edba:	681b      	ldr	r3, [r3, #0]
 800edbc:	3308      	adds	r3, #8
 800edbe:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800edc2:	66fa      	str	r2, [r7, #108]	; 0x6c
 800edc4:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800edc6:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800edc8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800edca:	e841 2300 	strex	r3, r2, [r1]
 800edce:	667b      	str	r3, [r7, #100]	; 0x64
   return(result);
 800edd0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800edd2:	2b00      	cmp	r3, #0
 800edd4:	d1e1      	bne.n	800ed9a <UART_RxISR_16BIT_FIFOEN+0x18e>

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 800edd6:	687b      	ldr	r3, [r7, #4]
 800edd8:	2220      	movs	r2, #32
 800edda:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 800edde:	687b      	ldr	r3, [r7, #4]
 800ede0:	2200      	movs	r2, #0
 800ede2:	675a      	str	r2, [r3, #116]	; 0x74

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 800ede4:	687b      	ldr	r3, [r7, #4]
 800ede6:	2200      	movs	r2, #0
 800ede8:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(LPUART1)
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 800edea:	687b      	ldr	r3, [r7, #4]
 800edec:	681b      	ldr	r3, [r3, #0]
 800edee:	4a5f      	ldr	r2, [pc, #380]	; (800ef6c <UART_RxISR_16BIT_FIFOEN+0x360>)
 800edf0:	4293      	cmp	r3, r2
 800edf2:	d021      	beq.n	800ee38 <UART_RxISR_16BIT_FIFOEN+0x22c>
        {
          /* Check that USART RTOEN bit is set */
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800edf4:	687b      	ldr	r3, [r7, #4]
 800edf6:	681b      	ldr	r3, [r3, #0]
 800edf8:	685b      	ldr	r3, [r3, #4]
 800edfa:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800edfe:	2b00      	cmp	r3, #0
 800ee00:	d01a      	beq.n	800ee38 <UART_RxISR_16BIT_FIFOEN+0x22c>
          {
            /* Enable the UART Receiver Timeout Interrupt */
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800ee02:	687b      	ldr	r3, [r7, #4]
 800ee04:	681b      	ldr	r3, [r3, #0]
 800ee06:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ee08:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ee0a:	e853 3f00 	ldrex	r3, [r3]
 800ee0e:	64bb      	str	r3, [r7, #72]	; 0x48
   return(result);
 800ee10:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ee12:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800ee16:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800ee1a:	687b      	ldr	r3, [r7, #4]
 800ee1c:	681b      	ldr	r3, [r3, #0]
 800ee1e:	461a      	mov	r2, r3
 800ee20:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800ee24:	65bb      	str	r3, [r7, #88]	; 0x58
 800ee26:	657a      	str	r2, [r7, #84]	; 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ee28:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800ee2a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800ee2c:	e841 2300 	strex	r3, r2, [r1]
 800ee30:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 800ee32:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ee34:	2b00      	cmp	r3, #0
 800ee36:	d1e4      	bne.n	800ee02 <UART_RxISR_16BIT_FIFOEN+0x1f6>
        }
#endif /* LPUART1 */

        /* Check current reception Mode :
           If Reception till IDLE event has been selected : */
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ee38:	687b      	ldr	r3, [r7, #4]
 800ee3a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ee3c:	2b01      	cmp	r3, #1
 800ee3e:	d130      	bne.n	800eea2 <UART_RxISR_16BIT_FIFOEN+0x296>
        {
          /* Set reception type to Standard */
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ee40:	687b      	ldr	r3, [r7, #4]
 800ee42:	2200      	movs	r2, #0
 800ee44:	66da      	str	r2, [r3, #108]	; 0x6c

          /* Disable IDLE interrupt */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800ee46:	687b      	ldr	r3, [r7, #4]
 800ee48:	681b      	ldr	r3, [r3, #0]
 800ee4a:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ee4c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ee4e:	e853 3f00 	ldrex	r3, [r3]
 800ee52:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 800ee54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee56:	f023 0310 	bic.w	r3, r3, #16
 800ee5a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800ee5e:	687b      	ldr	r3, [r7, #4]
 800ee60:	681b      	ldr	r3, [r3, #0]
 800ee62:	461a      	mov	r2, r3
 800ee64:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800ee68:	647b      	str	r3, [r7, #68]	; 0x44
 800ee6a:	643a      	str	r2, [r7, #64]	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ee6c:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ee6e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800ee70:	e841 2300 	strex	r3, r2, [r1]
 800ee74:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800ee76:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ee78:	2b00      	cmp	r3, #0
 800ee7a:	d1e4      	bne.n	800ee46 <UART_RxISR_16BIT_FIFOEN+0x23a>

          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 800ee7c:	687b      	ldr	r3, [r7, #4]
 800ee7e:	681b      	ldr	r3, [r3, #0]
 800ee80:	69db      	ldr	r3, [r3, #28]
 800ee82:	f003 0310 	and.w	r3, r3, #16
 800ee86:	2b10      	cmp	r3, #16
 800ee88:	d103      	bne.n	800ee92 <UART_RxISR_16BIT_FIFOEN+0x286>
          {
            /* Clear IDLE Flag */
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 800ee8a:	687b      	ldr	r3, [r7, #4]
 800ee8c:	681b      	ldr	r3, [r3, #0]
 800ee8e:	2210      	movs	r2, #16
 800ee90:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered Rx Event callback*/
          huart->RxEventCallback(huart, huart->RxXferSize);
#else
          /*Call legacy weak Rx Event callback*/
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800ee92:	687b      	ldr	r3, [r7, #4]
 800ee94:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800ee98:	4619      	mov	r1, r3
 800ee9a:	6878      	ldr	r0, [r7, #4]
 800ee9c:	f7ff f978 	bl	800e190 <HAL_UARTEx_RxEventCallback>
 800eea0:	e002      	b.n	800eea8 <UART_RxISR_16BIT_FIFOEN+0x29c>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered Rx complete callback*/
          huart->RxCpltCallback(huart);
#else
          /*Call legacy weak Rx complete callback*/
          HAL_UART_RxCpltCallback(huart);
 800eea2:	6878      	ldr	r0, [r7, #4]
 800eea4:	f7f8 fbce 	bl	8007644 <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 800eea8:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
 800eeac:	2b00      	cmp	r3, #0
 800eeae:	d006      	beq.n	800eebe <UART_RxISR_16BIT_FIFOEN+0x2b2>
 800eeb0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800eeb4:	f003 0320 	and.w	r3, r3, #32
 800eeb8:	2b00      	cmp	r3, #0
 800eeba:	f47f aecb 	bne.w	800ec54 <UART_RxISR_16BIT_FIFOEN+0x48>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 800eebe:	687b      	ldr	r3, [r7, #4]
 800eec0:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 800eec4:	f8a7 308e 	strh.w	r3, [r7, #142]	; 0x8e
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 800eec8:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
 800eecc:	2b00      	cmp	r3, #0
 800eece:	d049      	beq.n	800ef64 <UART_RxISR_16BIT_FIFOEN+0x358>
 800eed0:	687b      	ldr	r3, [r7, #4]
 800eed2:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800eed6:	f8b7 208e 	ldrh.w	r2, [r7, #142]	; 0x8e
 800eeda:	429a      	cmp	r2, r3
 800eedc:	d242      	bcs.n	800ef64 <UART_RxISR_16BIT_FIFOEN+0x358>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 800eede:	687b      	ldr	r3, [r7, #4]
 800eee0:	681b      	ldr	r3, [r3, #0]
 800eee2:	3308      	adds	r3, #8
 800eee4:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800eee6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eee8:	e853 3f00 	ldrex	r3, [r3]
 800eeec:	623b      	str	r3, [r7, #32]
   return(result);
 800eeee:	6a3b      	ldr	r3, [r7, #32]
 800eef0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800eef4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800eef8:	687b      	ldr	r3, [r7, #4]
 800eefa:	681b      	ldr	r3, [r3, #0]
 800eefc:	3308      	adds	r3, #8
 800eefe:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 800ef02:	633a      	str	r2, [r7, #48]	; 0x30
 800ef04:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ef06:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ef08:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800ef0a:	e841 2300 	strex	r3, r2, [r1]
 800ef0e:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800ef10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ef12:	2b00      	cmp	r3, #0
 800ef14:	d1e3      	bne.n	800eede <UART_RxISR_16BIT_FIFOEN+0x2d2>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 800ef16:	687b      	ldr	r3, [r7, #4]
 800ef18:	4a15      	ldr	r2, [pc, #84]	; (800ef70 <UART_RxISR_16BIT_FIFOEN+0x364>)
 800ef1a:	675a      	str	r2, [r3, #116]	; 0x74

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 800ef1c:	687b      	ldr	r3, [r7, #4]
 800ef1e:	681b      	ldr	r3, [r3, #0]
 800ef20:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ef22:	693b      	ldr	r3, [r7, #16]
 800ef24:	e853 3f00 	ldrex	r3, [r3]
 800ef28:	60fb      	str	r3, [r7, #12]
   return(result);
 800ef2a:	68fb      	ldr	r3, [r7, #12]
 800ef2c:	f043 0320 	orr.w	r3, r3, #32
 800ef30:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800ef34:	687b      	ldr	r3, [r7, #4]
 800ef36:	681b      	ldr	r3, [r3, #0]
 800ef38:	461a      	mov	r2, r3
 800ef3a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ef3e:	61fb      	str	r3, [r7, #28]
 800ef40:	61ba      	str	r2, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ef42:	69b9      	ldr	r1, [r7, #24]
 800ef44:	69fa      	ldr	r2, [r7, #28]
 800ef46:	e841 2300 	strex	r3, r2, [r1]
 800ef4a:	617b      	str	r3, [r7, #20]
   return(result);
 800ef4c:	697b      	ldr	r3, [r7, #20]
 800ef4e:	2b00      	cmp	r3, #0
 800ef50:	d1e4      	bne.n	800ef1c <UART_RxISR_16BIT_FIFOEN+0x310>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800ef52:	e007      	b.n	800ef64 <UART_RxISR_16BIT_FIFOEN+0x358>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800ef54:	687b      	ldr	r3, [r7, #4]
 800ef56:	681b      	ldr	r3, [r3, #0]
 800ef58:	699a      	ldr	r2, [r3, #24]
 800ef5a:	687b      	ldr	r3, [r7, #4]
 800ef5c:	681b      	ldr	r3, [r3, #0]
 800ef5e:	f042 0208 	orr.w	r2, r2, #8
 800ef62:	619a      	str	r2, [r3, #24]
}
 800ef64:	bf00      	nop
 800ef66:	37b8      	adds	r7, #184	; 0xb8
 800ef68:	46bd      	mov	sp, r7
 800ef6a:	bd80      	pop	{r7, pc}
 800ef6c:	40008000 	.word	0x40008000
 800ef70:	0800e6f5 	.word	0x0800e6f5

0800ef74 <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 800ef74:	b480      	push	{r7}
 800ef76:	b083      	sub	sp, #12
 800ef78:	af00      	add	r7, sp, #0
 800ef7a:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 800ef7c:	bf00      	nop
 800ef7e:	370c      	adds	r7, #12
 800ef80:	46bd      	mov	sp, r7
 800ef82:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef86:	4770      	bx	lr

0800ef88 <HAL_UARTEx_RxFifoFullCallback>:
  * @brief  UART RX Fifo full callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
{
 800ef88:	b480      	push	{r7}
 800ef8a:	b083      	sub	sp, #12
 800ef8c:	af00      	add	r7, sp, #0
 800ef8e:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxFifoFullCallback can be implemented in the user file.
   */
}
 800ef90:	bf00      	nop
 800ef92:	370c      	adds	r7, #12
 800ef94:	46bd      	mov	sp, r7
 800ef96:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef9a:	4770      	bx	lr

0800ef9c <HAL_UARTEx_TxFifoEmptyCallback>:
  * @brief  UART TX Fifo empty callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
{
 800ef9c:	b480      	push	{r7}
 800ef9e:	b083      	sub	sp, #12
 800efa0:	af00      	add	r7, sp, #0
 800efa2:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_TxFifoEmptyCallback can be implemented in the user file.
   */
}
 800efa4:	bf00      	nop
 800efa6:	370c      	adds	r7, #12
 800efa8:	46bd      	mov	sp, r7
 800efaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efae:	4770      	bx	lr

0800efb0 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_TypeDef *USBx)
{
 800efb0:	b480      	push	{r7}
 800efb2:	b085      	sub	sp, #20
 800efb4:	af00      	add	r7, sp, #0
 800efb6:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 800efb8:	687b      	ldr	r3, [r7, #4]
 800efba:	2200      	movs	r2, #0
 800efbc:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 800efc0:	f64b 7380 	movw	r3, #49024	; 0xbf80
 800efc4:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Set interrupt mask */
  USBx->CNTR = (uint16_t)winterruptmask;
 800efc6:	68fb      	ldr	r3, [r7, #12]
 800efc8:	b29a      	uxth	r2, r3
 800efca:	687b      	ldr	r3, [r7, #4]
 800efcc:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
 800efd0:	2300      	movs	r3, #0
}
 800efd2:	4618      	mov	r0, r3
 800efd4:	3714      	adds	r7, #20
 800efd6:	46bd      	mov	sp, r7
 800efd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800efdc:	4770      	bx	lr

0800efde <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_TypeDef *USBx)
{
 800efde:	b480      	push	{r7}
 800efe0:	b085      	sub	sp, #20
 800efe2:	af00      	add	r7, sp, #0
 800efe4:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 800efe6:	f64b 7380 	movw	r3, #49024	; 0xbf80
 800efea:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 800efec:	687b      	ldr	r3, [r7, #4]
 800efee:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800eff2:	b29a      	uxth	r2, r3
 800eff4:	68fb      	ldr	r3, [r7, #12]
 800eff6:	b29b      	uxth	r3, r3
 800eff8:	43db      	mvns	r3, r3
 800effa:	b29b      	uxth	r3, r3
 800effc:	4013      	ands	r3, r2
 800effe:	b29a      	uxth	r2, r3
 800f000:	687b      	ldr	r3, [r7, #4]
 800f002:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
 800f006:	2300      	movs	r3, #0
}
 800f008:	4618      	mov	r0, r3
 800f00a:	3714      	adds	r7, #20
 800f00c:	46bd      	mov	sp, r7
 800f00e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f012:	4770      	bx	lr

0800f014 <USB_DevInit>:
  * @param  cfg  pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800f014:	b480      	push	{r7}
 800f016:	b085      	sub	sp, #20
 800f018:	af00      	add	r7, sp, #0
 800f01a:	60f8      	str	r0, [r7, #12]
 800f01c:	1d3b      	adds	r3, r7, #4
 800f01e:	e883 0006 	stmia.w	r3, {r1, r2}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /* CNTR_FRES = 1 */
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 800f022:	68fb      	ldr	r3, [r7, #12]
 800f024:	2201      	movs	r2, #1
 800f026:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  /* CNTR_FRES = 0 */
  USBx->CNTR = 0U;
 800f02a:	68fb      	ldr	r3, [r7, #12]
 800f02c:	2200      	movs	r2, #0
 800f02e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 800f032:	68fb      	ldr	r3, [r7, #12]
 800f034:	2200      	movs	r2, #0
 800f036:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 800f03a:	68fb      	ldr	r3, [r7, #12]
 800f03c:	2200      	movs	r2, #0
 800f03e:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 800f042:	2300      	movs	r3, #0
}
 800f044:	4618      	mov	r0, r3
 800f046:	3714      	adds	r7, #20
 800f048:	46bd      	mov	sp, r7
 800f04a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f04e:	4770      	bx	lr

0800f050 <USB_ActivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800f050:	b480      	push	{r7}
 800f052:	b09d      	sub	sp, #116	; 0x74
 800f054:	af00      	add	r7, sp, #0
 800f056:	6078      	str	r0, [r7, #4]
 800f058:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef ret = HAL_OK;
 800f05a:	2300      	movs	r3, #0
 800f05c:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  uint16_t wEpRegVal;

  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 800f060:	687a      	ldr	r2, [r7, #4]
 800f062:	683b      	ldr	r3, [r7, #0]
 800f064:	781b      	ldrb	r3, [r3, #0]
 800f066:	009b      	lsls	r3, r3, #2
 800f068:	4413      	add	r3, r2
 800f06a:	881b      	ldrh	r3, [r3, #0]
 800f06c:	b29b      	uxth	r3, r3
 800f06e:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 800f072:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f076:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c

  /* initialize Endpoint */
  switch (ep->type)
 800f07a:	683b      	ldr	r3, [r7, #0]
 800f07c:	78db      	ldrb	r3, [r3, #3]
 800f07e:	2b03      	cmp	r3, #3
 800f080:	d81f      	bhi.n	800f0c2 <USB_ActivateEndpoint+0x72>
 800f082:	a201      	add	r2, pc, #4	; (adr r2, 800f088 <USB_ActivateEndpoint+0x38>)
 800f084:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f088:	0800f099 	.word	0x0800f099
 800f08c:	0800f0b5 	.word	0x0800f0b5
 800f090:	0800f0cb 	.word	0x0800f0cb
 800f094:	0800f0a7 	.word	0x0800f0a7
  {
    case EP_TYPE_CTRL:
      wEpRegVal |= USB_EP_CONTROL;
 800f098:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 800f09c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800f0a0:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
      break;
 800f0a4:	e012      	b.n	800f0cc <USB_ActivateEndpoint+0x7c>
    case EP_TYPE_BULK:
      wEpRegVal |= USB_EP_BULK;
      break;

    case EP_TYPE_INTR:
      wEpRegVal |= USB_EP_INTERRUPT;
 800f0a6:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 800f0aa:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
 800f0ae:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
      break;
 800f0b2:	e00b      	b.n	800f0cc <USB_ActivateEndpoint+0x7c>

    case EP_TYPE_ISOC:
      wEpRegVal |= USB_EP_ISOCHRONOUS;
 800f0b4:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 800f0b8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800f0bc:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
      break;
 800f0c0:	e004      	b.n	800f0cc <USB_ActivateEndpoint+0x7c>

    default:
      ret = HAL_ERROR;
 800f0c2:	2301      	movs	r3, #1
 800f0c4:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
      break;
 800f0c8:	e000      	b.n	800f0cc <USB_ActivateEndpoint+0x7c>
      break;
 800f0ca:	bf00      	nop
  }

  PCD_SET_ENDPOINT(USBx, ep->num, (wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX));
 800f0cc:	687a      	ldr	r2, [r7, #4]
 800f0ce:	683b      	ldr	r3, [r7, #0]
 800f0d0:	781b      	ldrb	r3, [r3, #0]
 800f0d2:	009b      	lsls	r3, r3, #2
 800f0d4:	441a      	add	r2, r3
 800f0d6:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 800f0da:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f0de:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f0e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f0e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f0ea:	b29b      	uxth	r3, r3
 800f0ec:	8013      	strh	r3, [r2, #0]

  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 800f0ee:	687a      	ldr	r2, [r7, #4]
 800f0f0:	683b      	ldr	r3, [r7, #0]
 800f0f2:	781b      	ldrb	r3, [r3, #0]
 800f0f4:	009b      	lsls	r3, r3, #2
 800f0f6:	4413      	add	r3, r2
 800f0f8:	881b      	ldrh	r3, [r3, #0]
 800f0fa:	b29b      	uxth	r3, r3
 800f0fc:	b21b      	sxth	r3, r3
 800f0fe:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f102:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f106:	b21a      	sxth	r2, r3
 800f108:	683b      	ldr	r3, [r7, #0]
 800f10a:	781b      	ldrb	r3, [r3, #0]
 800f10c:	b21b      	sxth	r3, r3
 800f10e:	4313      	orrs	r3, r2
 800f110:	b21b      	sxth	r3, r3
 800f112:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 800f116:	687a      	ldr	r2, [r7, #4]
 800f118:	683b      	ldr	r3, [r7, #0]
 800f11a:	781b      	ldrb	r3, [r3, #0]
 800f11c:	009b      	lsls	r3, r3, #2
 800f11e:	441a      	add	r2, r3
 800f120:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800f124:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f128:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f12c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f130:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f134:	b29b      	uxth	r3, r3
 800f136:	8013      	strh	r3, [r2, #0]

  if (ep->doublebuffer == 0U)
 800f138:	683b      	ldr	r3, [r7, #0]
 800f13a:	7b1b      	ldrb	r3, [r3, #12]
 800f13c:	2b00      	cmp	r3, #0
 800f13e:	f040 8178 	bne.w	800f432 <USB_ActivateEndpoint+0x3e2>
  {
    if (ep->is_in != 0U)
 800f142:	683b      	ldr	r3, [r7, #0]
 800f144:	785b      	ldrb	r3, [r3, #1]
 800f146:	2b00      	cmp	r3, #0
 800f148:	f000 8084 	beq.w	800f254 <USB_ActivateEndpoint+0x204>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 800f14c:	687b      	ldr	r3, [r7, #4]
 800f14e:	61bb      	str	r3, [r7, #24]
 800f150:	687b      	ldr	r3, [r7, #4]
 800f152:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f156:	b29b      	uxth	r3, r3
 800f158:	461a      	mov	r2, r3
 800f15a:	69bb      	ldr	r3, [r7, #24]
 800f15c:	4413      	add	r3, r2
 800f15e:	61bb      	str	r3, [r7, #24]
 800f160:	683b      	ldr	r3, [r7, #0]
 800f162:	781b      	ldrb	r3, [r3, #0]
 800f164:	00da      	lsls	r2, r3, #3
 800f166:	69bb      	ldr	r3, [r7, #24]
 800f168:	4413      	add	r3, r2
 800f16a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800f16e:	617b      	str	r3, [r7, #20]
 800f170:	683b      	ldr	r3, [r7, #0]
 800f172:	88db      	ldrh	r3, [r3, #6]
 800f174:	085b      	lsrs	r3, r3, #1
 800f176:	b29b      	uxth	r3, r3
 800f178:	005b      	lsls	r3, r3, #1
 800f17a:	b29a      	uxth	r2, r3
 800f17c:	697b      	ldr	r3, [r7, #20]
 800f17e:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800f180:	687a      	ldr	r2, [r7, #4]
 800f182:	683b      	ldr	r3, [r7, #0]
 800f184:	781b      	ldrb	r3, [r3, #0]
 800f186:	009b      	lsls	r3, r3, #2
 800f188:	4413      	add	r3, r2
 800f18a:	881b      	ldrh	r3, [r3, #0]
 800f18c:	827b      	strh	r3, [r7, #18]
 800f18e:	8a7b      	ldrh	r3, [r7, #18]
 800f190:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f194:	2b00      	cmp	r3, #0
 800f196:	d01b      	beq.n	800f1d0 <USB_ActivateEndpoint+0x180>
 800f198:	687a      	ldr	r2, [r7, #4]
 800f19a:	683b      	ldr	r3, [r7, #0]
 800f19c:	781b      	ldrb	r3, [r3, #0]
 800f19e:	009b      	lsls	r3, r3, #2
 800f1a0:	4413      	add	r3, r2
 800f1a2:	881b      	ldrh	r3, [r3, #0]
 800f1a4:	b29b      	uxth	r3, r3
 800f1a6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f1aa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f1ae:	823b      	strh	r3, [r7, #16]
 800f1b0:	687a      	ldr	r2, [r7, #4]
 800f1b2:	683b      	ldr	r3, [r7, #0]
 800f1b4:	781b      	ldrb	r3, [r3, #0]
 800f1b6:	009b      	lsls	r3, r3, #2
 800f1b8:	441a      	add	r2, r3
 800f1ba:	8a3b      	ldrh	r3, [r7, #16]
 800f1bc:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f1c0:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f1c4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f1c8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800f1cc:	b29b      	uxth	r3, r3
 800f1ce:	8013      	strh	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 800f1d0:	683b      	ldr	r3, [r7, #0]
 800f1d2:	78db      	ldrb	r3, [r3, #3]
 800f1d4:	2b01      	cmp	r3, #1
 800f1d6:	d020      	beq.n	800f21a <USB_ActivateEndpoint+0x1ca>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800f1d8:	687a      	ldr	r2, [r7, #4]
 800f1da:	683b      	ldr	r3, [r7, #0]
 800f1dc:	781b      	ldrb	r3, [r3, #0]
 800f1de:	009b      	lsls	r3, r3, #2
 800f1e0:	4413      	add	r3, r2
 800f1e2:	881b      	ldrh	r3, [r3, #0]
 800f1e4:	b29b      	uxth	r3, r3
 800f1e6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f1ea:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800f1ee:	81bb      	strh	r3, [r7, #12]
 800f1f0:	89bb      	ldrh	r3, [r7, #12]
 800f1f2:	f083 0320 	eor.w	r3, r3, #32
 800f1f6:	81bb      	strh	r3, [r7, #12]
 800f1f8:	687a      	ldr	r2, [r7, #4]
 800f1fa:	683b      	ldr	r3, [r7, #0]
 800f1fc:	781b      	ldrb	r3, [r3, #0]
 800f1fe:	009b      	lsls	r3, r3, #2
 800f200:	441a      	add	r2, r3
 800f202:	89bb      	ldrh	r3, [r7, #12]
 800f204:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f208:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f20c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f210:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f214:	b29b      	uxth	r3, r3
 800f216:	8013      	strh	r3, [r2, #0]
 800f218:	e2d5      	b.n	800f7c6 <USB_ActivateEndpoint+0x776>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800f21a:	687a      	ldr	r2, [r7, #4]
 800f21c:	683b      	ldr	r3, [r7, #0]
 800f21e:	781b      	ldrb	r3, [r3, #0]
 800f220:	009b      	lsls	r3, r3, #2
 800f222:	4413      	add	r3, r2
 800f224:	881b      	ldrh	r3, [r3, #0]
 800f226:	b29b      	uxth	r3, r3
 800f228:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f22c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800f230:	81fb      	strh	r3, [r7, #14]
 800f232:	687a      	ldr	r2, [r7, #4]
 800f234:	683b      	ldr	r3, [r7, #0]
 800f236:	781b      	ldrb	r3, [r3, #0]
 800f238:	009b      	lsls	r3, r3, #2
 800f23a:	441a      	add	r2, r3
 800f23c:	89fb      	ldrh	r3, [r7, #14]
 800f23e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f242:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f246:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f24a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f24e:	b29b      	uxth	r3, r3
 800f250:	8013      	strh	r3, [r2, #0]
 800f252:	e2b8      	b.n	800f7c6 <USB_ActivateEndpoint+0x776>
      }
    }
    else
    {
      /* Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 800f254:	687b      	ldr	r3, [r7, #4]
 800f256:	633b      	str	r3, [r7, #48]	; 0x30
 800f258:	687b      	ldr	r3, [r7, #4]
 800f25a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f25e:	b29b      	uxth	r3, r3
 800f260:	461a      	mov	r2, r3
 800f262:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f264:	4413      	add	r3, r2
 800f266:	633b      	str	r3, [r7, #48]	; 0x30
 800f268:	683b      	ldr	r3, [r7, #0]
 800f26a:	781b      	ldrb	r3, [r3, #0]
 800f26c:	00da      	lsls	r2, r3, #3
 800f26e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f270:	4413      	add	r3, r2
 800f272:	f203 4304 	addw	r3, r3, #1028	; 0x404
 800f276:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f278:	683b      	ldr	r3, [r7, #0]
 800f27a:	88db      	ldrh	r3, [r3, #6]
 800f27c:	085b      	lsrs	r3, r3, #1
 800f27e:	b29b      	uxth	r3, r3
 800f280:	005b      	lsls	r3, r3, #1
 800f282:	b29a      	uxth	r2, r3
 800f284:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f286:	801a      	strh	r2, [r3, #0]

      /* Set the endpoint Receive buffer counter */
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 800f288:	687b      	ldr	r3, [r7, #4]
 800f28a:	62bb      	str	r3, [r7, #40]	; 0x28
 800f28c:	687b      	ldr	r3, [r7, #4]
 800f28e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f292:	b29b      	uxth	r3, r3
 800f294:	461a      	mov	r2, r3
 800f296:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f298:	4413      	add	r3, r2
 800f29a:	62bb      	str	r3, [r7, #40]	; 0x28
 800f29c:	683b      	ldr	r3, [r7, #0]
 800f29e:	781b      	ldrb	r3, [r3, #0]
 800f2a0:	00da      	lsls	r2, r3, #3
 800f2a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f2a4:	4413      	add	r3, r2
 800f2a6:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800f2aa:	627b      	str	r3, [r7, #36]	; 0x24
 800f2ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2ae:	881b      	ldrh	r3, [r3, #0]
 800f2b0:	b29b      	uxth	r3, r3
 800f2b2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800f2b6:	b29a      	uxth	r2, r3
 800f2b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2ba:	801a      	strh	r2, [r3, #0]
 800f2bc:	683b      	ldr	r3, [r7, #0]
 800f2be:	691b      	ldr	r3, [r3, #16]
 800f2c0:	2b3e      	cmp	r3, #62	; 0x3e
 800f2c2:	d91d      	bls.n	800f300 <USB_ActivateEndpoint+0x2b0>
 800f2c4:	683b      	ldr	r3, [r7, #0]
 800f2c6:	691b      	ldr	r3, [r3, #16]
 800f2c8:	095b      	lsrs	r3, r3, #5
 800f2ca:	66bb      	str	r3, [r7, #104]	; 0x68
 800f2cc:	683b      	ldr	r3, [r7, #0]
 800f2ce:	691b      	ldr	r3, [r3, #16]
 800f2d0:	f003 031f 	and.w	r3, r3, #31
 800f2d4:	2b00      	cmp	r3, #0
 800f2d6:	d102      	bne.n	800f2de <USB_ActivateEndpoint+0x28e>
 800f2d8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f2da:	3b01      	subs	r3, #1
 800f2dc:	66bb      	str	r3, [r7, #104]	; 0x68
 800f2de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2e0:	881b      	ldrh	r3, [r3, #0]
 800f2e2:	b29a      	uxth	r2, r3
 800f2e4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f2e6:	b29b      	uxth	r3, r3
 800f2e8:	029b      	lsls	r3, r3, #10
 800f2ea:	b29b      	uxth	r3, r3
 800f2ec:	4313      	orrs	r3, r2
 800f2ee:	b29b      	uxth	r3, r3
 800f2f0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800f2f4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800f2f8:	b29a      	uxth	r2, r3
 800f2fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2fc:	801a      	strh	r2, [r3, #0]
 800f2fe:	e026      	b.n	800f34e <USB_ActivateEndpoint+0x2fe>
 800f300:	683b      	ldr	r3, [r7, #0]
 800f302:	691b      	ldr	r3, [r3, #16]
 800f304:	2b00      	cmp	r3, #0
 800f306:	d10a      	bne.n	800f31e <USB_ActivateEndpoint+0x2ce>
 800f308:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f30a:	881b      	ldrh	r3, [r3, #0]
 800f30c:	b29b      	uxth	r3, r3
 800f30e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800f312:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800f316:	b29a      	uxth	r2, r3
 800f318:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f31a:	801a      	strh	r2, [r3, #0]
 800f31c:	e017      	b.n	800f34e <USB_ActivateEndpoint+0x2fe>
 800f31e:	683b      	ldr	r3, [r7, #0]
 800f320:	691b      	ldr	r3, [r3, #16]
 800f322:	085b      	lsrs	r3, r3, #1
 800f324:	66bb      	str	r3, [r7, #104]	; 0x68
 800f326:	683b      	ldr	r3, [r7, #0]
 800f328:	691b      	ldr	r3, [r3, #16]
 800f32a:	f003 0301 	and.w	r3, r3, #1
 800f32e:	2b00      	cmp	r3, #0
 800f330:	d002      	beq.n	800f338 <USB_ActivateEndpoint+0x2e8>
 800f332:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f334:	3301      	adds	r3, #1
 800f336:	66bb      	str	r3, [r7, #104]	; 0x68
 800f338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f33a:	881b      	ldrh	r3, [r3, #0]
 800f33c:	b29a      	uxth	r2, r3
 800f33e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800f340:	b29b      	uxth	r3, r3
 800f342:	029b      	lsls	r3, r3, #10
 800f344:	b29b      	uxth	r3, r3
 800f346:	4313      	orrs	r3, r2
 800f348:	b29a      	uxth	r2, r3
 800f34a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f34c:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800f34e:	687a      	ldr	r2, [r7, #4]
 800f350:	683b      	ldr	r3, [r7, #0]
 800f352:	781b      	ldrb	r3, [r3, #0]
 800f354:	009b      	lsls	r3, r3, #2
 800f356:	4413      	add	r3, r2
 800f358:	881b      	ldrh	r3, [r3, #0]
 800f35a:	847b      	strh	r3, [r7, #34]	; 0x22
 800f35c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800f35e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800f362:	2b00      	cmp	r3, #0
 800f364:	d01b      	beq.n	800f39e <USB_ActivateEndpoint+0x34e>
 800f366:	687a      	ldr	r2, [r7, #4]
 800f368:	683b      	ldr	r3, [r7, #0]
 800f36a:	781b      	ldrb	r3, [r3, #0]
 800f36c:	009b      	lsls	r3, r3, #2
 800f36e:	4413      	add	r3, r2
 800f370:	881b      	ldrh	r3, [r3, #0]
 800f372:	b29b      	uxth	r3, r3
 800f374:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f378:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f37c:	843b      	strh	r3, [r7, #32]
 800f37e:	687a      	ldr	r2, [r7, #4]
 800f380:	683b      	ldr	r3, [r7, #0]
 800f382:	781b      	ldrb	r3, [r3, #0]
 800f384:	009b      	lsls	r3, r3, #2
 800f386:	441a      	add	r2, r3
 800f388:	8c3b      	ldrh	r3, [r7, #32]
 800f38a:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f38e:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f392:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f396:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f39a:	b29b      	uxth	r3, r3
 800f39c:	8013      	strh	r3, [r2, #0]

      if (ep->num == 0U)
 800f39e:	683b      	ldr	r3, [r7, #0]
 800f3a0:	781b      	ldrb	r3, [r3, #0]
 800f3a2:	2b00      	cmp	r3, #0
 800f3a4:	d124      	bne.n	800f3f0 <USB_ActivateEndpoint+0x3a0>
      {
        /* Configure VALID status for EP0 */
        PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800f3a6:	687a      	ldr	r2, [r7, #4]
 800f3a8:	683b      	ldr	r3, [r7, #0]
 800f3aa:	781b      	ldrb	r3, [r3, #0]
 800f3ac:	009b      	lsls	r3, r3, #2
 800f3ae:	4413      	add	r3, r2
 800f3b0:	881b      	ldrh	r3, [r3, #0]
 800f3b2:	b29b      	uxth	r3, r3
 800f3b4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f3b8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f3bc:	83bb      	strh	r3, [r7, #28]
 800f3be:	8bbb      	ldrh	r3, [r7, #28]
 800f3c0:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800f3c4:	83bb      	strh	r3, [r7, #28]
 800f3c6:	8bbb      	ldrh	r3, [r7, #28]
 800f3c8:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800f3cc:	83bb      	strh	r3, [r7, #28]
 800f3ce:	687a      	ldr	r2, [r7, #4]
 800f3d0:	683b      	ldr	r3, [r7, #0]
 800f3d2:	781b      	ldrb	r3, [r3, #0]
 800f3d4:	009b      	lsls	r3, r3, #2
 800f3d6:	441a      	add	r2, r3
 800f3d8:	8bbb      	ldrh	r3, [r7, #28]
 800f3da:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f3de:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f3e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f3e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f3ea:	b29b      	uxth	r3, r3
 800f3ec:	8013      	strh	r3, [r2, #0]
 800f3ee:	e1ea      	b.n	800f7c6 <USB_ActivateEndpoint+0x776>
      }
      else
      {
        /* Configure NAK status for OUT Endpoint */
        PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_NAK);
 800f3f0:	687a      	ldr	r2, [r7, #4]
 800f3f2:	683b      	ldr	r3, [r7, #0]
 800f3f4:	781b      	ldrb	r3, [r3, #0]
 800f3f6:	009b      	lsls	r3, r3, #2
 800f3f8:	4413      	add	r3, r2
 800f3fa:	881b      	ldrh	r3, [r3, #0]
 800f3fc:	b29b      	uxth	r3, r3
 800f3fe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f402:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f406:	83fb      	strh	r3, [r7, #30]
 800f408:	8bfb      	ldrh	r3, [r7, #30]
 800f40a:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800f40e:	83fb      	strh	r3, [r7, #30]
 800f410:	687a      	ldr	r2, [r7, #4]
 800f412:	683b      	ldr	r3, [r7, #0]
 800f414:	781b      	ldrb	r3, [r3, #0]
 800f416:	009b      	lsls	r3, r3, #2
 800f418:	441a      	add	r2, r3
 800f41a:	8bfb      	ldrh	r3, [r7, #30]
 800f41c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f420:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f424:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f428:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f42c:	b29b      	uxth	r3, r3
 800f42e:	8013      	strh	r3, [r2, #0]
 800f430:	e1c9      	b.n	800f7c6 <USB_ActivateEndpoint+0x776>
  }
#if (USE_USB_DOUBLE_BUFFER == 1U)
  /* Double Buffer */
  else
  {
    if (ep->type == EP_TYPE_BULK)
 800f432:	683b      	ldr	r3, [r7, #0]
 800f434:	78db      	ldrb	r3, [r3, #3]
 800f436:	2b02      	cmp	r3, #2
 800f438:	d11e      	bne.n	800f478 <USB_ActivateEndpoint+0x428>
    {
      /* Set bulk endpoint as double buffered */
      PCD_SET_BULK_EP_DBUF(USBx, ep->num);
 800f43a:	687a      	ldr	r2, [r7, #4]
 800f43c:	683b      	ldr	r3, [r7, #0]
 800f43e:	781b      	ldrb	r3, [r3, #0]
 800f440:	009b      	lsls	r3, r3, #2
 800f442:	4413      	add	r3, r2
 800f444:	881b      	ldrh	r3, [r3, #0]
 800f446:	b29b      	uxth	r3, r3
 800f448:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f44c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f450:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 800f454:	687a      	ldr	r2, [r7, #4]
 800f456:	683b      	ldr	r3, [r7, #0]
 800f458:	781b      	ldrb	r3, [r3, #0]
 800f45a:	009b      	lsls	r3, r3, #2
 800f45c:	441a      	add	r2, r3
 800f45e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 800f462:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f466:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f46a:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 800f46e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f472:	b29b      	uxth	r3, r3
 800f474:	8013      	strh	r3, [r2, #0]
 800f476:	e01d      	b.n	800f4b4 <USB_ActivateEndpoint+0x464>
    }
    else
    {
      /* Set the ISOC endpoint in double buffer mode */
      PCD_CLEAR_EP_KIND(USBx, ep->num);
 800f478:	687a      	ldr	r2, [r7, #4]
 800f47a:	683b      	ldr	r3, [r7, #0]
 800f47c:	781b      	ldrb	r3, [r3, #0]
 800f47e:	009b      	lsls	r3, r3, #2
 800f480:	4413      	add	r3, r2
 800f482:	881b      	ldrh	r3, [r3, #0]
 800f484:	b29b      	uxth	r3, r3
 800f486:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
 800f48a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f48e:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 800f492:	687a      	ldr	r2, [r7, #4]
 800f494:	683b      	ldr	r3, [r7, #0]
 800f496:	781b      	ldrb	r3, [r3, #0]
 800f498:	009b      	lsls	r3, r3, #2
 800f49a:	441a      	add	r2, r3
 800f49c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 800f4a0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f4a4:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f4a8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f4ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f4b0:	b29b      	uxth	r3, r3
 800f4b2:	8013      	strh	r3, [r2, #0]
    }

    /* Set buffer address for double buffered mode */
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 800f4b4:	687b      	ldr	r3, [r7, #4]
 800f4b6:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f4b8:	687b      	ldr	r3, [r7, #4]
 800f4ba:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f4be:	b29b      	uxth	r3, r3
 800f4c0:	461a      	mov	r2, r3
 800f4c2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f4c4:	4413      	add	r3, r2
 800f4c6:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f4c8:	683b      	ldr	r3, [r7, #0]
 800f4ca:	781b      	ldrb	r3, [r3, #0]
 800f4cc:	00da      	lsls	r2, r3, #3
 800f4ce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f4d0:	4413      	add	r3, r2
 800f4d2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800f4d6:	65bb      	str	r3, [r7, #88]	; 0x58
 800f4d8:	683b      	ldr	r3, [r7, #0]
 800f4da:	891b      	ldrh	r3, [r3, #8]
 800f4dc:	085b      	lsrs	r3, r3, #1
 800f4de:	b29b      	uxth	r3, r3
 800f4e0:	005b      	lsls	r3, r3, #1
 800f4e2:	b29a      	uxth	r2, r3
 800f4e4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f4e6:	801a      	strh	r2, [r3, #0]
 800f4e8:	687b      	ldr	r3, [r7, #4]
 800f4ea:	657b      	str	r3, [r7, #84]	; 0x54
 800f4ec:	687b      	ldr	r3, [r7, #4]
 800f4ee:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f4f2:	b29b      	uxth	r3, r3
 800f4f4:	461a      	mov	r2, r3
 800f4f6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f4f8:	4413      	add	r3, r2
 800f4fa:	657b      	str	r3, [r7, #84]	; 0x54
 800f4fc:	683b      	ldr	r3, [r7, #0]
 800f4fe:	781b      	ldrb	r3, [r3, #0]
 800f500:	00da      	lsls	r2, r3, #3
 800f502:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f504:	4413      	add	r3, r2
 800f506:	f203 4304 	addw	r3, r3, #1028	; 0x404
 800f50a:	653b      	str	r3, [r7, #80]	; 0x50
 800f50c:	683b      	ldr	r3, [r7, #0]
 800f50e:	895b      	ldrh	r3, [r3, #10]
 800f510:	085b      	lsrs	r3, r3, #1
 800f512:	b29b      	uxth	r3, r3
 800f514:	005b      	lsls	r3, r3, #1
 800f516:	b29a      	uxth	r2, r3
 800f518:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f51a:	801a      	strh	r2, [r3, #0]

    if (ep->is_in == 0U)
 800f51c:	683b      	ldr	r3, [r7, #0]
 800f51e:	785b      	ldrb	r3, [r3, #1]
 800f520:	2b00      	cmp	r3, #0
 800f522:	f040 8093 	bne.w	800f64c <USB_ActivateEndpoint+0x5fc>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT */
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800f526:	687a      	ldr	r2, [r7, #4]
 800f528:	683b      	ldr	r3, [r7, #0]
 800f52a:	781b      	ldrb	r3, [r3, #0]
 800f52c:	009b      	lsls	r3, r3, #2
 800f52e:	4413      	add	r3, r2
 800f530:	881b      	ldrh	r3, [r3, #0]
 800f532:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 800f536:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800f53a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800f53e:	2b00      	cmp	r3, #0
 800f540:	d01b      	beq.n	800f57a <USB_ActivateEndpoint+0x52a>
 800f542:	687a      	ldr	r2, [r7, #4]
 800f544:	683b      	ldr	r3, [r7, #0]
 800f546:	781b      	ldrb	r3, [r3, #0]
 800f548:	009b      	lsls	r3, r3, #2
 800f54a:	4413      	add	r3, r2
 800f54c:	881b      	ldrh	r3, [r3, #0]
 800f54e:	b29b      	uxth	r3, r3
 800f550:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f554:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f558:	87fb      	strh	r3, [r7, #62]	; 0x3e
 800f55a:	687a      	ldr	r2, [r7, #4]
 800f55c:	683b      	ldr	r3, [r7, #0]
 800f55e:	781b      	ldrb	r3, [r3, #0]
 800f560:	009b      	lsls	r3, r3, #2
 800f562:	441a      	add	r2, r3
 800f564:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800f566:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f56a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f56e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f572:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f576:	b29b      	uxth	r3, r3
 800f578:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800f57a:	687a      	ldr	r2, [r7, #4]
 800f57c:	683b      	ldr	r3, [r7, #0]
 800f57e:	781b      	ldrb	r3, [r3, #0]
 800f580:	009b      	lsls	r3, r3, #2
 800f582:	4413      	add	r3, r2
 800f584:	881b      	ldrh	r3, [r3, #0]
 800f586:	87bb      	strh	r3, [r7, #60]	; 0x3c
 800f588:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 800f58a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f58e:	2b00      	cmp	r3, #0
 800f590:	d01b      	beq.n	800f5ca <USB_ActivateEndpoint+0x57a>
 800f592:	687a      	ldr	r2, [r7, #4]
 800f594:	683b      	ldr	r3, [r7, #0]
 800f596:	781b      	ldrb	r3, [r3, #0]
 800f598:	009b      	lsls	r3, r3, #2
 800f59a:	4413      	add	r3, r2
 800f59c:	881b      	ldrh	r3, [r3, #0]
 800f59e:	b29b      	uxth	r3, r3
 800f5a0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f5a4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f5a8:	877b      	strh	r3, [r7, #58]	; 0x3a
 800f5aa:	687a      	ldr	r2, [r7, #4]
 800f5ac:	683b      	ldr	r3, [r7, #0]
 800f5ae:	781b      	ldrb	r3, [r3, #0]
 800f5b0:	009b      	lsls	r3, r3, #2
 800f5b2:	441a      	add	r2, r3
 800f5b4:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 800f5b6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f5ba:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f5be:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f5c2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800f5c6:	b29b      	uxth	r3, r3
 800f5c8:	8013      	strh	r3, [r2, #0]

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800f5ca:	687a      	ldr	r2, [r7, #4]
 800f5cc:	683b      	ldr	r3, [r7, #0]
 800f5ce:	781b      	ldrb	r3, [r3, #0]
 800f5d0:	009b      	lsls	r3, r3, #2
 800f5d2:	4413      	add	r3, r2
 800f5d4:	881b      	ldrh	r3, [r3, #0]
 800f5d6:	b29b      	uxth	r3, r3
 800f5d8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f5dc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f5e0:	873b      	strh	r3, [r7, #56]	; 0x38
 800f5e2:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800f5e4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800f5e8:	873b      	strh	r3, [r7, #56]	; 0x38
 800f5ea:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800f5ec:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800f5f0:	873b      	strh	r3, [r7, #56]	; 0x38
 800f5f2:	687a      	ldr	r2, [r7, #4]
 800f5f4:	683b      	ldr	r3, [r7, #0]
 800f5f6:	781b      	ldrb	r3, [r3, #0]
 800f5f8:	009b      	lsls	r3, r3, #2
 800f5fa:	441a      	add	r2, r3
 800f5fc:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800f5fe:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f602:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f606:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f60a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f60e:	b29b      	uxth	r3, r3
 800f610:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800f612:	687a      	ldr	r2, [r7, #4]
 800f614:	683b      	ldr	r3, [r7, #0]
 800f616:	781b      	ldrb	r3, [r3, #0]
 800f618:	009b      	lsls	r3, r3, #2
 800f61a:	4413      	add	r3, r2
 800f61c:	881b      	ldrh	r3, [r3, #0]
 800f61e:	b29b      	uxth	r3, r3
 800f620:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f624:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800f628:	86fb      	strh	r3, [r7, #54]	; 0x36
 800f62a:	687a      	ldr	r2, [r7, #4]
 800f62c:	683b      	ldr	r3, [r7, #0]
 800f62e:	781b      	ldrb	r3, [r3, #0]
 800f630:	009b      	lsls	r3, r3, #2
 800f632:	441a      	add	r2, r3
 800f634:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800f636:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f63a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f63e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f642:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f646:	b29b      	uxth	r3, r3
 800f648:	8013      	strh	r3, [r2, #0]
 800f64a:	e0bc      	b.n	800f7c6 <USB_ActivateEndpoint+0x776>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT */
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800f64c:	687a      	ldr	r2, [r7, #4]
 800f64e:	683b      	ldr	r3, [r7, #0]
 800f650:	781b      	ldrb	r3, [r3, #0]
 800f652:	009b      	lsls	r3, r3, #2
 800f654:	4413      	add	r3, r2
 800f656:	881b      	ldrh	r3, [r3, #0]
 800f658:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 800f65c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800f660:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800f664:	2b00      	cmp	r3, #0
 800f666:	d01d      	beq.n	800f6a4 <USB_ActivateEndpoint+0x654>
 800f668:	687a      	ldr	r2, [r7, #4]
 800f66a:	683b      	ldr	r3, [r7, #0]
 800f66c:	781b      	ldrb	r3, [r3, #0]
 800f66e:	009b      	lsls	r3, r3, #2
 800f670:	4413      	add	r3, r2
 800f672:	881b      	ldrh	r3, [r3, #0]
 800f674:	b29b      	uxth	r3, r3
 800f676:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f67a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f67e:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 800f682:	687a      	ldr	r2, [r7, #4]
 800f684:	683b      	ldr	r3, [r7, #0]
 800f686:	781b      	ldrb	r3, [r3, #0]
 800f688:	009b      	lsls	r3, r3, #2
 800f68a:	441a      	add	r2, r3
 800f68c:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800f690:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f694:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f698:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f69c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f6a0:	b29b      	uxth	r3, r3
 800f6a2:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800f6a4:	687a      	ldr	r2, [r7, #4]
 800f6a6:	683b      	ldr	r3, [r7, #0]
 800f6a8:	781b      	ldrb	r3, [r3, #0]
 800f6aa:	009b      	lsls	r3, r3, #2
 800f6ac:	4413      	add	r3, r2
 800f6ae:	881b      	ldrh	r3, [r3, #0]
 800f6b0:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 800f6b4:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800f6b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f6bc:	2b00      	cmp	r3, #0
 800f6be:	d01d      	beq.n	800f6fc <USB_ActivateEndpoint+0x6ac>
 800f6c0:	687a      	ldr	r2, [r7, #4]
 800f6c2:	683b      	ldr	r3, [r7, #0]
 800f6c4:	781b      	ldrb	r3, [r3, #0]
 800f6c6:	009b      	lsls	r3, r3, #2
 800f6c8:	4413      	add	r3, r2
 800f6ca:	881b      	ldrh	r3, [r3, #0]
 800f6cc:	b29b      	uxth	r3, r3
 800f6ce:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f6d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f6d6:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
 800f6da:	687a      	ldr	r2, [r7, #4]
 800f6dc:	683b      	ldr	r3, [r7, #0]
 800f6de:	781b      	ldrb	r3, [r3, #0]
 800f6e0:	009b      	lsls	r3, r3, #2
 800f6e2:	441a      	add	r2, r3
 800f6e4:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 800f6e8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f6ec:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f6f0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f6f4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800f6f8:	b29b      	uxth	r3, r3
 800f6fa:	8013      	strh	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 800f6fc:	683b      	ldr	r3, [r7, #0]
 800f6fe:	78db      	ldrb	r3, [r3, #3]
 800f700:	2b01      	cmp	r3, #1
 800f702:	d024      	beq.n	800f74e <USB_ActivateEndpoint+0x6fe>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800f704:	687a      	ldr	r2, [r7, #4]
 800f706:	683b      	ldr	r3, [r7, #0]
 800f708:	781b      	ldrb	r3, [r3, #0]
 800f70a:	009b      	lsls	r3, r3, #2
 800f70c:	4413      	add	r3, r2
 800f70e:	881b      	ldrh	r3, [r3, #0]
 800f710:	b29b      	uxth	r3, r3
 800f712:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f716:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800f71a:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 800f71e:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 800f722:	f083 0320 	eor.w	r3, r3, #32
 800f726:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 800f72a:	687a      	ldr	r2, [r7, #4]
 800f72c:	683b      	ldr	r3, [r7, #0]
 800f72e:	781b      	ldrb	r3, [r3, #0]
 800f730:	009b      	lsls	r3, r3, #2
 800f732:	441a      	add	r2, r3
 800f734:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 800f738:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f73c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f740:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f744:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f748:	b29b      	uxth	r3, r3
 800f74a:	8013      	strh	r3, [r2, #0]
 800f74c:	e01d      	b.n	800f78a <USB_ActivateEndpoint+0x73a>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800f74e:	687a      	ldr	r2, [r7, #4]
 800f750:	683b      	ldr	r3, [r7, #0]
 800f752:	781b      	ldrb	r3, [r3, #0]
 800f754:	009b      	lsls	r3, r3, #2
 800f756:	4413      	add	r3, r2
 800f758:	881b      	ldrh	r3, [r3, #0]
 800f75a:	b29b      	uxth	r3, r3
 800f75c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f760:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800f764:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 800f768:	687a      	ldr	r2, [r7, #4]
 800f76a:	683b      	ldr	r3, [r7, #0]
 800f76c:	781b      	ldrb	r3, [r3, #0]
 800f76e:	009b      	lsls	r3, r3, #2
 800f770:	441a      	add	r2, r3
 800f772:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 800f776:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f77a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f77e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f782:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f786:	b29b      	uxth	r3, r3
 800f788:	8013      	strh	r3, [r2, #0]
      }

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800f78a:	687a      	ldr	r2, [r7, #4]
 800f78c:	683b      	ldr	r3, [r7, #0]
 800f78e:	781b      	ldrb	r3, [r3, #0]
 800f790:	009b      	lsls	r3, r3, #2
 800f792:	4413      	add	r3, r2
 800f794:	881b      	ldrh	r3, [r3, #0]
 800f796:	b29b      	uxth	r3, r3
 800f798:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f79c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f7a0:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 800f7a4:	687a      	ldr	r2, [r7, #4]
 800f7a6:	683b      	ldr	r3, [r7, #0]
 800f7a8:	781b      	ldrb	r3, [r3, #0]
 800f7aa:	009b      	lsls	r3, r3, #2
 800f7ac:	441a      	add	r2, r3
 800f7ae:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 800f7b2:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f7b6:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f7ba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f7be:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f7c2:	b29b      	uxth	r3, r3
 800f7c4:	8013      	strh	r3, [r2, #0]
    }
  }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  return ret;
 800f7c6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
}
 800f7ca:	4618      	mov	r0, r3
 800f7cc:	3774      	adds	r7, #116	; 0x74
 800f7ce:	46bd      	mov	sp, r7
 800f7d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7d4:	4770      	bx	lr
 800f7d6:	bf00      	nop

0800f7d8 <USB_DeactivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800f7d8:	b480      	push	{r7}
 800f7da:	b08d      	sub	sp, #52	; 0x34
 800f7dc:	af00      	add	r7, sp, #0
 800f7de:	6078      	str	r0, [r7, #4]
 800f7e0:	6039      	str	r1, [r7, #0]
  if (ep->doublebuffer == 0U)
 800f7e2:	683b      	ldr	r3, [r7, #0]
 800f7e4:	7b1b      	ldrb	r3, [r3, #12]
 800f7e6:	2b00      	cmp	r3, #0
 800f7e8:	f040 808e 	bne.w	800f908 <USB_DeactivateEndpoint+0x130>
  {
    if (ep->is_in != 0U)
 800f7ec:	683b      	ldr	r3, [r7, #0]
 800f7ee:	785b      	ldrb	r3, [r3, #1]
 800f7f0:	2b00      	cmp	r3, #0
 800f7f2:	d044      	beq.n	800f87e <USB_DeactivateEndpoint+0xa6>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800f7f4:	687a      	ldr	r2, [r7, #4]
 800f7f6:	683b      	ldr	r3, [r7, #0]
 800f7f8:	781b      	ldrb	r3, [r3, #0]
 800f7fa:	009b      	lsls	r3, r3, #2
 800f7fc:	4413      	add	r3, r2
 800f7fe:	881b      	ldrh	r3, [r3, #0]
 800f800:	81bb      	strh	r3, [r7, #12]
 800f802:	89bb      	ldrh	r3, [r7, #12]
 800f804:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f808:	2b00      	cmp	r3, #0
 800f80a:	d01b      	beq.n	800f844 <USB_DeactivateEndpoint+0x6c>
 800f80c:	687a      	ldr	r2, [r7, #4]
 800f80e:	683b      	ldr	r3, [r7, #0]
 800f810:	781b      	ldrb	r3, [r3, #0]
 800f812:	009b      	lsls	r3, r3, #2
 800f814:	4413      	add	r3, r2
 800f816:	881b      	ldrh	r3, [r3, #0]
 800f818:	b29b      	uxth	r3, r3
 800f81a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f81e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f822:	817b      	strh	r3, [r7, #10]
 800f824:	687a      	ldr	r2, [r7, #4]
 800f826:	683b      	ldr	r3, [r7, #0]
 800f828:	781b      	ldrb	r3, [r3, #0]
 800f82a:	009b      	lsls	r3, r3, #2
 800f82c:	441a      	add	r2, r3
 800f82e:	897b      	ldrh	r3, [r7, #10]
 800f830:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f834:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f838:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f83c:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800f840:	b29b      	uxth	r3, r3
 800f842:	8013      	strh	r3, [r2, #0]

      /* Configure DISABLE status for the Endpoint */
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800f844:	687a      	ldr	r2, [r7, #4]
 800f846:	683b      	ldr	r3, [r7, #0]
 800f848:	781b      	ldrb	r3, [r3, #0]
 800f84a:	009b      	lsls	r3, r3, #2
 800f84c:	4413      	add	r3, r2
 800f84e:	881b      	ldrh	r3, [r3, #0]
 800f850:	b29b      	uxth	r3, r3
 800f852:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f856:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800f85a:	813b      	strh	r3, [r7, #8]
 800f85c:	687a      	ldr	r2, [r7, #4]
 800f85e:	683b      	ldr	r3, [r7, #0]
 800f860:	781b      	ldrb	r3, [r3, #0]
 800f862:	009b      	lsls	r3, r3, #2
 800f864:	441a      	add	r2, r3
 800f866:	893b      	ldrh	r3, [r7, #8]
 800f868:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f86c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f870:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f874:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f878:	b29b      	uxth	r3, r3
 800f87a:	8013      	strh	r3, [r2, #0]
 800f87c:	e192      	b.n	800fba4 <USB_DeactivateEndpoint+0x3cc>
    }

    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800f87e:	687a      	ldr	r2, [r7, #4]
 800f880:	683b      	ldr	r3, [r7, #0]
 800f882:	781b      	ldrb	r3, [r3, #0]
 800f884:	009b      	lsls	r3, r3, #2
 800f886:	4413      	add	r3, r2
 800f888:	881b      	ldrh	r3, [r3, #0]
 800f88a:	827b      	strh	r3, [r7, #18]
 800f88c:	8a7b      	ldrh	r3, [r7, #18]
 800f88e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800f892:	2b00      	cmp	r3, #0
 800f894:	d01b      	beq.n	800f8ce <USB_DeactivateEndpoint+0xf6>
 800f896:	687a      	ldr	r2, [r7, #4]
 800f898:	683b      	ldr	r3, [r7, #0]
 800f89a:	781b      	ldrb	r3, [r3, #0]
 800f89c:	009b      	lsls	r3, r3, #2
 800f89e:	4413      	add	r3, r2
 800f8a0:	881b      	ldrh	r3, [r3, #0]
 800f8a2:	b29b      	uxth	r3, r3
 800f8a4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f8a8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f8ac:	823b      	strh	r3, [r7, #16]
 800f8ae:	687a      	ldr	r2, [r7, #4]
 800f8b0:	683b      	ldr	r3, [r7, #0]
 800f8b2:	781b      	ldrb	r3, [r3, #0]
 800f8b4:	009b      	lsls	r3, r3, #2
 800f8b6:	441a      	add	r2, r3
 800f8b8:	8a3b      	ldrh	r3, [r7, #16]
 800f8ba:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f8be:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f8c2:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f8c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f8ca:	b29b      	uxth	r3, r3
 800f8cc:	8013      	strh	r3, [r2, #0]

      /* Configure DISABLE status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800f8ce:	687a      	ldr	r2, [r7, #4]
 800f8d0:	683b      	ldr	r3, [r7, #0]
 800f8d2:	781b      	ldrb	r3, [r3, #0]
 800f8d4:	009b      	lsls	r3, r3, #2
 800f8d6:	4413      	add	r3, r2
 800f8d8:	881b      	ldrh	r3, [r3, #0]
 800f8da:	b29b      	uxth	r3, r3
 800f8dc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f8e0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f8e4:	81fb      	strh	r3, [r7, #14]
 800f8e6:	687a      	ldr	r2, [r7, #4]
 800f8e8:	683b      	ldr	r3, [r7, #0]
 800f8ea:	781b      	ldrb	r3, [r3, #0]
 800f8ec:	009b      	lsls	r3, r3, #2
 800f8ee:	441a      	add	r2, r3
 800f8f0:	89fb      	ldrh	r3, [r7, #14]
 800f8f2:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f8f6:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f8fa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f8fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f902:	b29b      	uxth	r3, r3
 800f904:	8013      	strh	r3, [r2, #0]
 800f906:	e14d      	b.n	800fba4 <USB_DeactivateEndpoint+0x3cc>
  }
#if (USE_USB_DOUBLE_BUFFER == 1U)
  /* Double Buffer */
  else
  {
    if (ep->is_in == 0U)
 800f908:	683b      	ldr	r3, [r7, #0]
 800f90a:	785b      	ldrb	r3, [r3, #1]
 800f90c:	2b00      	cmp	r3, #0
 800f90e:	f040 80a5 	bne.w	800fa5c <USB_DeactivateEndpoint+0x284>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800f912:	687a      	ldr	r2, [r7, #4]
 800f914:	683b      	ldr	r3, [r7, #0]
 800f916:	781b      	ldrb	r3, [r3, #0]
 800f918:	009b      	lsls	r3, r3, #2
 800f91a:	4413      	add	r3, r2
 800f91c:	881b      	ldrh	r3, [r3, #0]
 800f91e:	843b      	strh	r3, [r7, #32]
 800f920:	8c3b      	ldrh	r3, [r7, #32]
 800f922:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800f926:	2b00      	cmp	r3, #0
 800f928:	d01b      	beq.n	800f962 <USB_DeactivateEndpoint+0x18a>
 800f92a:	687a      	ldr	r2, [r7, #4]
 800f92c:	683b      	ldr	r3, [r7, #0]
 800f92e:	781b      	ldrb	r3, [r3, #0]
 800f930:	009b      	lsls	r3, r3, #2
 800f932:	4413      	add	r3, r2
 800f934:	881b      	ldrh	r3, [r3, #0]
 800f936:	b29b      	uxth	r3, r3
 800f938:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f93c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f940:	83fb      	strh	r3, [r7, #30]
 800f942:	687a      	ldr	r2, [r7, #4]
 800f944:	683b      	ldr	r3, [r7, #0]
 800f946:	781b      	ldrb	r3, [r3, #0]
 800f948:	009b      	lsls	r3, r3, #2
 800f94a:	441a      	add	r2, r3
 800f94c:	8bfb      	ldrh	r3, [r7, #30]
 800f94e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f952:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f956:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f95a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f95e:	b29b      	uxth	r3, r3
 800f960:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800f962:	687a      	ldr	r2, [r7, #4]
 800f964:	683b      	ldr	r3, [r7, #0]
 800f966:	781b      	ldrb	r3, [r3, #0]
 800f968:	009b      	lsls	r3, r3, #2
 800f96a:	4413      	add	r3, r2
 800f96c:	881b      	ldrh	r3, [r3, #0]
 800f96e:	83bb      	strh	r3, [r7, #28]
 800f970:	8bbb      	ldrh	r3, [r7, #28]
 800f972:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f976:	2b00      	cmp	r3, #0
 800f978:	d01b      	beq.n	800f9b2 <USB_DeactivateEndpoint+0x1da>
 800f97a:	687a      	ldr	r2, [r7, #4]
 800f97c:	683b      	ldr	r3, [r7, #0]
 800f97e:	781b      	ldrb	r3, [r3, #0]
 800f980:	009b      	lsls	r3, r3, #2
 800f982:	4413      	add	r3, r2
 800f984:	881b      	ldrh	r3, [r3, #0]
 800f986:	b29b      	uxth	r3, r3
 800f988:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f98c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f990:	837b      	strh	r3, [r7, #26]
 800f992:	687a      	ldr	r2, [r7, #4]
 800f994:	683b      	ldr	r3, [r7, #0]
 800f996:	781b      	ldrb	r3, [r3, #0]
 800f998:	009b      	lsls	r3, r3, #2
 800f99a:	441a      	add	r2, r3
 800f99c:	8b7b      	ldrh	r3, [r7, #26]
 800f99e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f9a2:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f9a6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f9aa:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800f9ae:	b29b      	uxth	r3, r3
 800f9b0:	8013      	strh	r3, [r2, #0]

      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 800f9b2:	687a      	ldr	r2, [r7, #4]
 800f9b4:	683b      	ldr	r3, [r7, #0]
 800f9b6:	781b      	ldrb	r3, [r3, #0]
 800f9b8:	009b      	lsls	r3, r3, #2
 800f9ba:	4413      	add	r3, r2
 800f9bc:	881b      	ldrh	r3, [r3, #0]
 800f9be:	b29b      	uxth	r3, r3
 800f9c0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800f9c4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f9c8:	833b      	strh	r3, [r7, #24]
 800f9ca:	687a      	ldr	r2, [r7, #4]
 800f9cc:	683b      	ldr	r3, [r7, #0]
 800f9ce:	781b      	ldrb	r3, [r3, #0]
 800f9d0:	009b      	lsls	r3, r3, #2
 800f9d2:	441a      	add	r2, r3
 800f9d4:	8b3b      	ldrh	r3, [r7, #24]
 800f9d6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800f9da:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800f9de:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800f9e2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800f9e6:	b29b      	uxth	r3, r3
 800f9e8:	8013      	strh	r3, [r2, #0]

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800f9ea:	687a      	ldr	r2, [r7, #4]
 800f9ec:	683b      	ldr	r3, [r7, #0]
 800f9ee:	781b      	ldrb	r3, [r3, #0]
 800f9f0:	009b      	lsls	r3, r3, #2
 800f9f2:	4413      	add	r3, r2
 800f9f4:	881b      	ldrh	r3, [r3, #0]
 800f9f6:	b29b      	uxth	r3, r3
 800f9f8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800f9fc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fa00:	82fb      	strh	r3, [r7, #22]
 800fa02:	687a      	ldr	r2, [r7, #4]
 800fa04:	683b      	ldr	r3, [r7, #0]
 800fa06:	781b      	ldrb	r3, [r3, #0]
 800fa08:	009b      	lsls	r3, r3, #2
 800fa0a:	441a      	add	r2, r3
 800fa0c:	8afb      	ldrh	r3, [r7, #22]
 800fa0e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fa12:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fa16:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800fa1a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fa1e:	b29b      	uxth	r3, r3
 800fa20:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800fa22:	687a      	ldr	r2, [r7, #4]
 800fa24:	683b      	ldr	r3, [r7, #0]
 800fa26:	781b      	ldrb	r3, [r3, #0]
 800fa28:	009b      	lsls	r3, r3, #2
 800fa2a:	4413      	add	r3, r2
 800fa2c:	881b      	ldrh	r3, [r3, #0]
 800fa2e:	b29b      	uxth	r3, r3
 800fa30:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800fa34:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800fa38:	82bb      	strh	r3, [r7, #20]
 800fa3a:	687a      	ldr	r2, [r7, #4]
 800fa3c:	683b      	ldr	r3, [r7, #0]
 800fa3e:	781b      	ldrb	r3, [r3, #0]
 800fa40:	009b      	lsls	r3, r3, #2
 800fa42:	441a      	add	r2, r3
 800fa44:	8abb      	ldrh	r3, [r7, #20]
 800fa46:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fa4a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fa4e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800fa52:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fa56:	b29b      	uxth	r3, r3
 800fa58:	8013      	strh	r3, [r2, #0]
 800fa5a:	e0a3      	b.n	800fba4 <USB_DeactivateEndpoint+0x3cc>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800fa5c:	687a      	ldr	r2, [r7, #4]
 800fa5e:	683b      	ldr	r3, [r7, #0]
 800fa60:	781b      	ldrb	r3, [r3, #0]
 800fa62:	009b      	lsls	r3, r3, #2
 800fa64:	4413      	add	r3, r2
 800fa66:	881b      	ldrh	r3, [r3, #0]
 800fa68:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800fa6a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 800fa6c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800fa70:	2b00      	cmp	r3, #0
 800fa72:	d01b      	beq.n	800faac <USB_DeactivateEndpoint+0x2d4>
 800fa74:	687a      	ldr	r2, [r7, #4]
 800fa76:	683b      	ldr	r3, [r7, #0]
 800fa78:	781b      	ldrb	r3, [r3, #0]
 800fa7a:	009b      	lsls	r3, r3, #2
 800fa7c:	4413      	add	r3, r2
 800fa7e:	881b      	ldrh	r3, [r3, #0]
 800fa80:	b29b      	uxth	r3, r3
 800fa82:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800fa86:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fa8a:	85bb      	strh	r3, [r7, #44]	; 0x2c
 800fa8c:	687a      	ldr	r2, [r7, #4]
 800fa8e:	683b      	ldr	r3, [r7, #0]
 800fa90:	781b      	ldrb	r3, [r3, #0]
 800fa92:	009b      	lsls	r3, r3, #2
 800fa94:	441a      	add	r2, r3
 800fa96:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800fa98:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fa9c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800faa0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800faa4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800faa8:	b29b      	uxth	r3, r3
 800faaa:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800faac:	687a      	ldr	r2, [r7, #4]
 800faae:	683b      	ldr	r3, [r7, #0]
 800fab0:	781b      	ldrb	r3, [r3, #0]
 800fab2:	009b      	lsls	r3, r3, #2
 800fab4:	4413      	add	r3, r2
 800fab6:	881b      	ldrh	r3, [r3, #0]
 800fab8:	857b      	strh	r3, [r7, #42]	; 0x2a
 800faba:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800fabc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800fac0:	2b00      	cmp	r3, #0
 800fac2:	d01b      	beq.n	800fafc <USB_DeactivateEndpoint+0x324>
 800fac4:	687a      	ldr	r2, [r7, #4]
 800fac6:	683b      	ldr	r3, [r7, #0]
 800fac8:	781b      	ldrb	r3, [r3, #0]
 800faca:	009b      	lsls	r3, r3, #2
 800facc:	4413      	add	r3, r2
 800face:	881b      	ldrh	r3, [r3, #0]
 800fad0:	b29b      	uxth	r3, r3
 800fad2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800fad6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fada:	853b      	strh	r3, [r7, #40]	; 0x28
 800fadc:	687a      	ldr	r2, [r7, #4]
 800fade:	683b      	ldr	r3, [r7, #0]
 800fae0:	781b      	ldrb	r3, [r3, #0]
 800fae2:	009b      	lsls	r3, r3, #2
 800fae4:	441a      	add	r2, r3
 800fae6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800fae8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800faec:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800faf0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800faf4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800faf8:	b29b      	uxth	r3, r3
 800fafa:	8013      	strh	r3, [r2, #0]
      PCD_RX_DTOG(USBx, ep->num);
 800fafc:	687a      	ldr	r2, [r7, #4]
 800fafe:	683b      	ldr	r3, [r7, #0]
 800fb00:	781b      	ldrb	r3, [r3, #0]
 800fb02:	009b      	lsls	r3, r3, #2
 800fb04:	4413      	add	r3, r2
 800fb06:	881b      	ldrh	r3, [r3, #0]
 800fb08:	b29b      	uxth	r3, r3
 800fb0a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800fb0e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fb12:	84fb      	strh	r3, [r7, #38]	; 0x26
 800fb14:	687a      	ldr	r2, [r7, #4]
 800fb16:	683b      	ldr	r3, [r7, #0]
 800fb18:	781b      	ldrb	r3, [r3, #0]
 800fb1a:	009b      	lsls	r3, r3, #2
 800fb1c:	441a      	add	r2, r3
 800fb1e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800fb20:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fb24:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fb28:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800fb2c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fb30:	b29b      	uxth	r3, r3
 800fb32:	8013      	strh	r3, [r2, #0]

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800fb34:	687a      	ldr	r2, [r7, #4]
 800fb36:	683b      	ldr	r3, [r7, #0]
 800fb38:	781b      	ldrb	r3, [r3, #0]
 800fb3a:	009b      	lsls	r3, r3, #2
 800fb3c:	4413      	add	r3, r2
 800fb3e:	881b      	ldrh	r3, [r3, #0]
 800fb40:	b29b      	uxth	r3, r3
 800fb42:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800fb46:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800fb4a:	84bb      	strh	r3, [r7, #36]	; 0x24
 800fb4c:	687a      	ldr	r2, [r7, #4]
 800fb4e:	683b      	ldr	r3, [r7, #0]
 800fb50:	781b      	ldrb	r3, [r3, #0]
 800fb52:	009b      	lsls	r3, r3, #2
 800fb54:	441a      	add	r2, r3
 800fb56:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800fb58:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fb5c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fb60:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800fb64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fb68:	b29b      	uxth	r3, r3
 800fb6a:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800fb6c:	687a      	ldr	r2, [r7, #4]
 800fb6e:	683b      	ldr	r3, [r7, #0]
 800fb70:	781b      	ldrb	r3, [r3, #0]
 800fb72:	009b      	lsls	r3, r3, #2
 800fb74:	4413      	add	r3, r2
 800fb76:	881b      	ldrh	r3, [r3, #0]
 800fb78:	b29b      	uxth	r3, r3
 800fb7a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800fb7e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fb82:	847b      	strh	r3, [r7, #34]	; 0x22
 800fb84:	687a      	ldr	r2, [r7, #4]
 800fb86:	683b      	ldr	r3, [r7, #0]
 800fb88:	781b      	ldrb	r3, [r3, #0]
 800fb8a:	009b      	lsls	r3, r3, #2
 800fb8c:	441a      	add	r2, r3
 800fb8e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800fb90:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fb94:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fb98:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800fb9c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fba0:	b29b      	uxth	r3, r3
 800fba2:	8013      	strh	r3, [r2, #0]
    }
  }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  return HAL_OK;
 800fba4:	2300      	movs	r3, #0
}
 800fba6:	4618      	mov	r0, r3
 800fba8:	3734      	adds	r7, #52	; 0x34
 800fbaa:	46bd      	mov	sp, r7
 800fbac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbb0:	4770      	bx	lr

0800fbb2 <USB_EPStartXfer>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800fbb2:	b580      	push	{r7, lr}
 800fbb4:	b0c2      	sub	sp, #264	; 0x108
 800fbb6:	af00      	add	r7, sp, #0
 800fbb8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fbbc:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fbc0:	6018      	str	r0, [r3, #0]
 800fbc2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fbc6:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fbca:	6019      	str	r1, [r3, #0]
  uint16_t pmabuffer;
  uint16_t wEPVal;
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  /* IN endpoint */
  if (ep->is_in == 1U)
 800fbcc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fbd0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fbd4:	681b      	ldr	r3, [r3, #0]
 800fbd6:	785b      	ldrb	r3, [r3, #1]
 800fbd8:	2b01      	cmp	r3, #1
 800fbda:	f040 86b7 	bne.w	801094c <USB_EPStartXfer+0xd9a>
  {
    /*Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
 800fbde:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fbe2:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fbe6:	681b      	ldr	r3, [r3, #0]
 800fbe8:	699a      	ldr	r2, [r3, #24]
 800fbea:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fbee:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fbf2:	681b      	ldr	r3, [r3, #0]
 800fbf4:	691b      	ldr	r3, [r3, #16]
 800fbf6:	429a      	cmp	r2, r3
 800fbf8:	d908      	bls.n	800fc0c <USB_EPStartXfer+0x5a>
    {
      len = ep->maxpacket;
 800fbfa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fbfe:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fc02:	681b      	ldr	r3, [r3, #0]
 800fc04:	691b      	ldr	r3, [r3, #16]
 800fc06:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 800fc0a:	e007      	b.n	800fc1c <USB_EPStartXfer+0x6a>
    }
    else
    {
      len = ep->xfer_len;
 800fc0c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc10:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fc14:	681b      	ldr	r3, [r3, #0]
 800fc16:	699b      	ldr	r3, [r3, #24]
 800fc18:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    }

    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0U)
 800fc1c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc20:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fc24:	681b      	ldr	r3, [r3, #0]
 800fc26:	7b1b      	ldrb	r3, [r3, #12]
 800fc28:	2b00      	cmp	r3, #0
 800fc2a:	d13a      	bne.n	800fca2 <USB_EPStartXfer+0xf0>
    {
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, (uint16_t)len);
 800fc2c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc30:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fc34:	681b      	ldr	r3, [r3, #0]
 800fc36:	6959      	ldr	r1, [r3, #20]
 800fc38:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc3c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fc40:	681b      	ldr	r3, [r3, #0]
 800fc42:	88da      	ldrh	r2, [r3, #6]
 800fc44:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fc48:	b29b      	uxth	r3, r3
 800fc4a:	f507 7084 	add.w	r0, r7, #264	; 0x108
 800fc4e:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 800fc52:	6800      	ldr	r0, [r0, #0]
 800fc54:	f001 fc98 	bl	8011588 <USB_WritePMA>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 800fc58:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc5c:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fc60:	681b      	ldr	r3, [r3, #0]
 800fc62:	613b      	str	r3, [r7, #16]
 800fc64:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc68:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fc6c:	681b      	ldr	r3, [r3, #0]
 800fc6e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fc72:	b29b      	uxth	r3, r3
 800fc74:	461a      	mov	r2, r3
 800fc76:	693b      	ldr	r3, [r7, #16]
 800fc78:	4413      	add	r3, r2
 800fc7a:	613b      	str	r3, [r7, #16]
 800fc7c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fc80:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fc84:	681b      	ldr	r3, [r3, #0]
 800fc86:	781b      	ldrb	r3, [r3, #0]
 800fc88:	00da      	lsls	r2, r3, #3
 800fc8a:	693b      	ldr	r3, [r7, #16]
 800fc8c:	4413      	add	r3, r2
 800fc8e:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800fc92:	60fb      	str	r3, [r7, #12]
 800fc94:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fc98:	b29a      	uxth	r2, r3
 800fc9a:	68fb      	ldr	r3, [r7, #12]
 800fc9c:	801a      	strh	r2, [r3, #0]
 800fc9e:	f000 be1f 	b.w	80108e0 <USB_EPStartXfer+0xd2e>
    }
#if (USE_USB_DOUBLE_BUFFER == 1U)
    else
    {
      /* double buffer bulk management */
      if (ep->type == EP_TYPE_BULK)
 800fca2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fca6:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fcaa:	681b      	ldr	r3, [r3, #0]
 800fcac:	78db      	ldrb	r3, [r3, #3]
 800fcae:	2b02      	cmp	r3, #2
 800fcb0:	f040 8462 	bne.w	8010578 <USB_EPStartXfer+0x9c6>
      {
        if (ep->xfer_len_db > ep->maxpacket)
 800fcb4:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fcb8:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fcbc:	681b      	ldr	r3, [r3, #0]
 800fcbe:	6a1a      	ldr	r2, [r3, #32]
 800fcc0:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fcc4:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fcc8:	681b      	ldr	r3, [r3, #0]
 800fcca:	691b      	ldr	r3, [r3, #16]
 800fccc:	429a      	cmp	r2, r3
 800fcce:	f240 83df 	bls.w	8010490 <USB_EPStartXfer+0x8de>
        {
          /* enable double buffer */
          PCD_SET_BULK_EP_DBUF(USBx, ep->num);
 800fcd2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fcd6:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fcda:	681a      	ldr	r2, [r3, #0]
 800fcdc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fce0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fce4:	681b      	ldr	r3, [r3, #0]
 800fce6:	781b      	ldrb	r3, [r3, #0]
 800fce8:	009b      	lsls	r3, r3, #2
 800fcea:	4413      	add	r3, r2
 800fcec:	881b      	ldrh	r3, [r3, #0]
 800fcee:	b29b      	uxth	r3, r3
 800fcf0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800fcf4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fcf8:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 800fcfc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd00:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fd04:	681a      	ldr	r2, [r3, #0]
 800fd06:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd0a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fd0e:	681b      	ldr	r3, [r3, #0]
 800fd10:	781b      	ldrb	r3, [r3, #0]
 800fd12:	009b      	lsls	r3, r3, #2
 800fd14:	441a      	add	r2, r3
 800fd16:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 800fd1a:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fd1e:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fd22:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 800fd26:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fd2a:	b29b      	uxth	r3, r3
 800fd2c:	8013      	strh	r3, [r2, #0]

          /* each Time to write in PMA xfer_len_db will */
          ep->xfer_len_db -= len;
 800fd2e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd32:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fd36:	681b      	ldr	r3, [r3, #0]
 800fd38:	6a1a      	ldr	r2, [r3, #32]
 800fd3a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fd3e:	1ad2      	subs	r2, r2, r3
 800fd40:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd44:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fd48:	681b      	ldr	r3, [r3, #0]
 800fd4a:	621a      	str	r2, [r3, #32]

          /* Fill the two first buffer in the Buffer0 & Buffer1 */
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800fd4c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd50:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fd54:	681a      	ldr	r2, [r3, #0]
 800fd56:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd5a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fd5e:	681b      	ldr	r3, [r3, #0]
 800fd60:	781b      	ldrb	r3, [r3, #0]
 800fd62:	009b      	lsls	r3, r3, #2
 800fd64:	4413      	add	r3, r2
 800fd66:	881b      	ldrh	r3, [r3, #0]
 800fd68:	b29b      	uxth	r3, r3
 800fd6a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800fd6e:	2b00      	cmp	r3, #0
 800fd70:	f000 81c7 	beq.w	8010102 <USB_EPStartXfer+0x550>
          {
            /* Set the Double buffer counter for pmabuffer1 */
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800fd74:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd78:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fd7c:	681b      	ldr	r3, [r3, #0]
 800fd7e:	633b      	str	r3, [r7, #48]	; 0x30
 800fd80:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd84:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fd88:	681b      	ldr	r3, [r3, #0]
 800fd8a:	785b      	ldrb	r3, [r3, #1]
 800fd8c:	2b00      	cmp	r3, #0
 800fd8e:	d177      	bne.n	800fe80 <USB_EPStartXfer+0x2ce>
 800fd90:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fd94:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fd98:	681b      	ldr	r3, [r3, #0]
 800fd9a:	62bb      	str	r3, [r7, #40]	; 0x28
 800fd9c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fda0:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fda4:	681b      	ldr	r3, [r3, #0]
 800fda6:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fdaa:	b29b      	uxth	r3, r3
 800fdac:	461a      	mov	r2, r3
 800fdae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fdb0:	4413      	add	r3, r2
 800fdb2:	62bb      	str	r3, [r7, #40]	; 0x28
 800fdb4:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fdb8:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fdbc:	681b      	ldr	r3, [r3, #0]
 800fdbe:	781b      	ldrb	r3, [r3, #0]
 800fdc0:	00da      	lsls	r2, r3, #3
 800fdc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fdc4:	4413      	add	r3, r2
 800fdc6:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800fdca:	627b      	str	r3, [r7, #36]	; 0x24
 800fdcc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fdce:	881b      	ldrh	r3, [r3, #0]
 800fdd0:	b29b      	uxth	r3, r3
 800fdd2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800fdd6:	b29a      	uxth	r2, r3
 800fdd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fdda:	801a      	strh	r2, [r3, #0]
 800fddc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fde0:	2b3e      	cmp	r3, #62	; 0x3e
 800fde2:	d921      	bls.n	800fe28 <USB_EPStartXfer+0x276>
 800fde4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fde8:	095b      	lsrs	r3, r3, #5
 800fdea:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800fdee:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fdf2:	f003 031f 	and.w	r3, r3, #31
 800fdf6:	2b00      	cmp	r3, #0
 800fdf8:	d104      	bne.n	800fe04 <USB_EPStartXfer+0x252>
 800fdfa:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800fdfe:	3b01      	subs	r3, #1
 800fe00:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800fe04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe06:	881b      	ldrh	r3, [r3, #0]
 800fe08:	b29a      	uxth	r2, r3
 800fe0a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800fe0e:	b29b      	uxth	r3, r3
 800fe10:	029b      	lsls	r3, r3, #10
 800fe12:	b29b      	uxth	r3, r3
 800fe14:	4313      	orrs	r3, r2
 800fe16:	b29b      	uxth	r3, r3
 800fe18:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800fe1c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800fe20:	b29a      	uxth	r2, r3
 800fe22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe24:	801a      	strh	r2, [r3, #0]
 800fe26:	e050      	b.n	800feca <USB_EPStartXfer+0x318>
 800fe28:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fe2c:	2b00      	cmp	r3, #0
 800fe2e:	d10a      	bne.n	800fe46 <USB_EPStartXfer+0x294>
 800fe30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe32:	881b      	ldrh	r3, [r3, #0]
 800fe34:	b29b      	uxth	r3, r3
 800fe36:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800fe3a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800fe3e:	b29a      	uxth	r2, r3
 800fe40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe42:	801a      	strh	r2, [r3, #0]
 800fe44:	e041      	b.n	800feca <USB_EPStartXfer+0x318>
 800fe46:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fe4a:	085b      	lsrs	r3, r3, #1
 800fe4c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800fe50:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fe54:	f003 0301 	and.w	r3, r3, #1
 800fe58:	2b00      	cmp	r3, #0
 800fe5a:	d004      	beq.n	800fe66 <USB_EPStartXfer+0x2b4>
 800fe5c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800fe60:	3301      	adds	r3, #1
 800fe62:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 800fe66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe68:	881b      	ldrh	r3, [r3, #0]
 800fe6a:	b29a      	uxth	r2, r3
 800fe6c:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 800fe70:	b29b      	uxth	r3, r3
 800fe72:	029b      	lsls	r3, r3, #10
 800fe74:	b29b      	uxth	r3, r3
 800fe76:	4313      	orrs	r3, r2
 800fe78:	b29a      	uxth	r2, r3
 800fe7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe7c:	801a      	strh	r2, [r3, #0]
 800fe7e:	e024      	b.n	800feca <USB_EPStartXfer+0x318>
 800fe80:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fe84:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fe88:	681b      	ldr	r3, [r3, #0]
 800fe8a:	785b      	ldrb	r3, [r3, #1]
 800fe8c:	2b01      	cmp	r3, #1
 800fe8e:	d11c      	bne.n	800feca <USB_EPStartXfer+0x318>
 800fe90:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fe94:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800fe98:	681b      	ldr	r3, [r3, #0]
 800fe9a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fe9e:	b29b      	uxth	r3, r3
 800fea0:	461a      	mov	r2, r3
 800fea2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fea4:	4413      	add	r3, r2
 800fea6:	633b      	str	r3, [r7, #48]	; 0x30
 800fea8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800feac:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800feb0:	681b      	ldr	r3, [r3, #0]
 800feb2:	781b      	ldrb	r3, [r3, #0]
 800feb4:	00da      	lsls	r2, r3, #3
 800feb6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800feb8:	4413      	add	r3, r2
 800feba:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800febe:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fec0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800fec4:	b29a      	uxth	r2, r3
 800fec6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fec8:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr1;
 800feca:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fece:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fed2:	681b      	ldr	r3, [r3, #0]
 800fed4:	895b      	ldrh	r3, [r3, #10]
 800fed6:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800feda:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800fede:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800fee2:	681b      	ldr	r3, [r3, #0]
 800fee4:	6959      	ldr	r1, [r3, #20]
 800fee6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800feea:	b29b      	uxth	r3, r3
 800feec:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 800fef0:	f507 7084 	add.w	r0, r7, #264	; 0x108
 800fef4:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 800fef8:	6800      	ldr	r0, [r0, #0]
 800fefa:	f001 fb45 	bl	8011588 <USB_WritePMA>
            ep->xfer_buff += len;
 800fefe:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff02:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff06:	681b      	ldr	r3, [r3, #0]
 800ff08:	695a      	ldr	r2, [r3, #20]
 800ff0a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ff0e:	441a      	add	r2, r3
 800ff10:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff14:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff18:	681b      	ldr	r3, [r3, #0]
 800ff1a:	615a      	str	r2, [r3, #20]

            if (ep->xfer_len_db > ep->maxpacket)
 800ff1c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff20:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff24:	681b      	ldr	r3, [r3, #0]
 800ff26:	6a1a      	ldr	r2, [r3, #32]
 800ff28:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff2c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff30:	681b      	ldr	r3, [r3, #0]
 800ff32:	691b      	ldr	r3, [r3, #16]
 800ff34:	429a      	cmp	r2, r3
 800ff36:	d90f      	bls.n	800ff58 <USB_EPStartXfer+0x3a6>
            {
              ep->xfer_len_db -= len;
 800ff38:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff3c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff40:	681b      	ldr	r3, [r3, #0]
 800ff42:	6a1a      	ldr	r2, [r3, #32]
 800ff44:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ff48:	1ad2      	subs	r2, r2, r3
 800ff4a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff4e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff52:	681b      	ldr	r3, [r3, #0]
 800ff54:	621a      	str	r2, [r3, #32]
 800ff56:	e00e      	b.n	800ff76 <USB_EPStartXfer+0x3c4>
            }
            else
            {
              len = ep->xfer_len_db;
 800ff58:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff5c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff60:	681b      	ldr	r3, [r3, #0]
 800ff62:	6a1b      	ldr	r3, [r3, #32]
 800ff64:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
              ep->xfer_len_db = 0U;
 800ff68:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff6c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff70:	681b      	ldr	r3, [r3, #0]
 800ff72:	2200      	movs	r2, #0
 800ff74:	621a      	str	r2, [r3, #32]
            }

            /* Set the Double buffer counter for pmabuffer0 */
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800ff76:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff7a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ff7e:	681b      	ldr	r3, [r3, #0]
 800ff80:	785b      	ldrb	r3, [r3, #1]
 800ff82:	2b00      	cmp	r3, #0
 800ff84:	d177      	bne.n	8010076 <USB_EPStartXfer+0x4c4>
 800ff86:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff8a:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800ff8e:	681b      	ldr	r3, [r3, #0]
 800ff90:	61bb      	str	r3, [r7, #24]
 800ff92:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ff96:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 800ff9a:	681b      	ldr	r3, [r3, #0]
 800ff9c:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800ffa0:	b29b      	uxth	r3, r3
 800ffa2:	461a      	mov	r2, r3
 800ffa4:	69bb      	ldr	r3, [r7, #24]
 800ffa6:	4413      	add	r3, r2
 800ffa8:	61bb      	str	r3, [r7, #24]
 800ffaa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800ffae:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 800ffb2:	681b      	ldr	r3, [r3, #0]
 800ffb4:	781b      	ldrb	r3, [r3, #0]
 800ffb6:	00da      	lsls	r2, r3, #3
 800ffb8:	69bb      	ldr	r3, [r7, #24]
 800ffba:	4413      	add	r3, r2
 800ffbc:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800ffc0:	617b      	str	r3, [r7, #20]
 800ffc2:	697b      	ldr	r3, [r7, #20]
 800ffc4:	881b      	ldrh	r3, [r3, #0]
 800ffc6:	b29b      	uxth	r3, r3
 800ffc8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800ffcc:	b29a      	uxth	r2, r3
 800ffce:	697b      	ldr	r3, [r7, #20]
 800ffd0:	801a      	strh	r2, [r3, #0]
 800ffd2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ffd6:	2b3e      	cmp	r3, #62	; 0x3e
 800ffd8:	d921      	bls.n	801001e <USB_EPStartXfer+0x46c>
 800ffda:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ffde:	095b      	lsrs	r3, r3, #5
 800ffe0:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 800ffe4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800ffe8:	f003 031f 	and.w	r3, r3, #31
 800ffec:	2b00      	cmp	r3, #0
 800ffee:	d104      	bne.n	800fffa <USB_EPStartXfer+0x448>
 800fff0:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 800fff4:	3b01      	subs	r3, #1
 800fff6:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 800fffa:	697b      	ldr	r3, [r7, #20]
 800fffc:	881b      	ldrh	r3, [r3, #0]
 800fffe:	b29a      	uxth	r2, r3
 8010000:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8010004:	b29b      	uxth	r3, r3
 8010006:	029b      	lsls	r3, r3, #10
 8010008:	b29b      	uxth	r3, r3
 801000a:	4313      	orrs	r3, r2
 801000c:	b29b      	uxth	r3, r3
 801000e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010012:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010016:	b29a      	uxth	r2, r3
 8010018:	697b      	ldr	r3, [r7, #20]
 801001a:	801a      	strh	r2, [r3, #0]
 801001c:	e056      	b.n	80100cc <USB_EPStartXfer+0x51a>
 801001e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010022:	2b00      	cmp	r3, #0
 8010024:	d10a      	bne.n	801003c <USB_EPStartXfer+0x48a>
 8010026:	697b      	ldr	r3, [r7, #20]
 8010028:	881b      	ldrh	r3, [r3, #0]
 801002a:	b29b      	uxth	r3, r3
 801002c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010030:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010034:	b29a      	uxth	r2, r3
 8010036:	697b      	ldr	r3, [r7, #20]
 8010038:	801a      	strh	r2, [r3, #0]
 801003a:	e047      	b.n	80100cc <USB_EPStartXfer+0x51a>
 801003c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010040:	085b      	lsrs	r3, r3, #1
 8010042:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8010046:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801004a:	f003 0301 	and.w	r3, r3, #1
 801004e:	2b00      	cmp	r3, #0
 8010050:	d004      	beq.n	801005c <USB_EPStartXfer+0x4aa>
 8010052:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8010056:	3301      	adds	r3, #1
 8010058:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 801005c:	697b      	ldr	r3, [r7, #20]
 801005e:	881b      	ldrh	r3, [r3, #0]
 8010060:	b29a      	uxth	r2, r3
 8010062:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8010066:	b29b      	uxth	r3, r3
 8010068:	029b      	lsls	r3, r3, #10
 801006a:	b29b      	uxth	r3, r3
 801006c:	4313      	orrs	r3, r2
 801006e:	b29a      	uxth	r2, r3
 8010070:	697b      	ldr	r3, [r7, #20]
 8010072:	801a      	strh	r2, [r3, #0]
 8010074:	e02a      	b.n	80100cc <USB_EPStartXfer+0x51a>
 8010076:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801007a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801007e:	681b      	ldr	r3, [r3, #0]
 8010080:	785b      	ldrb	r3, [r3, #1]
 8010082:	2b01      	cmp	r3, #1
 8010084:	d122      	bne.n	80100cc <USB_EPStartXfer+0x51a>
 8010086:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801008a:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801008e:	681b      	ldr	r3, [r3, #0]
 8010090:	623b      	str	r3, [r7, #32]
 8010092:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010096:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801009a:	681b      	ldr	r3, [r3, #0]
 801009c:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80100a0:	b29b      	uxth	r3, r3
 80100a2:	461a      	mov	r2, r3
 80100a4:	6a3b      	ldr	r3, [r7, #32]
 80100a6:	4413      	add	r3, r2
 80100a8:	623b      	str	r3, [r7, #32]
 80100aa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80100ae:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80100b2:	681b      	ldr	r3, [r3, #0]
 80100b4:	781b      	ldrb	r3, [r3, #0]
 80100b6:	00da      	lsls	r2, r3, #3
 80100b8:	6a3b      	ldr	r3, [r7, #32]
 80100ba:	4413      	add	r3, r2
 80100bc:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80100c0:	61fb      	str	r3, [r7, #28]
 80100c2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80100c6:	b29a      	uxth	r2, r3
 80100c8:	69fb      	ldr	r3, [r7, #28]
 80100ca:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr0;
 80100cc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80100d0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80100d4:	681b      	ldr	r3, [r3, #0]
 80100d6:	891b      	ldrh	r3, [r3, #8]
 80100d8:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80100dc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80100e0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80100e4:	681b      	ldr	r3, [r3, #0]
 80100e6:	6959      	ldr	r1, [r3, #20]
 80100e8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80100ec:	b29b      	uxth	r3, r3
 80100ee:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 80100f2:	f507 7084 	add.w	r0, r7, #264	; 0x108
 80100f6:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 80100fa:	6800      	ldr	r0, [r0, #0]
 80100fc:	f001 fa44 	bl	8011588 <USB_WritePMA>
 8010100:	e3ee      	b.n	80108e0 <USB_EPStartXfer+0xd2e>
          }
          else
          {
            /* Set the Double buffer counter for pmabuffer0 */
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8010102:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010106:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801010a:	681b      	ldr	r3, [r3, #0]
 801010c:	785b      	ldrb	r3, [r3, #1]
 801010e:	2b00      	cmp	r3, #0
 8010110:	d177      	bne.n	8010202 <USB_EPStartXfer+0x650>
 8010112:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010116:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801011a:	681b      	ldr	r3, [r3, #0]
 801011c:	64bb      	str	r3, [r7, #72]	; 0x48
 801011e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010122:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010126:	681b      	ldr	r3, [r3, #0]
 8010128:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801012c:	b29b      	uxth	r3, r3
 801012e:	461a      	mov	r2, r3
 8010130:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010132:	4413      	add	r3, r2
 8010134:	64bb      	str	r3, [r7, #72]	; 0x48
 8010136:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801013a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801013e:	681b      	ldr	r3, [r3, #0]
 8010140:	781b      	ldrb	r3, [r3, #0]
 8010142:	00da      	lsls	r2, r3, #3
 8010144:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010146:	4413      	add	r3, r2
 8010148:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801014c:	647b      	str	r3, [r7, #68]	; 0x44
 801014e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010150:	881b      	ldrh	r3, [r3, #0]
 8010152:	b29b      	uxth	r3, r3
 8010154:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010158:	b29a      	uxth	r2, r3
 801015a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801015c:	801a      	strh	r2, [r3, #0]
 801015e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010162:	2b3e      	cmp	r3, #62	; 0x3e
 8010164:	d921      	bls.n	80101aa <USB_EPStartXfer+0x5f8>
 8010166:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801016a:	095b      	lsrs	r3, r3, #5
 801016c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8010170:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010174:	f003 031f 	and.w	r3, r3, #31
 8010178:	2b00      	cmp	r3, #0
 801017a:	d104      	bne.n	8010186 <USB_EPStartXfer+0x5d4>
 801017c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8010180:	3b01      	subs	r3, #1
 8010182:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8010186:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010188:	881b      	ldrh	r3, [r3, #0]
 801018a:	b29a      	uxth	r2, r3
 801018c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8010190:	b29b      	uxth	r3, r3
 8010192:	029b      	lsls	r3, r3, #10
 8010194:	b29b      	uxth	r3, r3
 8010196:	4313      	orrs	r3, r2
 8010198:	b29b      	uxth	r3, r3
 801019a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801019e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80101a2:	b29a      	uxth	r2, r3
 80101a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80101a6:	801a      	strh	r2, [r3, #0]
 80101a8:	e056      	b.n	8010258 <USB_EPStartXfer+0x6a6>
 80101aa:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80101ae:	2b00      	cmp	r3, #0
 80101b0:	d10a      	bne.n	80101c8 <USB_EPStartXfer+0x616>
 80101b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80101b4:	881b      	ldrh	r3, [r3, #0]
 80101b6:	b29b      	uxth	r3, r3
 80101b8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80101bc:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80101c0:	b29a      	uxth	r2, r3
 80101c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80101c4:	801a      	strh	r2, [r3, #0]
 80101c6:	e047      	b.n	8010258 <USB_EPStartXfer+0x6a6>
 80101c8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80101cc:	085b      	lsrs	r3, r3, #1
 80101ce:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 80101d2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80101d6:	f003 0301 	and.w	r3, r3, #1
 80101da:	2b00      	cmp	r3, #0
 80101dc:	d004      	beq.n	80101e8 <USB_EPStartXfer+0x636>
 80101de:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80101e2:	3301      	adds	r3, #1
 80101e4:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 80101e8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80101ea:	881b      	ldrh	r3, [r3, #0]
 80101ec:	b29a      	uxth	r2, r3
 80101ee:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80101f2:	b29b      	uxth	r3, r3
 80101f4:	029b      	lsls	r3, r3, #10
 80101f6:	b29b      	uxth	r3, r3
 80101f8:	4313      	orrs	r3, r2
 80101fa:	b29a      	uxth	r2, r3
 80101fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80101fe:	801a      	strh	r2, [r3, #0]
 8010200:	e02a      	b.n	8010258 <USB_EPStartXfer+0x6a6>
 8010202:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010206:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801020a:	681b      	ldr	r3, [r3, #0]
 801020c:	785b      	ldrb	r3, [r3, #1]
 801020e:	2b01      	cmp	r3, #1
 8010210:	d122      	bne.n	8010258 <USB_EPStartXfer+0x6a6>
 8010212:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010216:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801021a:	681b      	ldr	r3, [r3, #0]
 801021c:	653b      	str	r3, [r7, #80]	; 0x50
 801021e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010222:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010226:	681b      	ldr	r3, [r3, #0]
 8010228:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801022c:	b29b      	uxth	r3, r3
 801022e:	461a      	mov	r2, r3
 8010230:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010232:	4413      	add	r3, r2
 8010234:	653b      	str	r3, [r7, #80]	; 0x50
 8010236:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801023a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801023e:	681b      	ldr	r3, [r3, #0]
 8010240:	781b      	ldrb	r3, [r3, #0]
 8010242:	00da      	lsls	r2, r3, #3
 8010244:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010246:	4413      	add	r3, r2
 8010248:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801024c:	64fb      	str	r3, [r7, #76]	; 0x4c
 801024e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010252:	b29a      	uxth	r2, r3
 8010254:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010256:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr0;
 8010258:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801025c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010260:	681b      	ldr	r3, [r3, #0]
 8010262:	891b      	ldrh	r3, [r3, #8]
 8010264:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010268:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801026c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010270:	681b      	ldr	r3, [r3, #0]
 8010272:	6959      	ldr	r1, [r3, #20]
 8010274:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010278:	b29b      	uxth	r3, r3
 801027a:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 801027e:	f507 7084 	add.w	r0, r7, #264	; 0x108
 8010282:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 8010286:	6800      	ldr	r0, [r0, #0]
 8010288:	f001 f97e 	bl	8011588 <USB_WritePMA>
            ep->xfer_buff += len;
 801028c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010290:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010294:	681b      	ldr	r3, [r3, #0]
 8010296:	695a      	ldr	r2, [r3, #20]
 8010298:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801029c:	441a      	add	r2, r3
 801029e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102a2:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102a6:	681b      	ldr	r3, [r3, #0]
 80102a8:	615a      	str	r2, [r3, #20]

            if (ep->xfer_len_db > ep->maxpacket)
 80102aa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102ae:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102b2:	681b      	ldr	r3, [r3, #0]
 80102b4:	6a1a      	ldr	r2, [r3, #32]
 80102b6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102ba:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102be:	681b      	ldr	r3, [r3, #0]
 80102c0:	691b      	ldr	r3, [r3, #16]
 80102c2:	429a      	cmp	r2, r3
 80102c4:	d90f      	bls.n	80102e6 <USB_EPStartXfer+0x734>
            {
              ep->xfer_len_db -= len;
 80102c6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102ca:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102ce:	681b      	ldr	r3, [r3, #0]
 80102d0:	6a1a      	ldr	r2, [r3, #32]
 80102d2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80102d6:	1ad2      	subs	r2, r2, r3
 80102d8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102dc:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102e0:	681b      	ldr	r3, [r3, #0]
 80102e2:	621a      	str	r2, [r3, #32]
 80102e4:	e00e      	b.n	8010304 <USB_EPStartXfer+0x752>
            }
            else
            {
              len = ep->xfer_len_db;
 80102e6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102ea:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102ee:	681b      	ldr	r3, [r3, #0]
 80102f0:	6a1b      	ldr	r3, [r3, #32]
 80102f2:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
              ep->xfer_len_db = 0U;
 80102f6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80102fa:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80102fe:	681b      	ldr	r3, [r3, #0]
 8010300:	2200      	movs	r2, #0
 8010302:	621a      	str	r2, [r3, #32]
            }

            /* Set the Double buffer counter for pmabuffer1 */
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8010304:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010308:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801030c:	681b      	ldr	r3, [r3, #0]
 801030e:	643b      	str	r3, [r7, #64]	; 0x40
 8010310:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010314:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010318:	681b      	ldr	r3, [r3, #0]
 801031a:	785b      	ldrb	r3, [r3, #1]
 801031c:	2b00      	cmp	r3, #0
 801031e:	d177      	bne.n	8010410 <USB_EPStartXfer+0x85e>
 8010320:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010324:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010328:	681b      	ldr	r3, [r3, #0]
 801032a:	63bb      	str	r3, [r7, #56]	; 0x38
 801032c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010330:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010334:	681b      	ldr	r3, [r3, #0]
 8010336:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801033a:	b29b      	uxth	r3, r3
 801033c:	461a      	mov	r2, r3
 801033e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010340:	4413      	add	r3, r2
 8010342:	63bb      	str	r3, [r7, #56]	; 0x38
 8010344:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010348:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801034c:	681b      	ldr	r3, [r3, #0]
 801034e:	781b      	ldrb	r3, [r3, #0]
 8010350:	00da      	lsls	r2, r3, #3
 8010352:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010354:	4413      	add	r3, r2
 8010356:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801035a:	637b      	str	r3, [r7, #52]	; 0x34
 801035c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801035e:	881b      	ldrh	r3, [r3, #0]
 8010360:	b29b      	uxth	r3, r3
 8010362:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010366:	b29a      	uxth	r2, r3
 8010368:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801036a:	801a      	strh	r2, [r3, #0]
 801036c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010370:	2b3e      	cmp	r3, #62	; 0x3e
 8010372:	d921      	bls.n	80103b8 <USB_EPStartXfer+0x806>
 8010374:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010378:	095b      	lsrs	r3, r3, #5
 801037a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 801037e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010382:	f003 031f 	and.w	r3, r3, #31
 8010386:	2b00      	cmp	r3, #0
 8010388:	d104      	bne.n	8010394 <USB_EPStartXfer+0x7e2>
 801038a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 801038e:	3b01      	subs	r3, #1
 8010390:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 8010394:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010396:	881b      	ldrh	r3, [r3, #0]
 8010398:	b29a      	uxth	r2, r3
 801039a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 801039e:	b29b      	uxth	r3, r3
 80103a0:	029b      	lsls	r3, r3, #10
 80103a2:	b29b      	uxth	r3, r3
 80103a4:	4313      	orrs	r3, r2
 80103a6:	b29b      	uxth	r3, r3
 80103a8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80103ac:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80103b0:	b29a      	uxth	r2, r3
 80103b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80103b4:	801a      	strh	r2, [r3, #0]
 80103b6:	e050      	b.n	801045a <USB_EPStartXfer+0x8a8>
 80103b8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80103bc:	2b00      	cmp	r3, #0
 80103be:	d10a      	bne.n	80103d6 <USB_EPStartXfer+0x824>
 80103c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80103c2:	881b      	ldrh	r3, [r3, #0]
 80103c4:	b29b      	uxth	r3, r3
 80103c6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80103ca:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80103ce:	b29a      	uxth	r2, r3
 80103d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80103d2:	801a      	strh	r2, [r3, #0]
 80103d4:	e041      	b.n	801045a <USB_EPStartXfer+0x8a8>
 80103d6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80103da:	085b      	lsrs	r3, r3, #1
 80103dc:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 80103e0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80103e4:	f003 0301 	and.w	r3, r3, #1
 80103e8:	2b00      	cmp	r3, #0
 80103ea:	d004      	beq.n	80103f6 <USB_EPStartXfer+0x844>
 80103ec:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80103f0:	3301      	adds	r3, #1
 80103f2:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 80103f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80103f8:	881b      	ldrh	r3, [r3, #0]
 80103fa:	b29a      	uxth	r2, r3
 80103fc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8010400:	b29b      	uxth	r3, r3
 8010402:	029b      	lsls	r3, r3, #10
 8010404:	b29b      	uxth	r3, r3
 8010406:	4313      	orrs	r3, r2
 8010408:	b29a      	uxth	r2, r3
 801040a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801040c:	801a      	strh	r2, [r3, #0]
 801040e:	e024      	b.n	801045a <USB_EPStartXfer+0x8a8>
 8010410:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010414:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010418:	681b      	ldr	r3, [r3, #0]
 801041a:	785b      	ldrb	r3, [r3, #1]
 801041c:	2b01      	cmp	r3, #1
 801041e:	d11c      	bne.n	801045a <USB_EPStartXfer+0x8a8>
 8010420:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010424:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010428:	681b      	ldr	r3, [r3, #0]
 801042a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801042e:	b29b      	uxth	r3, r3
 8010430:	461a      	mov	r2, r3
 8010432:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010434:	4413      	add	r3, r2
 8010436:	643b      	str	r3, [r7, #64]	; 0x40
 8010438:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801043c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010440:	681b      	ldr	r3, [r3, #0]
 8010442:	781b      	ldrb	r3, [r3, #0]
 8010444:	00da      	lsls	r2, r3, #3
 8010446:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010448:	4413      	add	r3, r2
 801044a:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801044e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010450:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010454:	b29a      	uxth	r2, r3
 8010456:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010458:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr1;
 801045a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801045e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010462:	681b      	ldr	r3, [r3, #0]
 8010464:	895b      	ldrh	r3, [r3, #10]
 8010466:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 801046a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801046e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010472:	681b      	ldr	r3, [r3, #0]
 8010474:	6959      	ldr	r1, [r3, #20]
 8010476:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801047a:	b29b      	uxth	r3, r3
 801047c:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 8010480:	f507 7084 	add.w	r0, r7, #264	; 0x108
 8010484:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 8010488:	6800      	ldr	r0, [r0, #0]
 801048a:	f001 f87d 	bl	8011588 <USB_WritePMA>
 801048e:	e227      	b.n	80108e0 <USB_EPStartXfer+0xd2e>
          }
        }
        /* auto Switch to single buffer mode when transfer <Mps no need to manage in double buffer */
        else
        {
          len = ep->xfer_len_db;
 8010490:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010494:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010498:	681b      	ldr	r3, [r3, #0]
 801049a:	6a1b      	ldr	r3, [r3, #32]
 801049c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104

          /* disable double buffer mode for Bulk endpoint */
          PCD_CLEAR_BULK_EP_DBUF(USBx, ep->num);
 80104a0:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80104a4:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80104a8:	681a      	ldr	r2, [r3, #0]
 80104aa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80104ae:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80104b2:	681b      	ldr	r3, [r3, #0]
 80104b4:	781b      	ldrb	r3, [r3, #0]
 80104b6:	009b      	lsls	r3, r3, #2
 80104b8:	4413      	add	r3, r2
 80104ba:	881b      	ldrh	r3, [r3, #0]
 80104bc:	b29b      	uxth	r3, r3
 80104be:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
 80104c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80104c6:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 80104ca:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80104ce:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80104d2:	681a      	ldr	r2, [r3, #0]
 80104d4:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80104d8:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80104dc:	681b      	ldr	r3, [r3, #0]
 80104de:	781b      	ldrb	r3, [r3, #0]
 80104e0:	009b      	lsls	r3, r3, #2
 80104e2:	441a      	add	r2, r3
 80104e4:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 80104e8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80104ec:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80104f0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80104f4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80104f8:	b29b      	uxth	r3, r3
 80104fa:	8013      	strh	r3, [r2, #0]

          /* Set Tx count with nbre of byte to be transmitted */
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 80104fc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010500:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010504:	681b      	ldr	r3, [r3, #0]
 8010506:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010508:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801050c:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010510:	681b      	ldr	r3, [r3, #0]
 8010512:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010516:	b29b      	uxth	r3, r3
 8010518:	461a      	mov	r2, r3
 801051a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801051c:	4413      	add	r3, r2
 801051e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010520:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010524:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010528:	681b      	ldr	r3, [r3, #0]
 801052a:	781b      	ldrb	r3, [r3, #0]
 801052c:	00da      	lsls	r2, r3, #3
 801052e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010530:	4413      	add	r3, r2
 8010532:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010536:	65bb      	str	r3, [r7, #88]	; 0x58
 8010538:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801053c:	b29a      	uxth	r2, r3
 801053e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010540:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr0;
 8010542:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010546:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801054a:	681b      	ldr	r3, [r3, #0]
 801054c:	891b      	ldrh	r3, [r3, #8]
 801054e:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010552:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010556:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801055a:	681b      	ldr	r3, [r3, #0]
 801055c:	6959      	ldr	r1, [r3, #20]
 801055e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010562:	b29b      	uxth	r3, r3
 8010564:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 8010568:	f507 7084 	add.w	r0, r7, #264	; 0x108
 801056c:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 8010570:	6800      	ldr	r0, [r0, #0]
 8010572:	f001 f809 	bl	8011588 <USB_WritePMA>
 8010576:	e1b3      	b.n	80108e0 <USB_EPStartXfer+0xd2e>
        }
      }
      else /* manage isochronous double buffer IN mode */
      {
        /* each Time to write in PMA xfer_len_db will */
        ep->xfer_len_db -= len;
 8010578:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801057c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010580:	681b      	ldr	r3, [r3, #0]
 8010582:	6a1a      	ldr	r2, [r3, #32]
 8010584:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010588:	1ad2      	subs	r2, r2, r3
 801058a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801058e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010592:	681b      	ldr	r3, [r3, #0]
 8010594:	621a      	str	r2, [r3, #32]

        /* Fill the data buffer */
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 8010596:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801059a:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801059e:	681a      	ldr	r2, [r3, #0]
 80105a0:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80105a4:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80105a8:	681b      	ldr	r3, [r3, #0]
 80105aa:	781b      	ldrb	r3, [r3, #0]
 80105ac:	009b      	lsls	r3, r3, #2
 80105ae:	4413      	add	r3, r2
 80105b0:	881b      	ldrh	r3, [r3, #0]
 80105b2:	b29b      	uxth	r3, r3
 80105b4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80105b8:	2b00      	cmp	r3, #0
 80105ba:	f000 80c6 	beq.w	801074a <USB_EPStartXfer+0xb98>
        {
          /* Set the Double buffer counter for pmabuffer1 */
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80105be:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80105c2:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80105c6:	681b      	ldr	r3, [r3, #0]
 80105c8:	673b      	str	r3, [r7, #112]	; 0x70
 80105ca:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80105ce:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80105d2:	681b      	ldr	r3, [r3, #0]
 80105d4:	785b      	ldrb	r3, [r3, #1]
 80105d6:	2b00      	cmp	r3, #0
 80105d8:	d177      	bne.n	80106ca <USB_EPStartXfer+0xb18>
 80105da:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80105de:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80105e2:	681b      	ldr	r3, [r3, #0]
 80105e4:	66bb      	str	r3, [r7, #104]	; 0x68
 80105e6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80105ea:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80105ee:	681b      	ldr	r3, [r3, #0]
 80105f0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80105f4:	b29b      	uxth	r3, r3
 80105f6:	461a      	mov	r2, r3
 80105f8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80105fa:	4413      	add	r3, r2
 80105fc:	66bb      	str	r3, [r7, #104]	; 0x68
 80105fe:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010602:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010606:	681b      	ldr	r3, [r3, #0]
 8010608:	781b      	ldrb	r3, [r3, #0]
 801060a:	00da      	lsls	r2, r3, #3
 801060c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801060e:	4413      	add	r3, r2
 8010610:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010614:	667b      	str	r3, [r7, #100]	; 0x64
 8010616:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010618:	881b      	ldrh	r3, [r3, #0]
 801061a:	b29b      	uxth	r3, r3
 801061c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010620:	b29a      	uxth	r2, r3
 8010622:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010624:	801a      	strh	r2, [r3, #0]
 8010626:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801062a:	2b3e      	cmp	r3, #62	; 0x3e
 801062c:	d921      	bls.n	8010672 <USB_EPStartXfer+0xac0>
 801062e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010632:	095b      	lsrs	r3, r3, #5
 8010634:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8010638:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801063c:	f003 031f 	and.w	r3, r3, #31
 8010640:	2b00      	cmp	r3, #0
 8010642:	d104      	bne.n	801064e <USB_EPStartXfer+0xa9c>
 8010644:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8010648:	3b01      	subs	r3, #1
 801064a:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 801064e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010650:	881b      	ldrh	r3, [r3, #0]
 8010652:	b29a      	uxth	r2, r3
 8010654:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8010658:	b29b      	uxth	r3, r3
 801065a:	029b      	lsls	r3, r3, #10
 801065c:	b29b      	uxth	r3, r3
 801065e:	4313      	orrs	r3, r2
 8010660:	b29b      	uxth	r3, r3
 8010662:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010666:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801066a:	b29a      	uxth	r2, r3
 801066c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801066e:	801a      	strh	r2, [r3, #0]
 8010670:	e050      	b.n	8010714 <USB_EPStartXfer+0xb62>
 8010672:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010676:	2b00      	cmp	r3, #0
 8010678:	d10a      	bne.n	8010690 <USB_EPStartXfer+0xade>
 801067a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801067c:	881b      	ldrh	r3, [r3, #0]
 801067e:	b29b      	uxth	r3, r3
 8010680:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010684:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010688:	b29a      	uxth	r2, r3
 801068a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801068c:	801a      	strh	r2, [r3, #0]
 801068e:	e041      	b.n	8010714 <USB_EPStartXfer+0xb62>
 8010690:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010694:	085b      	lsrs	r3, r3, #1
 8010696:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 801069a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801069e:	f003 0301 	and.w	r3, r3, #1
 80106a2:	2b00      	cmp	r3, #0
 80106a4:	d004      	beq.n	80106b0 <USB_EPStartXfer+0xafe>
 80106a6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80106aa:	3301      	adds	r3, #1
 80106ac:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 80106b0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80106b2:	881b      	ldrh	r3, [r3, #0]
 80106b4:	b29a      	uxth	r2, r3
 80106b6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80106ba:	b29b      	uxth	r3, r3
 80106bc:	029b      	lsls	r3, r3, #10
 80106be:	b29b      	uxth	r3, r3
 80106c0:	4313      	orrs	r3, r2
 80106c2:	b29a      	uxth	r2, r3
 80106c4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80106c6:	801a      	strh	r2, [r3, #0]
 80106c8:	e024      	b.n	8010714 <USB_EPStartXfer+0xb62>
 80106ca:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80106ce:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80106d2:	681b      	ldr	r3, [r3, #0]
 80106d4:	785b      	ldrb	r3, [r3, #1]
 80106d6:	2b01      	cmp	r3, #1
 80106d8:	d11c      	bne.n	8010714 <USB_EPStartXfer+0xb62>
 80106da:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80106de:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80106e2:	681b      	ldr	r3, [r3, #0]
 80106e4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80106e8:	b29b      	uxth	r3, r3
 80106ea:	461a      	mov	r2, r3
 80106ec:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80106ee:	4413      	add	r3, r2
 80106f0:	673b      	str	r3, [r7, #112]	; 0x70
 80106f2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80106f6:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80106fa:	681b      	ldr	r3, [r3, #0]
 80106fc:	781b      	ldrb	r3, [r3, #0]
 80106fe:	00da      	lsls	r2, r3, #3
 8010700:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8010702:	4413      	add	r3, r2
 8010704:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010708:	66fb      	str	r3, [r7, #108]	; 0x6c
 801070a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801070e:	b29a      	uxth	r2, r3
 8010710:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8010712:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr1;
 8010714:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010718:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801071c:	681b      	ldr	r3, [r3, #0]
 801071e:	895b      	ldrh	r3, [r3, #10]
 8010720:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8010724:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010728:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801072c:	681b      	ldr	r3, [r3, #0]
 801072e:	6959      	ldr	r1, [r3, #20]
 8010730:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010734:	b29b      	uxth	r3, r3
 8010736:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 801073a:	f507 7084 	add.w	r0, r7, #264	; 0x108
 801073e:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 8010742:	6800      	ldr	r0, [r0, #0]
 8010744:	f000 ff20 	bl	8011588 <USB_WritePMA>
 8010748:	e0ca      	b.n	80108e0 <USB_EPStartXfer+0xd2e>
        }
        else
        {
          /* Set the Double buffer counter for pmabuffer0 */
          PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 801074a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801074e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010752:	681b      	ldr	r3, [r3, #0]
 8010754:	785b      	ldrb	r3, [r3, #1]
 8010756:	2b00      	cmp	r3, #0
 8010758:	d177      	bne.n	801084a <USB_EPStartXfer+0xc98>
 801075a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801075e:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010762:	681b      	ldr	r3, [r3, #0]
 8010764:	67fb      	str	r3, [r7, #124]	; 0x7c
 8010766:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801076a:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801076e:	681b      	ldr	r3, [r3, #0]
 8010770:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010774:	b29b      	uxth	r3, r3
 8010776:	461a      	mov	r2, r3
 8010778:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801077a:	4413      	add	r3, r2
 801077c:	67fb      	str	r3, [r7, #124]	; 0x7c
 801077e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010782:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010786:	681b      	ldr	r3, [r3, #0]
 8010788:	781b      	ldrb	r3, [r3, #0]
 801078a:	00da      	lsls	r2, r3, #3
 801078c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801078e:	4413      	add	r3, r2
 8010790:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010794:	67bb      	str	r3, [r7, #120]	; 0x78
 8010796:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010798:	881b      	ldrh	r3, [r3, #0]
 801079a:	b29b      	uxth	r3, r3
 801079c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80107a0:	b29a      	uxth	r2, r3
 80107a2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80107a4:	801a      	strh	r2, [r3, #0]
 80107a6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80107aa:	2b3e      	cmp	r3, #62	; 0x3e
 80107ac:	d921      	bls.n	80107f2 <USB_EPStartXfer+0xc40>
 80107ae:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80107b2:	095b      	lsrs	r3, r3, #5
 80107b4:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 80107b8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80107bc:	f003 031f 	and.w	r3, r3, #31
 80107c0:	2b00      	cmp	r3, #0
 80107c2:	d104      	bne.n	80107ce <USB_EPStartXfer+0xc1c>
 80107c4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 80107c8:	3b01      	subs	r3, #1
 80107ca:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 80107ce:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80107d0:	881b      	ldrh	r3, [r3, #0]
 80107d2:	b29a      	uxth	r2, r3
 80107d4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 80107d8:	b29b      	uxth	r3, r3
 80107da:	029b      	lsls	r3, r3, #10
 80107dc:	b29b      	uxth	r3, r3
 80107de:	4313      	orrs	r3, r2
 80107e0:	b29b      	uxth	r3, r3
 80107e2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80107e6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80107ea:	b29a      	uxth	r2, r3
 80107ec:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80107ee:	801a      	strh	r2, [r3, #0]
 80107f0:	e05c      	b.n	80108ac <USB_EPStartXfer+0xcfa>
 80107f2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80107f6:	2b00      	cmp	r3, #0
 80107f8:	d10a      	bne.n	8010810 <USB_EPStartXfer+0xc5e>
 80107fa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80107fc:	881b      	ldrh	r3, [r3, #0]
 80107fe:	b29b      	uxth	r3, r3
 8010800:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010804:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010808:	b29a      	uxth	r2, r3
 801080a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801080c:	801a      	strh	r2, [r3, #0]
 801080e:	e04d      	b.n	80108ac <USB_EPStartXfer+0xcfa>
 8010810:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010814:	085b      	lsrs	r3, r3, #1
 8010816:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 801081a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801081e:	f003 0301 	and.w	r3, r3, #1
 8010822:	2b00      	cmp	r3, #0
 8010824:	d004      	beq.n	8010830 <USB_EPStartXfer+0xc7e>
 8010826:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 801082a:	3301      	adds	r3, #1
 801082c:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8010830:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010832:	881b      	ldrh	r3, [r3, #0]
 8010834:	b29a      	uxth	r2, r3
 8010836:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 801083a:	b29b      	uxth	r3, r3
 801083c:	029b      	lsls	r3, r3, #10
 801083e:	b29b      	uxth	r3, r3
 8010840:	4313      	orrs	r3, r2
 8010842:	b29a      	uxth	r2, r3
 8010844:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010846:	801a      	strh	r2, [r3, #0]
 8010848:	e030      	b.n	80108ac <USB_EPStartXfer+0xcfa>
 801084a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801084e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010852:	681b      	ldr	r3, [r3, #0]
 8010854:	785b      	ldrb	r3, [r3, #1]
 8010856:	2b01      	cmp	r3, #1
 8010858:	d128      	bne.n	80108ac <USB_EPStartXfer+0xcfa>
 801085a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801085e:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010862:	681b      	ldr	r3, [r3, #0]
 8010864:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8010868:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801086c:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010870:	681b      	ldr	r3, [r3, #0]
 8010872:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010876:	b29b      	uxth	r3, r3
 8010878:	461a      	mov	r2, r3
 801087a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801087e:	4413      	add	r3, r2
 8010880:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8010884:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010888:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801088c:	681b      	ldr	r3, [r3, #0]
 801088e:	781b      	ldrb	r3, [r3, #0]
 8010890:	00da      	lsls	r2, r3, #3
 8010892:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8010896:	4413      	add	r3, r2
 8010898:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801089c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 80108a0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80108a4:	b29a      	uxth	r2, r3
 80108a6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80108aa:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr0;
 80108ac:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80108b0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80108b4:	681b      	ldr	r3, [r3, #0]
 80108b6:	891b      	ldrh	r3, [r3, #8]
 80108b8:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80108bc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80108c0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80108c4:	681b      	ldr	r3, [r3, #0]
 80108c6:	6959      	ldr	r1, [r3, #20]
 80108c8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80108cc:	b29b      	uxth	r3, r3
 80108ce:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 80108d2:	f507 7084 	add.w	r0, r7, #264	; 0x108
 80108d6:	f5a0 7082 	sub.w	r0, r0, #260	; 0x104
 80108da:	6800      	ldr	r0, [r0, #0]
 80108dc:	f000 fe54 	bl	8011588 <USB_WritePMA>
        }
      }
    }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 80108e0:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80108e4:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80108e8:	681a      	ldr	r2, [r3, #0]
 80108ea:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80108ee:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80108f2:	681b      	ldr	r3, [r3, #0]
 80108f4:	781b      	ldrb	r3, [r3, #0]
 80108f6:	009b      	lsls	r3, r3, #2
 80108f8:	4413      	add	r3, r2
 80108fa:	881b      	ldrh	r3, [r3, #0]
 80108fc:	b29b      	uxth	r3, r3
 80108fe:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8010902:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8010906:	817b      	strh	r3, [r7, #10]
 8010908:	897b      	ldrh	r3, [r7, #10]
 801090a:	f083 0310 	eor.w	r3, r3, #16
 801090e:	817b      	strh	r3, [r7, #10]
 8010910:	897b      	ldrh	r3, [r7, #10]
 8010912:	f083 0320 	eor.w	r3, r3, #32
 8010916:	817b      	strh	r3, [r7, #10]
 8010918:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801091c:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010920:	681a      	ldr	r2, [r3, #0]
 8010922:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010926:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801092a:	681b      	ldr	r3, [r3, #0]
 801092c:	781b      	ldrb	r3, [r3, #0]
 801092e:	009b      	lsls	r3, r3, #2
 8010930:	441a      	add	r2, r3
 8010932:	897b      	ldrh	r3, [r7, #10]
 8010934:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8010938:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801093c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8010940:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010944:	b29b      	uxth	r3, r3
 8010946:	8013      	strh	r3, [r2, #0]
 8010948:	f000 bcde 	b.w	8011308 <USB_EPStartXfer+0x1756>
  }
  else /* OUT endpoint */
  {
    if (ep->doublebuffer == 0U)
 801094c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010950:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010954:	681b      	ldr	r3, [r3, #0]
 8010956:	7b1b      	ldrb	r3, [r3, #12]
 8010958:	2b00      	cmp	r3, #0
 801095a:	f040 80bb 	bne.w	8010ad4 <USB_EPStartXfer+0xf22>
    {
      /* Multi packet transfer */
      if (ep->xfer_len > ep->maxpacket)
 801095e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010962:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010966:	681b      	ldr	r3, [r3, #0]
 8010968:	699a      	ldr	r2, [r3, #24]
 801096a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801096e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010972:	681b      	ldr	r3, [r3, #0]
 8010974:	691b      	ldr	r3, [r3, #16]
 8010976:	429a      	cmp	r2, r3
 8010978:	d917      	bls.n	80109aa <USB_EPStartXfer+0xdf8>
      {
        len = ep->maxpacket;
 801097a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801097e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010982:	681b      	ldr	r3, [r3, #0]
 8010984:	691b      	ldr	r3, [r3, #16]
 8010986:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
        ep->xfer_len -= len;
 801098a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801098e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010992:	681b      	ldr	r3, [r3, #0]
 8010994:	699a      	ldr	r2, [r3, #24]
 8010996:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801099a:	1ad2      	subs	r2, r2, r3
 801099c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80109a0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80109a4:	681b      	ldr	r3, [r3, #0]
 80109a6:	619a      	str	r2, [r3, #24]
 80109a8:	e00e      	b.n	80109c8 <USB_EPStartXfer+0xe16>
      }
      else
      {
        len = ep->xfer_len;
 80109aa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80109ae:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80109b2:	681b      	ldr	r3, [r3, #0]
 80109b4:	699b      	ldr	r3, [r3, #24]
 80109b6:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
        ep->xfer_len = 0U;
 80109ba:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80109be:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80109c2:	681b      	ldr	r3, [r3, #0]
 80109c4:	2200      	movs	r2, #0
 80109c6:	619a      	str	r2, [r3, #24]
      }
      /* configure and validate Rx endpoint */
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 80109c8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80109cc:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80109d0:	681b      	ldr	r3, [r3, #0]
 80109d2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80109d6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80109da:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80109de:	681b      	ldr	r3, [r3, #0]
 80109e0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80109e4:	b29b      	uxth	r3, r3
 80109e6:	461a      	mov	r2, r3
 80109e8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80109ec:	4413      	add	r3, r2
 80109ee:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80109f2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80109f6:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80109fa:	681b      	ldr	r3, [r3, #0]
 80109fc:	781b      	ldrb	r3, [r3, #0]
 80109fe:	00da      	lsls	r2, r3, #3
 8010a00:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8010a04:	4413      	add	r3, r2
 8010a06:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010a0a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8010a0e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010a12:	881b      	ldrh	r3, [r3, #0]
 8010a14:	b29b      	uxth	r3, r3
 8010a16:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010a1a:	b29a      	uxth	r2, r3
 8010a1c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010a20:	801a      	strh	r2, [r3, #0]
 8010a22:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010a26:	2b3e      	cmp	r3, #62	; 0x3e
 8010a28:	d924      	bls.n	8010a74 <USB_EPStartXfer+0xec2>
 8010a2a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010a2e:	095b      	lsrs	r3, r3, #5
 8010a30:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8010a34:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010a38:	f003 031f 	and.w	r3, r3, #31
 8010a3c:	2b00      	cmp	r3, #0
 8010a3e:	d104      	bne.n	8010a4a <USB_EPStartXfer+0xe98>
 8010a40:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8010a44:	3b01      	subs	r3, #1
 8010a46:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8010a4a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010a4e:	881b      	ldrh	r3, [r3, #0]
 8010a50:	b29a      	uxth	r2, r3
 8010a52:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8010a56:	b29b      	uxth	r3, r3
 8010a58:	029b      	lsls	r3, r3, #10
 8010a5a:	b29b      	uxth	r3, r3
 8010a5c:	4313      	orrs	r3, r2
 8010a5e:	b29b      	uxth	r3, r3
 8010a60:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010a64:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010a68:	b29a      	uxth	r2, r3
 8010a6a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010a6e:	801a      	strh	r2, [r3, #0]
 8010a70:	f000 bc10 	b.w	8011294 <USB_EPStartXfer+0x16e2>
 8010a74:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010a78:	2b00      	cmp	r3, #0
 8010a7a:	d10c      	bne.n	8010a96 <USB_EPStartXfer+0xee4>
 8010a7c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010a80:	881b      	ldrh	r3, [r3, #0]
 8010a82:	b29b      	uxth	r3, r3
 8010a84:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010a88:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010a8c:	b29a      	uxth	r2, r3
 8010a8e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010a92:	801a      	strh	r2, [r3, #0]
 8010a94:	e3fe      	b.n	8011294 <USB_EPStartXfer+0x16e2>
 8010a96:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010a9a:	085b      	lsrs	r3, r3, #1
 8010a9c:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8010aa0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010aa4:	f003 0301 	and.w	r3, r3, #1
 8010aa8:	2b00      	cmp	r3, #0
 8010aaa:	d004      	beq.n	8010ab6 <USB_EPStartXfer+0xf04>
 8010aac:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8010ab0:	3301      	adds	r3, #1
 8010ab2:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8010ab6:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010aba:	881b      	ldrh	r3, [r3, #0]
 8010abc:	b29a      	uxth	r2, r3
 8010abe:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8010ac2:	b29b      	uxth	r3, r3
 8010ac4:	029b      	lsls	r3, r3, #10
 8010ac6:	b29b      	uxth	r3, r3
 8010ac8:	4313      	orrs	r3, r2
 8010aca:	b29a      	uxth	r2, r3
 8010acc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8010ad0:	801a      	strh	r2, [r3, #0]
 8010ad2:	e3df      	b.n	8011294 <USB_EPStartXfer+0x16e2>
#if (USE_USB_DOUBLE_BUFFER == 1U)
    else
    {
      /* First Transfer Coming From HAL_PCD_EP_Receive & From ISR */
      /* Set the Double buffer counter */
      if (ep->type == EP_TYPE_BULK)
 8010ad4:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010ad8:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010adc:	681b      	ldr	r3, [r3, #0]
 8010ade:	78db      	ldrb	r3, [r3, #3]
 8010ae0:	2b02      	cmp	r3, #2
 8010ae2:	f040 8218 	bne.w	8010f16 <USB_EPStartXfer+0x1364>
      {
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 8010ae6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010aea:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010aee:	681b      	ldr	r3, [r3, #0]
 8010af0:	785b      	ldrb	r3, [r3, #1]
 8010af2:	2b00      	cmp	r3, #0
 8010af4:	f040 809d 	bne.w	8010c32 <USB_EPStartXfer+0x1080>
 8010af8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010afc:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010b00:	681b      	ldr	r3, [r3, #0]
 8010b02:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8010b06:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010b0a:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010b0e:	681b      	ldr	r3, [r3, #0]
 8010b10:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010b14:	b29b      	uxth	r3, r3
 8010b16:	461a      	mov	r2, r3
 8010b18:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8010b1c:	4413      	add	r3, r2
 8010b1e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8010b22:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010b26:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010b2a:	681b      	ldr	r3, [r3, #0]
 8010b2c:	781b      	ldrb	r3, [r3, #0]
 8010b2e:	00da      	lsls	r2, r3, #3
 8010b30:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8010b34:	4413      	add	r3, r2
 8010b36:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010b3a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8010b3e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010b42:	881b      	ldrh	r3, [r3, #0]
 8010b44:	b29b      	uxth	r3, r3
 8010b46:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010b4a:	b29a      	uxth	r2, r3
 8010b4c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010b50:	801a      	strh	r2, [r3, #0]
 8010b52:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010b56:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010b5a:	681b      	ldr	r3, [r3, #0]
 8010b5c:	691b      	ldr	r3, [r3, #16]
 8010b5e:	2b3e      	cmp	r3, #62	; 0x3e
 8010b60:	d92b      	bls.n	8010bba <USB_EPStartXfer+0x1008>
 8010b62:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010b66:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010b6a:	681b      	ldr	r3, [r3, #0]
 8010b6c:	691b      	ldr	r3, [r3, #16]
 8010b6e:	095b      	lsrs	r3, r3, #5
 8010b70:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8010b74:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010b78:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010b7c:	681b      	ldr	r3, [r3, #0]
 8010b7e:	691b      	ldr	r3, [r3, #16]
 8010b80:	f003 031f 	and.w	r3, r3, #31
 8010b84:	2b00      	cmp	r3, #0
 8010b86:	d104      	bne.n	8010b92 <USB_EPStartXfer+0xfe0>
 8010b88:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8010b8c:	3b01      	subs	r3, #1
 8010b8e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8010b92:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010b96:	881b      	ldrh	r3, [r3, #0]
 8010b98:	b29a      	uxth	r2, r3
 8010b9a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8010b9e:	b29b      	uxth	r3, r3
 8010ba0:	029b      	lsls	r3, r3, #10
 8010ba2:	b29b      	uxth	r3, r3
 8010ba4:	4313      	orrs	r3, r2
 8010ba6:	b29b      	uxth	r3, r3
 8010ba8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010bac:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010bb0:	b29a      	uxth	r2, r3
 8010bb2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010bb6:	801a      	strh	r2, [r3, #0]
 8010bb8:	e070      	b.n	8010c9c <USB_EPStartXfer+0x10ea>
 8010bba:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010bbe:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010bc2:	681b      	ldr	r3, [r3, #0]
 8010bc4:	691b      	ldr	r3, [r3, #16]
 8010bc6:	2b00      	cmp	r3, #0
 8010bc8:	d10c      	bne.n	8010be4 <USB_EPStartXfer+0x1032>
 8010bca:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010bce:	881b      	ldrh	r3, [r3, #0]
 8010bd0:	b29b      	uxth	r3, r3
 8010bd2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010bd6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010bda:	b29a      	uxth	r2, r3
 8010bdc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010be0:	801a      	strh	r2, [r3, #0]
 8010be2:	e05b      	b.n	8010c9c <USB_EPStartXfer+0x10ea>
 8010be4:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010be8:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010bec:	681b      	ldr	r3, [r3, #0]
 8010bee:	691b      	ldr	r3, [r3, #16]
 8010bf0:	085b      	lsrs	r3, r3, #1
 8010bf2:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8010bf6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010bfa:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010bfe:	681b      	ldr	r3, [r3, #0]
 8010c00:	691b      	ldr	r3, [r3, #16]
 8010c02:	f003 0301 	and.w	r3, r3, #1
 8010c06:	2b00      	cmp	r3, #0
 8010c08:	d004      	beq.n	8010c14 <USB_EPStartXfer+0x1062>
 8010c0a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8010c0e:	3301      	adds	r3, #1
 8010c10:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8010c14:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010c18:	881b      	ldrh	r3, [r3, #0]
 8010c1a:	b29a      	uxth	r2, r3
 8010c1c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8010c20:	b29b      	uxth	r3, r3
 8010c22:	029b      	lsls	r3, r3, #10
 8010c24:	b29b      	uxth	r3, r3
 8010c26:	4313      	orrs	r3, r2
 8010c28:	b29a      	uxth	r2, r3
 8010c2a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8010c2e:	801a      	strh	r2, [r3, #0]
 8010c30:	e034      	b.n	8010c9c <USB_EPStartXfer+0x10ea>
 8010c32:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010c36:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010c3a:	681b      	ldr	r3, [r3, #0]
 8010c3c:	785b      	ldrb	r3, [r3, #1]
 8010c3e:	2b01      	cmp	r3, #1
 8010c40:	d12c      	bne.n	8010c9c <USB_EPStartXfer+0x10ea>
 8010c42:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010c46:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010c4a:	681b      	ldr	r3, [r3, #0]
 8010c4c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8010c50:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010c54:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010c58:	681b      	ldr	r3, [r3, #0]
 8010c5a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010c5e:	b29b      	uxth	r3, r3
 8010c60:	461a      	mov	r2, r3
 8010c62:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8010c66:	4413      	add	r3, r2
 8010c68:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8010c6c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010c70:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010c74:	681b      	ldr	r3, [r3, #0]
 8010c76:	781b      	ldrb	r3, [r3, #0]
 8010c78:	00da      	lsls	r2, r3, #3
 8010c7a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8010c7e:	4413      	add	r3, r2
 8010c80:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010c84:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8010c88:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010c8c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010c90:	681b      	ldr	r3, [r3, #0]
 8010c92:	691b      	ldr	r3, [r3, #16]
 8010c94:	b29a      	uxth	r2, r3
 8010c96:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8010c9a:	801a      	strh	r2, [r3, #0]
 8010c9c:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010ca0:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010ca4:	681b      	ldr	r3, [r3, #0]
 8010ca6:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8010caa:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010cae:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010cb2:	681b      	ldr	r3, [r3, #0]
 8010cb4:	785b      	ldrb	r3, [r3, #1]
 8010cb6:	2b00      	cmp	r3, #0
 8010cb8:	f040 809d 	bne.w	8010df6 <USB_EPStartXfer+0x1244>
 8010cbc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010cc0:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010cc4:	681b      	ldr	r3, [r3, #0]
 8010cc6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8010cca:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010cce:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010cd2:	681b      	ldr	r3, [r3, #0]
 8010cd4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010cd8:	b29b      	uxth	r3, r3
 8010cda:	461a      	mov	r2, r3
 8010cdc:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8010ce0:	4413      	add	r3, r2
 8010ce2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8010ce6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010cea:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010cee:	681b      	ldr	r3, [r3, #0]
 8010cf0:	781b      	ldrb	r3, [r3, #0]
 8010cf2:	00da      	lsls	r2, r3, #3
 8010cf4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8010cf8:	4413      	add	r3, r2
 8010cfa:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010cfe:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8010d02:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010d06:	881b      	ldrh	r3, [r3, #0]
 8010d08:	b29b      	uxth	r3, r3
 8010d0a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010d0e:	b29a      	uxth	r2, r3
 8010d10:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010d14:	801a      	strh	r2, [r3, #0]
 8010d16:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010d1a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010d1e:	681b      	ldr	r3, [r3, #0]
 8010d20:	691b      	ldr	r3, [r3, #16]
 8010d22:	2b3e      	cmp	r3, #62	; 0x3e
 8010d24:	d92b      	bls.n	8010d7e <USB_EPStartXfer+0x11cc>
 8010d26:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010d2a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010d2e:	681b      	ldr	r3, [r3, #0]
 8010d30:	691b      	ldr	r3, [r3, #16]
 8010d32:	095b      	lsrs	r3, r3, #5
 8010d34:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8010d38:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010d3c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010d40:	681b      	ldr	r3, [r3, #0]
 8010d42:	691b      	ldr	r3, [r3, #16]
 8010d44:	f003 031f 	and.w	r3, r3, #31
 8010d48:	2b00      	cmp	r3, #0
 8010d4a:	d104      	bne.n	8010d56 <USB_EPStartXfer+0x11a4>
 8010d4c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8010d50:	3b01      	subs	r3, #1
 8010d52:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8010d56:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010d5a:	881b      	ldrh	r3, [r3, #0]
 8010d5c:	b29a      	uxth	r2, r3
 8010d5e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8010d62:	b29b      	uxth	r3, r3
 8010d64:	029b      	lsls	r3, r3, #10
 8010d66:	b29b      	uxth	r3, r3
 8010d68:	4313      	orrs	r3, r2
 8010d6a:	b29b      	uxth	r3, r3
 8010d6c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010d70:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010d74:	b29a      	uxth	r2, r3
 8010d76:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010d7a:	801a      	strh	r2, [r3, #0]
 8010d7c:	e069      	b.n	8010e52 <USB_EPStartXfer+0x12a0>
 8010d7e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010d82:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010d86:	681b      	ldr	r3, [r3, #0]
 8010d88:	691b      	ldr	r3, [r3, #16]
 8010d8a:	2b00      	cmp	r3, #0
 8010d8c:	d10c      	bne.n	8010da8 <USB_EPStartXfer+0x11f6>
 8010d8e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010d92:	881b      	ldrh	r3, [r3, #0]
 8010d94:	b29b      	uxth	r3, r3
 8010d96:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010d9a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010d9e:	b29a      	uxth	r2, r3
 8010da0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010da4:	801a      	strh	r2, [r3, #0]
 8010da6:	e054      	b.n	8010e52 <USB_EPStartXfer+0x12a0>
 8010da8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010dac:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010db0:	681b      	ldr	r3, [r3, #0]
 8010db2:	691b      	ldr	r3, [r3, #16]
 8010db4:	085b      	lsrs	r3, r3, #1
 8010db6:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8010dba:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010dbe:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010dc2:	681b      	ldr	r3, [r3, #0]
 8010dc4:	691b      	ldr	r3, [r3, #16]
 8010dc6:	f003 0301 	and.w	r3, r3, #1
 8010dca:	2b00      	cmp	r3, #0
 8010dcc:	d004      	beq.n	8010dd8 <USB_EPStartXfer+0x1226>
 8010dce:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8010dd2:	3301      	adds	r3, #1
 8010dd4:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8010dd8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010ddc:	881b      	ldrh	r3, [r3, #0]
 8010dde:	b29a      	uxth	r2, r3
 8010de0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8010de4:	b29b      	uxth	r3, r3
 8010de6:	029b      	lsls	r3, r3, #10
 8010de8:	b29b      	uxth	r3, r3
 8010dea:	4313      	orrs	r3, r2
 8010dec:	b29a      	uxth	r2, r3
 8010dee:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8010df2:	801a      	strh	r2, [r3, #0]
 8010df4:	e02d      	b.n	8010e52 <USB_EPStartXfer+0x12a0>
 8010df6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010dfa:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010dfe:	681b      	ldr	r3, [r3, #0]
 8010e00:	785b      	ldrb	r3, [r3, #1]
 8010e02:	2b01      	cmp	r3, #1
 8010e04:	d125      	bne.n	8010e52 <USB_EPStartXfer+0x12a0>
 8010e06:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010e0a:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010e0e:	681b      	ldr	r3, [r3, #0]
 8010e10:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010e14:	b29b      	uxth	r3, r3
 8010e16:	461a      	mov	r2, r3
 8010e18:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8010e1c:	4413      	add	r3, r2
 8010e1e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8010e22:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010e26:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010e2a:	681b      	ldr	r3, [r3, #0]
 8010e2c:	781b      	ldrb	r3, [r3, #0]
 8010e2e:	00da      	lsls	r2, r3, #3
 8010e30:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8010e34:	4413      	add	r3, r2
 8010e36:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010e3a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8010e3e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010e42:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010e46:	681b      	ldr	r3, [r3, #0]
 8010e48:	691b      	ldr	r3, [r3, #16]
 8010e4a:	b29a      	uxth	r2, r3
 8010e4c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8010e50:	801a      	strh	r2, [r3, #0]

        /* Coming from ISR */
        if (ep->xfer_count != 0U)
 8010e52:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010e56:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010e5a:	681b      	ldr	r3, [r3, #0]
 8010e5c:	69db      	ldr	r3, [r3, #28]
 8010e5e:	2b00      	cmp	r3, #0
 8010e60:	f000 8218 	beq.w	8011294 <USB_EPStartXfer+0x16e2>
        {
          /* update last value to check if there is blocking state */
          wEPVal = PCD_GET_ENDPOINT(USBx, ep->num);
 8010e64:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010e68:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010e6c:	681a      	ldr	r2, [r3, #0]
 8010e6e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010e72:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010e76:	681b      	ldr	r3, [r3, #0]
 8010e78:	781b      	ldrb	r3, [r3, #0]
 8010e7a:	009b      	lsls	r3, r3, #2
 8010e7c:	4413      	add	r3, r2
 8010e7e:	881b      	ldrh	r3, [r3, #0]
 8010e80:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96

          /*Blocking State */
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 8010e84:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8010e88:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8010e8c:	2b00      	cmp	r3, #0
 8010e8e:	d005      	beq.n	8010e9c <USB_EPStartXfer+0x12ea>
 8010e90:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8010e94:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010e98:	2b00      	cmp	r3, #0
 8010e9a:	d10d      	bne.n	8010eb8 <USB_EPStartXfer+0x1306>
              (((wEPVal & USB_EP_DTOG_RX) == 0U) && ((wEPVal & USB_EP_DTOG_TX) == 0U)))
 8010e9c:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8010ea0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 8010ea4:	2b00      	cmp	r3, #0
 8010ea6:	f040 81f5 	bne.w	8011294 <USB_EPStartXfer+0x16e2>
              (((wEPVal & USB_EP_DTOG_RX) == 0U) && ((wEPVal & USB_EP_DTOG_TX) == 0U)))
 8010eaa:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8010eae:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010eb2:	2b00      	cmp	r3, #0
 8010eb4:	f040 81ee 	bne.w	8011294 <USB_EPStartXfer+0x16e2>
          {
            PCD_FREE_USER_BUFFER(USBx, ep->num, 0U);
 8010eb8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010ebc:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010ec0:	681a      	ldr	r2, [r3, #0]
 8010ec2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010ec6:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010eca:	681b      	ldr	r3, [r3, #0]
 8010ecc:	781b      	ldrb	r3, [r3, #0]
 8010ece:	009b      	lsls	r3, r3, #2
 8010ed0:	4413      	add	r3, r2
 8010ed2:	881b      	ldrh	r3, [r3, #0]
 8010ed4:	b29b      	uxth	r3, r3
 8010ed6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8010eda:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8010ede:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
 8010ee2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010ee6:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010eea:	681a      	ldr	r2, [r3, #0]
 8010eec:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010ef0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010ef4:	681b      	ldr	r3, [r3, #0]
 8010ef6:	781b      	ldrb	r3, [r3, #0]
 8010ef8:	009b      	lsls	r3, r3, #2
 8010efa:	441a      	add	r2, r3
 8010efc:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
 8010f00:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8010f04:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8010f08:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8010f0c:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8010f10:	b29b      	uxth	r3, r3
 8010f12:	8013      	strh	r3, [r2, #0]
 8010f14:	e1be      	b.n	8011294 <USB_EPStartXfer+0x16e2>
          }
        }
      }
      /* iso out double */
      else if (ep->type == EP_TYPE_ISOC)
 8010f16:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f1a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f1e:	681b      	ldr	r3, [r3, #0]
 8010f20:	78db      	ldrb	r3, [r3, #3]
 8010f22:	2b01      	cmp	r3, #1
 8010f24:	f040 81b4 	bne.w	8011290 <USB_EPStartXfer+0x16de>
      {
        /* Multi packet transfer */
        if (ep->xfer_len > ep->maxpacket)
 8010f28:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f2c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f30:	681b      	ldr	r3, [r3, #0]
 8010f32:	699a      	ldr	r2, [r3, #24]
 8010f34:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f38:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f3c:	681b      	ldr	r3, [r3, #0]
 8010f3e:	691b      	ldr	r3, [r3, #16]
 8010f40:	429a      	cmp	r2, r3
 8010f42:	d917      	bls.n	8010f74 <USB_EPStartXfer+0x13c2>
        {
          len = ep->maxpacket;
 8010f44:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f48:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f4c:	681b      	ldr	r3, [r3, #0]
 8010f4e:	691b      	ldr	r3, [r3, #16]
 8010f50:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
          ep->xfer_len -= len;
 8010f54:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f58:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f5c:	681b      	ldr	r3, [r3, #0]
 8010f5e:	699a      	ldr	r2, [r3, #24]
 8010f60:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8010f64:	1ad2      	subs	r2, r2, r3
 8010f66:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f6a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f6e:	681b      	ldr	r3, [r3, #0]
 8010f70:	619a      	str	r2, [r3, #24]
 8010f72:	e00e      	b.n	8010f92 <USB_EPStartXfer+0x13e0>
        }
        else
        {
          len = ep->xfer_len;
 8010f74:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f78:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f7c:	681b      	ldr	r3, [r3, #0]
 8010f7e:	699b      	ldr	r3, [r3, #24]
 8010f80:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
          ep->xfer_len = 0U;
 8010f84:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f88:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f8c:	681b      	ldr	r3, [r3, #0]
 8010f8e:	2200      	movs	r2, #0
 8010f90:	619a      	str	r2, [r3, #24]
        }
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8010f92:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010f96:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010f9a:	681b      	ldr	r3, [r3, #0]
 8010f9c:	785b      	ldrb	r3, [r3, #1]
 8010f9e:	2b00      	cmp	r3, #0
 8010fa0:	f040 8085 	bne.w	80110ae <USB_EPStartXfer+0x14fc>
 8010fa4:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010fa8:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010fac:	681b      	ldr	r3, [r3, #0]
 8010fae:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8010fb2:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010fb6:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8010fba:	681b      	ldr	r3, [r3, #0]
 8010fbc:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010fc0:	b29b      	uxth	r3, r3
 8010fc2:	461a      	mov	r2, r3
 8010fc4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8010fc8:	4413      	add	r3, r2
 8010fca:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8010fce:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8010fd2:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8010fd6:	681b      	ldr	r3, [r3, #0]
 8010fd8:	781b      	ldrb	r3, [r3, #0]
 8010fda:	00da      	lsls	r2, r3, #3
 8010fdc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8010fe0:	4413      	add	r3, r2
 8010fe2:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010fe6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8010fea:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8010fee:	881b      	ldrh	r3, [r3, #0]
 8010ff0:	b29b      	uxth	r3, r3
 8010ff2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010ff6:	b29a      	uxth	r2, r3
 8010ff8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8010ffc:	801a      	strh	r2, [r3, #0]
 8010ffe:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011002:	2b3e      	cmp	r3, #62	; 0x3e
 8011004:	d923      	bls.n	801104e <USB_EPStartXfer+0x149c>
 8011006:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801100a:	095b      	lsrs	r3, r3, #5
 801100c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8011010:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011014:	f003 031f 	and.w	r3, r3, #31
 8011018:	2b00      	cmp	r3, #0
 801101a:	d104      	bne.n	8011026 <USB_EPStartXfer+0x1474>
 801101c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8011020:	3b01      	subs	r3, #1
 8011022:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8011026:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801102a:	881b      	ldrh	r3, [r3, #0]
 801102c:	b29a      	uxth	r2, r3
 801102e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8011032:	b29b      	uxth	r3, r3
 8011034:	029b      	lsls	r3, r3, #10
 8011036:	b29b      	uxth	r3, r3
 8011038:	4313      	orrs	r3, r2
 801103a:	b29b      	uxth	r3, r3
 801103c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8011040:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8011044:	b29a      	uxth	r2, r3
 8011046:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801104a:	801a      	strh	r2, [r3, #0]
 801104c:	e060      	b.n	8011110 <USB_EPStartXfer+0x155e>
 801104e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011052:	2b00      	cmp	r3, #0
 8011054:	d10c      	bne.n	8011070 <USB_EPStartXfer+0x14be>
 8011056:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801105a:	881b      	ldrh	r3, [r3, #0]
 801105c:	b29b      	uxth	r3, r3
 801105e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8011062:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8011066:	b29a      	uxth	r2, r3
 8011068:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801106c:	801a      	strh	r2, [r3, #0]
 801106e:	e04f      	b.n	8011110 <USB_EPStartXfer+0x155e>
 8011070:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011074:	085b      	lsrs	r3, r3, #1
 8011076:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 801107a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801107e:	f003 0301 	and.w	r3, r3, #1
 8011082:	2b00      	cmp	r3, #0
 8011084:	d004      	beq.n	8011090 <USB_EPStartXfer+0x14de>
 8011086:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801108a:	3301      	adds	r3, #1
 801108c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8011090:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8011094:	881b      	ldrh	r3, [r3, #0]
 8011096:	b29a      	uxth	r2, r3
 8011098:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801109c:	b29b      	uxth	r3, r3
 801109e:	029b      	lsls	r3, r3, #10
 80110a0:	b29b      	uxth	r3, r3
 80110a2:	4313      	orrs	r3, r2
 80110a4:	b29a      	uxth	r2, r3
 80110a6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80110aa:	801a      	strh	r2, [r3, #0]
 80110ac:	e030      	b.n	8011110 <USB_EPStartXfer+0x155e>
 80110ae:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80110b2:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80110b6:	681b      	ldr	r3, [r3, #0]
 80110b8:	785b      	ldrb	r3, [r3, #1]
 80110ba:	2b01      	cmp	r3, #1
 80110bc:	d128      	bne.n	8011110 <USB_EPStartXfer+0x155e>
 80110be:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80110c2:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80110c6:	681b      	ldr	r3, [r3, #0]
 80110c8:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 80110cc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80110d0:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80110d4:	681b      	ldr	r3, [r3, #0]
 80110d6:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80110da:	b29b      	uxth	r3, r3
 80110dc:	461a      	mov	r2, r3
 80110de:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80110e2:	4413      	add	r3, r2
 80110e4:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 80110e8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80110ec:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80110f0:	681b      	ldr	r3, [r3, #0]
 80110f2:	781b      	ldrb	r3, [r3, #0]
 80110f4:	00da      	lsls	r2, r3, #3
 80110f6:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80110fa:	4413      	add	r3, r2
 80110fc:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8011100:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8011104:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011108:	b29a      	uxth	r2, r3
 801110a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 801110e:	801a      	strh	r2, [r3, #0]
 8011110:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8011114:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8011118:	681b      	ldr	r3, [r3, #0]
 801111a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 801111e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8011122:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8011126:	681b      	ldr	r3, [r3, #0]
 8011128:	785b      	ldrb	r3, [r3, #1]
 801112a:	2b00      	cmp	r3, #0
 801112c:	f040 8085 	bne.w	801123a <USB_EPStartXfer+0x1688>
 8011130:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8011134:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8011138:	681b      	ldr	r3, [r3, #0]
 801113a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 801113e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8011142:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8011146:	681b      	ldr	r3, [r3, #0]
 8011148:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801114c:	b29b      	uxth	r3, r3
 801114e:	461a      	mov	r2, r3
 8011150:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8011154:	4413      	add	r3, r2
 8011156:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 801115a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801115e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8011162:	681b      	ldr	r3, [r3, #0]
 8011164:	781b      	ldrb	r3, [r3, #0]
 8011166:	00da      	lsls	r2, r3, #3
 8011168:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801116c:	4413      	add	r3, r2
 801116e:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8011172:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8011176:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801117a:	881b      	ldrh	r3, [r3, #0]
 801117c:	b29b      	uxth	r3, r3
 801117e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8011182:	b29a      	uxth	r2, r3
 8011184:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8011188:	801a      	strh	r2, [r3, #0]
 801118a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801118e:	2b3e      	cmp	r3, #62	; 0x3e
 8011190:	d923      	bls.n	80111da <USB_EPStartXfer+0x1628>
 8011192:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011196:	095b      	lsrs	r3, r3, #5
 8011198:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 801119c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80111a0:	f003 031f 	and.w	r3, r3, #31
 80111a4:	2b00      	cmp	r3, #0
 80111a6:	d104      	bne.n	80111b2 <USB_EPStartXfer+0x1600>
 80111a8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80111ac:	3b01      	subs	r3, #1
 80111ae:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 80111b2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80111b6:	881b      	ldrh	r3, [r3, #0]
 80111b8:	b29a      	uxth	r2, r3
 80111ba:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80111be:	b29b      	uxth	r3, r3
 80111c0:	029b      	lsls	r3, r3, #10
 80111c2:	b29b      	uxth	r3, r3
 80111c4:	4313      	orrs	r3, r2
 80111c6:	b29b      	uxth	r3, r3
 80111c8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80111cc:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80111d0:	b29a      	uxth	r2, r3
 80111d2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80111d6:	801a      	strh	r2, [r3, #0]
 80111d8:	e05c      	b.n	8011294 <USB_EPStartXfer+0x16e2>
 80111da:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80111de:	2b00      	cmp	r3, #0
 80111e0:	d10c      	bne.n	80111fc <USB_EPStartXfer+0x164a>
 80111e2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80111e6:	881b      	ldrh	r3, [r3, #0]
 80111e8:	b29b      	uxth	r3, r3
 80111ea:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80111ee:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80111f2:	b29a      	uxth	r2, r3
 80111f4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80111f8:	801a      	strh	r2, [r3, #0]
 80111fa:	e04b      	b.n	8011294 <USB_EPStartXfer+0x16e2>
 80111fc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011200:	085b      	lsrs	r3, r3, #1
 8011202:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8011206:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801120a:	f003 0301 	and.w	r3, r3, #1
 801120e:	2b00      	cmp	r3, #0
 8011210:	d004      	beq.n	801121c <USB_EPStartXfer+0x166a>
 8011212:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8011216:	3301      	adds	r3, #1
 8011218:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 801121c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8011220:	881b      	ldrh	r3, [r3, #0]
 8011222:	b29a      	uxth	r2, r3
 8011224:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8011228:	b29b      	uxth	r3, r3
 801122a:	029b      	lsls	r3, r3, #10
 801122c:	b29b      	uxth	r3, r3
 801122e:	4313      	orrs	r3, r2
 8011230:	b29a      	uxth	r2, r3
 8011232:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8011236:	801a      	strh	r2, [r3, #0]
 8011238:	e02c      	b.n	8011294 <USB_EPStartXfer+0x16e2>
 801123a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801123e:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8011242:	681b      	ldr	r3, [r3, #0]
 8011244:	785b      	ldrb	r3, [r3, #1]
 8011246:	2b01      	cmp	r3, #1
 8011248:	d124      	bne.n	8011294 <USB_EPStartXfer+0x16e2>
 801124a:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801124e:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8011252:	681b      	ldr	r3, [r3, #0]
 8011254:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8011258:	b29b      	uxth	r3, r3
 801125a:	461a      	mov	r2, r3
 801125c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8011260:	4413      	add	r3, r2
 8011262:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8011266:	f507 7384 	add.w	r3, r7, #264	; 0x108
 801126a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 801126e:	681b      	ldr	r3, [r3, #0]
 8011270:	781b      	ldrb	r3, [r3, #0]
 8011272:	00da      	lsls	r2, r3, #3
 8011274:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8011278:	4413      	add	r3, r2
 801127a:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801127e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8011282:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8011286:	b29a      	uxth	r2, r3
 8011288:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801128c:	801a      	strh	r2, [r3, #0]
 801128e:	e001      	b.n	8011294 <USB_EPStartXfer+0x16e2>
      }
      else
      {
        return HAL_ERROR;
 8011290:	2301      	movs	r3, #1
 8011292:	e03a      	b.n	801130a <USB_EPStartXfer+0x1758>
      }
    }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8011294:	f507 7384 	add.w	r3, r7, #264	; 0x108
 8011298:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 801129c:	681a      	ldr	r2, [r3, #0]
 801129e:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80112a2:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80112a6:	681b      	ldr	r3, [r3, #0]
 80112a8:	781b      	ldrb	r3, [r3, #0]
 80112aa:	009b      	lsls	r3, r3, #2
 80112ac:	4413      	add	r3, r2
 80112ae:	881b      	ldrh	r3, [r3, #0]
 80112b0:	b29b      	uxth	r3, r3
 80112b2:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80112b6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80112ba:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 80112be:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 80112c2:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80112c6:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 80112ca:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 80112ce:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 80112d2:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 80112d6:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80112da:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80112de:	681a      	ldr	r2, [r3, #0]
 80112e0:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80112e4:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 80112e8:	681b      	ldr	r3, [r3, #0]
 80112ea:	781b      	ldrb	r3, [r3, #0]
 80112ec:	009b      	lsls	r3, r3, #2
 80112ee:	441a      	add	r2, r3
 80112f0:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 80112f4:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80112f8:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80112fc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8011300:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8011304:	b29b      	uxth	r3, r3
 8011306:	8013      	strh	r3, [r2, #0]
  }

  return HAL_OK;
 8011308:	2300      	movs	r3, #0
}
 801130a:	4618      	mov	r0, r3
 801130c:	f507 7784 	add.w	r7, r7, #264	; 0x108
 8011310:	46bd      	mov	sp, r7
 8011312:	bd80      	pop	{r7, pc}

08011314 <USB_EPSetStall>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8011314:	b480      	push	{r7}
 8011316:	b085      	sub	sp, #20
 8011318:	af00      	add	r7, sp, #0
 801131a:	6078      	str	r0, [r7, #4]
 801131c:	6039      	str	r1, [r7, #0]
  if (ep->is_in != 0U)
 801131e:	683b      	ldr	r3, [r7, #0]
 8011320:	785b      	ldrb	r3, [r3, #1]
 8011322:	2b00      	cmp	r3, #0
 8011324:	d020      	beq.n	8011368 <USB_EPSetStall+0x54>
  {
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 8011326:	687a      	ldr	r2, [r7, #4]
 8011328:	683b      	ldr	r3, [r7, #0]
 801132a:	781b      	ldrb	r3, [r3, #0]
 801132c:	009b      	lsls	r3, r3, #2
 801132e:	4413      	add	r3, r2
 8011330:	881b      	ldrh	r3, [r3, #0]
 8011332:	b29b      	uxth	r3, r3
 8011334:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8011338:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801133c:	81bb      	strh	r3, [r7, #12]
 801133e:	89bb      	ldrh	r3, [r7, #12]
 8011340:	f083 0310 	eor.w	r3, r3, #16
 8011344:	81bb      	strh	r3, [r7, #12]
 8011346:	687a      	ldr	r2, [r7, #4]
 8011348:	683b      	ldr	r3, [r7, #0]
 801134a:	781b      	ldrb	r3, [r3, #0]
 801134c:	009b      	lsls	r3, r3, #2
 801134e:	441a      	add	r2, r3
 8011350:	89bb      	ldrh	r3, [r7, #12]
 8011352:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8011356:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801135a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801135e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8011362:	b29b      	uxth	r3, r3
 8011364:	8013      	strh	r3, [r2, #0]
 8011366:	e01f      	b.n	80113a8 <USB_EPSetStall+0x94>
  }
  else
  {
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 8011368:	687a      	ldr	r2, [r7, #4]
 801136a:	683b      	ldr	r3, [r7, #0]
 801136c:	781b      	ldrb	r3, [r3, #0]
 801136e:	009b      	lsls	r3, r3, #2
 8011370:	4413      	add	r3, r2
 8011372:	881b      	ldrh	r3, [r3, #0]
 8011374:	b29b      	uxth	r3, r3
 8011376:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 801137a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801137e:	81fb      	strh	r3, [r7, #14]
 8011380:	89fb      	ldrh	r3, [r7, #14]
 8011382:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8011386:	81fb      	strh	r3, [r7, #14]
 8011388:	687a      	ldr	r2, [r7, #4]
 801138a:	683b      	ldr	r3, [r7, #0]
 801138c:	781b      	ldrb	r3, [r3, #0]
 801138e:	009b      	lsls	r3, r3, #2
 8011390:	441a      	add	r2, r3
 8011392:	89fb      	ldrh	r3, [r7, #14]
 8011394:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8011398:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801139c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80113a0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80113a4:	b29b      	uxth	r3, r3
 80113a6:	8013      	strh	r3, [r2, #0]
  }

  return HAL_OK;
 80113a8:	2300      	movs	r3, #0
}
 80113aa:	4618      	mov	r0, r3
 80113ac:	3714      	adds	r7, #20
 80113ae:	46bd      	mov	sp, r7
 80113b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113b4:	4770      	bx	lr

080113b6 <USB_EPClearStall>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80113b6:	b480      	push	{r7}
 80113b8:	b087      	sub	sp, #28
 80113ba:	af00      	add	r7, sp, #0
 80113bc:	6078      	str	r0, [r7, #4]
 80113be:	6039      	str	r1, [r7, #0]
  if (ep->doublebuffer == 0U)
 80113c0:	683b      	ldr	r3, [r7, #0]
 80113c2:	7b1b      	ldrb	r3, [r3, #12]
 80113c4:	2b00      	cmp	r3, #0
 80113c6:	f040 809d 	bne.w	8011504 <USB_EPClearStall+0x14e>
  {
    if (ep->is_in != 0U)
 80113ca:	683b      	ldr	r3, [r7, #0]
 80113cc:	785b      	ldrb	r3, [r3, #1]
 80113ce:	2b00      	cmp	r3, #0
 80113d0:	d04c      	beq.n	801146c <USB_EPClearStall+0xb6>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80113d2:	687a      	ldr	r2, [r7, #4]
 80113d4:	683b      	ldr	r3, [r7, #0]
 80113d6:	781b      	ldrb	r3, [r3, #0]
 80113d8:	009b      	lsls	r3, r3, #2
 80113da:	4413      	add	r3, r2
 80113dc:	881b      	ldrh	r3, [r3, #0]
 80113de:	823b      	strh	r3, [r7, #16]
 80113e0:	8a3b      	ldrh	r3, [r7, #16]
 80113e2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80113e6:	2b00      	cmp	r3, #0
 80113e8:	d01b      	beq.n	8011422 <USB_EPClearStall+0x6c>
 80113ea:	687a      	ldr	r2, [r7, #4]
 80113ec:	683b      	ldr	r3, [r7, #0]
 80113ee:	781b      	ldrb	r3, [r3, #0]
 80113f0:	009b      	lsls	r3, r3, #2
 80113f2:	4413      	add	r3, r2
 80113f4:	881b      	ldrh	r3, [r3, #0]
 80113f6:	b29b      	uxth	r3, r3
 80113f8:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80113fc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8011400:	81fb      	strh	r3, [r7, #14]
 8011402:	687a      	ldr	r2, [r7, #4]
 8011404:	683b      	ldr	r3, [r7, #0]
 8011406:	781b      	ldrb	r3, [r3, #0]
 8011408:	009b      	lsls	r3, r3, #2
 801140a:	441a      	add	r2, r3
 801140c:	89fb      	ldrh	r3, [r7, #14]
 801140e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8011412:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8011416:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801141a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 801141e:	b29b      	uxth	r3, r3
 8011420:	8013      	strh	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8011422:	683b      	ldr	r3, [r7, #0]
 8011424:	78db      	ldrb	r3, [r3, #3]
 8011426:	2b01      	cmp	r3, #1
 8011428:	d06c      	beq.n	8011504 <USB_EPClearStall+0x14e>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 801142a:	687a      	ldr	r2, [r7, #4]
 801142c:	683b      	ldr	r3, [r7, #0]
 801142e:	781b      	ldrb	r3, [r3, #0]
 8011430:	009b      	lsls	r3, r3, #2
 8011432:	4413      	add	r3, r2
 8011434:	881b      	ldrh	r3, [r3, #0]
 8011436:	b29b      	uxth	r3, r3
 8011438:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801143c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8011440:	81bb      	strh	r3, [r7, #12]
 8011442:	89bb      	ldrh	r3, [r7, #12]
 8011444:	f083 0320 	eor.w	r3, r3, #32
 8011448:	81bb      	strh	r3, [r7, #12]
 801144a:	687a      	ldr	r2, [r7, #4]
 801144c:	683b      	ldr	r3, [r7, #0]
 801144e:	781b      	ldrb	r3, [r3, #0]
 8011450:	009b      	lsls	r3, r3, #2
 8011452:	441a      	add	r2, r3
 8011454:	89bb      	ldrh	r3, [r7, #12]
 8011456:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801145a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801145e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8011462:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8011466:	b29b      	uxth	r3, r3
 8011468:	8013      	strh	r3, [r2, #0]
 801146a:	e04b      	b.n	8011504 <USB_EPClearStall+0x14e>
      }
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 801146c:	687a      	ldr	r2, [r7, #4]
 801146e:	683b      	ldr	r3, [r7, #0]
 8011470:	781b      	ldrb	r3, [r3, #0]
 8011472:	009b      	lsls	r3, r3, #2
 8011474:	4413      	add	r3, r2
 8011476:	881b      	ldrh	r3, [r3, #0]
 8011478:	82fb      	strh	r3, [r7, #22]
 801147a:	8afb      	ldrh	r3, [r7, #22]
 801147c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8011480:	2b00      	cmp	r3, #0
 8011482:	d01b      	beq.n	80114bc <USB_EPClearStall+0x106>
 8011484:	687a      	ldr	r2, [r7, #4]
 8011486:	683b      	ldr	r3, [r7, #0]
 8011488:	781b      	ldrb	r3, [r3, #0]
 801148a:	009b      	lsls	r3, r3, #2
 801148c:	4413      	add	r3, r2
 801148e:	881b      	ldrh	r3, [r3, #0]
 8011490:	b29b      	uxth	r3, r3
 8011492:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8011496:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801149a:	82bb      	strh	r3, [r7, #20]
 801149c:	687a      	ldr	r2, [r7, #4]
 801149e:	683b      	ldr	r3, [r7, #0]
 80114a0:	781b      	ldrb	r3, [r3, #0]
 80114a2:	009b      	lsls	r3, r3, #2
 80114a4:	441a      	add	r2, r3
 80114a6:	8abb      	ldrh	r3, [r7, #20]
 80114a8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80114ac:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80114b0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80114b4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80114b8:	b29b      	uxth	r3, r3
 80114ba:	8013      	strh	r3, [r2, #0]

      /* Configure VALID status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80114bc:	687a      	ldr	r2, [r7, #4]
 80114be:	683b      	ldr	r3, [r7, #0]
 80114c0:	781b      	ldrb	r3, [r3, #0]
 80114c2:	009b      	lsls	r3, r3, #2
 80114c4:	4413      	add	r3, r2
 80114c6:	881b      	ldrh	r3, [r3, #0]
 80114c8:	b29b      	uxth	r3, r3
 80114ca:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80114ce:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80114d2:	827b      	strh	r3, [r7, #18]
 80114d4:	8a7b      	ldrh	r3, [r7, #18]
 80114d6:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80114da:	827b      	strh	r3, [r7, #18]
 80114dc:	8a7b      	ldrh	r3, [r7, #18]
 80114de:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 80114e2:	827b      	strh	r3, [r7, #18]
 80114e4:	687a      	ldr	r2, [r7, #4]
 80114e6:	683b      	ldr	r3, [r7, #0]
 80114e8:	781b      	ldrb	r3, [r3, #0]
 80114ea:	009b      	lsls	r3, r3, #2
 80114ec:	441a      	add	r2, r3
 80114ee:	8a7b      	ldrh	r3, [r7, #18]
 80114f0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80114f4:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80114f8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80114fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8011500:	b29b      	uxth	r3, r3
 8011502:	8013      	strh	r3, [r2, #0]
    }
  }

  return HAL_OK;
 8011504:	2300      	movs	r3, #0
}
 8011506:	4618      	mov	r0, r3
 8011508:	371c      	adds	r7, #28
 801150a:	46bd      	mov	sp, r7
 801150c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011510:	4770      	bx	lr

08011512 <USB_SetDevAddress>:
  * @param  address new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_TypeDef *USBx, uint8_t address)
{
 8011512:	b480      	push	{r7}
 8011514:	b083      	sub	sp, #12
 8011516:	af00      	add	r7, sp, #0
 8011518:	6078      	str	r0, [r7, #4]
 801151a:	460b      	mov	r3, r1
 801151c:	70fb      	strb	r3, [r7, #3]
  if (address == 0U)
 801151e:	78fb      	ldrb	r3, [r7, #3]
 8011520:	2b00      	cmp	r3, #0
 8011522:	d103      	bne.n	801152c <USB_SetDevAddress+0x1a>
  {
    /* set device address and enable function */
    USBx->DADDR = (uint16_t)USB_DADDR_EF;
 8011524:	687b      	ldr	r3, [r7, #4]
 8011526:	2280      	movs	r2, #128	; 0x80
 8011528:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 801152c:	2300      	movs	r3, #0
}
 801152e:	4618      	mov	r0, r3
 8011530:	370c      	adds	r7, #12
 8011532:	46bd      	mov	sp, r7
 8011534:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011538:	4770      	bx	lr

0801153a <USB_DevConnect>:
  * @brief  USB_DevConnect Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect(USB_TypeDef *USBx)
{
 801153a:	b480      	push	{r7}
 801153c:	b083      	sub	sp, #12
 801153e:	af00      	add	r7, sp, #0
 8011540:	6078      	str	r0, [r7, #4]
  /* Enabling DP Pull-UP bit to Connect internal PU resistor on USB DP line */
  USBx->BCDR |= (uint16_t)USB_BCDR_DPPU;
 8011542:	687b      	ldr	r3, [r7, #4]
 8011544:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 8011548:	b29b      	uxth	r3, r3
 801154a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801154e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8011552:	b29a      	uxth	r2, r3
 8011554:	687b      	ldr	r3, [r7, #4]
 8011556:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

  return HAL_OK;
 801155a:	2300      	movs	r3, #0
}
 801155c:	4618      	mov	r0, r3
 801155e:	370c      	adds	r7, #12
 8011560:	46bd      	mov	sp, r7
 8011562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011566:	4770      	bx	lr

08011568 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts return the global USB interrupt status
  * @param  USBx Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_TypeDef const *USBx)
{
 8011568:	b480      	push	{r7}
 801156a:	b085      	sub	sp, #20
 801156c:	af00      	add	r7, sp, #0
 801156e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->ISTR;
 8011570:	687b      	ldr	r3, [r7, #4]
 8011572:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8011576:	b29b      	uxth	r3, r3
 8011578:	60fb      	str	r3, [r7, #12]
  return tmpreg;
 801157a:	68fb      	ldr	r3, [r7, #12]
}
 801157c:	4618      	mov	r0, r3
 801157e:	3714      	adds	r7, #20
 8011580:	46bd      	mov	sp, r7
 8011582:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011586:	4770      	bx	lr

08011588 <USB_WritePMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef const *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8011588:	b480      	push	{r7}
 801158a:	b08b      	sub	sp, #44	; 0x2c
 801158c:	af00      	add	r7, sp, #0
 801158e:	60f8      	str	r0, [r7, #12]
 8011590:	60b9      	str	r1, [r7, #8]
 8011592:	4611      	mov	r1, r2
 8011594:	461a      	mov	r2, r3
 8011596:	460b      	mov	r3, r1
 8011598:	80fb      	strh	r3, [r7, #6]
 801159a:	4613      	mov	r3, r2
 801159c:	80bb      	strh	r3, [r7, #4]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 801159e:	88bb      	ldrh	r3, [r7, #4]
 80115a0:	3301      	adds	r3, #1
 80115a2:	085b      	lsrs	r3, r3, #1
 80115a4:	61bb      	str	r3, [r7, #24]
  uint32_t BaseAddr = (uint32_t)USBx;
 80115a6:	68fb      	ldr	r3, [r7, #12]
 80115a8:	617b      	str	r3, [r7, #20]
  uint32_t count;
  uint16_t WrVal;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;
 80115aa:	68bb      	ldr	r3, [r7, #8]
 80115ac:	61fb      	str	r3, [r7, #28]

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80115ae:	88fa      	ldrh	r2, [r7, #6]
 80115b0:	697b      	ldr	r3, [r7, #20]
 80115b2:	4413      	add	r3, r2
 80115b4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80115b8:	623b      	str	r3, [r7, #32]

  for (count = n; count != 0U; count--)
 80115ba:	69bb      	ldr	r3, [r7, #24]
 80115bc:	627b      	str	r3, [r7, #36]	; 0x24
 80115be:	e01b      	b.n	80115f8 <USB_WritePMA+0x70>
  {
    WrVal = pBuf[0];
 80115c0:	69fb      	ldr	r3, [r7, #28]
 80115c2:	781b      	ldrb	r3, [r3, #0]
 80115c4:	827b      	strh	r3, [r7, #18]
    WrVal |= (uint16_t)pBuf[1] << 8;
 80115c6:	69fb      	ldr	r3, [r7, #28]
 80115c8:	3301      	adds	r3, #1
 80115ca:	781b      	ldrb	r3, [r3, #0]
 80115cc:	021b      	lsls	r3, r3, #8
 80115ce:	b21a      	sxth	r2, r3
 80115d0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80115d4:	4313      	orrs	r3, r2
 80115d6:	b21b      	sxth	r3, r3
 80115d8:	827b      	strh	r3, [r7, #18]
    *pdwVal = (WrVal & 0xFFFFU);
 80115da:	6a3b      	ldr	r3, [r7, #32]
 80115dc:	8a7a      	ldrh	r2, [r7, #18]
 80115de:	801a      	strh	r2, [r3, #0]
    pdwVal++;
 80115e0:	6a3b      	ldr	r3, [r7, #32]
 80115e2:	3302      	adds	r3, #2
 80115e4:	623b      	str	r3, [r7, #32]

#if PMA_ACCESS > 1U
    pdwVal++;
#endif /* PMA_ACCESS */

    pBuf++;
 80115e6:	69fb      	ldr	r3, [r7, #28]
 80115e8:	3301      	adds	r3, #1
 80115ea:	61fb      	str	r3, [r7, #28]
    pBuf++;
 80115ec:	69fb      	ldr	r3, [r7, #28]
 80115ee:	3301      	adds	r3, #1
 80115f0:	61fb      	str	r3, [r7, #28]
  for (count = n; count != 0U; count--)
 80115f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80115f4:	3b01      	subs	r3, #1
 80115f6:	627b      	str	r3, [r7, #36]	; 0x24
 80115f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80115fa:	2b00      	cmp	r3, #0
 80115fc:	d1e0      	bne.n	80115c0 <USB_WritePMA+0x38>
  }
}
 80115fe:	bf00      	nop
 8011600:	bf00      	nop
 8011602:	372c      	adds	r7, #44	; 0x2c
 8011604:	46bd      	mov	sp, r7
 8011606:	f85d 7b04 	ldr.w	r7, [sp], #4
 801160a:	4770      	bx	lr

0801160c <USB_ReadPMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef const *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 801160c:	b480      	push	{r7}
 801160e:	b08b      	sub	sp, #44	; 0x2c
 8011610:	af00      	add	r7, sp, #0
 8011612:	60f8      	str	r0, [r7, #12]
 8011614:	60b9      	str	r1, [r7, #8]
 8011616:	4611      	mov	r1, r2
 8011618:	461a      	mov	r2, r3
 801161a:	460b      	mov	r3, r1
 801161c:	80fb      	strh	r3, [r7, #6]
 801161e:	4613      	mov	r3, r2
 8011620:	80bb      	strh	r3, [r7, #4]
  uint32_t n = (uint32_t)wNBytes >> 1;
 8011622:	88bb      	ldrh	r3, [r7, #4]
 8011624:	085b      	lsrs	r3, r3, #1
 8011626:	b29b      	uxth	r3, r3
 8011628:	61bb      	str	r3, [r7, #24]
  uint32_t BaseAddr = (uint32_t)USBx;
 801162a:	68fb      	ldr	r3, [r7, #12]
 801162c:	617b      	str	r3, [r7, #20]
  uint32_t count;
  uint32_t RdVal;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;
 801162e:	68bb      	ldr	r3, [r7, #8]
 8011630:	61fb      	str	r3, [r7, #28]

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8011632:	88fa      	ldrh	r2, [r7, #6]
 8011634:	697b      	ldr	r3, [r7, #20]
 8011636:	4413      	add	r3, r2
 8011638:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801163c:	623b      	str	r3, [r7, #32]

  for (count = n; count != 0U; count--)
 801163e:	69bb      	ldr	r3, [r7, #24]
 8011640:	627b      	str	r3, [r7, #36]	; 0x24
 8011642:	e018      	b.n	8011676 <USB_ReadPMA+0x6a>
  {
    RdVal = *(__IO uint16_t *)pdwVal;
 8011644:	6a3b      	ldr	r3, [r7, #32]
 8011646:	881b      	ldrh	r3, [r3, #0]
 8011648:	b29b      	uxth	r3, r3
 801164a:	613b      	str	r3, [r7, #16]
    pdwVal++;
 801164c:	6a3b      	ldr	r3, [r7, #32]
 801164e:	3302      	adds	r3, #2
 8011650:	623b      	str	r3, [r7, #32]
    *pBuf = (uint8_t)((RdVal >> 0) & 0xFFU);
 8011652:	693b      	ldr	r3, [r7, #16]
 8011654:	b2da      	uxtb	r2, r3
 8011656:	69fb      	ldr	r3, [r7, #28]
 8011658:	701a      	strb	r2, [r3, #0]
    pBuf++;
 801165a:	69fb      	ldr	r3, [r7, #28]
 801165c:	3301      	adds	r3, #1
 801165e:	61fb      	str	r3, [r7, #28]
    *pBuf = (uint8_t)((RdVal >> 8) & 0xFFU);
 8011660:	693b      	ldr	r3, [r7, #16]
 8011662:	0a1b      	lsrs	r3, r3, #8
 8011664:	b2da      	uxtb	r2, r3
 8011666:	69fb      	ldr	r3, [r7, #28]
 8011668:	701a      	strb	r2, [r3, #0]
    pBuf++;
 801166a:	69fb      	ldr	r3, [r7, #28]
 801166c:	3301      	adds	r3, #1
 801166e:	61fb      	str	r3, [r7, #28]
  for (count = n; count != 0U; count--)
 8011670:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011672:	3b01      	subs	r3, #1
 8011674:	627b      	str	r3, [r7, #36]	; 0x24
 8011676:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011678:	2b00      	cmp	r3, #0
 801167a:	d1e3      	bne.n	8011644 <USB_ReadPMA+0x38>
#if PMA_ACCESS > 1U
    pdwVal++;
#endif /* PMA_ACCESS */
  }

  if ((wNBytes % 2U) != 0U)
 801167c:	88bb      	ldrh	r3, [r7, #4]
 801167e:	f003 0301 	and.w	r3, r3, #1
 8011682:	b29b      	uxth	r3, r3
 8011684:	2b00      	cmp	r3, #0
 8011686:	d007      	beq.n	8011698 <USB_ReadPMA+0x8c>
  {
    RdVal = *pdwVal;
 8011688:	6a3b      	ldr	r3, [r7, #32]
 801168a:	881b      	ldrh	r3, [r3, #0]
 801168c:	b29b      	uxth	r3, r3
 801168e:	613b      	str	r3, [r7, #16]
    *pBuf = (uint8_t)((RdVal >> 0) & 0xFFU);
 8011690:	693b      	ldr	r3, [r7, #16]
 8011692:	b2da      	uxtb	r2, r3
 8011694:	69fb      	ldr	r3, [r7, #28]
 8011696:	701a      	strb	r2, [r3, #0]
  }
}
 8011698:	bf00      	nop
 801169a:	372c      	adds	r7, #44	; 0x2c
 801169c:	46bd      	mov	sp, r7
 801169e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116a2:	4770      	bx	lr

080116a4 <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80116a4:	b580      	push	{r7, lr}
 80116a6:	b084      	sub	sp, #16
 80116a8:	af00      	add	r7, sp, #0
 80116aa:	6078      	str	r0, [r7, #4]
 80116ac:	460b      	mov	r3, r1
 80116ae:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 80116b0:	f44f 7007 	mov.w	r0, #540	; 0x21c
 80116b4:	f006 fc62 	bl	8017f7c <malloc>
 80116b8:	4603      	mov	r3, r0
 80116ba:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 80116bc:	68fb      	ldr	r3, [r7, #12]
 80116be:	2b00      	cmp	r3, #0
 80116c0:	d109      	bne.n	80116d6 <USBD_CDC_Init+0x32>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 80116c2:	687b      	ldr	r3, [r7, #4]
 80116c4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80116c8:	687b      	ldr	r3, [r7, #4]
 80116ca:	32b0      	adds	r2, #176	; 0xb0
 80116cc:	2100      	movs	r1, #0
 80116ce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 80116d2:	2302      	movs	r3, #2
 80116d4:	e0d4      	b.n	8011880 <USBD_CDC_Init+0x1dc>
  }

  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 80116d6:	f44f 7207 	mov.w	r2, #540	; 0x21c
 80116da:	2100      	movs	r1, #0
 80116dc:	68f8      	ldr	r0, [r7, #12]
 80116de:	f006 febf 	bl	8018460 <memset>

  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 80116e2:	687b      	ldr	r3, [r7, #4]
 80116e4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80116e8:	687b      	ldr	r3, [r7, #4]
 80116ea:	32b0      	adds	r2, #176	; 0xb0
 80116ec:	68f9      	ldr	r1, [r7, #12]
 80116ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 80116f2:	687b      	ldr	r3, [r7, #4]
 80116f4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80116f8:	687b      	ldr	r3, [r7, #4]
 80116fa:	32b0      	adds	r2, #176	; 0xb0
 80116fc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011700:	687b      	ldr	r3, [r7, #4]
 8011702:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8011706:	687b      	ldr	r3, [r7, #4]
 8011708:	7c1b      	ldrb	r3, [r3, #16]
 801170a:	2b00      	cmp	r3, #0
 801170c:	d138      	bne.n	8011780 <USBD_CDC_Init+0xdc>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 801170e:	4b5e      	ldr	r3, [pc, #376]	; (8011888 <USBD_CDC_Init+0x1e4>)
 8011710:	7819      	ldrb	r1, [r3, #0]
 8011712:	f44f 7300 	mov.w	r3, #512	; 0x200
 8011716:	2202      	movs	r2, #2
 8011718:	6878      	ldr	r0, [r7, #4]
 801171a:	f002 fc58 	bl	8013fce <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 801171e:	4b5a      	ldr	r3, [pc, #360]	; (8011888 <USBD_CDC_Init+0x1e4>)
 8011720:	781b      	ldrb	r3, [r3, #0]
 8011722:	f003 020f 	and.w	r2, r3, #15
 8011726:	6879      	ldr	r1, [r7, #4]
 8011728:	4613      	mov	r3, r2
 801172a:	009b      	lsls	r3, r3, #2
 801172c:	4413      	add	r3, r2
 801172e:	009b      	lsls	r3, r3, #2
 8011730:	440b      	add	r3, r1
 8011732:	3324      	adds	r3, #36	; 0x24
 8011734:	2201      	movs	r2, #1
 8011736:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8011738:	4b54      	ldr	r3, [pc, #336]	; (801188c <USBD_CDC_Init+0x1e8>)
 801173a:	7819      	ldrb	r1, [r3, #0]
 801173c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8011740:	2202      	movs	r2, #2
 8011742:	6878      	ldr	r0, [r7, #4]
 8011744:	f002 fc43 	bl	8013fce <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8011748:	4b50      	ldr	r3, [pc, #320]	; (801188c <USBD_CDC_Init+0x1e8>)
 801174a:	781b      	ldrb	r3, [r3, #0]
 801174c:	f003 020f 	and.w	r2, r3, #15
 8011750:	6879      	ldr	r1, [r7, #4]
 8011752:	4613      	mov	r3, r2
 8011754:	009b      	lsls	r3, r3, #2
 8011756:	4413      	add	r3, r2
 8011758:	009b      	lsls	r3, r3, #2
 801175a:	440b      	add	r3, r1
 801175c:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 8011760:	2201      	movs	r2, #1
 8011762:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 8011764:	4b4a      	ldr	r3, [pc, #296]	; (8011890 <USBD_CDC_Init+0x1ec>)
 8011766:	781b      	ldrb	r3, [r3, #0]
 8011768:	f003 020f 	and.w	r2, r3, #15
 801176c:	6879      	ldr	r1, [r7, #4]
 801176e:	4613      	mov	r3, r2
 8011770:	009b      	lsls	r3, r3, #2
 8011772:	4413      	add	r3, r2
 8011774:	009b      	lsls	r3, r3, #2
 8011776:	440b      	add	r3, r1
 8011778:	3326      	adds	r3, #38	; 0x26
 801177a:	2210      	movs	r2, #16
 801177c:	801a      	strh	r2, [r3, #0]
 801177e:	e035      	b.n	80117ec <USBD_CDC_Init+0x148>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8011780:	4b41      	ldr	r3, [pc, #260]	; (8011888 <USBD_CDC_Init+0x1e4>)
 8011782:	7819      	ldrb	r1, [r3, #0]
 8011784:	2340      	movs	r3, #64	; 0x40
 8011786:	2202      	movs	r2, #2
 8011788:	6878      	ldr	r0, [r7, #4]
 801178a:	f002 fc20 	bl	8013fce <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 801178e:	4b3e      	ldr	r3, [pc, #248]	; (8011888 <USBD_CDC_Init+0x1e4>)
 8011790:	781b      	ldrb	r3, [r3, #0]
 8011792:	f003 020f 	and.w	r2, r3, #15
 8011796:	6879      	ldr	r1, [r7, #4]
 8011798:	4613      	mov	r3, r2
 801179a:	009b      	lsls	r3, r3, #2
 801179c:	4413      	add	r3, r2
 801179e:	009b      	lsls	r3, r3, #2
 80117a0:	440b      	add	r3, r1
 80117a2:	3324      	adds	r3, #36	; 0x24
 80117a4:	2201      	movs	r2, #1
 80117a6:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 80117a8:	4b38      	ldr	r3, [pc, #224]	; (801188c <USBD_CDC_Init+0x1e8>)
 80117aa:	7819      	ldrb	r1, [r3, #0]
 80117ac:	2340      	movs	r3, #64	; 0x40
 80117ae:	2202      	movs	r2, #2
 80117b0:	6878      	ldr	r0, [r7, #4]
 80117b2:	f002 fc0c 	bl	8013fce <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 80117b6:	4b35      	ldr	r3, [pc, #212]	; (801188c <USBD_CDC_Init+0x1e8>)
 80117b8:	781b      	ldrb	r3, [r3, #0]
 80117ba:	f003 020f 	and.w	r2, r3, #15
 80117be:	6879      	ldr	r1, [r7, #4]
 80117c0:	4613      	mov	r3, r2
 80117c2:	009b      	lsls	r3, r3, #2
 80117c4:	4413      	add	r3, r2
 80117c6:	009b      	lsls	r3, r3, #2
 80117c8:	440b      	add	r3, r1
 80117ca:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 80117ce:	2201      	movs	r2, #1
 80117d0:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 80117d2:	4b2f      	ldr	r3, [pc, #188]	; (8011890 <USBD_CDC_Init+0x1ec>)
 80117d4:	781b      	ldrb	r3, [r3, #0]
 80117d6:	f003 020f 	and.w	r2, r3, #15
 80117da:	6879      	ldr	r1, [r7, #4]
 80117dc:	4613      	mov	r3, r2
 80117de:	009b      	lsls	r3, r3, #2
 80117e0:	4413      	add	r3, r2
 80117e2:	009b      	lsls	r3, r3, #2
 80117e4:	440b      	add	r3, r1
 80117e6:	3326      	adds	r3, #38	; 0x26
 80117e8:	2210      	movs	r2, #16
 80117ea:	801a      	strh	r2, [r3, #0]
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 80117ec:	4b28      	ldr	r3, [pc, #160]	; (8011890 <USBD_CDC_Init+0x1ec>)
 80117ee:	7819      	ldrb	r1, [r3, #0]
 80117f0:	2308      	movs	r3, #8
 80117f2:	2203      	movs	r2, #3
 80117f4:	6878      	ldr	r0, [r7, #4]
 80117f6:	f002 fbea 	bl	8013fce <USBD_LL_OpenEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 80117fa:	4b25      	ldr	r3, [pc, #148]	; (8011890 <USBD_CDC_Init+0x1ec>)
 80117fc:	781b      	ldrb	r3, [r3, #0]
 80117fe:	f003 020f 	and.w	r2, r3, #15
 8011802:	6879      	ldr	r1, [r7, #4]
 8011804:	4613      	mov	r3, r2
 8011806:	009b      	lsls	r3, r3, #2
 8011808:	4413      	add	r3, r2
 801180a:	009b      	lsls	r3, r3, #2
 801180c:	440b      	add	r3, r1
 801180e:	3324      	adds	r3, #36	; 0x24
 8011810:	2201      	movs	r2, #1
 8011812:	801a      	strh	r2, [r3, #0]

  hcdc->RxBuffer = NULL;
 8011814:	68fb      	ldr	r3, [r7, #12]
 8011816:	2200      	movs	r2, #0
 8011818:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 801181c:	687b      	ldr	r3, [r7, #4]
 801181e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011822:	687a      	ldr	r2, [r7, #4]
 8011824:	33b0      	adds	r3, #176	; 0xb0
 8011826:	009b      	lsls	r3, r3, #2
 8011828:	4413      	add	r3, r2
 801182a:	685b      	ldr	r3, [r3, #4]
 801182c:	681b      	ldr	r3, [r3, #0]
 801182e:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 8011830:	68fb      	ldr	r3, [r7, #12]
 8011832:	2200      	movs	r2, #0
 8011834:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
  hcdc->RxState = 0U;
 8011838:	68fb      	ldr	r3, [r7, #12]
 801183a:	2200      	movs	r2, #0
 801183c:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218

  if (hcdc->RxBuffer == NULL)
 8011840:	68fb      	ldr	r3, [r7, #12]
 8011842:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8011846:	2b00      	cmp	r3, #0
 8011848:	d101      	bne.n	801184e <USBD_CDC_Init+0x1aa>
  {
    return (uint8_t)USBD_EMEM;
 801184a:	2302      	movs	r3, #2
 801184c:	e018      	b.n	8011880 <USBD_CDC_Init+0x1dc>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801184e:	687b      	ldr	r3, [r7, #4]
 8011850:	7c1b      	ldrb	r3, [r3, #16]
 8011852:	2b00      	cmp	r3, #0
 8011854:	d10a      	bne.n	801186c <USBD_CDC_Init+0x1c8>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8011856:	4b0d      	ldr	r3, [pc, #52]	; (801188c <USBD_CDC_Init+0x1e8>)
 8011858:	7819      	ldrb	r1, [r3, #0]
 801185a:	68fb      	ldr	r3, [r7, #12]
 801185c:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8011860:	f44f 7300 	mov.w	r3, #512	; 0x200
 8011864:	6878      	ldr	r0, [r7, #4]
 8011866:	f002 fc59 	bl	801411c <USBD_LL_PrepareReceive>
 801186a:	e008      	b.n	801187e <USBD_CDC_Init+0x1da>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801186c:	4b07      	ldr	r3, [pc, #28]	; (801188c <USBD_CDC_Init+0x1e8>)
 801186e:	7819      	ldrb	r1, [r3, #0]
 8011870:	68fb      	ldr	r3, [r7, #12]
 8011872:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8011876:	2340      	movs	r3, #64	; 0x40
 8011878:	6878      	ldr	r0, [r7, #4]
 801187a:	f002 fc4f 	bl	801411c <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 801187e:	2300      	movs	r3, #0
}
 8011880:	4618      	mov	r0, r3
 8011882:	3710      	adds	r7, #16
 8011884:	46bd      	mov	sp, r7
 8011886:	bd80      	pop	{r7, pc}
 8011888:	200000ab 	.word	0x200000ab
 801188c:	200000ac 	.word	0x200000ac
 8011890:	200000ad 	.word	0x200000ad

08011894 <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8011894:	b580      	push	{r7, lr}
 8011896:	b082      	sub	sp, #8
 8011898:	af00      	add	r7, sp, #0
 801189a:	6078      	str	r0, [r7, #4]
 801189c:	460b      	mov	r3, r1
 801189e:	70fb      	strb	r3, [r7, #3]
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 80118a0:	4b3a      	ldr	r3, [pc, #232]	; (801198c <USBD_CDC_DeInit+0xf8>)
 80118a2:	781b      	ldrb	r3, [r3, #0]
 80118a4:	4619      	mov	r1, r3
 80118a6:	6878      	ldr	r0, [r7, #4]
 80118a8:	f002 fbab 	bl	8014002 <USBD_LL_CloseEP>
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 80118ac:	4b37      	ldr	r3, [pc, #220]	; (801198c <USBD_CDC_DeInit+0xf8>)
 80118ae:	781b      	ldrb	r3, [r3, #0]
 80118b0:	f003 020f 	and.w	r2, r3, #15
 80118b4:	6879      	ldr	r1, [r7, #4]
 80118b6:	4613      	mov	r3, r2
 80118b8:	009b      	lsls	r3, r3, #2
 80118ba:	4413      	add	r3, r2
 80118bc:	009b      	lsls	r3, r3, #2
 80118be:	440b      	add	r3, r1
 80118c0:	3324      	adds	r3, #36	; 0x24
 80118c2:	2200      	movs	r2, #0
 80118c4:	801a      	strh	r2, [r3, #0]

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 80118c6:	4b32      	ldr	r3, [pc, #200]	; (8011990 <USBD_CDC_DeInit+0xfc>)
 80118c8:	781b      	ldrb	r3, [r3, #0]
 80118ca:	4619      	mov	r1, r3
 80118cc:	6878      	ldr	r0, [r7, #4]
 80118ce:	f002 fb98 	bl	8014002 <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 80118d2:	4b2f      	ldr	r3, [pc, #188]	; (8011990 <USBD_CDC_DeInit+0xfc>)
 80118d4:	781b      	ldrb	r3, [r3, #0]
 80118d6:	f003 020f 	and.w	r2, r3, #15
 80118da:	6879      	ldr	r1, [r7, #4]
 80118dc:	4613      	mov	r3, r2
 80118de:	009b      	lsls	r3, r3, #2
 80118e0:	4413      	add	r3, r2
 80118e2:	009b      	lsls	r3, r3, #2
 80118e4:	440b      	add	r3, r1
 80118e6:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 80118ea:	2200      	movs	r2, #0
 80118ec:	801a      	strh	r2, [r3, #0]

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 80118ee:	4b29      	ldr	r3, [pc, #164]	; (8011994 <USBD_CDC_DeInit+0x100>)
 80118f0:	781b      	ldrb	r3, [r3, #0]
 80118f2:	4619      	mov	r1, r3
 80118f4:	6878      	ldr	r0, [r7, #4]
 80118f6:	f002 fb84 	bl	8014002 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 80118fa:	4b26      	ldr	r3, [pc, #152]	; (8011994 <USBD_CDC_DeInit+0x100>)
 80118fc:	781b      	ldrb	r3, [r3, #0]
 80118fe:	f003 020f 	and.w	r2, r3, #15
 8011902:	6879      	ldr	r1, [r7, #4]
 8011904:	4613      	mov	r3, r2
 8011906:	009b      	lsls	r3, r3, #2
 8011908:	4413      	add	r3, r2
 801190a:	009b      	lsls	r3, r3, #2
 801190c:	440b      	add	r3, r1
 801190e:	3324      	adds	r3, #36	; 0x24
 8011910:	2200      	movs	r2, #0
 8011912:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 8011914:	4b1f      	ldr	r3, [pc, #124]	; (8011994 <USBD_CDC_DeInit+0x100>)
 8011916:	781b      	ldrb	r3, [r3, #0]
 8011918:	f003 020f 	and.w	r2, r3, #15
 801191c:	6879      	ldr	r1, [r7, #4]
 801191e:	4613      	mov	r3, r2
 8011920:	009b      	lsls	r3, r3, #2
 8011922:	4413      	add	r3, r2
 8011924:	009b      	lsls	r3, r3, #2
 8011926:	440b      	add	r3, r1
 8011928:	3326      	adds	r3, #38	; 0x26
 801192a:	2200      	movs	r2, #0
 801192c:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 801192e:	687b      	ldr	r3, [r7, #4]
 8011930:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011934:	687b      	ldr	r3, [r7, #4]
 8011936:	32b0      	adds	r2, #176	; 0xb0
 8011938:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801193c:	2b00      	cmp	r3, #0
 801193e:	d01f      	beq.n	8011980 <USBD_CDC_DeInit+0xec>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8011940:	687b      	ldr	r3, [r7, #4]
 8011942:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011946:	687a      	ldr	r2, [r7, #4]
 8011948:	33b0      	adds	r3, #176	; 0xb0
 801194a:	009b      	lsls	r3, r3, #2
 801194c:	4413      	add	r3, r2
 801194e:	685b      	ldr	r3, [r3, #4]
 8011950:	685b      	ldr	r3, [r3, #4]
 8011952:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8011954:	687b      	ldr	r3, [r7, #4]
 8011956:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 801195a:	687b      	ldr	r3, [r7, #4]
 801195c:	32b0      	adds	r2, #176	; 0xb0
 801195e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011962:	4618      	mov	r0, r3
 8011964:	f006 fb12 	bl	8017f8c <free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8011968:	687b      	ldr	r3, [r7, #4]
 801196a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 801196e:	687b      	ldr	r3, [r7, #4]
 8011970:	32b0      	adds	r2, #176	; 0xb0
 8011972:	2100      	movs	r1, #0
 8011974:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 8011978:	687b      	ldr	r3, [r7, #4]
 801197a:	2200      	movs	r2, #0
 801197c:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
  }

  return (uint8_t)USBD_OK;
 8011980:	2300      	movs	r3, #0
}
 8011982:	4618      	mov	r0, r3
 8011984:	3708      	adds	r7, #8
 8011986:	46bd      	mov	sp, r7
 8011988:	bd80      	pop	{r7, pc}
 801198a:	bf00      	nop
 801198c:	200000ab 	.word	0x200000ab
 8011990:	200000ac 	.word	0x200000ac
 8011994:	200000ad 	.word	0x200000ad

08011998 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 8011998:	b580      	push	{r7, lr}
 801199a:	b086      	sub	sp, #24
 801199c:	af00      	add	r7, sp, #0
 801199e:	6078      	str	r0, [r7, #4]
 80119a0:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 80119a2:	687b      	ldr	r3, [r7, #4]
 80119a4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80119a8:	687b      	ldr	r3, [r7, #4]
 80119aa:	32b0      	adds	r2, #176	; 0xb0
 80119ac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80119b0:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 80119b2:	2300      	movs	r3, #0
 80119b4:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 80119b6:	2300      	movs	r3, #0
 80119b8:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 80119ba:	2300      	movs	r3, #0
 80119bc:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 80119be:	693b      	ldr	r3, [r7, #16]
 80119c0:	2b00      	cmp	r3, #0
 80119c2:	d101      	bne.n	80119c8 <USBD_CDC_Setup+0x30>
  {
    return (uint8_t)USBD_FAIL;
 80119c4:	2303      	movs	r3, #3
 80119c6:	e0bf      	b.n	8011b48 <USBD_CDC_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80119c8:	683b      	ldr	r3, [r7, #0]
 80119ca:	781b      	ldrb	r3, [r3, #0]
 80119cc:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80119d0:	2b00      	cmp	r3, #0
 80119d2:	d050      	beq.n	8011a76 <USBD_CDC_Setup+0xde>
 80119d4:	2b20      	cmp	r3, #32
 80119d6:	f040 80af 	bne.w	8011b38 <USBD_CDC_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 80119da:	683b      	ldr	r3, [r7, #0]
 80119dc:	88db      	ldrh	r3, [r3, #6]
 80119de:	2b00      	cmp	r3, #0
 80119e0:	d03a      	beq.n	8011a58 <USBD_CDC_Setup+0xc0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 80119e2:	683b      	ldr	r3, [r7, #0]
 80119e4:	781b      	ldrb	r3, [r3, #0]
 80119e6:	b25b      	sxtb	r3, r3
 80119e8:	2b00      	cmp	r3, #0
 80119ea:	da1b      	bge.n	8011a24 <USBD_CDC_Setup+0x8c>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 80119ec:	687b      	ldr	r3, [r7, #4]
 80119ee:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 80119f2:	687a      	ldr	r2, [r7, #4]
 80119f4:	33b0      	adds	r3, #176	; 0xb0
 80119f6:	009b      	lsls	r3, r3, #2
 80119f8:	4413      	add	r3, r2
 80119fa:	685b      	ldr	r3, [r3, #4]
 80119fc:	689b      	ldr	r3, [r3, #8]
 80119fe:	683a      	ldr	r2, [r7, #0]
 8011a00:	7850      	ldrb	r0, [r2, #1]
                                                                           (uint8_t *)hcdc->data,
 8011a02:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8011a04:	683a      	ldr	r2, [r7, #0]
 8011a06:	88d2      	ldrh	r2, [r2, #6]
 8011a08:	4798      	blx	r3
                                                                           req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8011a0a:	683b      	ldr	r3, [r7, #0]
 8011a0c:	88db      	ldrh	r3, [r3, #6]
 8011a0e:	2b07      	cmp	r3, #7
 8011a10:	bf28      	it	cs
 8011a12:	2307      	movcs	r3, #7
 8011a14:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 8011a16:	693b      	ldr	r3, [r7, #16]
 8011a18:	89fa      	ldrh	r2, [r7, #14]
 8011a1a:	4619      	mov	r1, r3
 8011a1c:	6878      	ldr	r0, [r7, #4]
 8011a1e:	f001 fcf7 	bl	8013410 <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
                                                                         (uint8_t *)req, 0U);
      }
      break;
 8011a22:	e090      	b.n	8011b46 <USBD_CDC_Setup+0x1ae>
          hcdc->CmdOpCode = req->bRequest;
 8011a24:	683b      	ldr	r3, [r7, #0]
 8011a26:	785a      	ldrb	r2, [r3, #1]
 8011a28:	693b      	ldr	r3, [r7, #16]
 8011a2a:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8011a2e:	683b      	ldr	r3, [r7, #0]
 8011a30:	88db      	ldrh	r3, [r3, #6]
 8011a32:	2b3f      	cmp	r3, #63	; 0x3f
 8011a34:	d803      	bhi.n	8011a3e <USBD_CDC_Setup+0xa6>
 8011a36:	683b      	ldr	r3, [r7, #0]
 8011a38:	88db      	ldrh	r3, [r3, #6]
 8011a3a:	b2da      	uxtb	r2, r3
 8011a3c:	e000      	b.n	8011a40 <USBD_CDC_Setup+0xa8>
 8011a3e:	2240      	movs	r2, #64	; 0x40
 8011a40:	693b      	ldr	r3, [r7, #16]
 8011a42:	f883 2201 	strb.w	r2, [r3, #513]	; 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8011a46:	6939      	ldr	r1, [r7, #16]
 8011a48:	693b      	ldr	r3, [r7, #16]
 8011a4a:	f893 3201 	ldrb.w	r3, [r3, #513]	; 0x201
 8011a4e:	461a      	mov	r2, r3
 8011a50:	6878      	ldr	r0, [r7, #4]
 8011a52:	f001 fd09 	bl	8013468 <USBD_CtlPrepareRx>
      break;
 8011a56:	e076      	b.n	8011b46 <USBD_CDC_Setup+0x1ae>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8011a58:	687b      	ldr	r3, [r7, #4]
 8011a5a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011a5e:	687a      	ldr	r2, [r7, #4]
 8011a60:	33b0      	adds	r3, #176	; 0xb0
 8011a62:	009b      	lsls	r3, r3, #2
 8011a64:	4413      	add	r3, r2
 8011a66:	685b      	ldr	r3, [r3, #4]
 8011a68:	689b      	ldr	r3, [r3, #8]
 8011a6a:	683a      	ldr	r2, [r7, #0]
 8011a6c:	7850      	ldrb	r0, [r2, #1]
 8011a6e:	2200      	movs	r2, #0
 8011a70:	6839      	ldr	r1, [r7, #0]
 8011a72:	4798      	blx	r3
      break;
 8011a74:	e067      	b.n	8011b46 <USBD_CDC_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8011a76:	683b      	ldr	r3, [r7, #0]
 8011a78:	785b      	ldrb	r3, [r3, #1]
 8011a7a:	2b0b      	cmp	r3, #11
 8011a7c:	d851      	bhi.n	8011b22 <USBD_CDC_Setup+0x18a>
 8011a7e:	a201      	add	r2, pc, #4	; (adr r2, 8011a84 <USBD_CDC_Setup+0xec>)
 8011a80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011a84:	08011ab5 	.word	0x08011ab5
 8011a88:	08011b31 	.word	0x08011b31
 8011a8c:	08011b23 	.word	0x08011b23
 8011a90:	08011b23 	.word	0x08011b23
 8011a94:	08011b23 	.word	0x08011b23
 8011a98:	08011b23 	.word	0x08011b23
 8011a9c:	08011b23 	.word	0x08011b23
 8011aa0:	08011b23 	.word	0x08011b23
 8011aa4:	08011b23 	.word	0x08011b23
 8011aa8:	08011b23 	.word	0x08011b23
 8011aac:	08011adf 	.word	0x08011adf
 8011ab0:	08011b09 	.word	0x08011b09
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011ab4:	687b      	ldr	r3, [r7, #4]
 8011ab6:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8011aba:	b2db      	uxtb	r3, r3
 8011abc:	2b03      	cmp	r3, #3
 8011abe:	d107      	bne.n	8011ad0 <USBD_CDC_Setup+0x138>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8011ac0:	f107 030a 	add.w	r3, r7, #10
 8011ac4:	2202      	movs	r2, #2
 8011ac6:	4619      	mov	r1, r3
 8011ac8:	6878      	ldr	r0, [r7, #4]
 8011aca:	f001 fca1 	bl	8013410 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8011ace:	e032      	b.n	8011b36 <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8011ad0:	6839      	ldr	r1, [r7, #0]
 8011ad2:	6878      	ldr	r0, [r7, #4]
 8011ad4:	f001 fc2b 	bl	801332e <USBD_CtlError>
            ret = USBD_FAIL;
 8011ad8:	2303      	movs	r3, #3
 8011ada:	75fb      	strb	r3, [r7, #23]
          break;
 8011adc:	e02b      	b.n	8011b36 <USBD_CDC_Setup+0x19e>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011ade:	687b      	ldr	r3, [r7, #4]
 8011ae0:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8011ae4:	b2db      	uxtb	r3, r3
 8011ae6:	2b03      	cmp	r3, #3
 8011ae8:	d107      	bne.n	8011afa <USBD_CDC_Setup+0x162>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8011aea:	f107 030d 	add.w	r3, r7, #13
 8011aee:	2201      	movs	r2, #1
 8011af0:	4619      	mov	r1, r3
 8011af2:	6878      	ldr	r0, [r7, #4]
 8011af4:	f001 fc8c 	bl	8013410 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8011af8:	e01d      	b.n	8011b36 <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8011afa:	6839      	ldr	r1, [r7, #0]
 8011afc:	6878      	ldr	r0, [r7, #4]
 8011afe:	f001 fc16 	bl	801332e <USBD_CtlError>
            ret = USBD_FAIL;
 8011b02:	2303      	movs	r3, #3
 8011b04:	75fb      	strb	r3, [r7, #23]
          break;
 8011b06:	e016      	b.n	8011b36 <USBD_CDC_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8011b08:	687b      	ldr	r3, [r7, #4]
 8011b0a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8011b0e:	b2db      	uxtb	r3, r3
 8011b10:	2b03      	cmp	r3, #3
 8011b12:	d00f      	beq.n	8011b34 <USBD_CDC_Setup+0x19c>
          {
            USBD_CtlError(pdev, req);
 8011b14:	6839      	ldr	r1, [r7, #0]
 8011b16:	6878      	ldr	r0, [r7, #4]
 8011b18:	f001 fc09 	bl	801332e <USBD_CtlError>
            ret = USBD_FAIL;
 8011b1c:	2303      	movs	r3, #3
 8011b1e:	75fb      	strb	r3, [r7, #23]
          }
          break;
 8011b20:	e008      	b.n	8011b34 <USBD_CDC_Setup+0x19c>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 8011b22:	6839      	ldr	r1, [r7, #0]
 8011b24:	6878      	ldr	r0, [r7, #4]
 8011b26:	f001 fc02 	bl	801332e <USBD_CtlError>
          ret = USBD_FAIL;
 8011b2a:	2303      	movs	r3, #3
 8011b2c:	75fb      	strb	r3, [r7, #23]
          break;
 8011b2e:	e002      	b.n	8011b36 <USBD_CDC_Setup+0x19e>
          break;
 8011b30:	bf00      	nop
 8011b32:	e008      	b.n	8011b46 <USBD_CDC_Setup+0x1ae>
          break;
 8011b34:	bf00      	nop
      }
      break;
 8011b36:	e006      	b.n	8011b46 <USBD_CDC_Setup+0x1ae>

    default:
      USBD_CtlError(pdev, req);
 8011b38:	6839      	ldr	r1, [r7, #0]
 8011b3a:	6878      	ldr	r0, [r7, #4]
 8011b3c:	f001 fbf7 	bl	801332e <USBD_CtlError>
      ret = USBD_FAIL;
 8011b40:	2303      	movs	r3, #3
 8011b42:	75fb      	strb	r3, [r7, #23]
      break;
 8011b44:	bf00      	nop
  }

  return (uint8_t)ret;
 8011b46:	7dfb      	ldrb	r3, [r7, #23]
}
 8011b48:	4618      	mov	r0, r3
 8011b4a:	3718      	adds	r7, #24
 8011b4c:	46bd      	mov	sp, r7
 8011b4e:	bd80      	pop	{r7, pc}

08011b50 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8011b50:	b580      	push	{r7, lr}
 8011b52:	b084      	sub	sp, #16
 8011b54:	af00      	add	r7, sp, #0
 8011b56:	6078      	str	r0, [r7, #4]
 8011b58:	460b      	mov	r3, r1
 8011b5a:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 8011b5c:	687b      	ldr	r3, [r7, #4]
 8011b5e:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 8011b62:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8011b64:	687b      	ldr	r3, [r7, #4]
 8011b66:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011b6a:	687b      	ldr	r3, [r7, #4]
 8011b6c:	32b0      	adds	r2, #176	; 0xb0
 8011b6e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011b72:	2b00      	cmp	r3, #0
 8011b74:	d101      	bne.n	8011b7a <USBD_CDC_DataIn+0x2a>
  {
    return (uint8_t)USBD_FAIL;
 8011b76:	2303      	movs	r3, #3
 8011b78:	e065      	b.n	8011c46 <USBD_CDC_DataIn+0xf6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011b7a:	687b      	ldr	r3, [r7, #4]
 8011b7c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011b80:	687b      	ldr	r3, [r7, #4]
 8011b82:	32b0      	adds	r2, #176	; 0xb0
 8011b84:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011b88:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8011b8a:	78fb      	ldrb	r3, [r7, #3]
 8011b8c:	f003 020f 	and.w	r2, r3, #15
 8011b90:	6879      	ldr	r1, [r7, #4]
 8011b92:	4613      	mov	r3, r2
 8011b94:	009b      	lsls	r3, r3, #2
 8011b96:	4413      	add	r3, r2
 8011b98:	009b      	lsls	r3, r3, #2
 8011b9a:	440b      	add	r3, r1
 8011b9c:	3318      	adds	r3, #24
 8011b9e:	681b      	ldr	r3, [r3, #0]
 8011ba0:	2b00      	cmp	r3, #0
 8011ba2:	d02f      	beq.n	8011c04 <USBD_CDC_DataIn+0xb4>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 8011ba4:	78fb      	ldrb	r3, [r7, #3]
 8011ba6:	f003 020f 	and.w	r2, r3, #15
 8011baa:	6879      	ldr	r1, [r7, #4]
 8011bac:	4613      	mov	r3, r2
 8011bae:	009b      	lsls	r3, r3, #2
 8011bb0:	4413      	add	r3, r2
 8011bb2:	009b      	lsls	r3, r3, #2
 8011bb4:	440b      	add	r3, r1
 8011bb6:	3318      	adds	r3, #24
 8011bb8:	681a      	ldr	r2, [r3, #0]
 8011bba:	78fb      	ldrb	r3, [r7, #3]
 8011bbc:	f003 010f 	and.w	r1, r3, #15
 8011bc0:	68f8      	ldr	r0, [r7, #12]
 8011bc2:	460b      	mov	r3, r1
 8011bc4:	009b      	lsls	r3, r3, #2
 8011bc6:	440b      	add	r3, r1
 8011bc8:	00db      	lsls	r3, r3, #3
 8011bca:	4403      	add	r3, r0
 8011bcc:	3320      	adds	r3, #32
 8011bce:	681b      	ldr	r3, [r3, #0]
 8011bd0:	fbb2 f1f3 	udiv	r1, r2, r3
 8011bd4:	fb01 f303 	mul.w	r3, r1, r3
 8011bd8:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8011bda:	2b00      	cmp	r3, #0
 8011bdc:	d112      	bne.n	8011c04 <USBD_CDC_DataIn+0xb4>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8011bde:	78fb      	ldrb	r3, [r7, #3]
 8011be0:	f003 020f 	and.w	r2, r3, #15
 8011be4:	6879      	ldr	r1, [r7, #4]
 8011be6:	4613      	mov	r3, r2
 8011be8:	009b      	lsls	r3, r3, #2
 8011bea:	4413      	add	r3, r2
 8011bec:	009b      	lsls	r3, r3, #2
 8011bee:	440b      	add	r3, r1
 8011bf0:	3318      	adds	r3, #24
 8011bf2:	2200      	movs	r2, #0
 8011bf4:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8011bf6:	78f9      	ldrb	r1, [r7, #3]
 8011bf8:	2300      	movs	r3, #0
 8011bfa:	2200      	movs	r2, #0
 8011bfc:	6878      	ldr	r0, [r7, #4]
 8011bfe:	f002 fa78 	bl	80140f2 <USBD_LL_Transmit>
 8011c02:	e01f      	b.n	8011c44 <USBD_CDC_DataIn+0xf4>
  }
  else
  {
    hcdc->TxState = 0U;
 8011c04:	68bb      	ldr	r3, [r7, #8]
 8011c06:	2200      	movs	r2, #0
 8011c08:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8011c0c:	687b      	ldr	r3, [r7, #4]
 8011c0e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011c12:	687a      	ldr	r2, [r7, #4]
 8011c14:	33b0      	adds	r3, #176	; 0xb0
 8011c16:	009b      	lsls	r3, r3, #2
 8011c18:	4413      	add	r3, r2
 8011c1a:	685b      	ldr	r3, [r3, #4]
 8011c1c:	691b      	ldr	r3, [r3, #16]
 8011c1e:	2b00      	cmp	r3, #0
 8011c20:	d010      	beq.n	8011c44 <USBD_CDC_DataIn+0xf4>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8011c22:	687b      	ldr	r3, [r7, #4]
 8011c24:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011c28:	687a      	ldr	r2, [r7, #4]
 8011c2a:	33b0      	adds	r3, #176	; 0xb0
 8011c2c:	009b      	lsls	r3, r3, #2
 8011c2e:	4413      	add	r3, r2
 8011c30:	685b      	ldr	r3, [r3, #4]
 8011c32:	691b      	ldr	r3, [r3, #16]
 8011c34:	68ba      	ldr	r2, [r7, #8]
 8011c36:	f8d2 0208 	ldr.w	r0, [r2, #520]	; 0x208
 8011c3a:	68ba      	ldr	r2, [r7, #8]
 8011c3c:	f502 7104 	add.w	r1, r2, #528	; 0x210
 8011c40:	78fa      	ldrb	r2, [r7, #3]
 8011c42:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 8011c44:	2300      	movs	r3, #0
}
 8011c46:	4618      	mov	r0, r3
 8011c48:	3710      	adds	r7, #16
 8011c4a:	46bd      	mov	sp, r7
 8011c4c:	bd80      	pop	{r7, pc}

08011c4e <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8011c4e:	b580      	push	{r7, lr}
 8011c50:	b084      	sub	sp, #16
 8011c52:	af00      	add	r7, sp, #0
 8011c54:	6078      	str	r0, [r7, #4]
 8011c56:	460b      	mov	r3, r1
 8011c58:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011c5a:	687b      	ldr	r3, [r7, #4]
 8011c5c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011c60:	687b      	ldr	r3, [r7, #4]
 8011c62:	32b0      	adds	r2, #176	; 0xb0
 8011c64:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011c68:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8011c6a:	687b      	ldr	r3, [r7, #4]
 8011c6c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011c70:	687b      	ldr	r3, [r7, #4]
 8011c72:	32b0      	adds	r2, #176	; 0xb0
 8011c74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011c78:	2b00      	cmp	r3, #0
 8011c7a:	d101      	bne.n	8011c80 <USBD_CDC_DataOut+0x32>
  {
    return (uint8_t)USBD_FAIL;
 8011c7c:	2303      	movs	r3, #3
 8011c7e:	e01a      	b.n	8011cb6 <USBD_CDC_DataOut+0x68>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8011c80:	78fb      	ldrb	r3, [r7, #3]
 8011c82:	4619      	mov	r1, r3
 8011c84:	6878      	ldr	r0, [r7, #4]
 8011c86:	f002 fa5e 	bl	8014146 <USBD_LL_GetRxDataSize>
 8011c8a:	4602      	mov	r2, r0
 8011c8c:	68fb      	ldr	r3, [r7, #12]
 8011c8e:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8011c92:	687b      	ldr	r3, [r7, #4]
 8011c94:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011c98:	687a      	ldr	r2, [r7, #4]
 8011c9a:	33b0      	adds	r3, #176	; 0xb0
 8011c9c:	009b      	lsls	r3, r3, #2
 8011c9e:	4413      	add	r3, r2
 8011ca0:	685b      	ldr	r3, [r3, #4]
 8011ca2:	68db      	ldr	r3, [r3, #12]
 8011ca4:	68fa      	ldr	r2, [r7, #12]
 8011ca6:	f8d2 0204 	ldr.w	r0, [r2, #516]	; 0x204
 8011caa:	68fa      	ldr	r2, [r7, #12]
 8011cac:	f502 7203 	add.w	r2, r2, #524	; 0x20c
 8011cb0:	4611      	mov	r1, r2
 8011cb2:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 8011cb4:	2300      	movs	r3, #0
}
 8011cb6:	4618      	mov	r0, r3
 8011cb8:	3710      	adds	r7, #16
 8011cba:	46bd      	mov	sp, r7
 8011cbc:	bd80      	pop	{r7, pc}

08011cbe <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8011cbe:	b580      	push	{r7, lr}
 8011cc0:	b084      	sub	sp, #16
 8011cc2:	af00      	add	r7, sp, #0
 8011cc4:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011cc6:	687b      	ldr	r3, [r7, #4]
 8011cc8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011ccc:	687b      	ldr	r3, [r7, #4]
 8011cce:	32b0      	adds	r2, #176	; 0xb0
 8011cd0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011cd4:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8011cd6:	68fb      	ldr	r3, [r7, #12]
 8011cd8:	2b00      	cmp	r3, #0
 8011cda:	d101      	bne.n	8011ce0 <USBD_CDC_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8011cdc:	2303      	movs	r3, #3
 8011cde:	e025      	b.n	8011d2c <USBD_CDC_EP0_RxReady+0x6e>
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011ce6:	687a      	ldr	r2, [r7, #4]
 8011ce8:	33b0      	adds	r3, #176	; 0xb0
 8011cea:	009b      	lsls	r3, r3, #2
 8011cec:	4413      	add	r3, r2
 8011cee:	685b      	ldr	r3, [r3, #4]
 8011cf0:	2b00      	cmp	r3, #0
 8011cf2:	d01a      	beq.n	8011d2a <USBD_CDC_EP0_RxReady+0x6c>
 8011cf4:	68fb      	ldr	r3, [r7, #12]
 8011cf6:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8011cfa:	2bff      	cmp	r3, #255	; 0xff
 8011cfc:	d015      	beq.n	8011d2a <USBD_CDC_EP0_RxReady+0x6c>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8011cfe:	687b      	ldr	r3, [r7, #4]
 8011d00:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011d04:	687a      	ldr	r2, [r7, #4]
 8011d06:	33b0      	adds	r3, #176	; 0xb0
 8011d08:	009b      	lsls	r3, r3, #2
 8011d0a:	4413      	add	r3, r2
 8011d0c:	685b      	ldr	r3, [r3, #4]
 8011d0e:	689b      	ldr	r3, [r3, #8]
 8011d10:	68fa      	ldr	r2, [r7, #12]
 8011d12:	f892 0200 	ldrb.w	r0, [r2, #512]	; 0x200
                                                                     (uint8_t *)hcdc->data,
 8011d16:	68f9      	ldr	r1, [r7, #12]
                                                                     (uint16_t)hcdc->CmdLength);
 8011d18:	68fa      	ldr	r2, [r7, #12]
 8011d1a:	f892 2201 	ldrb.w	r2, [r2, #513]	; 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8011d1e:	b292      	uxth	r2, r2
 8011d20:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8011d22:	68fb      	ldr	r3, [r7, #12]
 8011d24:	22ff      	movs	r2, #255	; 0xff
 8011d26:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
  }

  return (uint8_t)USBD_OK;
 8011d2a:	2300      	movs	r3, #0
}
 8011d2c:	4618      	mov	r0, r3
 8011d2e:	3710      	adds	r7, #16
 8011d30:	46bd      	mov	sp, r7
 8011d32:	bd80      	pop	{r7, pc}

08011d34 <USBD_CDC_GetFSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8011d34:	b580      	push	{r7, lr}
 8011d36:	b086      	sub	sp, #24
 8011d38:	af00      	add	r7, sp, #0
 8011d3a:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8011d3c:	2182      	movs	r1, #130	; 0x82
 8011d3e:	4818      	ldr	r0, [pc, #96]	; (8011da0 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8011d40:	f000 fcbd 	bl	80126be <USBD_GetEpDesc>
 8011d44:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8011d46:	2101      	movs	r1, #1
 8011d48:	4815      	ldr	r0, [pc, #84]	; (8011da0 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8011d4a:	f000 fcb8 	bl	80126be <USBD_GetEpDesc>
 8011d4e:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8011d50:	2181      	movs	r1, #129	; 0x81
 8011d52:	4813      	ldr	r0, [pc, #76]	; (8011da0 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8011d54:	f000 fcb3 	bl	80126be <USBD_GetEpDesc>
 8011d58:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8011d5a:	697b      	ldr	r3, [r7, #20]
 8011d5c:	2b00      	cmp	r3, #0
 8011d5e:	d002      	beq.n	8011d66 <USBD_CDC_GetFSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8011d60:	697b      	ldr	r3, [r7, #20]
 8011d62:	2210      	movs	r2, #16
 8011d64:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8011d66:	693b      	ldr	r3, [r7, #16]
 8011d68:	2b00      	cmp	r3, #0
 8011d6a:	d006      	beq.n	8011d7a <USBD_CDC_GetFSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8011d6c:	693b      	ldr	r3, [r7, #16]
 8011d6e:	2200      	movs	r2, #0
 8011d70:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8011d74:	711a      	strb	r2, [r3, #4]
 8011d76:	2200      	movs	r2, #0
 8011d78:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8011d7a:	68fb      	ldr	r3, [r7, #12]
 8011d7c:	2b00      	cmp	r3, #0
 8011d7e:	d006      	beq.n	8011d8e <USBD_CDC_GetFSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8011d80:	68fb      	ldr	r3, [r7, #12]
 8011d82:	2200      	movs	r2, #0
 8011d84:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8011d88:	711a      	strb	r2, [r3, #4]
 8011d8a:	2200      	movs	r2, #0
 8011d8c:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8011d8e:	687b      	ldr	r3, [r7, #4]
 8011d90:	2243      	movs	r2, #67	; 0x43
 8011d92:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8011d94:	4b02      	ldr	r3, [pc, #8]	; (8011da0 <USBD_CDC_GetFSCfgDesc+0x6c>)
}
 8011d96:	4618      	mov	r0, r3
 8011d98:	3718      	adds	r7, #24
 8011d9a:	46bd      	mov	sp, r7
 8011d9c:	bd80      	pop	{r7, pc}
 8011d9e:	bf00      	nop
 8011da0:	20000068 	.word	0x20000068

08011da4 <USBD_CDC_GetHSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8011da4:	b580      	push	{r7, lr}
 8011da6:	b086      	sub	sp, #24
 8011da8:	af00      	add	r7, sp, #0
 8011daa:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8011dac:	2182      	movs	r1, #130	; 0x82
 8011dae:	4818      	ldr	r0, [pc, #96]	; (8011e10 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8011db0:	f000 fc85 	bl	80126be <USBD_GetEpDesc>
 8011db4:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8011db6:	2101      	movs	r1, #1
 8011db8:	4815      	ldr	r0, [pc, #84]	; (8011e10 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8011dba:	f000 fc80 	bl	80126be <USBD_GetEpDesc>
 8011dbe:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8011dc0:	2181      	movs	r1, #129	; 0x81
 8011dc2:	4813      	ldr	r0, [pc, #76]	; (8011e10 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8011dc4:	f000 fc7b 	bl	80126be <USBD_GetEpDesc>
 8011dc8:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8011dca:	697b      	ldr	r3, [r7, #20]
 8011dcc:	2b00      	cmp	r3, #0
 8011dce:	d002      	beq.n	8011dd6 <USBD_CDC_GetHSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8011dd0:	697b      	ldr	r3, [r7, #20]
 8011dd2:	2210      	movs	r2, #16
 8011dd4:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8011dd6:	693b      	ldr	r3, [r7, #16]
 8011dd8:	2b00      	cmp	r3, #0
 8011dda:	d006      	beq.n	8011dea <USBD_CDC_GetHSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8011ddc:	693b      	ldr	r3, [r7, #16]
 8011dde:	2200      	movs	r2, #0
 8011de0:	711a      	strb	r2, [r3, #4]
 8011de2:	2200      	movs	r2, #0
 8011de4:	f042 0202 	orr.w	r2, r2, #2
 8011de8:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8011dea:	68fb      	ldr	r3, [r7, #12]
 8011dec:	2b00      	cmp	r3, #0
 8011dee:	d006      	beq.n	8011dfe <USBD_CDC_GetHSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8011df0:	68fb      	ldr	r3, [r7, #12]
 8011df2:	2200      	movs	r2, #0
 8011df4:	711a      	strb	r2, [r3, #4]
 8011df6:	2200      	movs	r2, #0
 8011df8:	f042 0202 	orr.w	r2, r2, #2
 8011dfc:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8011dfe:	687b      	ldr	r3, [r7, #4]
 8011e00:	2243      	movs	r2, #67	; 0x43
 8011e02:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8011e04:	4b02      	ldr	r3, [pc, #8]	; (8011e10 <USBD_CDC_GetHSCfgDesc+0x6c>)
}
 8011e06:	4618      	mov	r0, r3
 8011e08:	3718      	adds	r7, #24
 8011e0a:	46bd      	mov	sp, r7
 8011e0c:	bd80      	pop	{r7, pc}
 8011e0e:	bf00      	nop
 8011e10:	20000068 	.word	0x20000068

08011e14 <USBD_CDC_GetOtherSpeedCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 8011e14:	b580      	push	{r7, lr}
 8011e16:	b086      	sub	sp, #24
 8011e18:	af00      	add	r7, sp, #0
 8011e1a:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8011e1c:	2182      	movs	r1, #130	; 0x82
 8011e1e:	4818      	ldr	r0, [pc, #96]	; (8011e80 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8011e20:	f000 fc4d 	bl	80126be <USBD_GetEpDesc>
 8011e24:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8011e26:	2101      	movs	r1, #1
 8011e28:	4815      	ldr	r0, [pc, #84]	; (8011e80 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8011e2a:	f000 fc48 	bl	80126be <USBD_GetEpDesc>
 8011e2e:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8011e30:	2181      	movs	r1, #129	; 0x81
 8011e32:	4813      	ldr	r0, [pc, #76]	; (8011e80 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8011e34:	f000 fc43 	bl	80126be <USBD_GetEpDesc>
 8011e38:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8011e3a:	697b      	ldr	r3, [r7, #20]
 8011e3c:	2b00      	cmp	r3, #0
 8011e3e:	d002      	beq.n	8011e46 <USBD_CDC_GetOtherSpeedCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8011e40:	697b      	ldr	r3, [r7, #20]
 8011e42:	2210      	movs	r2, #16
 8011e44:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8011e46:	693b      	ldr	r3, [r7, #16]
 8011e48:	2b00      	cmp	r3, #0
 8011e4a:	d006      	beq.n	8011e5a <USBD_CDC_GetOtherSpeedCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8011e4c:	693b      	ldr	r3, [r7, #16]
 8011e4e:	2200      	movs	r2, #0
 8011e50:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8011e54:	711a      	strb	r2, [r3, #4]
 8011e56:	2200      	movs	r2, #0
 8011e58:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8011e5a:	68fb      	ldr	r3, [r7, #12]
 8011e5c:	2b00      	cmp	r3, #0
 8011e5e:	d006      	beq.n	8011e6e <USBD_CDC_GetOtherSpeedCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8011e60:	68fb      	ldr	r3, [r7, #12]
 8011e62:	2200      	movs	r2, #0
 8011e64:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8011e68:	711a      	strb	r2, [r3, #4]
 8011e6a:	2200      	movs	r2, #0
 8011e6c:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8011e6e:	687b      	ldr	r3, [r7, #4]
 8011e70:	2243      	movs	r2, #67	; 0x43
 8011e72:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8011e74:	4b02      	ldr	r3, [pc, #8]	; (8011e80 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
}
 8011e76:	4618      	mov	r0, r3
 8011e78:	3718      	adds	r7, #24
 8011e7a:	46bd      	mov	sp, r7
 8011e7c:	bd80      	pop	{r7, pc}
 8011e7e:	bf00      	nop
 8011e80:	20000068 	.word	0x20000068

08011e84 <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 8011e84:	b480      	push	{r7}
 8011e86:	b083      	sub	sp, #12
 8011e88:	af00      	add	r7, sp, #0
 8011e8a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 8011e8c:	687b      	ldr	r3, [r7, #4]
 8011e8e:	220a      	movs	r2, #10
 8011e90:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 8011e92:	4b03      	ldr	r3, [pc, #12]	; (8011ea0 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 8011e94:	4618      	mov	r0, r3
 8011e96:	370c      	adds	r7, #12
 8011e98:	46bd      	mov	sp, r7
 8011e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e9e:	4770      	bx	lr
 8011ea0:	20000024 	.word	0x20000024

08011ea4 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 8011ea4:	b480      	push	{r7}
 8011ea6:	b083      	sub	sp, #12
 8011ea8:	af00      	add	r7, sp, #0
 8011eaa:	6078      	str	r0, [r7, #4]
 8011eac:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 8011eae:	683b      	ldr	r3, [r7, #0]
 8011eb0:	2b00      	cmp	r3, #0
 8011eb2:	d101      	bne.n	8011eb8 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 8011eb4:	2303      	movs	r3, #3
 8011eb6:	e009      	b.n	8011ecc <USBD_CDC_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 8011eb8:	687b      	ldr	r3, [r7, #4]
 8011eba:	f8d3 32d4 	ldr.w	r3, [r3, #724]	; 0x2d4
 8011ebe:	687a      	ldr	r2, [r7, #4]
 8011ec0:	33b0      	adds	r3, #176	; 0xb0
 8011ec2:	009b      	lsls	r3, r3, #2
 8011ec4:	4413      	add	r3, r2
 8011ec6:	683a      	ldr	r2, [r7, #0]
 8011ec8:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 8011eca:	2300      	movs	r3, #0
}
 8011ecc:	4618      	mov	r0, r3
 8011ece:	370c      	adds	r7, #12
 8011ed0:	46bd      	mov	sp, r7
 8011ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ed6:	4770      	bx	lr

08011ed8 <USBD_CDC_SetTxBuffer>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 8011ed8:	b480      	push	{r7}
 8011eda:	b087      	sub	sp, #28
 8011edc:	af00      	add	r7, sp, #0
 8011ede:	60f8      	str	r0, [r7, #12]
 8011ee0:	60b9      	str	r1, [r7, #8]
 8011ee2:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011ee4:	68fb      	ldr	r3, [r7, #12]
 8011ee6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011eea:	68fb      	ldr	r3, [r7, #12]
 8011eec:	32b0      	adds	r2, #176	; 0xb0
 8011eee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011ef2:	617b      	str	r3, [r7, #20]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 8011ef4:	697b      	ldr	r3, [r7, #20]
 8011ef6:	2b00      	cmp	r3, #0
 8011ef8:	d101      	bne.n	8011efe <USBD_CDC_SetTxBuffer+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8011efa:	2303      	movs	r3, #3
 8011efc:	e008      	b.n	8011f10 <USBD_CDC_SetTxBuffer+0x38>
  }

  hcdc->TxBuffer = pbuff;
 8011efe:	697b      	ldr	r3, [r7, #20]
 8011f00:	68ba      	ldr	r2, [r7, #8]
 8011f02:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 8011f06:	697b      	ldr	r3, [r7, #20]
 8011f08:	687a      	ldr	r2, [r7, #4]
 8011f0a:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

  return (uint8_t)USBD_OK;
 8011f0e:	2300      	movs	r3, #0
}
 8011f10:	4618      	mov	r0, r3
 8011f12:	371c      	adds	r7, #28
 8011f14:	46bd      	mov	sp, r7
 8011f16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f1a:	4770      	bx	lr

08011f1c <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 8011f1c:	b480      	push	{r7}
 8011f1e:	b085      	sub	sp, #20
 8011f20:	af00      	add	r7, sp, #0
 8011f22:	6078      	str	r0, [r7, #4]
 8011f24:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011f26:	687b      	ldr	r3, [r7, #4]
 8011f28:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011f2c:	687b      	ldr	r3, [r7, #4]
 8011f2e:	32b0      	adds	r2, #176	; 0xb0
 8011f30:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011f34:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8011f36:	68fb      	ldr	r3, [r7, #12]
 8011f38:	2b00      	cmp	r3, #0
 8011f3a:	d101      	bne.n	8011f40 <USBD_CDC_SetRxBuffer+0x24>
  {
    return (uint8_t)USBD_FAIL;
 8011f3c:	2303      	movs	r3, #3
 8011f3e:	e004      	b.n	8011f4a <USBD_CDC_SetRxBuffer+0x2e>
  }

  hcdc->RxBuffer = pbuff;
 8011f40:	68fb      	ldr	r3, [r7, #12]
 8011f42:	683a      	ldr	r2, [r7, #0]
 8011f44:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

  return (uint8_t)USBD_OK;
 8011f48:	2300      	movs	r3, #0
}
 8011f4a:	4618      	mov	r0, r3
 8011f4c:	3714      	adds	r7, #20
 8011f4e:	46bd      	mov	sp, r7
 8011f50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f54:	4770      	bx	lr
	...

08011f58 <USBD_CDC_TransmitPacket>:
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev, uint8_t ClassId)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
 8011f58:	b580      	push	{r7, lr}
 8011f5a:	b084      	sub	sp, #16
 8011f5c:	af00      	add	r7, sp, #0
 8011f5e:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011f60:	687b      	ldr	r3, [r7, #4]
 8011f62:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011f66:	687b      	ldr	r3, [r7, #4]
 8011f68:	32b0      	adds	r2, #176	; 0xb0
 8011f6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011f6e:	60bb      	str	r3, [r7, #8]
#endif  /* USE_USBD_COMPOSITE */

  USBD_StatusTypeDef ret = USBD_BUSY;
 8011f70:	2301      	movs	r3, #1
 8011f72:	73fb      	strb	r3, [r7, #15]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, ClassId);
#endif  /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 8011f74:	68bb      	ldr	r3, [r7, #8]
 8011f76:	2b00      	cmp	r3, #0
 8011f78:	d101      	bne.n	8011f7e <USBD_CDC_TransmitPacket+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8011f7a:	2303      	movs	r3, #3
 8011f7c:	e025      	b.n	8011fca <USBD_CDC_TransmitPacket+0x72>
  }

  if (hcdc->TxState == 0U)
 8011f7e:	68bb      	ldr	r3, [r7, #8]
 8011f80:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8011f84:	2b00      	cmp	r3, #0
 8011f86:	d11f      	bne.n	8011fc8 <USBD_CDC_TransmitPacket+0x70>
  {
    /* Tx Transfer in progress */
    hcdc->TxState = 1U;
 8011f88:	68bb      	ldr	r3, [r7, #8]
 8011f8a:	2201      	movs	r2, #1
 8011f8c:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214

    /* Update the packet total length */
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 8011f90:	4b10      	ldr	r3, [pc, #64]	; (8011fd4 <USBD_CDC_TransmitPacket+0x7c>)
 8011f92:	781b      	ldrb	r3, [r3, #0]
 8011f94:	f003 020f 	and.w	r2, r3, #15
 8011f98:	68bb      	ldr	r3, [r7, #8]
 8011f9a:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
 8011f9e:	6878      	ldr	r0, [r7, #4]
 8011fa0:	4613      	mov	r3, r2
 8011fa2:	009b      	lsls	r3, r3, #2
 8011fa4:	4413      	add	r3, r2
 8011fa6:	009b      	lsls	r3, r3, #2
 8011fa8:	4403      	add	r3, r0
 8011faa:	3318      	adds	r3, #24
 8011fac:	6019      	str	r1, [r3, #0]

    /* Transmit next packet */
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8011fae:	4b09      	ldr	r3, [pc, #36]	; (8011fd4 <USBD_CDC_TransmitPacket+0x7c>)
 8011fb0:	7819      	ldrb	r1, [r3, #0]
 8011fb2:	68bb      	ldr	r3, [r7, #8]
 8011fb4:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 8011fb8:	68bb      	ldr	r3, [r7, #8]
 8011fba:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8011fbe:	6878      	ldr	r0, [r7, #4]
 8011fc0:	f002 f897 	bl	80140f2 <USBD_LL_Transmit>

    ret = USBD_OK;
 8011fc4:	2300      	movs	r3, #0
 8011fc6:	73fb      	strb	r3, [r7, #15]
  }

  return (uint8_t)ret;
 8011fc8:	7bfb      	ldrb	r3, [r7, #15]
}
 8011fca:	4618      	mov	r0, r3
 8011fcc:	3710      	adds	r7, #16
 8011fce:	46bd      	mov	sp, r7
 8011fd0:	bd80      	pop	{r7, pc}
 8011fd2:	bf00      	nop
 8011fd4:	200000ab 	.word	0x200000ab

08011fd8 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 8011fd8:	b580      	push	{r7, lr}
 8011fda:	b084      	sub	sp, #16
 8011fdc:	af00      	add	r7, sp, #0
 8011fde:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8011fe0:	687b      	ldr	r3, [r7, #4]
 8011fe2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011fe6:	687b      	ldr	r3, [r7, #4]
 8011fe8:	32b0      	adds	r2, #176	; 0xb0
 8011fea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011fee:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8011ff0:	687b      	ldr	r3, [r7, #4]
 8011ff2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 8011ff6:	687b      	ldr	r3, [r7, #4]
 8011ff8:	32b0      	adds	r2, #176	; 0xb0
 8011ffa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011ffe:	2b00      	cmp	r3, #0
 8012000:	d101      	bne.n	8012006 <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
 8012002:	2303      	movs	r3, #3
 8012004:	e018      	b.n	8012038 <USBD_CDC_ReceivePacket+0x60>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012006:	687b      	ldr	r3, [r7, #4]
 8012008:	7c1b      	ldrb	r3, [r3, #16]
 801200a:	2b00      	cmp	r3, #0
 801200c:	d10a      	bne.n	8012024 <USBD_CDC_ReceivePacket+0x4c>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801200e:	4b0c      	ldr	r3, [pc, #48]	; (8012040 <USBD_CDC_ReceivePacket+0x68>)
 8012010:	7819      	ldrb	r1, [r3, #0]
 8012012:	68fb      	ldr	r3, [r7, #12]
 8012014:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8012018:	f44f 7300 	mov.w	r3, #512	; 0x200
 801201c:	6878      	ldr	r0, [r7, #4]
 801201e:	f002 f87d 	bl	801411c <USBD_LL_PrepareReceive>
 8012022:	e008      	b.n	8012036 <USBD_CDC_ReceivePacket+0x5e>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8012024:	4b06      	ldr	r3, [pc, #24]	; (8012040 <USBD_CDC_ReceivePacket+0x68>)
 8012026:	7819      	ldrb	r1, [r3, #0]
 8012028:	68fb      	ldr	r3, [r7, #12]
 801202a:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 801202e:	2340      	movs	r3, #64	; 0x40
 8012030:	6878      	ldr	r0, [r7, #4]
 8012032:	f002 f873 	bl	801411c <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8012036:	2300      	movs	r3, #0
}
 8012038:	4618      	mov	r0, r3
 801203a:	3710      	adds	r7, #16
 801203c:	46bd      	mov	sp, r7
 801203e:	bd80      	pop	{r7, pc}
 8012040:	200000ac 	.word	0x200000ac

08012044 <USBD_Init>:
  * @param  id: Low level core index
  * @retval None
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8012044:	b580      	push	{r7, lr}
 8012046:	b086      	sub	sp, #24
 8012048:	af00      	add	r7, sp, #0
 801204a:	60f8      	str	r0, [r7, #12]
 801204c:	60b9      	str	r1, [r7, #8]
 801204e:	4613      	mov	r3, r2
 8012050:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 8012052:	68fb      	ldr	r3, [r7, #12]
 8012054:	2b00      	cmp	r3, #0
 8012056:	d101      	bne.n	801205c <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8012058:	2303      	movs	r3, #3
 801205a:	e01f      	b.n	801209c <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 801205c:	68fb      	ldr	r3, [r7, #12]
 801205e:	2200      	movs	r2, #0
 8012060:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  pdev->pUserData[0] = NULL;
 8012064:	68fb      	ldr	r3, [r7, #12]
 8012066:	2200      	movs	r2, #0
 8012068:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 801206c:	68fb      	ldr	r3, [r7, #12]
 801206e:	2200      	movs	r2, #0
 8012070:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 8012074:	68bb      	ldr	r3, [r7, #8]
 8012076:	2b00      	cmp	r3, #0
 8012078:	d003      	beq.n	8012082 <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 801207a:	68fb      	ldr	r3, [r7, #12]
 801207c:	68ba      	ldr	r2, [r7, #8]
 801207e:	f8c3 22b4 	str.w	r2, [r3, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8012082:	68fb      	ldr	r3, [r7, #12]
 8012084:	2201      	movs	r2, #1
 8012086:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->id = id;
 801208a:	68fb      	ldr	r3, [r7, #12]
 801208c:	79fa      	ldrb	r2, [r7, #7]
 801208e:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8012090:	68f8      	ldr	r0, [r7, #12]
 8012092:	f001 ff49 	bl	8013f28 <USBD_LL_Init>
 8012096:	4603      	mov	r3, r0
 8012098:	75fb      	strb	r3, [r7, #23]

  return ret;
 801209a:	7dfb      	ldrb	r3, [r7, #23]
}
 801209c:	4618      	mov	r0, r3
 801209e:	3718      	adds	r7, #24
 80120a0:	46bd      	mov	sp, r7
 80120a2:	bd80      	pop	{r7, pc}

080120a4 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 80120a4:	b580      	push	{r7, lr}
 80120a6:	b084      	sub	sp, #16
 80120a8:	af00      	add	r7, sp, #0
 80120aa:	6078      	str	r0, [r7, #4]
 80120ac:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 80120ae:	2300      	movs	r3, #0
 80120b0:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 80120b2:	683b      	ldr	r3, [r7, #0]
 80120b4:	2b00      	cmp	r3, #0
 80120b6:	d101      	bne.n	80120bc <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 80120b8:	2303      	movs	r3, #3
 80120ba:	e025      	b.n	8012108 <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 80120bc:	687b      	ldr	r3, [r7, #4]
 80120be:	683a      	ldr	r2, [r7, #0]
 80120c0:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 80120c4:	687b      	ldr	r3, [r7, #4]
 80120c6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80120ca:	687b      	ldr	r3, [r7, #4]
 80120cc:	32ae      	adds	r2, #174	; 0xae
 80120ce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80120d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80120d4:	2b00      	cmp	r3, #0
 80120d6:	d00f      	beq.n	80120f8 <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 80120d8:	687b      	ldr	r3, [r7, #4]
 80120da:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80120de:	687b      	ldr	r3, [r7, #4]
 80120e0:	32ae      	adds	r2, #174	; 0xae
 80120e2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80120e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80120e8:	f107 020e 	add.w	r2, r7, #14
 80120ec:	4610      	mov	r0, r2
 80120ee:	4798      	blx	r3
 80120f0:	4602      	mov	r2, r0
 80120f2:	687b      	ldr	r3, [r7, #4]
 80120f4:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses ++;
 80120f8:	687b      	ldr	r3, [r7, #4]
 80120fa:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 80120fe:	1c5a      	adds	r2, r3, #1
 8012100:	687b      	ldr	r3, [r7, #4]
 8012102:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8

  return USBD_OK;
 8012106:	2300      	movs	r3, #0
}
 8012108:	4618      	mov	r0, r3
 801210a:	3710      	adds	r7, #16
 801210c:	46bd      	mov	sp, r7
 801210e:	bd80      	pop	{r7, pc}

08012110 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 8012110:	b580      	push	{r7, lr}
 8012112:	b082      	sub	sp, #8
 8012114:	af00      	add	r7, sp, #0
 8012116:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8012118:	6878      	ldr	r0, [r7, #4]
 801211a:	f001 ff49 	bl	8013fb0 <USBD_LL_Start>
 801211e:	4603      	mov	r3, r0
}
 8012120:	4618      	mov	r0, r3
 8012122:	3708      	adds	r7, #8
 8012124:	46bd      	mov	sp, r7
 8012126:	bd80      	pop	{r7, pc}

08012128 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 8012128:	b480      	push	{r7}
 801212a:	b083      	sub	sp, #12
 801212c:	af00      	add	r7, sp, #0
 801212e:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8012130:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 8012132:	4618      	mov	r0, r3
 8012134:	370c      	adds	r7, #12
 8012136:	46bd      	mov	sp, r7
 8012138:	f85d 7b04 	ldr.w	r7, [sp], #4
 801213c:	4770      	bx	lr

0801213e <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 801213e:	b580      	push	{r7, lr}
 8012140:	b084      	sub	sp, #16
 8012142:	af00      	add	r7, sp, #0
 8012144:	6078      	str	r0, [r7, #4]
 8012146:	460b      	mov	r3, r1
 8012148:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 801214a:	2300      	movs	r3, #0
 801214c:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 801214e:	687b      	ldr	r3, [r7, #4]
 8012150:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012154:	2b00      	cmp	r3, #0
 8012156:	d009      	beq.n	801216c <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 8012158:	687b      	ldr	r3, [r7, #4]
 801215a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801215e:	681b      	ldr	r3, [r3, #0]
 8012160:	78fa      	ldrb	r2, [r7, #3]
 8012162:	4611      	mov	r1, r2
 8012164:	6878      	ldr	r0, [r7, #4]
 8012166:	4798      	blx	r3
 8012168:	4603      	mov	r3, r0
 801216a:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 801216c:	7bfb      	ldrb	r3, [r7, #15]
}
 801216e:	4618      	mov	r0, r3
 8012170:	3710      	adds	r7, #16
 8012172:	46bd      	mov	sp, r7
 8012174:	bd80      	pop	{r7, pc}

08012176 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status: USBD_StatusTypeDef
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8012176:	b580      	push	{r7, lr}
 8012178:	b084      	sub	sp, #16
 801217a:	af00      	add	r7, sp, #0
 801217c:	6078      	str	r0, [r7, #4]
 801217e:	460b      	mov	r3, r1
 8012180:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 8012182:	2300      	movs	r3, #0
 8012184:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 8012186:	687b      	ldr	r3, [r7, #4]
 8012188:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801218c:	685b      	ldr	r3, [r3, #4]
 801218e:	78fa      	ldrb	r2, [r7, #3]
 8012190:	4611      	mov	r1, r2
 8012192:	6878      	ldr	r0, [r7, #4]
 8012194:	4798      	blx	r3
 8012196:	4603      	mov	r3, r0
 8012198:	2b00      	cmp	r3, #0
 801219a:	d001      	beq.n	80121a0 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 801219c:	2303      	movs	r3, #3
 801219e:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 80121a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80121a2:	4618      	mov	r0, r3
 80121a4:	3710      	adds	r7, #16
 80121a6:	46bd      	mov	sp, r7
 80121a8:	bd80      	pop	{r7, pc}

080121aa <USBD_LL_SetupStage>:
  *         Handle the setup stage
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80121aa:	b580      	push	{r7, lr}
 80121ac:	b084      	sub	sp, #16
 80121ae:	af00      	add	r7, sp, #0
 80121b0:	6078      	str	r0, [r7, #4]
 80121b2:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80121b4:	687b      	ldr	r3, [r7, #4]
 80121b6:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 80121ba:	6839      	ldr	r1, [r7, #0]
 80121bc:	4618      	mov	r0, r3
 80121be:	f001 f87c 	bl	80132ba <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 80121c2:	687b      	ldr	r3, [r7, #4]
 80121c4:	2201      	movs	r2, #1
 80121c6:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 80121ca:	687b      	ldr	r3, [r7, #4]
 80121cc:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	; 0x2b0
 80121d0:	461a      	mov	r2, r3
 80121d2:	687b      	ldr	r3, [r7, #4]
 80121d4:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 80121d8:	687b      	ldr	r3, [r7, #4]
 80121da:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 80121de:	f003 031f 	and.w	r3, r3, #31
 80121e2:	2b02      	cmp	r3, #2
 80121e4:	d01a      	beq.n	801221c <USBD_LL_SetupStage+0x72>
 80121e6:	2b02      	cmp	r3, #2
 80121e8:	d822      	bhi.n	8012230 <USBD_LL_SetupStage+0x86>
 80121ea:	2b00      	cmp	r3, #0
 80121ec:	d002      	beq.n	80121f4 <USBD_LL_SetupStage+0x4a>
 80121ee:	2b01      	cmp	r3, #1
 80121f0:	d00a      	beq.n	8012208 <USBD_LL_SetupStage+0x5e>
 80121f2:	e01d      	b.n	8012230 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 80121f4:	687b      	ldr	r3, [r7, #4]
 80121f6:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 80121fa:	4619      	mov	r1, r3
 80121fc:	6878      	ldr	r0, [r7, #4]
 80121fe:	f000 fad3 	bl	80127a8 <USBD_StdDevReq>
 8012202:	4603      	mov	r3, r0
 8012204:	73fb      	strb	r3, [r7, #15]
      break;
 8012206:	e020      	b.n	801224a <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8012208:	687b      	ldr	r3, [r7, #4]
 801220a:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 801220e:	4619      	mov	r1, r3
 8012210:	6878      	ldr	r0, [r7, #4]
 8012212:	f000 fb3b 	bl	801288c <USBD_StdItfReq>
 8012216:	4603      	mov	r3, r0
 8012218:	73fb      	strb	r3, [r7, #15]
      break;
 801221a:	e016      	b.n	801224a <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 801221c:	687b      	ldr	r3, [r7, #4]
 801221e:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8012222:	4619      	mov	r1, r3
 8012224:	6878      	ldr	r0, [r7, #4]
 8012226:	f000 fb9d 	bl	8012964 <USBD_StdEPReq>
 801222a:	4603      	mov	r3, r0
 801222c:	73fb      	strb	r3, [r7, #15]
      break;
 801222e:	e00c      	b.n	801224a <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8012230:	687b      	ldr	r3, [r7, #4]
 8012232:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 8012236:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801223a:	b2db      	uxtb	r3, r3
 801223c:	4619      	mov	r1, r3
 801223e:	6878      	ldr	r0, [r7, #4]
 8012240:	f001 fef2 	bl	8014028 <USBD_LL_StallEP>
 8012244:	4603      	mov	r3, r0
 8012246:	73fb      	strb	r3, [r7, #15]
      break;
 8012248:	bf00      	nop
  }

  return ret;
 801224a:	7bfb      	ldrb	r3, [r7, #15]
}
 801224c:	4618      	mov	r0, r3
 801224e:	3710      	adds	r7, #16
 8012250:	46bd      	mov	sp, r7
 8012252:	bd80      	pop	{r7, pc}

08012254 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8012254:	b580      	push	{r7, lr}
 8012256:	b086      	sub	sp, #24
 8012258:	af00      	add	r7, sp, #0
 801225a:	60f8      	str	r0, [r7, #12]
 801225c:	460b      	mov	r3, r1
 801225e:	607a      	str	r2, [r7, #4]
 8012260:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 8012262:	2300      	movs	r3, #0
 8012264:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 8012266:	7afb      	ldrb	r3, [r7, #11]
 8012268:	2b00      	cmp	r3, #0
 801226a:	d16e      	bne.n	801234a <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 801226c:	68fb      	ldr	r3, [r7, #12]
 801226e:	f503 73aa 	add.w	r3, r3, #340	; 0x154
 8012272:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 8012274:	68fb      	ldr	r3, [r7, #12]
 8012276:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 801227a:	2b03      	cmp	r3, #3
 801227c:	f040 8098 	bne.w	80123b0 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 8012280:	693b      	ldr	r3, [r7, #16]
 8012282:	689a      	ldr	r2, [r3, #8]
 8012284:	693b      	ldr	r3, [r7, #16]
 8012286:	68db      	ldr	r3, [r3, #12]
 8012288:	429a      	cmp	r2, r3
 801228a:	d913      	bls.n	80122b4 <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 801228c:	693b      	ldr	r3, [r7, #16]
 801228e:	689a      	ldr	r2, [r3, #8]
 8012290:	693b      	ldr	r3, [r7, #16]
 8012292:	68db      	ldr	r3, [r3, #12]
 8012294:	1ad2      	subs	r2, r2, r3
 8012296:	693b      	ldr	r3, [r7, #16]
 8012298:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 801229a:	693b      	ldr	r3, [r7, #16]
 801229c:	68da      	ldr	r2, [r3, #12]
 801229e:	693b      	ldr	r3, [r7, #16]
 80122a0:	689b      	ldr	r3, [r3, #8]
 80122a2:	4293      	cmp	r3, r2
 80122a4:	bf28      	it	cs
 80122a6:	4613      	movcs	r3, r2
 80122a8:	461a      	mov	r2, r3
 80122aa:	6879      	ldr	r1, [r7, #4]
 80122ac:	68f8      	ldr	r0, [r7, #12]
 80122ae:	f001 f8f8 	bl	80134a2 <USBD_CtlContinueRx>
 80122b2:	e07d      	b.n	80123b0 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 80122b4:	68fb      	ldr	r3, [r7, #12]
 80122b6:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 80122ba:	f003 031f 	and.w	r3, r3, #31
 80122be:	2b02      	cmp	r3, #2
 80122c0:	d014      	beq.n	80122ec <USBD_LL_DataOutStage+0x98>
 80122c2:	2b02      	cmp	r3, #2
 80122c4:	d81d      	bhi.n	8012302 <USBD_LL_DataOutStage+0xae>
 80122c6:	2b00      	cmp	r3, #0
 80122c8:	d002      	beq.n	80122d0 <USBD_LL_DataOutStage+0x7c>
 80122ca:	2b01      	cmp	r3, #1
 80122cc:	d003      	beq.n	80122d6 <USBD_LL_DataOutStage+0x82>
 80122ce:	e018      	b.n	8012302 <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 80122d0:	2300      	movs	r3, #0
 80122d2:	75bb      	strb	r3, [r7, #22]
            break;
 80122d4:	e018      	b.n	8012308 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 80122d6:	68fb      	ldr	r3, [r7, #12]
 80122d8:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	; 0x2ae
 80122dc:	b2db      	uxtb	r3, r3
 80122de:	4619      	mov	r1, r3
 80122e0:	68f8      	ldr	r0, [r7, #12]
 80122e2:	f000 f9d2 	bl	801268a <USBD_CoreFindIF>
 80122e6:	4603      	mov	r3, r0
 80122e8:	75bb      	strb	r3, [r7, #22]
            break;
 80122ea:	e00d      	b.n	8012308 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 80122ec:	68fb      	ldr	r3, [r7, #12]
 80122ee:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	; 0x2ae
 80122f2:	b2db      	uxtb	r3, r3
 80122f4:	4619      	mov	r1, r3
 80122f6:	68f8      	ldr	r0, [r7, #12]
 80122f8:	f000 f9d4 	bl	80126a4 <USBD_CoreFindEP>
 80122fc:	4603      	mov	r3, r0
 80122fe:	75bb      	strb	r3, [r7, #22]
            break;
 8012300:	e002      	b.n	8012308 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 8012302:	2300      	movs	r3, #0
 8012304:	75bb      	strb	r3, [r7, #22]
            break;
 8012306:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 8012308:	7dbb      	ldrb	r3, [r7, #22]
 801230a:	2b00      	cmp	r3, #0
 801230c:	d119      	bne.n	8012342 <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801230e:	68fb      	ldr	r3, [r7, #12]
 8012310:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012314:	b2db      	uxtb	r3, r3
 8012316:	2b03      	cmp	r3, #3
 8012318:	d113      	bne.n	8012342 <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 801231a:	7dba      	ldrb	r2, [r7, #22]
 801231c:	68fb      	ldr	r3, [r7, #12]
 801231e:	32ae      	adds	r2, #174	; 0xae
 8012320:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012324:	691b      	ldr	r3, [r3, #16]
 8012326:	2b00      	cmp	r3, #0
 8012328:	d00b      	beq.n	8012342 <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 801232a:	7dba      	ldrb	r2, [r7, #22]
 801232c:	68fb      	ldr	r3, [r7, #12]
 801232e:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 8012332:	7dba      	ldrb	r2, [r7, #22]
 8012334:	68fb      	ldr	r3, [r7, #12]
 8012336:	32ae      	adds	r2, #174	; 0xae
 8012338:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801233c:	691b      	ldr	r3, [r3, #16]
 801233e:	68f8      	ldr	r0, [r7, #12]
 8012340:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 8012342:	68f8      	ldr	r0, [r7, #12]
 8012344:	f001 f8be 	bl	80134c4 <USBD_CtlSendStatus>
 8012348:	e032      	b.n	80123b0 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 801234a:	7afb      	ldrb	r3, [r7, #11]
 801234c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012350:	b2db      	uxtb	r3, r3
 8012352:	4619      	mov	r1, r3
 8012354:	68f8      	ldr	r0, [r7, #12]
 8012356:	f000 f9a5 	bl	80126a4 <USBD_CoreFindEP>
 801235a:	4603      	mov	r3, r0
 801235c:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801235e:	7dbb      	ldrb	r3, [r7, #22]
 8012360:	2bff      	cmp	r3, #255	; 0xff
 8012362:	d025      	beq.n	80123b0 <USBD_LL_DataOutStage+0x15c>
 8012364:	7dbb      	ldrb	r3, [r7, #22]
 8012366:	2b00      	cmp	r3, #0
 8012368:	d122      	bne.n	80123b0 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801236a:	68fb      	ldr	r3, [r7, #12]
 801236c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012370:	b2db      	uxtb	r3, r3
 8012372:	2b03      	cmp	r3, #3
 8012374:	d117      	bne.n	80123a6 <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 8012376:	7dba      	ldrb	r2, [r7, #22]
 8012378:	68fb      	ldr	r3, [r7, #12]
 801237a:	32ae      	adds	r2, #174	; 0xae
 801237c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012380:	699b      	ldr	r3, [r3, #24]
 8012382:	2b00      	cmp	r3, #0
 8012384:	d00f      	beq.n	80123a6 <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 8012386:	7dba      	ldrb	r2, [r7, #22]
 8012388:	68fb      	ldr	r3, [r7, #12]
 801238a:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 801238e:	7dba      	ldrb	r2, [r7, #22]
 8012390:	68fb      	ldr	r3, [r7, #12]
 8012392:	32ae      	adds	r2, #174	; 0xae
 8012394:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012398:	699b      	ldr	r3, [r3, #24]
 801239a:	7afa      	ldrb	r2, [r7, #11]
 801239c:	4611      	mov	r1, r2
 801239e:	68f8      	ldr	r0, [r7, #12]
 80123a0:	4798      	blx	r3
 80123a2:	4603      	mov	r3, r0
 80123a4:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 80123a6:	7dfb      	ldrb	r3, [r7, #23]
 80123a8:	2b00      	cmp	r3, #0
 80123aa:	d001      	beq.n	80123b0 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 80123ac:	7dfb      	ldrb	r3, [r7, #23]
 80123ae:	e000      	b.n	80123b2 <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 80123b0:	2300      	movs	r3, #0
}
 80123b2:	4618      	mov	r0, r3
 80123b4:	3718      	adds	r7, #24
 80123b6:	46bd      	mov	sp, r7
 80123b8:	bd80      	pop	{r7, pc}

080123ba <USBD_LL_DataInStage>:
  * @param  epnum: endpoint index
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 80123ba:	b580      	push	{r7, lr}
 80123bc:	b086      	sub	sp, #24
 80123be:	af00      	add	r7, sp, #0
 80123c0:	60f8      	str	r0, [r7, #12]
 80123c2:	460b      	mov	r3, r1
 80123c4:	607a      	str	r2, [r7, #4]
 80123c6:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 80123c8:	7afb      	ldrb	r3, [r7, #11]
 80123ca:	2b00      	cmp	r3, #0
 80123cc:	d16f      	bne.n	80124ae <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 80123ce:	68fb      	ldr	r3, [r7, #12]
 80123d0:	3314      	adds	r3, #20
 80123d2:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 80123d4:	68fb      	ldr	r3, [r7, #12]
 80123d6:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 80123da:	2b02      	cmp	r3, #2
 80123dc:	d15a      	bne.n	8012494 <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 80123de:	693b      	ldr	r3, [r7, #16]
 80123e0:	689a      	ldr	r2, [r3, #8]
 80123e2:	693b      	ldr	r3, [r7, #16]
 80123e4:	68db      	ldr	r3, [r3, #12]
 80123e6:	429a      	cmp	r2, r3
 80123e8:	d914      	bls.n	8012414 <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 80123ea:	693b      	ldr	r3, [r7, #16]
 80123ec:	689a      	ldr	r2, [r3, #8]
 80123ee:	693b      	ldr	r3, [r7, #16]
 80123f0:	68db      	ldr	r3, [r3, #12]
 80123f2:	1ad2      	subs	r2, r2, r3
 80123f4:	693b      	ldr	r3, [r7, #16]
 80123f6:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80123f8:	693b      	ldr	r3, [r7, #16]
 80123fa:	689b      	ldr	r3, [r3, #8]
 80123fc:	461a      	mov	r2, r3
 80123fe:	6879      	ldr	r1, [r7, #4]
 8012400:	68f8      	ldr	r0, [r7, #12]
 8012402:	f001 f820 	bl	8013446 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8012406:	2300      	movs	r3, #0
 8012408:	2200      	movs	r2, #0
 801240a:	2100      	movs	r1, #0
 801240c:	68f8      	ldr	r0, [r7, #12]
 801240e:	f001 fe85 	bl	801411c <USBD_LL_PrepareReceive>
 8012412:	e03f      	b.n	8012494 <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 8012414:	693b      	ldr	r3, [r7, #16]
 8012416:	68da      	ldr	r2, [r3, #12]
 8012418:	693b      	ldr	r3, [r7, #16]
 801241a:	689b      	ldr	r3, [r3, #8]
 801241c:	429a      	cmp	r2, r3
 801241e:	d11c      	bne.n	801245a <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 8012420:	693b      	ldr	r3, [r7, #16]
 8012422:	685a      	ldr	r2, [r3, #4]
 8012424:	693b      	ldr	r3, [r7, #16]
 8012426:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 8012428:	429a      	cmp	r2, r3
 801242a:	d316      	bcc.n	801245a <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 801242c:	693b      	ldr	r3, [r7, #16]
 801242e:	685a      	ldr	r2, [r3, #4]
 8012430:	68fb      	ldr	r3, [r7, #12]
 8012432:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
            (pep->total_length >= pep->maxpacket) &&
 8012436:	429a      	cmp	r2, r3
 8012438:	d20f      	bcs.n	801245a <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 801243a:	2200      	movs	r2, #0
 801243c:	2100      	movs	r1, #0
 801243e:	68f8      	ldr	r0, [r7, #12]
 8012440:	f001 f801 	bl	8013446 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 8012444:	68fb      	ldr	r3, [r7, #12]
 8012446:	2200      	movs	r2, #0
 8012448:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801244c:	2300      	movs	r3, #0
 801244e:	2200      	movs	r2, #0
 8012450:	2100      	movs	r1, #0
 8012452:	68f8      	ldr	r0, [r7, #12]
 8012454:	f001 fe62 	bl	801411c <USBD_LL_PrepareReceive>
 8012458:	e01c      	b.n	8012494 <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801245a:	68fb      	ldr	r3, [r7, #12]
 801245c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012460:	b2db      	uxtb	r3, r3
 8012462:	2b03      	cmp	r3, #3
 8012464:	d10f      	bne.n	8012486 <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 8012466:	68fb      	ldr	r3, [r7, #12]
 8012468:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801246c:	68db      	ldr	r3, [r3, #12]
 801246e:	2b00      	cmp	r3, #0
 8012470:	d009      	beq.n	8012486 <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 8012472:	68fb      	ldr	r3, [r7, #12]
 8012474:	2200      	movs	r2, #0
 8012476:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 801247a:	68fb      	ldr	r3, [r7, #12]
 801247c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012480:	68db      	ldr	r3, [r3, #12]
 8012482:	68f8      	ldr	r0, [r7, #12]
 8012484:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 8012486:	2180      	movs	r1, #128	; 0x80
 8012488:	68f8      	ldr	r0, [r7, #12]
 801248a:	f001 fdcd 	bl	8014028 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 801248e:	68f8      	ldr	r0, [r7, #12]
 8012490:	f001 f82b 	bl	80134ea <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 8012494:	68fb      	ldr	r3, [r7, #12]
 8012496:	f893 32a0 	ldrb.w	r3, [r3, #672]	; 0x2a0
 801249a:	2b00      	cmp	r3, #0
 801249c:	d03a      	beq.n	8012514 <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 801249e:	68f8      	ldr	r0, [r7, #12]
 80124a0:	f7ff fe42 	bl	8012128 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 80124a4:	68fb      	ldr	r3, [r7, #12]
 80124a6:	2200      	movs	r2, #0
 80124a8:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
 80124ac:	e032      	b.n	8012514 <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 80124ae:	7afb      	ldrb	r3, [r7, #11]
 80124b0:	f063 037f 	orn	r3, r3, #127	; 0x7f
 80124b4:	b2db      	uxtb	r3, r3
 80124b6:	4619      	mov	r1, r3
 80124b8:	68f8      	ldr	r0, [r7, #12]
 80124ba:	f000 f8f3 	bl	80126a4 <USBD_CoreFindEP>
 80124be:	4603      	mov	r3, r0
 80124c0:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80124c2:	7dfb      	ldrb	r3, [r7, #23]
 80124c4:	2bff      	cmp	r3, #255	; 0xff
 80124c6:	d025      	beq.n	8012514 <USBD_LL_DataInStage+0x15a>
 80124c8:	7dfb      	ldrb	r3, [r7, #23]
 80124ca:	2b00      	cmp	r3, #0
 80124cc:	d122      	bne.n	8012514 <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80124ce:	68fb      	ldr	r3, [r7, #12]
 80124d0:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80124d4:	b2db      	uxtb	r3, r3
 80124d6:	2b03      	cmp	r3, #3
 80124d8:	d11c      	bne.n	8012514 <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 80124da:	7dfa      	ldrb	r2, [r7, #23]
 80124dc:	68fb      	ldr	r3, [r7, #12]
 80124de:	32ae      	adds	r2, #174	; 0xae
 80124e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80124e4:	695b      	ldr	r3, [r3, #20]
 80124e6:	2b00      	cmp	r3, #0
 80124e8:	d014      	beq.n	8012514 <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 80124ea:	7dfa      	ldrb	r2, [r7, #23]
 80124ec:	68fb      	ldr	r3, [r7, #12]
 80124ee:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 80124f2:	7dfa      	ldrb	r2, [r7, #23]
 80124f4:	68fb      	ldr	r3, [r7, #12]
 80124f6:	32ae      	adds	r2, #174	; 0xae
 80124f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80124fc:	695b      	ldr	r3, [r3, #20]
 80124fe:	7afa      	ldrb	r2, [r7, #11]
 8012500:	4611      	mov	r1, r2
 8012502:	68f8      	ldr	r0, [r7, #12]
 8012504:	4798      	blx	r3
 8012506:	4603      	mov	r3, r0
 8012508:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 801250a:	7dbb      	ldrb	r3, [r7, #22]
 801250c:	2b00      	cmp	r3, #0
 801250e:	d001      	beq.n	8012514 <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 8012510:	7dbb      	ldrb	r3, [r7, #22]
 8012512:	e000      	b.n	8012516 <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 8012514:	2300      	movs	r3, #0
}
 8012516:	4618      	mov	r0, r3
 8012518:	3718      	adds	r7, #24
 801251a:	46bd      	mov	sp, r7
 801251c:	bd80      	pop	{r7, pc}

0801251e <USBD_LL_Reset>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 801251e:	b580      	push	{r7, lr}
 8012520:	b084      	sub	sp, #16
 8012522:	af00      	add	r7, sp, #0
 8012524:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 8012526:	2300      	movs	r3, #0
 8012528:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801252a:	687b      	ldr	r3, [r7, #4]
 801252c:	2201      	movs	r2, #1
 801252e:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 8012532:	687b      	ldr	r3, [r7, #4]
 8012534:	2200      	movs	r2, #0
 8012536:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->dev_config = 0U;
 801253a:	687b      	ldr	r3, [r7, #4]
 801253c:	2200      	movs	r2, #0
 801253e:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 8012540:	687b      	ldr	r3, [r7, #4]
 8012542:	2200      	movs	r2, #0
 8012544:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
  pdev->dev_test_mode = 0U;
 8012548:	687b      	ldr	r3, [r7, #4]
 801254a:	2200      	movs	r2, #0
 801254c:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 8012550:	687b      	ldr	r3, [r7, #4]
 8012552:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012556:	2b00      	cmp	r3, #0
 8012558:	d014      	beq.n	8012584 <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 801255a:	687b      	ldr	r3, [r7, #4]
 801255c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012560:	685b      	ldr	r3, [r3, #4]
 8012562:	2b00      	cmp	r3, #0
 8012564:	d00e      	beq.n	8012584 <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 8012566:	687b      	ldr	r3, [r7, #4]
 8012568:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801256c:	685b      	ldr	r3, [r3, #4]
 801256e:	687a      	ldr	r2, [r7, #4]
 8012570:	6852      	ldr	r2, [r2, #4]
 8012572:	b2d2      	uxtb	r2, r2
 8012574:	4611      	mov	r1, r2
 8012576:	6878      	ldr	r0, [r7, #4]
 8012578:	4798      	blx	r3
 801257a:	4603      	mov	r3, r0
 801257c:	2b00      	cmp	r3, #0
 801257e:	d001      	beq.n	8012584 <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 8012580:	2303      	movs	r3, #3
 8012582:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8012584:	2340      	movs	r3, #64	; 0x40
 8012586:	2200      	movs	r2, #0
 8012588:	2100      	movs	r1, #0
 801258a:	6878      	ldr	r0, [r7, #4]
 801258c:	f001 fd1f 	bl	8013fce <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8012590:	687b      	ldr	r3, [r7, #4]
 8012592:	2201      	movs	r2, #1
 8012594:	f8a3 2164 	strh.w	r2, [r3, #356]	; 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8012598:	687b      	ldr	r3, [r7, #4]
 801259a:	2240      	movs	r2, #64	; 0x40
 801259c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80125a0:	2340      	movs	r3, #64	; 0x40
 80125a2:	2200      	movs	r2, #0
 80125a4:	2180      	movs	r1, #128	; 0x80
 80125a6:	6878      	ldr	r0, [r7, #4]
 80125a8:	f001 fd11 	bl	8013fce <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 80125ac:	687b      	ldr	r3, [r7, #4]
 80125ae:	2201      	movs	r2, #1
 80125b0:	849a      	strh	r2, [r3, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80125b2:	687b      	ldr	r3, [r7, #4]
 80125b4:	2240      	movs	r2, #64	; 0x40
 80125b6:	621a      	str	r2, [r3, #32]

  return ret;
 80125b8:	7bfb      	ldrb	r3, [r7, #15]
}
 80125ba:	4618      	mov	r0, r3
 80125bc:	3710      	adds	r7, #16
 80125be:	46bd      	mov	sp, r7
 80125c0:	bd80      	pop	{r7, pc}

080125c2 <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 80125c2:	b480      	push	{r7}
 80125c4:	b083      	sub	sp, #12
 80125c6:	af00      	add	r7, sp, #0
 80125c8:	6078      	str	r0, [r7, #4]
 80125ca:	460b      	mov	r3, r1
 80125cc:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 80125ce:	687b      	ldr	r3, [r7, #4]
 80125d0:	78fa      	ldrb	r2, [r7, #3]
 80125d2:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 80125d4:	2300      	movs	r3, #0
}
 80125d6:	4618      	mov	r0, r3
 80125d8:	370c      	adds	r7, #12
 80125da:	46bd      	mov	sp, r7
 80125dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125e0:	4770      	bx	lr

080125e2 <USBD_LL_Suspend>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 80125e2:	b480      	push	{r7}
 80125e4:	b083      	sub	sp, #12
 80125e6:	af00      	add	r7, sp, #0
 80125e8:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 80125ea:	687b      	ldr	r3, [r7, #4]
 80125ec:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80125f0:	b2db      	uxtb	r3, r3
 80125f2:	2b04      	cmp	r3, #4
 80125f4:	d006      	beq.n	8012604 <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 80125f6:	687b      	ldr	r3, [r7, #4]
 80125f8:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80125fc:	b2da      	uxtb	r2, r3
 80125fe:	687b      	ldr	r3, [r7, #4]
 8012600:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 8012604:	687b      	ldr	r3, [r7, #4]
 8012606:	2204      	movs	r2, #4
 8012608:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c

  return USBD_OK;
 801260c:	2300      	movs	r3, #0
}
 801260e:	4618      	mov	r0, r3
 8012610:	370c      	adds	r7, #12
 8012612:	46bd      	mov	sp, r7
 8012614:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012618:	4770      	bx	lr

0801261a <USBD_LL_Resume>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 801261a:	b480      	push	{r7}
 801261c:	b083      	sub	sp, #12
 801261e:	af00      	add	r7, sp, #0
 8012620:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8012622:	687b      	ldr	r3, [r7, #4]
 8012624:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012628:	b2db      	uxtb	r3, r3
 801262a:	2b04      	cmp	r3, #4
 801262c:	d106      	bne.n	801263c <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 801262e:	687b      	ldr	r3, [r7, #4]
 8012630:	f893 329d 	ldrb.w	r3, [r3, #669]	; 0x29d
 8012634:	b2da      	uxtb	r2, r3
 8012636:	687b      	ldr	r3, [r7, #4]
 8012638:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  }

  return USBD_OK;
 801263c:	2300      	movs	r3, #0
}
 801263e:	4618      	mov	r0, r3
 8012640:	370c      	adds	r7, #12
 8012642:	46bd      	mov	sp, r7
 8012644:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012648:	4770      	bx	lr

0801264a <USBD_LL_SOF>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 801264a:	b580      	push	{r7, lr}
 801264c:	b082      	sub	sp, #8
 801264e:	af00      	add	r7, sp, #0
 8012650:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012652:	687b      	ldr	r3, [r7, #4]
 8012654:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012658:	b2db      	uxtb	r3, r3
 801265a:	2b03      	cmp	r3, #3
 801265c:	d110      	bne.n	8012680 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 801265e:	687b      	ldr	r3, [r7, #4]
 8012660:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012664:	2b00      	cmp	r3, #0
 8012666:	d00b      	beq.n	8012680 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 8012668:	687b      	ldr	r3, [r7, #4]
 801266a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801266e:	69db      	ldr	r3, [r3, #28]
 8012670:	2b00      	cmp	r3, #0
 8012672:	d005      	beq.n	8012680 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 8012674:	687b      	ldr	r3, [r7, #4]
 8012676:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801267a:	69db      	ldr	r3, [r3, #28]
 801267c:	6878      	ldr	r0, [r7, #4]
 801267e:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 8012680:	2300      	movs	r3, #0
}
 8012682:	4618      	mov	r0, r3
 8012684:	3708      	adds	r7, #8
 8012686:	46bd      	mov	sp, r7
 8012688:	bd80      	pop	{r7, pc}

0801268a <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 801268a:	b480      	push	{r7}
 801268c:	b083      	sub	sp, #12
 801268e:	af00      	add	r7, sp, #0
 8012690:	6078      	str	r0, [r7, #4]
 8012692:	460b      	mov	r3, r1
 8012694:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 8012696:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 8012698:	4618      	mov	r0, r3
 801269a:	370c      	adds	r7, #12
 801269c:	46bd      	mov	sp, r7
 801269e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126a2:	4770      	bx	lr

080126a4 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 80126a4:	b480      	push	{r7}
 80126a6:	b083      	sub	sp, #12
 80126a8:	af00      	add	r7, sp, #0
 80126aa:	6078      	str	r0, [r7, #4]
 80126ac:	460b      	mov	r3, r1
 80126ae:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 80126b0:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 80126b2:	4618      	mov	r0, r3
 80126b4:	370c      	adds	r7, #12
 80126b6:	46bd      	mov	sp, r7
 80126b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126bc:	4770      	bx	lr

080126be <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 80126be:	b580      	push	{r7, lr}
 80126c0:	b086      	sub	sp, #24
 80126c2:	af00      	add	r7, sp, #0
 80126c4:	6078      	str	r0, [r7, #4]
 80126c6:	460b      	mov	r3, r1
 80126c8:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 80126ca:	687b      	ldr	r3, [r7, #4]
 80126cc:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 80126ce:	687b      	ldr	r3, [r7, #4]
 80126d0:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 80126d2:	2300      	movs	r3, #0
 80126d4:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 80126d6:	68fb      	ldr	r3, [r7, #12]
 80126d8:	885b      	ldrh	r3, [r3, #2]
 80126da:	b29a      	uxth	r2, r3
 80126dc:	68fb      	ldr	r3, [r7, #12]
 80126de:	781b      	ldrb	r3, [r3, #0]
 80126e0:	b29b      	uxth	r3, r3
 80126e2:	429a      	cmp	r2, r3
 80126e4:	d920      	bls.n	8012728 <USBD_GetEpDesc+0x6a>
  {
    ptr = desc->bLength;
 80126e6:	68fb      	ldr	r3, [r7, #12]
 80126e8:	781b      	ldrb	r3, [r3, #0]
 80126ea:	b29b      	uxth	r3, r3
 80126ec:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 80126ee:	e013      	b.n	8012718 <USBD_GetEpDesc+0x5a>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 80126f0:	f107 030a 	add.w	r3, r7, #10
 80126f4:	4619      	mov	r1, r3
 80126f6:	6978      	ldr	r0, [r7, #20]
 80126f8:	f000 f81b 	bl	8012732 <USBD_GetNextDesc>
 80126fc:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 80126fe:	697b      	ldr	r3, [r7, #20]
 8012700:	785b      	ldrb	r3, [r3, #1]
 8012702:	2b05      	cmp	r3, #5
 8012704:	d108      	bne.n	8012718 <USBD_GetEpDesc+0x5a>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 8012706:	697b      	ldr	r3, [r7, #20]
 8012708:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 801270a:	693b      	ldr	r3, [r7, #16]
 801270c:	789b      	ldrb	r3, [r3, #2]
 801270e:	78fa      	ldrb	r2, [r7, #3]
 8012710:	429a      	cmp	r2, r3
 8012712:	d008      	beq.n	8012726 <USBD_GetEpDesc+0x68>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 8012714:	2300      	movs	r3, #0
 8012716:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 8012718:	68fb      	ldr	r3, [r7, #12]
 801271a:	885b      	ldrh	r3, [r3, #2]
 801271c:	b29a      	uxth	r2, r3
 801271e:	897b      	ldrh	r3, [r7, #10]
 8012720:	429a      	cmp	r2, r3
 8012722:	d8e5      	bhi.n	80126f0 <USBD_GetEpDesc+0x32>
 8012724:	e000      	b.n	8012728 <USBD_GetEpDesc+0x6a>
          break;
 8012726:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 8012728:	693b      	ldr	r3, [r7, #16]
}
 801272a:	4618      	mov	r0, r3
 801272c:	3718      	adds	r7, #24
 801272e:	46bd      	mov	sp, r7
 8012730:	bd80      	pop	{r7, pc}

08012732 <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 8012732:	b480      	push	{r7}
 8012734:	b085      	sub	sp, #20
 8012736:	af00      	add	r7, sp, #0
 8012738:	6078      	str	r0, [r7, #4]
 801273a:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 801273c:	687b      	ldr	r3, [r7, #4]
 801273e:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 8012740:	683b      	ldr	r3, [r7, #0]
 8012742:	881a      	ldrh	r2, [r3, #0]
 8012744:	68fb      	ldr	r3, [r7, #12]
 8012746:	781b      	ldrb	r3, [r3, #0]
 8012748:	b29b      	uxth	r3, r3
 801274a:	4413      	add	r3, r2
 801274c:	b29a      	uxth	r2, r3
 801274e:	683b      	ldr	r3, [r7, #0]
 8012750:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 8012752:	68fb      	ldr	r3, [r7, #12]
 8012754:	781b      	ldrb	r3, [r3, #0]
 8012756:	461a      	mov	r2, r3
 8012758:	687b      	ldr	r3, [r7, #4]
 801275a:	4413      	add	r3, r2
 801275c:	60fb      	str	r3, [r7, #12]

  return (pnext);
 801275e:	68fb      	ldr	r3, [r7, #12]
}
 8012760:	4618      	mov	r0, r3
 8012762:	3714      	adds	r7, #20
 8012764:	46bd      	mov	sp, r7
 8012766:	f85d 7b04 	ldr.w	r7, [sp], #4
 801276a:	4770      	bx	lr

0801276c <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 801276c:	b480      	push	{r7}
 801276e:	b087      	sub	sp, #28
 8012770:	af00      	add	r7, sp, #0
 8012772:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 8012774:	687b      	ldr	r3, [r7, #4]
 8012776:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 8012778:	697b      	ldr	r3, [r7, #20]
 801277a:	781b      	ldrb	r3, [r3, #0]
 801277c:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 801277e:	697b      	ldr	r3, [r7, #20]
 8012780:	3301      	adds	r3, #1
 8012782:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 8012784:	697b      	ldr	r3, [r7, #20]
 8012786:	781b      	ldrb	r3, [r3, #0]
 8012788:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 801278a:	8a3b      	ldrh	r3, [r7, #16]
 801278c:	021b      	lsls	r3, r3, #8
 801278e:	b21a      	sxth	r2, r3
 8012790:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8012794:	4313      	orrs	r3, r2
 8012796:	b21b      	sxth	r3, r3
 8012798:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 801279a:	89fb      	ldrh	r3, [r7, #14]
}
 801279c:	4618      	mov	r0, r3
 801279e:	371c      	adds	r7, #28
 80127a0:	46bd      	mov	sp, r7
 80127a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127a6:	4770      	bx	lr

080127a8 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80127a8:	b580      	push	{r7, lr}
 80127aa:	b084      	sub	sp, #16
 80127ac:	af00      	add	r7, sp, #0
 80127ae:	6078      	str	r0, [r7, #4]
 80127b0:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 80127b2:	2300      	movs	r3, #0
 80127b4:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80127b6:	683b      	ldr	r3, [r7, #0]
 80127b8:	781b      	ldrb	r3, [r3, #0]
 80127ba:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80127be:	2b40      	cmp	r3, #64	; 0x40
 80127c0:	d005      	beq.n	80127ce <USBD_StdDevReq+0x26>
 80127c2:	2b40      	cmp	r3, #64	; 0x40
 80127c4:	d857      	bhi.n	8012876 <USBD_StdDevReq+0xce>
 80127c6:	2b00      	cmp	r3, #0
 80127c8:	d00f      	beq.n	80127ea <USBD_StdDevReq+0x42>
 80127ca:	2b20      	cmp	r3, #32
 80127cc:	d153      	bne.n	8012876 <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 80127ce:	687b      	ldr	r3, [r7, #4]
 80127d0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	; 0x2d4
 80127d4:	687b      	ldr	r3, [r7, #4]
 80127d6:	32ae      	adds	r2, #174	; 0xae
 80127d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80127dc:	689b      	ldr	r3, [r3, #8]
 80127de:	6839      	ldr	r1, [r7, #0]
 80127e0:	6878      	ldr	r0, [r7, #4]
 80127e2:	4798      	blx	r3
 80127e4:	4603      	mov	r3, r0
 80127e6:	73fb      	strb	r3, [r7, #15]
      break;
 80127e8:	e04a      	b.n	8012880 <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 80127ea:	683b      	ldr	r3, [r7, #0]
 80127ec:	785b      	ldrb	r3, [r3, #1]
 80127ee:	2b09      	cmp	r3, #9
 80127f0:	d83b      	bhi.n	801286a <USBD_StdDevReq+0xc2>
 80127f2:	a201      	add	r2, pc, #4	; (adr r2, 80127f8 <USBD_StdDevReq+0x50>)
 80127f4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80127f8:	0801284d 	.word	0x0801284d
 80127fc:	08012861 	.word	0x08012861
 8012800:	0801286b 	.word	0x0801286b
 8012804:	08012857 	.word	0x08012857
 8012808:	0801286b 	.word	0x0801286b
 801280c:	0801282b 	.word	0x0801282b
 8012810:	08012821 	.word	0x08012821
 8012814:	0801286b 	.word	0x0801286b
 8012818:	08012843 	.word	0x08012843
 801281c:	08012835 	.word	0x08012835
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 8012820:	6839      	ldr	r1, [r7, #0]
 8012822:	6878      	ldr	r0, [r7, #4]
 8012824:	f000 fa3c 	bl	8012ca0 <USBD_GetDescriptor>
          break;
 8012828:	e024      	b.n	8012874 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 801282a:	6839      	ldr	r1, [r7, #0]
 801282c:	6878      	ldr	r0, [r7, #4]
 801282e:	f000 fba1 	bl	8012f74 <USBD_SetAddress>
          break;
 8012832:	e01f      	b.n	8012874 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 8012834:	6839      	ldr	r1, [r7, #0]
 8012836:	6878      	ldr	r0, [r7, #4]
 8012838:	f000 fbe0 	bl	8012ffc <USBD_SetConfig>
 801283c:	4603      	mov	r3, r0
 801283e:	73fb      	strb	r3, [r7, #15]
          break;
 8012840:	e018      	b.n	8012874 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 8012842:	6839      	ldr	r1, [r7, #0]
 8012844:	6878      	ldr	r0, [r7, #4]
 8012846:	f000 fc83 	bl	8013150 <USBD_GetConfig>
          break;
 801284a:	e013      	b.n	8012874 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 801284c:	6839      	ldr	r1, [r7, #0]
 801284e:	6878      	ldr	r0, [r7, #4]
 8012850:	f000 fcb4 	bl	80131bc <USBD_GetStatus>
          break;
 8012854:	e00e      	b.n	8012874 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 8012856:	6839      	ldr	r1, [r7, #0]
 8012858:	6878      	ldr	r0, [r7, #4]
 801285a:	f000 fce3 	bl	8013224 <USBD_SetFeature>
          break;
 801285e:	e009      	b.n	8012874 <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8012860:	6839      	ldr	r1, [r7, #0]
 8012862:	6878      	ldr	r0, [r7, #4]
 8012864:	f000 fd07 	bl	8013276 <USBD_ClrFeature>
          break;
 8012868:	e004      	b.n	8012874 <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 801286a:	6839      	ldr	r1, [r7, #0]
 801286c:	6878      	ldr	r0, [r7, #4]
 801286e:	f000 fd5e 	bl	801332e <USBD_CtlError>
          break;
 8012872:	bf00      	nop
      }
      break;
 8012874:	e004      	b.n	8012880 <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 8012876:	6839      	ldr	r1, [r7, #0]
 8012878:	6878      	ldr	r0, [r7, #4]
 801287a:	f000 fd58 	bl	801332e <USBD_CtlError>
      break;
 801287e:	bf00      	nop
  }

  return ret;
 8012880:	7bfb      	ldrb	r3, [r7, #15]
}
 8012882:	4618      	mov	r0, r3
 8012884:	3710      	adds	r7, #16
 8012886:	46bd      	mov	sp, r7
 8012888:	bd80      	pop	{r7, pc}
 801288a:	bf00      	nop

0801288c <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801288c:	b580      	push	{r7, lr}
 801288e:	b084      	sub	sp, #16
 8012890:	af00      	add	r7, sp, #0
 8012892:	6078      	str	r0, [r7, #4]
 8012894:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8012896:	2300      	movs	r3, #0
 8012898:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801289a:	683b      	ldr	r3, [r7, #0]
 801289c:	781b      	ldrb	r3, [r3, #0]
 801289e:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80128a2:	2b40      	cmp	r3, #64	; 0x40
 80128a4:	d005      	beq.n	80128b2 <USBD_StdItfReq+0x26>
 80128a6:	2b40      	cmp	r3, #64	; 0x40
 80128a8:	d852      	bhi.n	8012950 <USBD_StdItfReq+0xc4>
 80128aa:	2b00      	cmp	r3, #0
 80128ac:	d001      	beq.n	80128b2 <USBD_StdItfReq+0x26>
 80128ae:	2b20      	cmp	r3, #32
 80128b0:	d14e      	bne.n	8012950 <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 80128b2:	687b      	ldr	r3, [r7, #4]
 80128b4:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80128b8:	b2db      	uxtb	r3, r3
 80128ba:	3b01      	subs	r3, #1
 80128bc:	2b02      	cmp	r3, #2
 80128be:	d840      	bhi.n	8012942 <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 80128c0:	683b      	ldr	r3, [r7, #0]
 80128c2:	889b      	ldrh	r3, [r3, #4]
 80128c4:	b2db      	uxtb	r3, r3
 80128c6:	2b01      	cmp	r3, #1
 80128c8:	d836      	bhi.n	8012938 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 80128ca:	683b      	ldr	r3, [r7, #0]
 80128cc:	889b      	ldrh	r3, [r3, #4]
 80128ce:	b2db      	uxtb	r3, r3
 80128d0:	4619      	mov	r1, r3
 80128d2:	6878      	ldr	r0, [r7, #4]
 80128d4:	f7ff fed9 	bl	801268a <USBD_CoreFindIF>
 80128d8:	4603      	mov	r3, r0
 80128da:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80128dc:	7bbb      	ldrb	r3, [r7, #14]
 80128de:	2bff      	cmp	r3, #255	; 0xff
 80128e0:	d01d      	beq.n	801291e <USBD_StdItfReq+0x92>
 80128e2:	7bbb      	ldrb	r3, [r7, #14]
 80128e4:	2b00      	cmp	r3, #0
 80128e6:	d11a      	bne.n	801291e <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 80128e8:	7bba      	ldrb	r2, [r7, #14]
 80128ea:	687b      	ldr	r3, [r7, #4]
 80128ec:	32ae      	adds	r2, #174	; 0xae
 80128ee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80128f2:	689b      	ldr	r3, [r3, #8]
 80128f4:	2b00      	cmp	r3, #0
 80128f6:	d00f      	beq.n	8012918 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 80128f8:	7bba      	ldrb	r2, [r7, #14]
 80128fa:	687b      	ldr	r3, [r7, #4]
 80128fc:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8012900:	7bba      	ldrb	r2, [r7, #14]
 8012902:	687b      	ldr	r3, [r7, #4]
 8012904:	32ae      	adds	r2, #174	; 0xae
 8012906:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801290a:	689b      	ldr	r3, [r3, #8]
 801290c:	6839      	ldr	r1, [r7, #0]
 801290e:	6878      	ldr	r0, [r7, #4]
 8012910:	4798      	blx	r3
 8012912:	4603      	mov	r3, r0
 8012914:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 8012916:	e004      	b.n	8012922 <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 8012918:	2303      	movs	r3, #3
 801291a:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 801291c:	e001      	b.n	8012922 <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 801291e:	2303      	movs	r3, #3
 8012920:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 8012922:	683b      	ldr	r3, [r7, #0]
 8012924:	88db      	ldrh	r3, [r3, #6]
 8012926:	2b00      	cmp	r3, #0
 8012928:	d110      	bne.n	801294c <USBD_StdItfReq+0xc0>
 801292a:	7bfb      	ldrb	r3, [r7, #15]
 801292c:	2b00      	cmp	r3, #0
 801292e:	d10d      	bne.n	801294c <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 8012930:	6878      	ldr	r0, [r7, #4]
 8012932:	f000 fdc7 	bl	80134c4 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 8012936:	e009      	b.n	801294c <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 8012938:	6839      	ldr	r1, [r7, #0]
 801293a:	6878      	ldr	r0, [r7, #4]
 801293c:	f000 fcf7 	bl	801332e <USBD_CtlError>
          break;
 8012940:	e004      	b.n	801294c <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 8012942:	6839      	ldr	r1, [r7, #0]
 8012944:	6878      	ldr	r0, [r7, #4]
 8012946:	f000 fcf2 	bl	801332e <USBD_CtlError>
          break;
 801294a:	e000      	b.n	801294e <USBD_StdItfReq+0xc2>
          break;
 801294c:	bf00      	nop
      }
      break;
 801294e:	e004      	b.n	801295a <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 8012950:	6839      	ldr	r1, [r7, #0]
 8012952:	6878      	ldr	r0, [r7, #4]
 8012954:	f000 fceb 	bl	801332e <USBD_CtlError>
      break;
 8012958:	bf00      	nop
  }

  return ret;
 801295a:	7bfb      	ldrb	r3, [r7, #15]
}
 801295c:	4618      	mov	r0, r3
 801295e:	3710      	adds	r7, #16
 8012960:	46bd      	mov	sp, r7
 8012962:	bd80      	pop	{r7, pc}

08012964 <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012964:	b580      	push	{r7, lr}
 8012966:	b084      	sub	sp, #16
 8012968:	af00      	add	r7, sp, #0
 801296a:	6078      	str	r0, [r7, #4]
 801296c:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 801296e:	2300      	movs	r3, #0
 8012970:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 8012972:	683b      	ldr	r3, [r7, #0]
 8012974:	889b      	ldrh	r3, [r3, #4]
 8012976:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8012978:	683b      	ldr	r3, [r7, #0]
 801297a:	781b      	ldrb	r3, [r3, #0]
 801297c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8012980:	2b40      	cmp	r3, #64	; 0x40
 8012982:	d007      	beq.n	8012994 <USBD_StdEPReq+0x30>
 8012984:	2b40      	cmp	r3, #64	; 0x40
 8012986:	f200 817f 	bhi.w	8012c88 <USBD_StdEPReq+0x324>
 801298a:	2b00      	cmp	r3, #0
 801298c:	d02a      	beq.n	80129e4 <USBD_StdEPReq+0x80>
 801298e:	2b20      	cmp	r3, #32
 8012990:	f040 817a 	bne.w	8012c88 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 8012994:	7bbb      	ldrb	r3, [r7, #14]
 8012996:	4619      	mov	r1, r3
 8012998:	6878      	ldr	r0, [r7, #4]
 801299a:	f7ff fe83 	bl	80126a4 <USBD_CoreFindEP>
 801299e:	4603      	mov	r3, r0
 80129a0:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80129a2:	7b7b      	ldrb	r3, [r7, #13]
 80129a4:	2bff      	cmp	r3, #255	; 0xff
 80129a6:	f000 8174 	beq.w	8012c92 <USBD_StdEPReq+0x32e>
 80129aa:	7b7b      	ldrb	r3, [r7, #13]
 80129ac:	2b00      	cmp	r3, #0
 80129ae:	f040 8170 	bne.w	8012c92 <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 80129b2:	7b7a      	ldrb	r2, [r7, #13]
 80129b4:	687b      	ldr	r3, [r7, #4]
 80129b6:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 80129ba:	7b7a      	ldrb	r2, [r7, #13]
 80129bc:	687b      	ldr	r3, [r7, #4]
 80129be:	32ae      	adds	r2, #174	; 0xae
 80129c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80129c4:	689b      	ldr	r3, [r3, #8]
 80129c6:	2b00      	cmp	r3, #0
 80129c8:	f000 8163 	beq.w	8012c92 <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 80129cc:	7b7a      	ldrb	r2, [r7, #13]
 80129ce:	687b      	ldr	r3, [r7, #4]
 80129d0:	32ae      	adds	r2, #174	; 0xae
 80129d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80129d6:	689b      	ldr	r3, [r3, #8]
 80129d8:	6839      	ldr	r1, [r7, #0]
 80129da:	6878      	ldr	r0, [r7, #4]
 80129dc:	4798      	blx	r3
 80129de:	4603      	mov	r3, r0
 80129e0:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 80129e2:	e156      	b.n	8012c92 <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 80129e4:	683b      	ldr	r3, [r7, #0]
 80129e6:	785b      	ldrb	r3, [r3, #1]
 80129e8:	2b03      	cmp	r3, #3
 80129ea:	d008      	beq.n	80129fe <USBD_StdEPReq+0x9a>
 80129ec:	2b03      	cmp	r3, #3
 80129ee:	f300 8145 	bgt.w	8012c7c <USBD_StdEPReq+0x318>
 80129f2:	2b00      	cmp	r3, #0
 80129f4:	f000 809b 	beq.w	8012b2e <USBD_StdEPReq+0x1ca>
 80129f8:	2b01      	cmp	r3, #1
 80129fa:	d03c      	beq.n	8012a76 <USBD_StdEPReq+0x112>
 80129fc:	e13e      	b.n	8012c7c <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 80129fe:	687b      	ldr	r3, [r7, #4]
 8012a00:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012a04:	b2db      	uxtb	r3, r3
 8012a06:	2b02      	cmp	r3, #2
 8012a08:	d002      	beq.n	8012a10 <USBD_StdEPReq+0xac>
 8012a0a:	2b03      	cmp	r3, #3
 8012a0c:	d016      	beq.n	8012a3c <USBD_StdEPReq+0xd8>
 8012a0e:	e02c      	b.n	8012a6a <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8012a10:	7bbb      	ldrb	r3, [r7, #14]
 8012a12:	2b00      	cmp	r3, #0
 8012a14:	d00d      	beq.n	8012a32 <USBD_StdEPReq+0xce>
 8012a16:	7bbb      	ldrb	r3, [r7, #14]
 8012a18:	2b80      	cmp	r3, #128	; 0x80
 8012a1a:	d00a      	beq.n	8012a32 <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8012a1c:	7bbb      	ldrb	r3, [r7, #14]
 8012a1e:	4619      	mov	r1, r3
 8012a20:	6878      	ldr	r0, [r7, #4]
 8012a22:	f001 fb01 	bl	8014028 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8012a26:	2180      	movs	r1, #128	; 0x80
 8012a28:	6878      	ldr	r0, [r7, #4]
 8012a2a:	f001 fafd 	bl	8014028 <USBD_LL_StallEP>
 8012a2e:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8012a30:	e020      	b.n	8012a74 <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 8012a32:	6839      	ldr	r1, [r7, #0]
 8012a34:	6878      	ldr	r0, [r7, #4]
 8012a36:	f000 fc7a 	bl	801332e <USBD_CtlError>
              break;
 8012a3a:	e01b      	b.n	8012a74 <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8012a3c:	683b      	ldr	r3, [r7, #0]
 8012a3e:	885b      	ldrh	r3, [r3, #2]
 8012a40:	2b00      	cmp	r3, #0
 8012a42:	d10e      	bne.n	8012a62 <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8012a44:	7bbb      	ldrb	r3, [r7, #14]
 8012a46:	2b00      	cmp	r3, #0
 8012a48:	d00b      	beq.n	8012a62 <USBD_StdEPReq+0xfe>
 8012a4a:	7bbb      	ldrb	r3, [r7, #14]
 8012a4c:	2b80      	cmp	r3, #128	; 0x80
 8012a4e:	d008      	beq.n	8012a62 <USBD_StdEPReq+0xfe>
 8012a50:	683b      	ldr	r3, [r7, #0]
 8012a52:	88db      	ldrh	r3, [r3, #6]
 8012a54:	2b00      	cmp	r3, #0
 8012a56:	d104      	bne.n	8012a62 <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8012a58:	7bbb      	ldrb	r3, [r7, #14]
 8012a5a:	4619      	mov	r1, r3
 8012a5c:	6878      	ldr	r0, [r7, #4]
 8012a5e:	f001 fae3 	bl	8014028 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 8012a62:	6878      	ldr	r0, [r7, #4]
 8012a64:	f000 fd2e 	bl	80134c4 <USBD_CtlSendStatus>

              break;
 8012a68:	e004      	b.n	8012a74 <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 8012a6a:	6839      	ldr	r1, [r7, #0]
 8012a6c:	6878      	ldr	r0, [r7, #4]
 8012a6e:	f000 fc5e 	bl	801332e <USBD_CtlError>
              break;
 8012a72:	bf00      	nop
          }
          break;
 8012a74:	e107      	b.n	8012c86 <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 8012a76:	687b      	ldr	r3, [r7, #4]
 8012a78:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012a7c:	b2db      	uxtb	r3, r3
 8012a7e:	2b02      	cmp	r3, #2
 8012a80:	d002      	beq.n	8012a88 <USBD_StdEPReq+0x124>
 8012a82:	2b03      	cmp	r3, #3
 8012a84:	d016      	beq.n	8012ab4 <USBD_StdEPReq+0x150>
 8012a86:	e04b      	b.n	8012b20 <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8012a88:	7bbb      	ldrb	r3, [r7, #14]
 8012a8a:	2b00      	cmp	r3, #0
 8012a8c:	d00d      	beq.n	8012aaa <USBD_StdEPReq+0x146>
 8012a8e:	7bbb      	ldrb	r3, [r7, #14]
 8012a90:	2b80      	cmp	r3, #128	; 0x80
 8012a92:	d00a      	beq.n	8012aaa <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8012a94:	7bbb      	ldrb	r3, [r7, #14]
 8012a96:	4619      	mov	r1, r3
 8012a98:	6878      	ldr	r0, [r7, #4]
 8012a9a:	f001 fac5 	bl	8014028 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8012a9e:	2180      	movs	r1, #128	; 0x80
 8012aa0:	6878      	ldr	r0, [r7, #4]
 8012aa2:	f001 fac1 	bl	8014028 <USBD_LL_StallEP>
 8012aa6:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8012aa8:	e040      	b.n	8012b2c <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 8012aaa:	6839      	ldr	r1, [r7, #0]
 8012aac:	6878      	ldr	r0, [r7, #4]
 8012aae:	f000 fc3e 	bl	801332e <USBD_CtlError>
              break;
 8012ab2:	e03b      	b.n	8012b2c <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8012ab4:	683b      	ldr	r3, [r7, #0]
 8012ab6:	885b      	ldrh	r3, [r3, #2]
 8012ab8:	2b00      	cmp	r3, #0
 8012aba:	d136      	bne.n	8012b2a <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 8012abc:	7bbb      	ldrb	r3, [r7, #14]
 8012abe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012ac2:	2b00      	cmp	r3, #0
 8012ac4:	d004      	beq.n	8012ad0 <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8012ac6:	7bbb      	ldrb	r3, [r7, #14]
 8012ac8:	4619      	mov	r1, r3
 8012aca:	6878      	ldr	r0, [r7, #4]
 8012acc:	f001 fabf 	bl	801404e <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 8012ad0:	6878      	ldr	r0, [r7, #4]
 8012ad2:	f000 fcf7 	bl	80134c4 <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8012ad6:	7bbb      	ldrb	r3, [r7, #14]
 8012ad8:	4619      	mov	r1, r3
 8012ada:	6878      	ldr	r0, [r7, #4]
 8012adc:	f7ff fde2 	bl	80126a4 <USBD_CoreFindEP>
 8012ae0:	4603      	mov	r3, r0
 8012ae2:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8012ae4:	7b7b      	ldrb	r3, [r7, #13]
 8012ae6:	2bff      	cmp	r3, #255	; 0xff
 8012ae8:	d01f      	beq.n	8012b2a <USBD_StdEPReq+0x1c6>
 8012aea:	7b7b      	ldrb	r3, [r7, #13]
 8012aec:	2b00      	cmp	r3, #0
 8012aee:	d11c      	bne.n	8012b2a <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 8012af0:	7b7a      	ldrb	r2, [r7, #13]
 8012af2:	687b      	ldr	r3, [r7, #4]
 8012af4:	f8c3 22d4 	str.w	r2, [r3, #724]	; 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 8012af8:	7b7a      	ldrb	r2, [r7, #13]
 8012afa:	687b      	ldr	r3, [r7, #4]
 8012afc:	32ae      	adds	r2, #174	; 0xae
 8012afe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012b02:	689b      	ldr	r3, [r3, #8]
 8012b04:	2b00      	cmp	r3, #0
 8012b06:	d010      	beq.n	8012b2a <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8012b08:	7b7a      	ldrb	r2, [r7, #13]
 8012b0a:	687b      	ldr	r3, [r7, #4]
 8012b0c:	32ae      	adds	r2, #174	; 0xae
 8012b0e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012b12:	689b      	ldr	r3, [r3, #8]
 8012b14:	6839      	ldr	r1, [r7, #0]
 8012b16:	6878      	ldr	r0, [r7, #4]
 8012b18:	4798      	blx	r3
 8012b1a:	4603      	mov	r3, r0
 8012b1c:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 8012b1e:	e004      	b.n	8012b2a <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 8012b20:	6839      	ldr	r1, [r7, #0]
 8012b22:	6878      	ldr	r0, [r7, #4]
 8012b24:	f000 fc03 	bl	801332e <USBD_CtlError>
              break;
 8012b28:	e000      	b.n	8012b2c <USBD_StdEPReq+0x1c8>
              break;
 8012b2a:	bf00      	nop
          }
          break;
 8012b2c:	e0ab      	b.n	8012c86 <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 8012b2e:	687b      	ldr	r3, [r7, #4]
 8012b30:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012b34:	b2db      	uxtb	r3, r3
 8012b36:	2b02      	cmp	r3, #2
 8012b38:	d002      	beq.n	8012b40 <USBD_StdEPReq+0x1dc>
 8012b3a:	2b03      	cmp	r3, #3
 8012b3c:	d032      	beq.n	8012ba4 <USBD_StdEPReq+0x240>
 8012b3e:	e097      	b.n	8012c70 <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8012b40:	7bbb      	ldrb	r3, [r7, #14]
 8012b42:	2b00      	cmp	r3, #0
 8012b44:	d007      	beq.n	8012b56 <USBD_StdEPReq+0x1f2>
 8012b46:	7bbb      	ldrb	r3, [r7, #14]
 8012b48:	2b80      	cmp	r3, #128	; 0x80
 8012b4a:	d004      	beq.n	8012b56 <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 8012b4c:	6839      	ldr	r1, [r7, #0]
 8012b4e:	6878      	ldr	r0, [r7, #4]
 8012b50:	f000 fbed 	bl	801332e <USBD_CtlError>
                break;
 8012b54:	e091      	b.n	8012c7a <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012b56:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8012b5a:	2b00      	cmp	r3, #0
 8012b5c:	da0b      	bge.n	8012b76 <USBD_StdEPReq+0x212>
 8012b5e:	7bbb      	ldrb	r3, [r7, #14]
 8012b60:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8012b64:	4613      	mov	r3, r2
 8012b66:	009b      	lsls	r3, r3, #2
 8012b68:	4413      	add	r3, r2
 8012b6a:	009b      	lsls	r3, r3, #2
 8012b6c:	3310      	adds	r3, #16
 8012b6e:	687a      	ldr	r2, [r7, #4]
 8012b70:	4413      	add	r3, r2
 8012b72:	3304      	adds	r3, #4
 8012b74:	e00b      	b.n	8012b8e <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8012b76:	7bbb      	ldrb	r3, [r7, #14]
 8012b78:	f003 027f 	and.w	r2, r3, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012b7c:	4613      	mov	r3, r2
 8012b7e:	009b      	lsls	r3, r3, #2
 8012b80:	4413      	add	r3, r2
 8012b82:	009b      	lsls	r3, r3, #2
 8012b84:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8012b88:	687a      	ldr	r2, [r7, #4]
 8012b8a:	4413      	add	r3, r2
 8012b8c:	3304      	adds	r3, #4
 8012b8e:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 8012b90:	68bb      	ldr	r3, [r7, #8]
 8012b92:	2200      	movs	r2, #0
 8012b94:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8012b96:	68bb      	ldr	r3, [r7, #8]
 8012b98:	2202      	movs	r2, #2
 8012b9a:	4619      	mov	r1, r3
 8012b9c:	6878      	ldr	r0, [r7, #4]
 8012b9e:	f000 fc37 	bl	8013410 <USBD_CtlSendData>
              break;
 8012ba2:	e06a      	b.n	8012c7a <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 8012ba4:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8012ba8:	2b00      	cmp	r3, #0
 8012baa:	da11      	bge.n	8012bd0 <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8012bac:	7bbb      	ldrb	r3, [r7, #14]
 8012bae:	f003 020f 	and.w	r2, r3, #15
 8012bb2:	6879      	ldr	r1, [r7, #4]
 8012bb4:	4613      	mov	r3, r2
 8012bb6:	009b      	lsls	r3, r3, #2
 8012bb8:	4413      	add	r3, r2
 8012bba:	009b      	lsls	r3, r3, #2
 8012bbc:	440b      	add	r3, r1
 8012bbe:	3324      	adds	r3, #36	; 0x24
 8012bc0:	881b      	ldrh	r3, [r3, #0]
 8012bc2:	2b00      	cmp	r3, #0
 8012bc4:	d117      	bne.n	8012bf6 <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8012bc6:	6839      	ldr	r1, [r7, #0]
 8012bc8:	6878      	ldr	r0, [r7, #4]
 8012bca:	f000 fbb0 	bl	801332e <USBD_CtlError>
                  break;
 8012bce:	e054      	b.n	8012c7a <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8012bd0:	7bbb      	ldrb	r3, [r7, #14]
 8012bd2:	f003 020f 	and.w	r2, r3, #15
 8012bd6:	6879      	ldr	r1, [r7, #4]
 8012bd8:	4613      	mov	r3, r2
 8012bda:	009b      	lsls	r3, r3, #2
 8012bdc:	4413      	add	r3, r2
 8012bde:	009b      	lsls	r3, r3, #2
 8012be0:	440b      	add	r3, r1
 8012be2:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 8012be6:	881b      	ldrh	r3, [r3, #0]
 8012be8:	2b00      	cmp	r3, #0
 8012bea:	d104      	bne.n	8012bf6 <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8012bec:	6839      	ldr	r1, [r7, #0]
 8012bee:	6878      	ldr	r0, [r7, #4]
 8012bf0:	f000 fb9d 	bl	801332e <USBD_CtlError>
                  break;
 8012bf4:	e041      	b.n	8012c7a <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012bf6:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8012bfa:	2b00      	cmp	r3, #0
 8012bfc:	da0b      	bge.n	8012c16 <USBD_StdEPReq+0x2b2>
 8012bfe:	7bbb      	ldrb	r3, [r7, #14]
 8012c00:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8012c04:	4613      	mov	r3, r2
 8012c06:	009b      	lsls	r3, r3, #2
 8012c08:	4413      	add	r3, r2
 8012c0a:	009b      	lsls	r3, r3, #2
 8012c0c:	3310      	adds	r3, #16
 8012c0e:	687a      	ldr	r2, [r7, #4]
 8012c10:	4413      	add	r3, r2
 8012c12:	3304      	adds	r3, #4
 8012c14:	e00b      	b.n	8012c2e <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8012c16:	7bbb      	ldrb	r3, [r7, #14]
 8012c18:	f003 027f 	and.w	r2, r3, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8012c1c:	4613      	mov	r3, r2
 8012c1e:	009b      	lsls	r3, r3, #2
 8012c20:	4413      	add	r3, r2
 8012c22:	009b      	lsls	r3, r3, #2
 8012c24:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8012c28:	687a      	ldr	r2, [r7, #4]
 8012c2a:	4413      	add	r3, r2
 8012c2c:	3304      	adds	r3, #4
 8012c2e:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8012c30:	7bbb      	ldrb	r3, [r7, #14]
 8012c32:	2b00      	cmp	r3, #0
 8012c34:	d002      	beq.n	8012c3c <USBD_StdEPReq+0x2d8>
 8012c36:	7bbb      	ldrb	r3, [r7, #14]
 8012c38:	2b80      	cmp	r3, #128	; 0x80
 8012c3a:	d103      	bne.n	8012c44 <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 8012c3c:	68bb      	ldr	r3, [r7, #8]
 8012c3e:	2200      	movs	r2, #0
 8012c40:	601a      	str	r2, [r3, #0]
 8012c42:	e00e      	b.n	8012c62 <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8012c44:	7bbb      	ldrb	r3, [r7, #14]
 8012c46:	4619      	mov	r1, r3
 8012c48:	6878      	ldr	r0, [r7, #4]
 8012c4a:	f001 fa13 	bl	8014074 <USBD_LL_IsStallEP>
 8012c4e:	4603      	mov	r3, r0
 8012c50:	2b00      	cmp	r3, #0
 8012c52:	d003      	beq.n	8012c5c <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 8012c54:	68bb      	ldr	r3, [r7, #8]
 8012c56:	2201      	movs	r2, #1
 8012c58:	601a      	str	r2, [r3, #0]
 8012c5a:	e002      	b.n	8012c62 <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 8012c5c:	68bb      	ldr	r3, [r7, #8]
 8012c5e:	2200      	movs	r2, #0
 8012c60:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8012c62:	68bb      	ldr	r3, [r7, #8]
 8012c64:	2202      	movs	r2, #2
 8012c66:	4619      	mov	r1, r3
 8012c68:	6878      	ldr	r0, [r7, #4]
 8012c6a:	f000 fbd1 	bl	8013410 <USBD_CtlSendData>
              break;
 8012c6e:	e004      	b.n	8012c7a <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 8012c70:	6839      	ldr	r1, [r7, #0]
 8012c72:	6878      	ldr	r0, [r7, #4]
 8012c74:	f000 fb5b 	bl	801332e <USBD_CtlError>
              break;
 8012c78:	bf00      	nop
          }
          break;
 8012c7a:	e004      	b.n	8012c86 <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 8012c7c:	6839      	ldr	r1, [r7, #0]
 8012c7e:	6878      	ldr	r0, [r7, #4]
 8012c80:	f000 fb55 	bl	801332e <USBD_CtlError>
          break;
 8012c84:	bf00      	nop
      }
      break;
 8012c86:	e005      	b.n	8012c94 <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 8012c88:	6839      	ldr	r1, [r7, #0]
 8012c8a:	6878      	ldr	r0, [r7, #4]
 8012c8c:	f000 fb4f 	bl	801332e <USBD_CtlError>
      break;
 8012c90:	e000      	b.n	8012c94 <USBD_StdEPReq+0x330>
      break;
 8012c92:	bf00      	nop
  }

  return ret;
 8012c94:	7bfb      	ldrb	r3, [r7, #15]
}
 8012c96:	4618      	mov	r0, r3
 8012c98:	3710      	adds	r7, #16
 8012c9a:	46bd      	mov	sp, r7
 8012c9c:	bd80      	pop	{r7, pc}
	...

08012ca0 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012ca0:	b580      	push	{r7, lr}
 8012ca2:	b084      	sub	sp, #16
 8012ca4:	af00      	add	r7, sp, #0
 8012ca6:	6078      	str	r0, [r7, #4]
 8012ca8:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8012caa:	2300      	movs	r3, #0
 8012cac:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 8012cae:	2300      	movs	r3, #0
 8012cb0:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 8012cb2:	2300      	movs	r3, #0
 8012cb4:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 8012cb6:	683b      	ldr	r3, [r7, #0]
 8012cb8:	885b      	ldrh	r3, [r3, #2]
 8012cba:	0a1b      	lsrs	r3, r3, #8
 8012cbc:	b29b      	uxth	r3, r3
 8012cbe:	3b01      	subs	r3, #1
 8012cc0:	2b06      	cmp	r3, #6
 8012cc2:	f200 8128 	bhi.w	8012f16 <USBD_GetDescriptor+0x276>
 8012cc6:	a201      	add	r2, pc, #4	; (adr r2, 8012ccc <USBD_GetDescriptor+0x2c>)
 8012cc8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012ccc:	08012ce9 	.word	0x08012ce9
 8012cd0:	08012d01 	.word	0x08012d01
 8012cd4:	08012d41 	.word	0x08012d41
 8012cd8:	08012f17 	.word	0x08012f17
 8012cdc:	08012f17 	.word	0x08012f17
 8012ce0:	08012eb7 	.word	0x08012eb7
 8012ce4:	08012ee3 	.word	0x08012ee3
        err++;
      }
      break;
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8012ce8:	687b      	ldr	r3, [r7, #4]
 8012cea:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012cee:	681b      	ldr	r3, [r3, #0]
 8012cf0:	687a      	ldr	r2, [r7, #4]
 8012cf2:	7c12      	ldrb	r2, [r2, #16]
 8012cf4:	f107 0108 	add.w	r1, r7, #8
 8012cf8:	4610      	mov	r0, r2
 8012cfa:	4798      	blx	r3
 8012cfc:	60f8      	str	r0, [r7, #12]
      break;
 8012cfe:	e112      	b.n	8012f26 <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012d00:	687b      	ldr	r3, [r7, #4]
 8012d02:	7c1b      	ldrb	r3, [r3, #16]
 8012d04:	2b00      	cmp	r3, #0
 8012d06:	d10d      	bne.n	8012d24 <USBD_GetDescriptor+0x84>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 8012d08:	687b      	ldr	r3, [r7, #4]
 8012d0a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012d0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012d10:	f107 0208 	add.w	r2, r7, #8
 8012d14:	4610      	mov	r0, r2
 8012d16:	4798      	blx	r3
 8012d18:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8012d1a:	68fb      	ldr	r3, [r7, #12]
 8012d1c:	3301      	adds	r3, #1
 8012d1e:	2202      	movs	r2, #2
 8012d20:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 8012d22:	e100      	b.n	8012f26 <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 8012d24:	687b      	ldr	r3, [r7, #4]
 8012d26:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012d2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012d2c:	f107 0208 	add.w	r2, r7, #8
 8012d30:	4610      	mov	r0, r2
 8012d32:	4798      	blx	r3
 8012d34:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8012d36:	68fb      	ldr	r3, [r7, #12]
 8012d38:	3301      	adds	r3, #1
 8012d3a:	2202      	movs	r2, #2
 8012d3c:	701a      	strb	r2, [r3, #0]
      break;
 8012d3e:	e0f2      	b.n	8012f26 <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 8012d40:	683b      	ldr	r3, [r7, #0]
 8012d42:	885b      	ldrh	r3, [r3, #2]
 8012d44:	b2db      	uxtb	r3, r3
 8012d46:	2b05      	cmp	r3, #5
 8012d48:	f200 80ac 	bhi.w	8012ea4 <USBD_GetDescriptor+0x204>
 8012d4c:	a201      	add	r2, pc, #4	; (adr r2, 8012d54 <USBD_GetDescriptor+0xb4>)
 8012d4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012d52:	bf00      	nop
 8012d54:	08012d6d 	.word	0x08012d6d
 8012d58:	08012da1 	.word	0x08012da1
 8012d5c:	08012dd5 	.word	0x08012dd5
 8012d60:	08012e09 	.word	0x08012e09
 8012d64:	08012e3d 	.word	0x08012e3d
 8012d68:	08012e71 	.word	0x08012e71
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8012d6c:	687b      	ldr	r3, [r7, #4]
 8012d6e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012d72:	685b      	ldr	r3, [r3, #4]
 8012d74:	2b00      	cmp	r3, #0
 8012d76:	d00b      	beq.n	8012d90 <USBD_GetDescriptor+0xf0>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8012d78:	687b      	ldr	r3, [r7, #4]
 8012d7a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012d7e:	685b      	ldr	r3, [r3, #4]
 8012d80:	687a      	ldr	r2, [r7, #4]
 8012d82:	7c12      	ldrb	r2, [r2, #16]
 8012d84:	f107 0108 	add.w	r1, r7, #8
 8012d88:	4610      	mov	r0, r2
 8012d8a:	4798      	blx	r3
 8012d8c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012d8e:	e091      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8012d90:	6839      	ldr	r1, [r7, #0]
 8012d92:	6878      	ldr	r0, [r7, #4]
 8012d94:	f000 facb 	bl	801332e <USBD_CtlError>
            err++;
 8012d98:	7afb      	ldrb	r3, [r7, #11]
 8012d9a:	3301      	adds	r3, #1
 8012d9c:	72fb      	strb	r3, [r7, #11]
          break;
 8012d9e:	e089      	b.n	8012eb4 <USBD_GetDescriptor+0x214>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8012da0:	687b      	ldr	r3, [r7, #4]
 8012da2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012da6:	689b      	ldr	r3, [r3, #8]
 8012da8:	2b00      	cmp	r3, #0
 8012daa:	d00b      	beq.n	8012dc4 <USBD_GetDescriptor+0x124>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8012dac:	687b      	ldr	r3, [r7, #4]
 8012dae:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012db2:	689b      	ldr	r3, [r3, #8]
 8012db4:	687a      	ldr	r2, [r7, #4]
 8012db6:	7c12      	ldrb	r2, [r2, #16]
 8012db8:	f107 0108 	add.w	r1, r7, #8
 8012dbc:	4610      	mov	r0, r2
 8012dbe:	4798      	blx	r3
 8012dc0:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012dc2:	e077      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8012dc4:	6839      	ldr	r1, [r7, #0]
 8012dc6:	6878      	ldr	r0, [r7, #4]
 8012dc8:	f000 fab1 	bl	801332e <USBD_CtlError>
            err++;
 8012dcc:	7afb      	ldrb	r3, [r7, #11]
 8012dce:	3301      	adds	r3, #1
 8012dd0:	72fb      	strb	r3, [r7, #11]
          break;
 8012dd2:	e06f      	b.n	8012eb4 <USBD_GetDescriptor+0x214>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8012dd4:	687b      	ldr	r3, [r7, #4]
 8012dd6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012dda:	68db      	ldr	r3, [r3, #12]
 8012ddc:	2b00      	cmp	r3, #0
 8012dde:	d00b      	beq.n	8012df8 <USBD_GetDescriptor+0x158>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8012de0:	687b      	ldr	r3, [r7, #4]
 8012de2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012de6:	68db      	ldr	r3, [r3, #12]
 8012de8:	687a      	ldr	r2, [r7, #4]
 8012dea:	7c12      	ldrb	r2, [r2, #16]
 8012dec:	f107 0108 	add.w	r1, r7, #8
 8012df0:	4610      	mov	r0, r2
 8012df2:	4798      	blx	r3
 8012df4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012df6:	e05d      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8012df8:	6839      	ldr	r1, [r7, #0]
 8012dfa:	6878      	ldr	r0, [r7, #4]
 8012dfc:	f000 fa97 	bl	801332e <USBD_CtlError>
            err++;
 8012e00:	7afb      	ldrb	r3, [r7, #11]
 8012e02:	3301      	adds	r3, #1
 8012e04:	72fb      	strb	r3, [r7, #11]
          break;
 8012e06:	e055      	b.n	8012eb4 <USBD_GetDescriptor+0x214>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8012e08:	687b      	ldr	r3, [r7, #4]
 8012e0a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012e0e:	691b      	ldr	r3, [r3, #16]
 8012e10:	2b00      	cmp	r3, #0
 8012e12:	d00b      	beq.n	8012e2c <USBD_GetDescriptor+0x18c>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8012e14:	687b      	ldr	r3, [r7, #4]
 8012e16:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012e1a:	691b      	ldr	r3, [r3, #16]
 8012e1c:	687a      	ldr	r2, [r7, #4]
 8012e1e:	7c12      	ldrb	r2, [r2, #16]
 8012e20:	f107 0108 	add.w	r1, r7, #8
 8012e24:	4610      	mov	r0, r2
 8012e26:	4798      	blx	r3
 8012e28:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012e2a:	e043      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8012e2c:	6839      	ldr	r1, [r7, #0]
 8012e2e:	6878      	ldr	r0, [r7, #4]
 8012e30:	f000 fa7d 	bl	801332e <USBD_CtlError>
            err++;
 8012e34:	7afb      	ldrb	r3, [r7, #11]
 8012e36:	3301      	adds	r3, #1
 8012e38:	72fb      	strb	r3, [r7, #11]
          break;
 8012e3a:	e03b      	b.n	8012eb4 <USBD_GetDescriptor+0x214>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8012e3c:	687b      	ldr	r3, [r7, #4]
 8012e3e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012e42:	695b      	ldr	r3, [r3, #20]
 8012e44:	2b00      	cmp	r3, #0
 8012e46:	d00b      	beq.n	8012e60 <USBD_GetDescriptor+0x1c0>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8012e48:	687b      	ldr	r3, [r7, #4]
 8012e4a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012e4e:	695b      	ldr	r3, [r3, #20]
 8012e50:	687a      	ldr	r2, [r7, #4]
 8012e52:	7c12      	ldrb	r2, [r2, #16]
 8012e54:	f107 0108 	add.w	r1, r7, #8
 8012e58:	4610      	mov	r0, r2
 8012e5a:	4798      	blx	r3
 8012e5c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012e5e:	e029      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8012e60:	6839      	ldr	r1, [r7, #0]
 8012e62:	6878      	ldr	r0, [r7, #4]
 8012e64:	f000 fa63 	bl	801332e <USBD_CtlError>
            err++;
 8012e68:	7afb      	ldrb	r3, [r7, #11]
 8012e6a:	3301      	adds	r3, #1
 8012e6c:	72fb      	strb	r3, [r7, #11]
          break;
 8012e6e:	e021      	b.n	8012eb4 <USBD_GetDescriptor+0x214>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8012e70:	687b      	ldr	r3, [r7, #4]
 8012e72:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012e76:	699b      	ldr	r3, [r3, #24]
 8012e78:	2b00      	cmp	r3, #0
 8012e7a:	d00b      	beq.n	8012e94 <USBD_GetDescriptor+0x1f4>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8012e7c:	687b      	ldr	r3, [r7, #4]
 8012e7e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8012e82:	699b      	ldr	r3, [r3, #24]
 8012e84:	687a      	ldr	r2, [r7, #4]
 8012e86:	7c12      	ldrb	r2, [r2, #16]
 8012e88:	f107 0108 	add.w	r1, r7, #8
 8012e8c:	4610      	mov	r0, r2
 8012e8e:	4798      	blx	r3
 8012e90:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8012e92:	e00f      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 8012e94:	6839      	ldr	r1, [r7, #0]
 8012e96:	6878      	ldr	r0, [r7, #4]
 8012e98:	f000 fa49 	bl	801332e <USBD_CtlError>
            err++;
 8012e9c:	7afb      	ldrb	r3, [r7, #11]
 8012e9e:	3301      	adds	r3, #1
 8012ea0:	72fb      	strb	r3, [r7, #11]
          break;
 8012ea2:	e007      	b.n	8012eb4 <USBD_GetDescriptor+0x214>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 8012ea4:	6839      	ldr	r1, [r7, #0]
 8012ea6:	6878      	ldr	r0, [r7, #4]
 8012ea8:	f000 fa41 	bl	801332e <USBD_CtlError>
          err++;
 8012eac:	7afb      	ldrb	r3, [r7, #11]
 8012eae:	3301      	adds	r3, #1
 8012eb0:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 8012eb2:	bf00      	nop
      }
      break;
 8012eb4:	e037      	b.n	8012f26 <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012eb6:	687b      	ldr	r3, [r7, #4]
 8012eb8:	7c1b      	ldrb	r3, [r3, #16]
 8012eba:	2b00      	cmp	r3, #0
 8012ebc:	d109      	bne.n	8012ed2 <USBD_GetDescriptor+0x232>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 8012ebe:	687b      	ldr	r3, [r7, #4]
 8012ec0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012ec4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012ec6:	f107 0208 	add.w	r2, r7, #8
 8012eca:	4610      	mov	r0, r2
 8012ecc:	4798      	blx	r3
 8012ece:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8012ed0:	e029      	b.n	8012f26 <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 8012ed2:	6839      	ldr	r1, [r7, #0]
 8012ed4:	6878      	ldr	r0, [r7, #4]
 8012ed6:	f000 fa2a 	bl	801332e <USBD_CtlError>
        err++;
 8012eda:	7afb      	ldrb	r3, [r7, #11]
 8012edc:	3301      	adds	r3, #1
 8012ede:	72fb      	strb	r3, [r7, #11]
      break;
 8012ee0:	e021      	b.n	8012f26 <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012ee2:	687b      	ldr	r3, [r7, #4]
 8012ee4:	7c1b      	ldrb	r3, [r3, #16]
 8012ee6:	2b00      	cmp	r3, #0
 8012ee8:	d10d      	bne.n	8012f06 <USBD_GetDescriptor+0x266>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 8012eea:	687b      	ldr	r3, [r7, #4]
 8012eec:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8012ef0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012ef2:	f107 0208 	add.w	r2, r7, #8
 8012ef6:	4610      	mov	r0, r2
 8012ef8:	4798      	blx	r3
 8012efa:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8012efc:	68fb      	ldr	r3, [r7, #12]
 8012efe:	3301      	adds	r3, #1
 8012f00:	2207      	movs	r2, #7
 8012f02:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8012f04:	e00f      	b.n	8012f26 <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 8012f06:	6839      	ldr	r1, [r7, #0]
 8012f08:	6878      	ldr	r0, [r7, #4]
 8012f0a:	f000 fa10 	bl	801332e <USBD_CtlError>
        err++;
 8012f0e:	7afb      	ldrb	r3, [r7, #11]
 8012f10:	3301      	adds	r3, #1
 8012f12:	72fb      	strb	r3, [r7, #11]
      break;
 8012f14:	e007      	b.n	8012f26 <USBD_GetDescriptor+0x286>

    default:
      USBD_CtlError(pdev, req);
 8012f16:	6839      	ldr	r1, [r7, #0]
 8012f18:	6878      	ldr	r0, [r7, #4]
 8012f1a:	f000 fa08 	bl	801332e <USBD_CtlError>
      err++;
 8012f1e:	7afb      	ldrb	r3, [r7, #11]
 8012f20:	3301      	adds	r3, #1
 8012f22:	72fb      	strb	r3, [r7, #11]
      break;
 8012f24:	bf00      	nop
  }

  if (err != 0U)
 8012f26:	7afb      	ldrb	r3, [r7, #11]
 8012f28:	2b00      	cmp	r3, #0
 8012f2a:	d11e      	bne.n	8012f6a <USBD_GetDescriptor+0x2ca>
  {
    return;
  }

  if (req->wLength != 0U)
 8012f2c:	683b      	ldr	r3, [r7, #0]
 8012f2e:	88db      	ldrh	r3, [r3, #6]
 8012f30:	2b00      	cmp	r3, #0
 8012f32:	d016      	beq.n	8012f62 <USBD_GetDescriptor+0x2c2>
  {
    if (len != 0U)
 8012f34:	893b      	ldrh	r3, [r7, #8]
 8012f36:	2b00      	cmp	r3, #0
 8012f38:	d00e      	beq.n	8012f58 <USBD_GetDescriptor+0x2b8>
    {
      len = MIN(len, req->wLength);
 8012f3a:	683b      	ldr	r3, [r7, #0]
 8012f3c:	88da      	ldrh	r2, [r3, #6]
 8012f3e:	893b      	ldrh	r3, [r7, #8]
 8012f40:	4293      	cmp	r3, r2
 8012f42:	bf28      	it	cs
 8012f44:	4613      	movcs	r3, r2
 8012f46:	b29b      	uxth	r3, r3
 8012f48:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8012f4a:	893b      	ldrh	r3, [r7, #8]
 8012f4c:	461a      	mov	r2, r3
 8012f4e:	68f9      	ldr	r1, [r7, #12]
 8012f50:	6878      	ldr	r0, [r7, #4]
 8012f52:	f000 fa5d 	bl	8013410 <USBD_CtlSendData>
 8012f56:	e009      	b.n	8012f6c <USBD_GetDescriptor+0x2cc>
    }
    else
    {
      USBD_CtlError(pdev, req);
 8012f58:	6839      	ldr	r1, [r7, #0]
 8012f5a:	6878      	ldr	r0, [r7, #4]
 8012f5c:	f000 f9e7 	bl	801332e <USBD_CtlError>
 8012f60:	e004      	b.n	8012f6c <USBD_GetDescriptor+0x2cc>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 8012f62:	6878      	ldr	r0, [r7, #4]
 8012f64:	f000 faae 	bl	80134c4 <USBD_CtlSendStatus>
 8012f68:	e000      	b.n	8012f6c <USBD_GetDescriptor+0x2cc>
    return;
 8012f6a:	bf00      	nop
  }
}
 8012f6c:	3710      	adds	r7, #16
 8012f6e:	46bd      	mov	sp, r7
 8012f70:	bd80      	pop	{r7, pc}
 8012f72:	bf00      	nop

08012f74 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012f74:	b580      	push	{r7, lr}
 8012f76:	b084      	sub	sp, #16
 8012f78:	af00      	add	r7, sp, #0
 8012f7a:	6078      	str	r0, [r7, #4]
 8012f7c:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8012f7e:	683b      	ldr	r3, [r7, #0]
 8012f80:	889b      	ldrh	r3, [r3, #4]
 8012f82:	2b00      	cmp	r3, #0
 8012f84:	d131      	bne.n	8012fea <USBD_SetAddress+0x76>
 8012f86:	683b      	ldr	r3, [r7, #0]
 8012f88:	88db      	ldrh	r3, [r3, #6]
 8012f8a:	2b00      	cmp	r3, #0
 8012f8c:	d12d      	bne.n	8012fea <USBD_SetAddress+0x76>
 8012f8e:	683b      	ldr	r3, [r7, #0]
 8012f90:	885b      	ldrh	r3, [r3, #2]
 8012f92:	2b7f      	cmp	r3, #127	; 0x7f
 8012f94:	d829      	bhi.n	8012fea <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8012f96:	683b      	ldr	r3, [r7, #0]
 8012f98:	885b      	ldrh	r3, [r3, #2]
 8012f9a:	b2db      	uxtb	r3, r3
 8012f9c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012fa0:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012fa2:	687b      	ldr	r3, [r7, #4]
 8012fa4:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8012fa8:	b2db      	uxtb	r3, r3
 8012faa:	2b03      	cmp	r3, #3
 8012fac:	d104      	bne.n	8012fb8 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 8012fae:	6839      	ldr	r1, [r7, #0]
 8012fb0:	6878      	ldr	r0, [r7, #4]
 8012fb2:	f000 f9bc 	bl	801332e <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012fb6:	e01d      	b.n	8012ff4 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 8012fb8:	687b      	ldr	r3, [r7, #4]
 8012fba:	7bfa      	ldrb	r2, [r7, #15]
 8012fbc:	f883 229e 	strb.w	r2, [r3, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 8012fc0:	7bfb      	ldrb	r3, [r7, #15]
 8012fc2:	4619      	mov	r1, r3
 8012fc4:	6878      	ldr	r0, [r7, #4]
 8012fc6:	f001 f881 	bl	80140cc <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 8012fca:	6878      	ldr	r0, [r7, #4]
 8012fcc:	f000 fa7a 	bl	80134c4 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 8012fd0:	7bfb      	ldrb	r3, [r7, #15]
 8012fd2:	2b00      	cmp	r3, #0
 8012fd4:	d004      	beq.n	8012fe0 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8012fd6:	687b      	ldr	r3, [r7, #4]
 8012fd8:	2202      	movs	r2, #2
 8012fda:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012fde:	e009      	b.n	8012ff4 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 8012fe0:	687b      	ldr	r3, [r7, #4]
 8012fe2:	2201      	movs	r2, #1
 8012fe4:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012fe8:	e004      	b.n	8012ff4 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 8012fea:	6839      	ldr	r1, [r7, #0]
 8012fec:	6878      	ldr	r0, [r7, #4]
 8012fee:	f000 f99e 	bl	801332e <USBD_CtlError>
  }
}
 8012ff2:	bf00      	nop
 8012ff4:	bf00      	nop
 8012ff6:	3710      	adds	r7, #16
 8012ff8:	46bd      	mov	sp, r7
 8012ffa:	bd80      	pop	{r7, pc}

08012ffc <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012ffc:	b580      	push	{r7, lr}
 8012ffe:	b084      	sub	sp, #16
 8013000:	af00      	add	r7, sp, #0
 8013002:	6078      	str	r0, [r7, #4]
 8013004:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8013006:	2300      	movs	r3, #0
 8013008:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 801300a:	683b      	ldr	r3, [r7, #0]
 801300c:	885b      	ldrh	r3, [r3, #2]
 801300e:	b2da      	uxtb	r2, r3
 8013010:	4b4e      	ldr	r3, [pc, #312]	; (801314c <USBD_SetConfig+0x150>)
 8013012:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8013014:	4b4d      	ldr	r3, [pc, #308]	; (801314c <USBD_SetConfig+0x150>)
 8013016:	781b      	ldrb	r3, [r3, #0]
 8013018:	2b01      	cmp	r3, #1
 801301a:	d905      	bls.n	8013028 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 801301c:	6839      	ldr	r1, [r7, #0]
 801301e:	6878      	ldr	r0, [r7, #4]
 8013020:	f000 f985 	bl	801332e <USBD_CtlError>
    return USBD_FAIL;
 8013024:	2303      	movs	r3, #3
 8013026:	e08c      	b.n	8013142 <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 8013028:	687b      	ldr	r3, [r7, #4]
 801302a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 801302e:	b2db      	uxtb	r3, r3
 8013030:	2b02      	cmp	r3, #2
 8013032:	d002      	beq.n	801303a <USBD_SetConfig+0x3e>
 8013034:	2b03      	cmp	r3, #3
 8013036:	d029      	beq.n	801308c <USBD_SetConfig+0x90>
 8013038:	e075      	b.n	8013126 <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 801303a:	4b44      	ldr	r3, [pc, #272]	; (801314c <USBD_SetConfig+0x150>)
 801303c:	781b      	ldrb	r3, [r3, #0]
 801303e:	2b00      	cmp	r3, #0
 8013040:	d020      	beq.n	8013084 <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 8013042:	4b42      	ldr	r3, [pc, #264]	; (801314c <USBD_SetConfig+0x150>)
 8013044:	781b      	ldrb	r3, [r3, #0]
 8013046:	461a      	mov	r2, r3
 8013048:	687b      	ldr	r3, [r7, #4]
 801304a:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 801304c:	4b3f      	ldr	r3, [pc, #252]	; (801314c <USBD_SetConfig+0x150>)
 801304e:	781b      	ldrb	r3, [r3, #0]
 8013050:	4619      	mov	r1, r3
 8013052:	6878      	ldr	r0, [r7, #4]
 8013054:	f7ff f873 	bl	801213e <USBD_SetClassConfig>
 8013058:	4603      	mov	r3, r0
 801305a:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 801305c:	7bfb      	ldrb	r3, [r7, #15]
 801305e:	2b00      	cmp	r3, #0
 8013060:	d008      	beq.n	8013074 <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 8013062:	6839      	ldr	r1, [r7, #0]
 8013064:	6878      	ldr	r0, [r7, #4]
 8013066:	f000 f962 	bl	801332e <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 801306a:	687b      	ldr	r3, [r7, #4]
 801306c:	2202      	movs	r2, #2
 801306e:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 8013072:	e065      	b.n	8013140 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 8013074:	6878      	ldr	r0, [r7, #4]
 8013076:	f000 fa25 	bl	80134c4 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 801307a:	687b      	ldr	r3, [r7, #4]
 801307c:	2203      	movs	r2, #3
 801307e:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      break;
 8013082:	e05d      	b.n	8013140 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 8013084:	6878      	ldr	r0, [r7, #4]
 8013086:	f000 fa1d 	bl	80134c4 <USBD_CtlSendStatus>
      break;
 801308a:	e059      	b.n	8013140 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 801308c:	4b2f      	ldr	r3, [pc, #188]	; (801314c <USBD_SetConfig+0x150>)
 801308e:	781b      	ldrb	r3, [r3, #0]
 8013090:	2b00      	cmp	r3, #0
 8013092:	d112      	bne.n	80130ba <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8013094:	687b      	ldr	r3, [r7, #4]
 8013096:	2202      	movs	r2, #2
 8013098:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
        pdev->dev_config = cfgidx;
 801309c:	4b2b      	ldr	r3, [pc, #172]	; (801314c <USBD_SetConfig+0x150>)
 801309e:	781b      	ldrb	r3, [r3, #0]
 80130a0:	461a      	mov	r2, r3
 80130a2:	687b      	ldr	r3, [r7, #4]
 80130a4:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 80130a6:	4b29      	ldr	r3, [pc, #164]	; (801314c <USBD_SetConfig+0x150>)
 80130a8:	781b      	ldrb	r3, [r3, #0]
 80130aa:	4619      	mov	r1, r3
 80130ac:	6878      	ldr	r0, [r7, #4]
 80130ae:	f7ff f862 	bl	8012176 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 80130b2:	6878      	ldr	r0, [r7, #4]
 80130b4:	f000 fa06 	bl	80134c4 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 80130b8:	e042      	b.n	8013140 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 80130ba:	4b24      	ldr	r3, [pc, #144]	; (801314c <USBD_SetConfig+0x150>)
 80130bc:	781b      	ldrb	r3, [r3, #0]
 80130be:	461a      	mov	r2, r3
 80130c0:	687b      	ldr	r3, [r7, #4]
 80130c2:	685b      	ldr	r3, [r3, #4]
 80130c4:	429a      	cmp	r2, r3
 80130c6:	d02a      	beq.n	801311e <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80130c8:	687b      	ldr	r3, [r7, #4]
 80130ca:	685b      	ldr	r3, [r3, #4]
 80130cc:	b2db      	uxtb	r3, r3
 80130ce:	4619      	mov	r1, r3
 80130d0:	6878      	ldr	r0, [r7, #4]
 80130d2:	f7ff f850 	bl	8012176 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 80130d6:	4b1d      	ldr	r3, [pc, #116]	; (801314c <USBD_SetConfig+0x150>)
 80130d8:	781b      	ldrb	r3, [r3, #0]
 80130da:	461a      	mov	r2, r3
 80130dc:	687b      	ldr	r3, [r7, #4]
 80130de:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80130e0:	4b1a      	ldr	r3, [pc, #104]	; (801314c <USBD_SetConfig+0x150>)
 80130e2:	781b      	ldrb	r3, [r3, #0]
 80130e4:	4619      	mov	r1, r3
 80130e6:	6878      	ldr	r0, [r7, #4]
 80130e8:	f7ff f829 	bl	801213e <USBD_SetClassConfig>
 80130ec:	4603      	mov	r3, r0
 80130ee:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 80130f0:	7bfb      	ldrb	r3, [r7, #15]
 80130f2:	2b00      	cmp	r3, #0
 80130f4:	d00f      	beq.n	8013116 <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 80130f6:	6839      	ldr	r1, [r7, #0]
 80130f8:	6878      	ldr	r0, [r7, #4]
 80130fa:	f000 f918 	bl	801332e <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80130fe:	687b      	ldr	r3, [r7, #4]
 8013100:	685b      	ldr	r3, [r3, #4]
 8013102:	b2db      	uxtb	r3, r3
 8013104:	4619      	mov	r1, r3
 8013106:	6878      	ldr	r0, [r7, #4]
 8013108:	f7ff f835 	bl	8012176 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 801310c:	687b      	ldr	r3, [r7, #4]
 801310e:	2202      	movs	r2, #2
 8013110:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      break;
 8013114:	e014      	b.n	8013140 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 8013116:	6878      	ldr	r0, [r7, #4]
 8013118:	f000 f9d4 	bl	80134c4 <USBD_CtlSendStatus>
      break;
 801311c:	e010      	b.n	8013140 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 801311e:	6878      	ldr	r0, [r7, #4]
 8013120:	f000 f9d0 	bl	80134c4 <USBD_CtlSendStatus>
      break;
 8013124:	e00c      	b.n	8013140 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 8013126:	6839      	ldr	r1, [r7, #0]
 8013128:	6878      	ldr	r0, [r7, #4]
 801312a:	f000 f900 	bl	801332e <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 801312e:	4b07      	ldr	r3, [pc, #28]	; (801314c <USBD_SetConfig+0x150>)
 8013130:	781b      	ldrb	r3, [r3, #0]
 8013132:	4619      	mov	r1, r3
 8013134:	6878      	ldr	r0, [r7, #4]
 8013136:	f7ff f81e 	bl	8012176 <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 801313a:	2303      	movs	r3, #3
 801313c:	73fb      	strb	r3, [r7, #15]
      break;
 801313e:	bf00      	nop
  }

  return ret;
 8013140:	7bfb      	ldrb	r3, [r7, #15]
}
 8013142:	4618      	mov	r0, r3
 8013144:	3710      	adds	r7, #16
 8013146:	46bd      	mov	sp, r7
 8013148:	bd80      	pop	{r7, pc}
 801314a:	bf00      	nop
 801314c:	20000dc8 	.word	0x20000dc8

08013150 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8013150:	b580      	push	{r7, lr}
 8013152:	b082      	sub	sp, #8
 8013154:	af00      	add	r7, sp, #0
 8013156:	6078      	str	r0, [r7, #4]
 8013158:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 801315a:	683b      	ldr	r3, [r7, #0]
 801315c:	88db      	ldrh	r3, [r3, #6]
 801315e:	2b01      	cmp	r3, #1
 8013160:	d004      	beq.n	801316c <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 8013162:	6839      	ldr	r1, [r7, #0]
 8013164:	6878      	ldr	r0, [r7, #4]
 8013166:	f000 f8e2 	bl	801332e <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 801316a:	e023      	b.n	80131b4 <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 801316c:	687b      	ldr	r3, [r7, #4]
 801316e:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8013172:	b2db      	uxtb	r3, r3
 8013174:	2b02      	cmp	r3, #2
 8013176:	dc02      	bgt.n	801317e <USBD_GetConfig+0x2e>
 8013178:	2b00      	cmp	r3, #0
 801317a:	dc03      	bgt.n	8013184 <USBD_GetConfig+0x34>
 801317c:	e015      	b.n	80131aa <USBD_GetConfig+0x5a>
 801317e:	2b03      	cmp	r3, #3
 8013180:	d00b      	beq.n	801319a <USBD_GetConfig+0x4a>
 8013182:	e012      	b.n	80131aa <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 8013184:	687b      	ldr	r3, [r7, #4]
 8013186:	2200      	movs	r2, #0
 8013188:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 801318a:	687b      	ldr	r3, [r7, #4]
 801318c:	3308      	adds	r3, #8
 801318e:	2201      	movs	r2, #1
 8013190:	4619      	mov	r1, r3
 8013192:	6878      	ldr	r0, [r7, #4]
 8013194:	f000 f93c 	bl	8013410 <USBD_CtlSendData>
        break;
 8013198:	e00c      	b.n	80131b4 <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 801319a:	687b      	ldr	r3, [r7, #4]
 801319c:	3304      	adds	r3, #4
 801319e:	2201      	movs	r2, #1
 80131a0:	4619      	mov	r1, r3
 80131a2:	6878      	ldr	r0, [r7, #4]
 80131a4:	f000 f934 	bl	8013410 <USBD_CtlSendData>
        break;
 80131a8:	e004      	b.n	80131b4 <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 80131aa:	6839      	ldr	r1, [r7, #0]
 80131ac:	6878      	ldr	r0, [r7, #4]
 80131ae:	f000 f8be 	bl	801332e <USBD_CtlError>
        break;
 80131b2:	bf00      	nop
}
 80131b4:	bf00      	nop
 80131b6:	3708      	adds	r7, #8
 80131b8:	46bd      	mov	sp, r7
 80131ba:	bd80      	pop	{r7, pc}

080131bc <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80131bc:	b580      	push	{r7, lr}
 80131be:	b082      	sub	sp, #8
 80131c0:	af00      	add	r7, sp, #0
 80131c2:	6078      	str	r0, [r7, #4]
 80131c4:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 80131c6:	687b      	ldr	r3, [r7, #4]
 80131c8:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80131cc:	b2db      	uxtb	r3, r3
 80131ce:	3b01      	subs	r3, #1
 80131d0:	2b02      	cmp	r3, #2
 80131d2:	d81e      	bhi.n	8013212 <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 80131d4:	683b      	ldr	r3, [r7, #0]
 80131d6:	88db      	ldrh	r3, [r3, #6]
 80131d8:	2b02      	cmp	r3, #2
 80131da:	d004      	beq.n	80131e6 <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 80131dc:	6839      	ldr	r1, [r7, #0]
 80131de:	6878      	ldr	r0, [r7, #4]
 80131e0:	f000 f8a5 	bl	801332e <USBD_CtlError>
        break;
 80131e4:	e01a      	b.n	801321c <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80131e6:	687b      	ldr	r3, [r7, #4]
 80131e8:	2201      	movs	r2, #1
 80131ea:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 80131ec:	687b      	ldr	r3, [r7, #4]
 80131ee:	f8d3 32a4 	ldr.w	r3, [r3, #676]	; 0x2a4
 80131f2:	2b00      	cmp	r3, #0
 80131f4:	d005      	beq.n	8013202 <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80131f6:	687b      	ldr	r3, [r7, #4]
 80131f8:	68db      	ldr	r3, [r3, #12]
 80131fa:	f043 0202 	orr.w	r2, r3, #2
 80131fe:	687b      	ldr	r3, [r7, #4]
 8013200:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 8013202:	687b      	ldr	r3, [r7, #4]
 8013204:	330c      	adds	r3, #12
 8013206:	2202      	movs	r2, #2
 8013208:	4619      	mov	r1, r3
 801320a:	6878      	ldr	r0, [r7, #4]
 801320c:	f000 f900 	bl	8013410 <USBD_CtlSendData>
      break;
 8013210:	e004      	b.n	801321c <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 8013212:	6839      	ldr	r1, [r7, #0]
 8013214:	6878      	ldr	r0, [r7, #4]
 8013216:	f000 f88a 	bl	801332e <USBD_CtlError>
      break;
 801321a:	bf00      	nop
  }
}
 801321c:	bf00      	nop
 801321e:	3708      	adds	r7, #8
 8013220:	46bd      	mov	sp, r7
 8013222:	bd80      	pop	{r7, pc}

08013224 <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8013224:	b580      	push	{r7, lr}
 8013226:	b082      	sub	sp, #8
 8013228:	af00      	add	r7, sp, #0
 801322a:	6078      	str	r0, [r7, #4]
 801322c:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801322e:	683b      	ldr	r3, [r7, #0]
 8013230:	885b      	ldrh	r3, [r3, #2]
 8013232:	2b01      	cmp	r3, #1
 8013234:	d107      	bne.n	8013246 <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 8013236:	687b      	ldr	r3, [r7, #4]
 8013238:	2201      	movs	r2, #1
 801323a:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 801323e:	6878      	ldr	r0, [r7, #4]
 8013240:	f000 f940 	bl	80134c4 <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 8013244:	e013      	b.n	801326e <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 8013246:	683b      	ldr	r3, [r7, #0]
 8013248:	885b      	ldrh	r3, [r3, #2]
 801324a:	2b02      	cmp	r3, #2
 801324c:	d10b      	bne.n	8013266 <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 801324e:	683b      	ldr	r3, [r7, #0]
 8013250:	889b      	ldrh	r3, [r3, #4]
 8013252:	0a1b      	lsrs	r3, r3, #8
 8013254:	b29b      	uxth	r3, r3
 8013256:	b2da      	uxtb	r2, r3
 8013258:	687b      	ldr	r3, [r7, #4]
 801325a:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 801325e:	6878      	ldr	r0, [r7, #4]
 8013260:	f000 f930 	bl	80134c4 <USBD_CtlSendStatus>
}
 8013264:	e003      	b.n	801326e <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 8013266:	6839      	ldr	r1, [r7, #0]
 8013268:	6878      	ldr	r0, [r7, #4]
 801326a:	f000 f860 	bl	801332e <USBD_CtlError>
}
 801326e:	bf00      	nop
 8013270:	3708      	adds	r7, #8
 8013272:	46bd      	mov	sp, r7
 8013274:	bd80      	pop	{r7, pc}

08013276 <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8013276:	b580      	push	{r7, lr}
 8013278:	b082      	sub	sp, #8
 801327a:	af00      	add	r7, sp, #0
 801327c:	6078      	str	r0, [r7, #4]
 801327e:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 8013280:	687b      	ldr	r3, [r7, #4]
 8013282:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8013286:	b2db      	uxtb	r3, r3
 8013288:	3b01      	subs	r3, #1
 801328a:	2b02      	cmp	r3, #2
 801328c:	d80b      	bhi.n	80132a6 <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801328e:	683b      	ldr	r3, [r7, #0]
 8013290:	885b      	ldrh	r3, [r3, #2]
 8013292:	2b01      	cmp	r3, #1
 8013294:	d10c      	bne.n	80132b0 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 8013296:	687b      	ldr	r3, [r7, #4]
 8013298:	2200      	movs	r2, #0
 801329a:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 801329e:	6878      	ldr	r0, [r7, #4]
 80132a0:	f000 f910 	bl	80134c4 <USBD_CtlSendStatus>
      }
      break;
 80132a4:	e004      	b.n	80132b0 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 80132a6:	6839      	ldr	r1, [r7, #0]
 80132a8:	6878      	ldr	r0, [r7, #4]
 80132aa:	f000 f840 	bl	801332e <USBD_CtlError>
      break;
 80132ae:	e000      	b.n	80132b2 <USBD_ClrFeature+0x3c>
      break;
 80132b0:	bf00      	nop
  }
}
 80132b2:	bf00      	nop
 80132b4:	3708      	adds	r7, #8
 80132b6:	46bd      	mov	sp, r7
 80132b8:	bd80      	pop	{r7, pc}

080132ba <USBD_ParseSetupRequest>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 80132ba:	b580      	push	{r7, lr}
 80132bc:	b084      	sub	sp, #16
 80132be:	af00      	add	r7, sp, #0
 80132c0:	6078      	str	r0, [r7, #4]
 80132c2:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 80132c4:	683b      	ldr	r3, [r7, #0]
 80132c6:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 80132c8:	68fb      	ldr	r3, [r7, #12]
 80132ca:	781a      	ldrb	r2, [r3, #0]
 80132cc:	687b      	ldr	r3, [r7, #4]
 80132ce:	701a      	strb	r2, [r3, #0]

  pbuff++;
 80132d0:	68fb      	ldr	r3, [r7, #12]
 80132d2:	3301      	adds	r3, #1
 80132d4:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 80132d6:	68fb      	ldr	r3, [r7, #12]
 80132d8:	781a      	ldrb	r2, [r3, #0]
 80132da:	687b      	ldr	r3, [r7, #4]
 80132dc:	705a      	strb	r2, [r3, #1]

  pbuff++;
 80132de:	68fb      	ldr	r3, [r7, #12]
 80132e0:	3301      	adds	r3, #1
 80132e2:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 80132e4:	68f8      	ldr	r0, [r7, #12]
 80132e6:	f7ff fa41 	bl	801276c <SWAPBYTE>
 80132ea:	4603      	mov	r3, r0
 80132ec:	461a      	mov	r2, r3
 80132ee:	687b      	ldr	r3, [r7, #4]
 80132f0:	805a      	strh	r2, [r3, #2]

  pbuff++;
 80132f2:	68fb      	ldr	r3, [r7, #12]
 80132f4:	3301      	adds	r3, #1
 80132f6:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80132f8:	68fb      	ldr	r3, [r7, #12]
 80132fa:	3301      	adds	r3, #1
 80132fc:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 80132fe:	68f8      	ldr	r0, [r7, #12]
 8013300:	f7ff fa34 	bl	801276c <SWAPBYTE>
 8013304:	4603      	mov	r3, r0
 8013306:	461a      	mov	r2, r3
 8013308:	687b      	ldr	r3, [r7, #4]
 801330a:	809a      	strh	r2, [r3, #4]

  pbuff++;
 801330c:	68fb      	ldr	r3, [r7, #12]
 801330e:	3301      	adds	r3, #1
 8013310:	60fb      	str	r3, [r7, #12]
  pbuff++;
 8013312:	68fb      	ldr	r3, [r7, #12]
 8013314:	3301      	adds	r3, #1
 8013316:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 8013318:	68f8      	ldr	r0, [r7, #12]
 801331a:	f7ff fa27 	bl	801276c <SWAPBYTE>
 801331e:	4603      	mov	r3, r0
 8013320:	461a      	mov	r2, r3
 8013322:	687b      	ldr	r3, [r7, #4]
 8013324:	80da      	strh	r2, [r3, #6]
}
 8013326:	bf00      	nop
 8013328:	3710      	adds	r7, #16
 801332a:	46bd      	mov	sp, r7
 801332c:	bd80      	pop	{r7, pc}

0801332e <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801332e:	b580      	push	{r7, lr}
 8013330:	b082      	sub	sp, #8
 8013332:	af00      	add	r7, sp, #0
 8013334:	6078      	str	r0, [r7, #4]
 8013336:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 8013338:	2180      	movs	r1, #128	; 0x80
 801333a:	6878      	ldr	r0, [r7, #4]
 801333c:	f000 fe74 	bl	8014028 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013340:	2100      	movs	r1, #0
 8013342:	6878      	ldr	r0, [r7, #4]
 8013344:	f000 fe70 	bl	8014028 <USBD_LL_StallEP>
}
 8013348:	bf00      	nop
 801334a:	3708      	adds	r7, #8
 801334c:	46bd      	mov	sp, r7
 801334e:	bd80      	pop	{r7, pc}

08013350 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8013350:	b580      	push	{r7, lr}
 8013352:	b086      	sub	sp, #24
 8013354:	af00      	add	r7, sp, #0
 8013356:	60f8      	str	r0, [r7, #12]
 8013358:	60b9      	str	r1, [r7, #8]
 801335a:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 801335c:	2300      	movs	r3, #0
 801335e:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 8013360:	68fb      	ldr	r3, [r7, #12]
 8013362:	2b00      	cmp	r3, #0
 8013364:	d036      	beq.n	80133d4 <USBD_GetString+0x84>
  {
    return;
  }

  pdesc = desc;
 8013366:	68fb      	ldr	r3, [r7, #12]
 8013368:	613b      	str	r3, [r7, #16]
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 801336a:	6938      	ldr	r0, [r7, #16]
 801336c:	f000 f836 	bl	80133dc <USBD_GetLen>
 8013370:	4603      	mov	r3, r0
 8013372:	3301      	adds	r3, #1
 8013374:	b29b      	uxth	r3, r3
 8013376:	005b      	lsls	r3, r3, #1
 8013378:	b29a      	uxth	r2, r3
 801337a:	687b      	ldr	r3, [r7, #4]
 801337c:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 801337e:	7dfb      	ldrb	r3, [r7, #23]
 8013380:	68ba      	ldr	r2, [r7, #8]
 8013382:	4413      	add	r3, r2
 8013384:	687a      	ldr	r2, [r7, #4]
 8013386:	7812      	ldrb	r2, [r2, #0]
 8013388:	701a      	strb	r2, [r3, #0]
  idx++;
 801338a:	7dfb      	ldrb	r3, [r7, #23]
 801338c:	3301      	adds	r3, #1
 801338e:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8013390:	7dfb      	ldrb	r3, [r7, #23]
 8013392:	68ba      	ldr	r2, [r7, #8]
 8013394:	4413      	add	r3, r2
 8013396:	2203      	movs	r2, #3
 8013398:	701a      	strb	r2, [r3, #0]
  idx++;
 801339a:	7dfb      	ldrb	r3, [r7, #23]
 801339c:	3301      	adds	r3, #1
 801339e:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 80133a0:	e013      	b.n	80133ca <USBD_GetString+0x7a>
  {
    unicode[idx] = *pdesc;
 80133a2:	7dfb      	ldrb	r3, [r7, #23]
 80133a4:	68ba      	ldr	r2, [r7, #8]
 80133a6:	4413      	add	r3, r2
 80133a8:	693a      	ldr	r2, [r7, #16]
 80133aa:	7812      	ldrb	r2, [r2, #0]
 80133ac:	701a      	strb	r2, [r3, #0]
    pdesc++;
 80133ae:	693b      	ldr	r3, [r7, #16]
 80133b0:	3301      	adds	r3, #1
 80133b2:	613b      	str	r3, [r7, #16]
    idx++;
 80133b4:	7dfb      	ldrb	r3, [r7, #23]
 80133b6:	3301      	adds	r3, #1
 80133b8:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 80133ba:	7dfb      	ldrb	r3, [r7, #23]
 80133bc:	68ba      	ldr	r2, [r7, #8]
 80133be:	4413      	add	r3, r2
 80133c0:	2200      	movs	r2, #0
 80133c2:	701a      	strb	r2, [r3, #0]
    idx++;
 80133c4:	7dfb      	ldrb	r3, [r7, #23]
 80133c6:	3301      	adds	r3, #1
 80133c8:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 80133ca:	693b      	ldr	r3, [r7, #16]
 80133cc:	781b      	ldrb	r3, [r3, #0]
 80133ce:	2b00      	cmp	r3, #0
 80133d0:	d1e7      	bne.n	80133a2 <USBD_GetString+0x52>
 80133d2:	e000      	b.n	80133d6 <USBD_GetString+0x86>
    return;
 80133d4:	bf00      	nop
  }
}
 80133d6:	3718      	adds	r7, #24
 80133d8:	46bd      	mov	sp, r7
 80133da:	bd80      	pop	{r7, pc}

080133dc <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 80133dc:	b480      	push	{r7}
 80133de:	b085      	sub	sp, #20
 80133e0:	af00      	add	r7, sp, #0
 80133e2:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 80133e4:	2300      	movs	r3, #0
 80133e6:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 80133e8:	687b      	ldr	r3, [r7, #4]
 80133ea:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 80133ec:	e005      	b.n	80133fa <USBD_GetLen+0x1e>
  {
    len++;
 80133ee:	7bfb      	ldrb	r3, [r7, #15]
 80133f0:	3301      	adds	r3, #1
 80133f2:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 80133f4:	68bb      	ldr	r3, [r7, #8]
 80133f6:	3301      	adds	r3, #1
 80133f8:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 80133fa:	68bb      	ldr	r3, [r7, #8]
 80133fc:	781b      	ldrb	r3, [r3, #0]
 80133fe:	2b00      	cmp	r3, #0
 8013400:	d1f5      	bne.n	80133ee <USBD_GetLen+0x12>
  }

  return len;
 8013402:	7bfb      	ldrb	r3, [r7, #15]
}
 8013404:	4618      	mov	r0, r3
 8013406:	3714      	adds	r7, #20
 8013408:	46bd      	mov	sp, r7
 801340a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801340e:	4770      	bx	lr

08013410 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8013410:	b580      	push	{r7, lr}
 8013412:	b084      	sub	sp, #16
 8013414:	af00      	add	r7, sp, #0
 8013416:	60f8      	str	r0, [r7, #12]
 8013418:	60b9      	str	r1, [r7, #8]
 801341a:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 801341c:	68fb      	ldr	r3, [r7, #12]
 801341e:	2202      	movs	r2, #2
 8013420:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_in[0].total_length = len;
 8013424:	68fb      	ldr	r3, [r7, #12]
 8013426:	687a      	ldr	r2, [r7, #4]
 8013428:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 801342a:	68fb      	ldr	r3, [r7, #12]
 801342c:	687a      	ldr	r2, [r7, #4]
 801342e:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8013430:	687b      	ldr	r3, [r7, #4]
 8013432:	68ba      	ldr	r2, [r7, #8]
 8013434:	2100      	movs	r1, #0
 8013436:	68f8      	ldr	r0, [r7, #12]
 8013438:	f000 fe5b 	bl	80140f2 <USBD_LL_Transmit>

  return USBD_OK;
 801343c:	2300      	movs	r3, #0
}
 801343e:	4618      	mov	r0, r3
 8013440:	3710      	adds	r7, #16
 8013442:	46bd      	mov	sp, r7
 8013444:	bd80      	pop	{r7, pc}

08013446 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 8013446:	b580      	push	{r7, lr}
 8013448:	b084      	sub	sp, #16
 801344a:	af00      	add	r7, sp, #0
 801344c:	60f8      	str	r0, [r7, #12]
 801344e:	60b9      	str	r1, [r7, #8]
 8013450:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8013452:	687b      	ldr	r3, [r7, #4]
 8013454:	68ba      	ldr	r2, [r7, #8]
 8013456:	2100      	movs	r1, #0
 8013458:	68f8      	ldr	r0, [r7, #12]
 801345a:	f000 fe4a 	bl	80140f2 <USBD_LL_Transmit>

  return USBD_OK;
 801345e:	2300      	movs	r3, #0
}
 8013460:	4618      	mov	r0, r3
 8013462:	3710      	adds	r7, #16
 8013464:	46bd      	mov	sp, r7
 8013466:	bd80      	pop	{r7, pc}

08013468 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 8013468:	b580      	push	{r7, lr}
 801346a:	b084      	sub	sp, #16
 801346c:	af00      	add	r7, sp, #0
 801346e:	60f8      	str	r0, [r7, #12]
 8013470:	60b9      	str	r1, [r7, #8]
 8013472:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8013474:	68fb      	ldr	r3, [r7, #12]
 8013476:	2203      	movs	r2, #3
 8013478:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_out[0].total_length = len;
 801347c:	68fb      	ldr	r3, [r7, #12]
 801347e:	687a      	ldr	r2, [r7, #4]
 8013480:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8013484:	68fb      	ldr	r3, [r7, #12]
 8013486:	687a      	ldr	r2, [r7, #4]
 8013488:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801348c:	687b      	ldr	r3, [r7, #4]
 801348e:	68ba      	ldr	r2, [r7, #8]
 8013490:	2100      	movs	r1, #0
 8013492:	68f8      	ldr	r0, [r7, #12]
 8013494:	f000 fe42 	bl	801411c <USBD_LL_PrepareReceive>

  return USBD_OK;
 8013498:	2300      	movs	r3, #0
}
 801349a:	4618      	mov	r0, r3
 801349c:	3710      	adds	r7, #16
 801349e:	46bd      	mov	sp, r7
 80134a0:	bd80      	pop	{r7, pc}

080134a2 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 80134a2:	b580      	push	{r7, lr}
 80134a4:	b084      	sub	sp, #16
 80134a6:	af00      	add	r7, sp, #0
 80134a8:	60f8      	str	r0, [r7, #12]
 80134aa:	60b9      	str	r1, [r7, #8]
 80134ac:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 80134ae:	687b      	ldr	r3, [r7, #4]
 80134b0:	68ba      	ldr	r2, [r7, #8]
 80134b2:	2100      	movs	r1, #0
 80134b4:	68f8      	ldr	r0, [r7, #12]
 80134b6:	f000 fe31 	bl	801411c <USBD_LL_PrepareReceive>

  return USBD_OK;
 80134ba:	2300      	movs	r3, #0
}
 80134bc:	4618      	mov	r0, r3
 80134be:	3710      	adds	r7, #16
 80134c0:	46bd      	mov	sp, r7
 80134c2:	bd80      	pop	{r7, pc}

080134c4 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 80134c4:	b580      	push	{r7, lr}
 80134c6:	b082      	sub	sp, #8
 80134c8:	af00      	add	r7, sp, #0
 80134ca:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80134cc:	687b      	ldr	r3, [r7, #4]
 80134ce:	2204      	movs	r2, #4
 80134d0:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80134d4:	2300      	movs	r3, #0
 80134d6:	2200      	movs	r2, #0
 80134d8:	2100      	movs	r1, #0
 80134da:	6878      	ldr	r0, [r7, #4]
 80134dc:	f000 fe09 	bl	80140f2 <USBD_LL_Transmit>

  return USBD_OK;
 80134e0:	2300      	movs	r3, #0
}
 80134e2:	4618      	mov	r0, r3
 80134e4:	3708      	adds	r7, #8
 80134e6:	46bd      	mov	sp, r7
 80134e8:	bd80      	pop	{r7, pc}

080134ea <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80134ea:	b580      	push	{r7, lr}
 80134ec:	b082      	sub	sp, #8
 80134ee:	af00      	add	r7, sp, #0
 80134f0:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80134f2:	687b      	ldr	r3, [r7, #4]
 80134f4:	2205      	movs	r2, #5
 80134f6:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80134fa:	2300      	movs	r3, #0
 80134fc:	2200      	movs	r2, #0
 80134fe:	2100      	movs	r1, #0
 8013500:	6878      	ldr	r0, [r7, #4]
 8013502:	f000 fe0b 	bl	801411c <USBD_LL_PrepareReceive>

  return USBD_OK;
 8013506:	2300      	movs	r3, #0
}
 8013508:	4618      	mov	r0, r3
 801350a:	3708      	adds	r7, #8
 801350c:	46bd      	mov	sp, r7
 801350e:	bd80      	pop	{r7, pc}

08013510 <SHCI_C2_ZIGBEE_Init>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_ZIGBEE_Init( void )
{
 8013510:	b580      	push	{r7, lr}
 8013512:	b086      	sub	sp, #24
 8013514:	af00      	add	r7, sp, #0
   * Buffer is large enough to hold command complete without payload
   */
  uint8_t local_buffer[TL_BLEEVT_CC_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;
 8013516:	1d3b      	adds	r3, r7, #4
 8013518:	617b      	str	r3, [r7, #20]

  shci_send( SHCI_OPCODE_C2_ZIGBEE_INIT,
 801351a:	697b      	ldr	r3, [r7, #20]
 801351c:	2200      	movs	r2, #0
 801351e:	2100      	movs	r1, #0
 8013520:	f64f 4070 	movw	r0, #64624	; 0xfc70
 8013524:	f000 f920 	bl	8013768 <shci_send>
             0,
             0,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
 8013528:	697b      	ldr	r3, [r7, #20]
 801352a:	330b      	adds	r3, #11
 801352c:	78db      	ldrb	r3, [r3, #3]
}
 801352e:	4618      	mov	r0, r3
 8013530:	3718      	adds	r7, #24
 8013532:	46bd      	mov	sp, r7
 8013534:	bd80      	pop	{r7, pc}
	...

08013538 <SHCI_GetWirelessFwInfo>:
 *  Local System COMMAND
 *  These commands are NOT sent to the CPU2
 */

SHCI_CmdStatus_t SHCI_GetWirelessFwInfo( WirelessFwInfo_t* pWirelessInfo )
{
 8013538:	b480      	push	{r7}
 801353a:	b08b      	sub	sp, #44	; 0x2c
 801353c:	af00      	add	r7, sp, #0
 801353e:	6078      	str	r0, [r7, #4]
  uint32_t ipccdba = 0;
 8013540:	2300      	movs	r3, #0
 8013542:	613b      	str	r3, [r7, #16]
  MB_RefTable_t * p_RefTable = NULL;
 8013544:	2300      	movs	r3, #0
 8013546:	60fb      	str	r3, [r7, #12]
  uint32_t wireless_firmware_version = 0;
 8013548:	2300      	movs	r3, #0
 801354a:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t wireless_firmware_memorySize = 0;
 801354c:	2300      	movs	r3, #0
 801354e:	623b      	str	r3, [r7, #32]
  uint32_t wireless_firmware_infoStack = 0;
 8013550:	2300      	movs	r3, #0
 8013552:	61fb      	str	r3, [r7, #28]
  MB_FUS_DeviceInfoTable_t * p_fus_device_info_table = NULL;
 8013554:	2300      	movs	r3, #0
 8013556:	60bb      	str	r3, [r7, #8]
  uint32_t fus_version = 0;
 8013558:	2300      	movs	r3, #0
 801355a:	61bb      	str	r3, [r7, #24]
  uint32_t fus_memorySize = 0;
 801355c:	2300      	movs	r3, #0
 801355e:	617b      	str	r3, [r7, #20]

  ipccdba = READ_BIT( FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA );
 8013560:	4b4a      	ldr	r3, [pc, #296]	; (801368c <SHCI_GetWirelessFwInfo+0x154>)
 8013562:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013564:	f3c3 030d 	ubfx	r3, r3, #0, #14
 8013568:	613b      	str	r3, [r7, #16]
  /**
   * The Device Info Table mapping depends on which firmware is running on CPU2.
   * If the FUS is running on CPU2, FUS_DEVICE_INFO_TABLE_VALIDITY_KEYWORD shall be written in the table.
   * Otherwise, it means the Wireless Firmware is running on the CPU2
   */
  p_fus_device_info_table = (MB_FUS_DeviceInfoTable_t*)(*(uint32_t*)((ipccdba<<2) + SRAM2A_BASE));
 801356a:	693b      	ldr	r3, [r7, #16]
 801356c:	009b      	lsls	r3, r3, #2
 801356e:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8013572:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
 8013576:	681b      	ldr	r3, [r3, #0]
 8013578:	60bb      	str	r3, [r7, #8]

  if(p_fus_device_info_table->DeviceInfoTableState == FUS_DEVICE_INFO_TABLE_VALIDITY_KEYWORD)
 801357a:	68bb      	ldr	r3, [r7, #8]
 801357c:	681b      	ldr	r3, [r3, #0]
 801357e:	4a44      	ldr	r2, [pc, #272]	; (8013690 <SHCI_GetWirelessFwInfo+0x158>)
 8013580:	4293      	cmp	r3, r2
 8013582:	d10f      	bne.n	80135a4 <SHCI_GetWirelessFwInfo+0x6c>
    /* The FUS is running on CPU2 */
    /**
     *  Retrieve the WirelessFwInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    wireless_firmware_version =  p_fus_device_info_table->WirelessStackVersion;
 8013584:	68bb      	ldr	r3, [r7, #8]
 8013586:	695b      	ldr	r3, [r3, #20]
 8013588:	627b      	str	r3, [r7, #36]	; 0x24
    wireless_firmware_memorySize =  p_fus_device_info_table->WirelessStackMemorySize;
 801358a:	68bb      	ldr	r3, [r7, #8]
 801358c:	699b      	ldr	r3, [r3, #24]
 801358e:	623b      	str	r3, [r7, #32]
    wireless_firmware_infoStack =  p_fus_device_info_table->WirelessFirmwareBleInfo;
 8013590:	68bb      	ldr	r3, [r7, #8]
 8013592:	69db      	ldr	r3, [r3, #28]
 8013594:	61fb      	str	r3, [r7, #28]

    /**
     *  Retrieve the FusInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    fus_version =  p_fus_device_info_table->FusVersion;
 8013596:	68bb      	ldr	r3, [r7, #8]
 8013598:	68db      	ldr	r3, [r3, #12]
 801359a:	61bb      	str	r3, [r7, #24]
    fus_memorySize =  p_fus_device_info_table->FusMemorySize;
 801359c:	68bb      	ldr	r3, [r7, #8]
 801359e:	691b      	ldr	r3, [r3, #16]
 80135a0:	617b      	str	r3, [r7, #20]
 80135a2:	e01a      	b.n	80135da <SHCI_GetWirelessFwInfo+0xa2>
  }
  else
  {
    /* The Wireless Firmware is running on CPU2 */
    p_RefTable = (MB_RefTable_t*)((ipccdba<<2) + SRAM2A_BASE);
 80135a4:	693b      	ldr	r3, [r7, #16]
 80135a6:	009b      	lsls	r3, r3, #2
 80135a8:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80135ac:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
 80135b0:	60fb      	str	r3, [r7, #12]

    /**
     *  Retrieve the WirelessFwInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    wireless_firmware_version =  p_RefTable->p_device_info_table->WirelessFwInfoTable.Version;
 80135b2:	68fb      	ldr	r3, [r7, #12]
 80135b4:	681b      	ldr	r3, [r3, #0]
 80135b6:	691b      	ldr	r3, [r3, #16]
 80135b8:	627b      	str	r3, [r7, #36]	; 0x24
    wireless_firmware_memorySize =  p_RefTable->p_device_info_table->WirelessFwInfoTable.MemorySize;
 80135ba:	68fb      	ldr	r3, [r7, #12]
 80135bc:	681b      	ldr	r3, [r3, #0]
 80135be:	695b      	ldr	r3, [r3, #20]
 80135c0:	623b      	str	r3, [r7, #32]
    wireless_firmware_infoStack =  p_RefTable->p_device_info_table->WirelessFwInfoTable.InfoStack;
 80135c2:	68fb      	ldr	r3, [r7, #12]
 80135c4:	681b      	ldr	r3, [r3, #0]
 80135c6:	699b      	ldr	r3, [r3, #24]
 80135c8:	61fb      	str	r3, [r7, #28]

    /**
     *  Retrieve the FusInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    fus_version =  p_RefTable->p_device_info_table->FusInfoTable.Version;
 80135ca:	68fb      	ldr	r3, [r7, #12]
 80135cc:	681b      	ldr	r3, [r3, #0]
 80135ce:	685b      	ldr	r3, [r3, #4]
 80135d0:	61bb      	str	r3, [r7, #24]
    fus_memorySize =  p_RefTable->p_device_info_table->FusInfoTable.MemorySize;
 80135d2:	68fb      	ldr	r3, [r7, #12]
 80135d4:	681b      	ldr	r3, [r3, #0]
 80135d6:	689b      	ldr	r3, [r3, #8]
 80135d8:	617b      	str	r3, [r7, #20]

  /**
   *  Retrieve the WirelessFwInfoTable
   *  This table is stored in RAM at startup during the TL (transport layer) initialization
   */
  pWirelessInfo->VersionMajor       = ((wireless_firmware_version & INFO_VERSION_MAJOR_MASK) >> INFO_VERSION_MAJOR_OFFSET);
 80135da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80135dc:	0e1b      	lsrs	r3, r3, #24
 80135de:	b2da      	uxtb	r2, r3
 80135e0:	687b      	ldr	r3, [r7, #4]
 80135e2:	701a      	strb	r2, [r3, #0]
  pWirelessInfo->VersionMinor       = ((wireless_firmware_version & INFO_VERSION_MINOR_MASK) >> INFO_VERSION_MINOR_OFFSET);
 80135e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80135e6:	0c1b      	lsrs	r3, r3, #16
 80135e8:	b2da      	uxtb	r2, r3
 80135ea:	687b      	ldr	r3, [r7, #4]
 80135ec:	705a      	strb	r2, [r3, #1]
  pWirelessInfo->VersionSub         = ((wireless_firmware_version & INFO_VERSION_SUB_MASK) >> INFO_VERSION_SUB_OFFSET);
 80135ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80135f0:	0a1b      	lsrs	r3, r3, #8
 80135f2:	b2da      	uxtb	r2, r3
 80135f4:	687b      	ldr	r3, [r7, #4]
 80135f6:	709a      	strb	r2, [r3, #2]
  pWirelessInfo->VersionBranch      = ((wireless_firmware_version & INFO_VERSION_BRANCH_MASK) >> INFO_VERSION_BRANCH_OFFSET);
 80135f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80135fa:	091b      	lsrs	r3, r3, #4
 80135fc:	b2db      	uxtb	r3, r3
 80135fe:	f003 030f 	and.w	r3, r3, #15
 8013602:	b2da      	uxtb	r2, r3
 8013604:	687b      	ldr	r3, [r7, #4]
 8013606:	70da      	strb	r2, [r3, #3]
  pWirelessInfo->VersionReleaseType = ((wireless_firmware_version & INFO_VERSION_TYPE_MASK) >> INFO_VERSION_TYPE_OFFSET);
 8013608:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801360a:	b2db      	uxtb	r3, r3
 801360c:	f003 030f 	and.w	r3, r3, #15
 8013610:	b2da      	uxtb	r2, r3
 8013612:	687b      	ldr	r3, [r7, #4]
 8013614:	711a      	strb	r2, [r3, #4]

  pWirelessInfo->MemorySizeSram2B   = ((wireless_firmware_memorySize & INFO_SIZE_SRAM2B_MASK) >> INFO_SIZE_SRAM2B_OFFSET);
 8013616:	6a3b      	ldr	r3, [r7, #32]
 8013618:	0e1b      	lsrs	r3, r3, #24
 801361a:	b2da      	uxtb	r2, r3
 801361c:	687b      	ldr	r3, [r7, #4]
 801361e:	715a      	strb	r2, [r3, #5]
  pWirelessInfo->MemorySizeSram2A   = ((wireless_firmware_memorySize & INFO_SIZE_SRAM2A_MASK) >> INFO_SIZE_SRAM2A_OFFSET);
 8013620:	6a3b      	ldr	r3, [r7, #32]
 8013622:	0c1b      	lsrs	r3, r3, #16
 8013624:	b2da      	uxtb	r2, r3
 8013626:	687b      	ldr	r3, [r7, #4]
 8013628:	719a      	strb	r2, [r3, #6]
  pWirelessInfo->MemorySizeSram1    = ((wireless_firmware_memorySize & INFO_SIZE_SRAM1_MASK) >> INFO_SIZE_SRAM1_OFFSET);
 801362a:	6a3b      	ldr	r3, [r7, #32]
 801362c:	0a1b      	lsrs	r3, r3, #8
 801362e:	b2da      	uxtb	r2, r3
 8013630:	687b      	ldr	r3, [r7, #4]
 8013632:	71da      	strb	r2, [r3, #7]
  pWirelessInfo->MemorySizeFlash    = ((wireless_firmware_memorySize & INFO_SIZE_FLASH_MASK) >> INFO_SIZE_FLASH_OFFSET);
 8013634:	6a3b      	ldr	r3, [r7, #32]
 8013636:	b2da      	uxtb	r2, r3
 8013638:	687b      	ldr	r3, [r7, #4]
 801363a:	721a      	strb	r2, [r3, #8]

  pWirelessInfo->StackType          = ((wireless_firmware_infoStack & INFO_STACK_TYPE_MASK) >> INFO_STACK_TYPE_OFFSET);
 801363c:	69fb      	ldr	r3, [r7, #28]
 801363e:	b2da      	uxtb	r2, r3
 8013640:	687b      	ldr	r3, [r7, #4]
 8013642:	725a      	strb	r2, [r3, #9]

  /**
   *  Retrieve the FusInfoTable
   *  This table is stored in RAM at startup during the TL (transport layer) initialization
   */
  pWirelessInfo->FusVersionMajor       = ((fus_version & INFO_VERSION_MAJOR_MASK) >> INFO_VERSION_MAJOR_OFFSET);
 8013644:	69bb      	ldr	r3, [r7, #24]
 8013646:	0e1b      	lsrs	r3, r3, #24
 8013648:	b2da      	uxtb	r2, r3
 801364a:	687b      	ldr	r3, [r7, #4]
 801364c:	729a      	strb	r2, [r3, #10]
  pWirelessInfo->FusVersionMinor       = ((fus_version & INFO_VERSION_MINOR_MASK) >> INFO_VERSION_MINOR_OFFSET);
 801364e:	69bb      	ldr	r3, [r7, #24]
 8013650:	0c1b      	lsrs	r3, r3, #16
 8013652:	b2da      	uxtb	r2, r3
 8013654:	687b      	ldr	r3, [r7, #4]
 8013656:	72da      	strb	r2, [r3, #11]
  pWirelessInfo->FusVersionSub         = ((fus_version & INFO_VERSION_SUB_MASK) >> INFO_VERSION_SUB_OFFSET);
 8013658:	69bb      	ldr	r3, [r7, #24]
 801365a:	0a1b      	lsrs	r3, r3, #8
 801365c:	b2da      	uxtb	r2, r3
 801365e:	687b      	ldr	r3, [r7, #4]
 8013660:	731a      	strb	r2, [r3, #12]

  pWirelessInfo->FusMemorySizeSram2B   = ((fus_memorySize & INFO_SIZE_SRAM2B_MASK) >> INFO_SIZE_SRAM2B_OFFSET);
 8013662:	697b      	ldr	r3, [r7, #20]
 8013664:	0e1b      	lsrs	r3, r3, #24
 8013666:	b2da      	uxtb	r2, r3
 8013668:	687b      	ldr	r3, [r7, #4]
 801366a:	735a      	strb	r2, [r3, #13]
  pWirelessInfo->FusMemorySizeSram2A   = ((fus_memorySize & INFO_SIZE_SRAM2A_MASK) >> INFO_SIZE_SRAM2A_OFFSET);
 801366c:	697b      	ldr	r3, [r7, #20]
 801366e:	0c1b      	lsrs	r3, r3, #16
 8013670:	b2da      	uxtb	r2, r3
 8013672:	687b      	ldr	r3, [r7, #4]
 8013674:	739a      	strb	r2, [r3, #14]
  pWirelessInfo->FusMemorySizeFlash    = ((fus_memorySize & INFO_SIZE_FLASH_MASK) >> INFO_SIZE_FLASH_OFFSET);
 8013676:	697b      	ldr	r3, [r7, #20]
 8013678:	b2da      	uxtb	r2, r3
 801367a:	687b      	ldr	r3, [r7, #4]
 801367c:	73da      	strb	r2, [r3, #15]

  return (SHCI_Success);
 801367e:	2300      	movs	r3, #0
}
 8013680:	4618      	mov	r0, r3
 8013682:	372c      	adds	r7, #44	; 0x2c
 8013684:	46bd      	mov	sp, r7
 8013686:	f85d 7b04 	ldr.w	r7, [sp], #4
 801368a:	4770      	bx	lr
 801368c:	58004000 	.word	0x58004000
 8013690:	a94656b9 	.word	0xa94656b9

08013694 <shci_init>:
static void TlUserEvtReceived(TL_EvtPacket_t *shcievt);
static void TlInit( TL_CmdPacket_t * p_cmdbuffer );

/* Interface ------- ---------------------------------------------------------*/
void shci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 8013694:	b580      	push	{r7, lr}
 8013696:	b082      	sub	sp, #8
 8013698:	af00      	add	r7, sp, #0
 801369a:	6078      	str	r0, [r7, #4]
 801369c:	6039      	str	r1, [r7, #0]
  StatusNotCallBackFunction = ((SHCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 801369e:	683b      	ldr	r3, [r7, #0]
 80136a0:	685b      	ldr	r3, [r3, #4]
 80136a2:	4a08      	ldr	r2, [pc, #32]	; (80136c4 <shci_init+0x30>)
 80136a4:	6013      	str	r3, [r2, #0]
  shciContext.UserEvtRx = UserEvtRx;
 80136a6:	4a08      	ldr	r2, [pc, #32]	; (80136c8 <shci_init+0x34>)
 80136a8:	687b      	ldr	r3, [r7, #4]
 80136aa:	61d3      	str	r3, [r2, #28]

  shci_register_io_bus (&shciContext.io);
 80136ac:	4806      	ldr	r0, [pc, #24]	; (80136c8 <shci_init+0x34>)
 80136ae:	f000 f915 	bl	80138dc <shci_register_io_bus>

  TlInit((TL_CmdPacket_t *)(((SHCI_TL_HciInitConf_t *)pConf)->p_cmdbuffer));
 80136b2:	683b      	ldr	r3, [r7, #0]
 80136b4:	681b      	ldr	r3, [r3, #0]
 80136b6:	4618      	mov	r0, r3
 80136b8:	f000 f898 	bl	80137ec <TlInit>

  return;
 80136bc:	bf00      	nop
}
 80136be:	3708      	adds	r7, #8
 80136c0:	46bd      	mov	sp, r7
 80136c2:	bd80      	pop	{r7, pc}
 80136c4:	20000dec 	.word	0x20000dec
 80136c8:	20000dcc 	.word	0x20000dcc

080136cc <shci_user_evt_proc>:

void shci_user_evt_proc(void)
{
 80136cc:	b580      	push	{r7, lr}
 80136ce:	b084      	sub	sp, #16
 80136d0:	af00      	add	r7, sp, #0

  /**
   * It is more secure to use LST_remove_head()/LST_insert_head() compare to LST_get_next_node()/LST_remove_node()
   * in case the user overwrite the header where the next/prev pointers are located
   */
  if((LST_is_empty(&SHciAsynchEventQueue) == FALSE) && (SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable))
 80136d2:	4822      	ldr	r0, [pc, #136]	; (801375c <shci_user_evt_proc+0x90>)
 80136d4:	f001 f8cc 	bl	8014870 <LST_is_empty>
 80136d8:	4603      	mov	r3, r0
 80136da:	2b00      	cmp	r3, #0
 80136dc:	d12b      	bne.n	8013736 <shci_user_evt_proc+0x6a>
 80136de:	4b20      	ldr	r3, [pc, #128]	; (8013760 <shci_user_evt_proc+0x94>)
 80136e0:	781b      	ldrb	r3, [r3, #0]
 80136e2:	2b00      	cmp	r3, #0
 80136e4:	d027      	beq.n	8013736 <shci_user_evt_proc+0x6a>
  {
    LST_remove_head ( &SHciAsynchEventQueue, (tListNode **)&phcievtbuffer );
 80136e6:	f107 030c 	add.w	r3, r7, #12
 80136ea:	4619      	mov	r1, r3
 80136ec:	481b      	ldr	r0, [pc, #108]	; (801375c <shci_user_evt_proc+0x90>)
 80136ee:	f001 f94e 	bl	801498e <LST_remove_head>

    if (shciContext.UserEvtRx != NULL)
 80136f2:	4b1c      	ldr	r3, [pc, #112]	; (8013764 <shci_user_evt_proc+0x98>)
 80136f4:	69db      	ldr	r3, [r3, #28]
 80136f6:	2b00      	cmp	r3, #0
 80136f8:	d00c      	beq.n	8013714 <shci_user_evt_proc+0x48>
    {
      UserEvtRxParam.pckt = phcievtbuffer;
 80136fa:	68fb      	ldr	r3, [r7, #12]
 80136fc:	60bb      	str	r3, [r7, #8]
      UserEvtRxParam.status = SHCI_TL_UserEventFlow_Enable;
 80136fe:	2301      	movs	r3, #1
 8013700:	713b      	strb	r3, [r7, #4]
      shciContext.UserEvtRx((void *)&UserEvtRxParam);
 8013702:	4b18      	ldr	r3, [pc, #96]	; (8013764 <shci_user_evt_proc+0x98>)
 8013704:	69db      	ldr	r3, [r3, #28]
 8013706:	1d3a      	adds	r2, r7, #4
 8013708:	4610      	mov	r0, r2
 801370a:	4798      	blx	r3
      SHCI_TL_UserEventFlow = UserEvtRxParam.status;
 801370c:	793a      	ldrb	r2, [r7, #4]
 801370e:	4b14      	ldr	r3, [pc, #80]	; (8013760 <shci_user_evt_proc+0x94>)
 8013710:	701a      	strb	r2, [r3, #0]
 8013712:	e002      	b.n	801371a <shci_user_evt_proc+0x4e>
    }
    else
    {
      SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 8013714:	4b12      	ldr	r3, [pc, #72]	; (8013760 <shci_user_evt_proc+0x94>)
 8013716:	2201      	movs	r2, #1
 8013718:	701a      	strb	r2, [r3, #0]
    }

    if(SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable)
 801371a:	4b11      	ldr	r3, [pc, #68]	; (8013760 <shci_user_evt_proc+0x94>)
 801371c:	781b      	ldrb	r3, [r3, #0]
 801371e:	2b00      	cmp	r3, #0
 8013720:	d004      	beq.n	801372c <shci_user_evt_proc+0x60>
    {
      TL_MM_EvtDone( phcievtbuffer );
 8013722:	68fb      	ldr	r3, [r7, #12]
 8013724:	4618      	mov	r0, r3
 8013726:	f000 fa8b 	bl	8013c40 <TL_MM_EvtDone>
 801372a:	e004      	b.n	8013736 <shci_user_evt_proc+0x6a>
    else
    {
      /**
       * put back the event in the queue
       */
      LST_insert_head ( &SHciAsynchEventQueue, (tListNode *)phcievtbuffer );
 801372c:	68fb      	ldr	r3, [r7, #12]
 801372e:	4619      	mov	r1, r3
 8013730:	480a      	ldr	r0, [pc, #40]	; (801375c <shci_user_evt_proc+0x90>)
 8013732:	f001 f8bf 	bl	80148b4 <LST_insert_head>
    }
  }

  if((LST_is_empty(&SHciAsynchEventQueue) == FALSE) && (SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable))
 8013736:	4809      	ldr	r0, [pc, #36]	; (801375c <shci_user_evt_proc+0x90>)
 8013738:	f001 f89a 	bl	8014870 <LST_is_empty>
 801373c:	4603      	mov	r3, r0
 801373e:	2b00      	cmp	r3, #0
 8013740:	d107      	bne.n	8013752 <shci_user_evt_proc+0x86>
 8013742:	4b07      	ldr	r3, [pc, #28]	; (8013760 <shci_user_evt_proc+0x94>)
 8013744:	781b      	ldrb	r3, [r3, #0]
 8013746:	2b00      	cmp	r3, #0
 8013748:	d003      	beq.n	8013752 <shci_user_evt_proc+0x86>
  {
    shci_notify_asynch_evt((void*) &SHciAsynchEventQueue);
 801374a:	4804      	ldr	r0, [pc, #16]	; (801375c <shci_user_evt_proc+0x90>)
 801374c:	f7f3 f860 	bl	8006810 <shci_notify_asynch_evt>
  }


  return;
 8013750:	bf00      	nop
 8013752:	bf00      	nop
}
 8013754:	3710      	adds	r7, #16
 8013756:	46bd      	mov	sp, r7
 8013758:	bd80      	pop	{r7, pc}
 801375a:	bf00      	nop
 801375c:	20000170 	.word	0x20000170
 8013760:	20000180 	.word	0x20000180
 8013764:	20000dcc 	.word	0x20000dcc

08013768 <shci_send>:

  return;
}

void shci_send( uint16_t cmd_code, uint8_t len_cmd_payload, uint8_t * p_cmd_payload, TL_EvtPacket_t * p_rsp )
{
 8013768:	b580      	push	{r7, lr}
 801376a:	b084      	sub	sp, #16
 801376c:	af00      	add	r7, sp, #0
 801376e:	60ba      	str	r2, [r7, #8]
 8013770:	607b      	str	r3, [r7, #4]
 8013772:	4603      	mov	r3, r0
 8013774:	81fb      	strh	r3, [r7, #14]
 8013776:	460b      	mov	r3, r1
 8013778:	737b      	strb	r3, [r7, #13]
  Cmd_SetStatus(SHCI_TL_CmdBusy);
 801377a:	2000      	movs	r0, #0
 801377c:	f000 f868 	bl	8013850 <Cmd_SetStatus>

  pCmdBuffer->cmdserial.cmd.cmdcode = cmd_code;
 8013780:	4b17      	ldr	r3, [pc, #92]	; (80137e0 <shci_send+0x78>)
 8013782:	681b      	ldr	r3, [r3, #0]
 8013784:	89fa      	ldrh	r2, [r7, #14]
 8013786:	f8a3 2009 	strh.w	r2, [r3, #9]
  pCmdBuffer->cmdserial.cmd.plen = len_cmd_payload;
 801378a:	4b15      	ldr	r3, [pc, #84]	; (80137e0 <shci_send+0x78>)
 801378c:	681b      	ldr	r3, [r3, #0]
 801378e:	7b7a      	ldrb	r2, [r7, #13]
 8013790:	72da      	strb	r2, [r3, #11]

  memcpy(pCmdBuffer->cmdserial.cmd.payload, p_cmd_payload, len_cmd_payload );
 8013792:	4b13      	ldr	r3, [pc, #76]	; (80137e0 <shci_send+0x78>)
 8013794:	681b      	ldr	r3, [r3, #0]
 8013796:	330c      	adds	r3, #12
 8013798:	7b7a      	ldrb	r2, [r7, #13]
 801379a:	68b9      	ldr	r1, [r7, #8]
 801379c:	4618      	mov	r0, r3
 801379e:	f004 fefa 	bl	8018596 <memcpy>
  CmdRspStatusFlag = SHCI_TL_CMD_RESP_WAIT;
 80137a2:	4b10      	ldr	r3, [pc, #64]	; (80137e4 <shci_send+0x7c>)
 80137a4:	2201      	movs	r2, #1
 80137a6:	701a      	strb	r2, [r3, #0]
  shciContext.io.Send(0,0);
 80137a8:	4b0f      	ldr	r3, [pc, #60]	; (80137e8 <shci_send+0x80>)
 80137aa:	691b      	ldr	r3, [r3, #16]
 80137ac:	2100      	movs	r1, #0
 80137ae:	2000      	movs	r0, #0
 80137b0:	4798      	blx	r3

  shci_cmd_resp_wait(SHCI_TL_DEFAULT_TIMEOUT);
 80137b2:	f248 00e8 	movw	r0, #33000	; 0x80e8
 80137b6:	f7f3 f842 	bl	800683e <shci_cmd_resp_wait>

  /**
   * The command complete of a system command does not have the header
   * It starts immediately with the evtserial field
   */
  memcpy( &(p_rsp->evtserial), pCmdBuffer, ((TL_EvtSerial_t*)pCmdBuffer)->evt.plen + TL_EVT_HDR_SIZE );
 80137ba:	687b      	ldr	r3, [r7, #4]
 80137bc:	f103 0008 	add.w	r0, r3, #8
 80137c0:	4b07      	ldr	r3, [pc, #28]	; (80137e0 <shci_send+0x78>)
 80137c2:	6819      	ldr	r1, [r3, #0]
 80137c4:	4b06      	ldr	r3, [pc, #24]	; (80137e0 <shci_send+0x78>)
 80137c6:	681b      	ldr	r3, [r3, #0]
 80137c8:	789b      	ldrb	r3, [r3, #2]
 80137ca:	3303      	adds	r3, #3
 80137cc:	461a      	mov	r2, r3
 80137ce:	f004 fee2 	bl	8018596 <memcpy>

  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 80137d2:	2001      	movs	r0, #1
 80137d4:	f000 f83c 	bl	8013850 <Cmd_SetStatus>

  return;
 80137d8:	bf00      	nop
}
 80137da:	3710      	adds	r7, #16
 80137dc:	46bd      	mov	sp, r7
 80137de:	bd80      	pop	{r7, pc}
 80137e0:	2000017c 	.word	0x2000017c
 80137e4:	20000df0 	.word	0x20000df0
 80137e8:	20000dcc 	.word	0x20000dcc

080137ec <TlInit>:

/* Private functions ---------------------------------------------------------*/
static void TlInit( TL_CmdPacket_t * p_cmdbuffer )
{
 80137ec:	b580      	push	{r7, lr}
 80137ee:	b086      	sub	sp, #24
 80137f0:	af00      	add	r7, sp, #0
 80137f2:	6078      	str	r0, [r7, #4]
  TL_SYS_InitConf_t Conf;

  pCmdBuffer = p_cmdbuffer;
 80137f4:	4a10      	ldr	r2, [pc, #64]	; (8013838 <TlInit+0x4c>)
 80137f6:	687b      	ldr	r3, [r7, #4]
 80137f8:	6013      	str	r3, [r2, #0]

  LST_init_head (&SHciAsynchEventQueue);
 80137fa:	4810      	ldr	r0, [pc, #64]	; (801383c <TlInit+0x50>)
 80137fc:	f001 f828 	bl	8014850 <LST_init_head>

  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 8013800:	2001      	movs	r0, #1
 8013802:	f000 f825 	bl	8013850 <Cmd_SetStatus>

  SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 8013806:	4b0e      	ldr	r3, [pc, #56]	; (8013840 <TlInit+0x54>)
 8013808:	2201      	movs	r2, #1
 801380a:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  if (shciContext.io.Init)
 801380c:	4b0d      	ldr	r3, [pc, #52]	; (8013844 <TlInit+0x58>)
 801380e:	681b      	ldr	r3, [r3, #0]
 8013810:	2b00      	cmp	r3, #0
 8013812:	d00c      	beq.n	801382e <TlInit+0x42>
  {

    Conf.p_cmdbuffer = (uint8_t *)p_cmdbuffer;
 8013814:	687b      	ldr	r3, [r7, #4]
 8013816:	617b      	str	r3, [r7, #20]
    Conf.IoBusCallBackCmdEvt = TlCmdEvtReceived;
 8013818:	4b0b      	ldr	r3, [pc, #44]	; (8013848 <TlInit+0x5c>)
 801381a:	60fb      	str	r3, [r7, #12]
    Conf.IoBusCallBackUserEvt = TlUserEvtReceived;
 801381c:	4b0b      	ldr	r3, [pc, #44]	; (801384c <TlInit+0x60>)
 801381e:	613b      	str	r3, [r7, #16]
    shciContext.io.Init(&Conf);
 8013820:	4b08      	ldr	r3, [pc, #32]	; (8013844 <TlInit+0x58>)
 8013822:	681b      	ldr	r3, [r3, #0]
 8013824:	f107 020c 	add.w	r2, r7, #12
 8013828:	4610      	mov	r0, r2
 801382a:	4798      	blx	r3
  }

  return;
 801382c:	bf00      	nop
 801382e:	bf00      	nop
}
 8013830:	3718      	adds	r7, #24
 8013832:	46bd      	mov	sp, r7
 8013834:	bd80      	pop	{r7, pc}
 8013836:	bf00      	nop
 8013838:	2000017c 	.word	0x2000017c
 801383c:	20000170 	.word	0x20000170
 8013840:	20000180 	.word	0x20000180
 8013844:	20000dcc 	.word	0x20000dcc
 8013848:	080138a1 	.word	0x080138a1
 801384c:	080138b9 	.word	0x080138b9

08013850 <Cmd_SetStatus>:

static void Cmd_SetStatus(SHCI_TL_CmdStatus_t shcicmdstatus)
{
 8013850:	b580      	push	{r7, lr}
 8013852:	b082      	sub	sp, #8
 8013854:	af00      	add	r7, sp, #0
 8013856:	4603      	mov	r3, r0
 8013858:	71fb      	strb	r3, [r7, #7]
  if(shcicmdstatus == SHCI_TL_CmdBusy)
 801385a:	79fb      	ldrb	r3, [r7, #7]
 801385c:	2b00      	cmp	r3, #0
 801385e:	d10b      	bne.n	8013878 <Cmd_SetStatus+0x28>
  {
    if(StatusNotCallBackFunction != 0)
 8013860:	4b0d      	ldr	r3, [pc, #52]	; (8013898 <Cmd_SetStatus+0x48>)
 8013862:	681b      	ldr	r3, [r3, #0]
 8013864:	2b00      	cmp	r3, #0
 8013866:	d003      	beq.n	8013870 <Cmd_SetStatus+0x20>
    {
      StatusNotCallBackFunction( SHCI_TL_CmdBusy );
 8013868:	4b0b      	ldr	r3, [pc, #44]	; (8013898 <Cmd_SetStatus+0x48>)
 801386a:	681b      	ldr	r3, [r3, #0]
 801386c:	2000      	movs	r0, #0
 801386e:	4798      	blx	r3
    }
    SHCICmdStatus = SHCI_TL_CmdBusy;
 8013870:	4b0a      	ldr	r3, [pc, #40]	; (801389c <Cmd_SetStatus+0x4c>)
 8013872:	2200      	movs	r2, #0
 8013874:	701a      	strb	r2, [r3, #0]
    {
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
    }
  }

  return;
 8013876:	e00b      	b.n	8013890 <Cmd_SetStatus+0x40>
    SHCICmdStatus = SHCI_TL_CmdAvailable;
 8013878:	4b08      	ldr	r3, [pc, #32]	; (801389c <Cmd_SetStatus+0x4c>)
 801387a:	2201      	movs	r2, #1
 801387c:	701a      	strb	r2, [r3, #0]
    if(StatusNotCallBackFunction != 0)
 801387e:	4b06      	ldr	r3, [pc, #24]	; (8013898 <Cmd_SetStatus+0x48>)
 8013880:	681b      	ldr	r3, [r3, #0]
 8013882:	2b00      	cmp	r3, #0
 8013884:	d004      	beq.n	8013890 <Cmd_SetStatus+0x40>
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
 8013886:	4b04      	ldr	r3, [pc, #16]	; (8013898 <Cmd_SetStatus+0x48>)
 8013888:	681b      	ldr	r3, [r3, #0]
 801388a:	2001      	movs	r0, #1
 801388c:	4798      	blx	r3
  return;
 801388e:	bf00      	nop
 8013890:	bf00      	nop
}
 8013892:	3708      	adds	r7, #8
 8013894:	46bd      	mov	sp, r7
 8013896:	bd80      	pop	{r7, pc}
 8013898:	20000dec 	.word	0x20000dec
 801389c:	20000178 	.word	0x20000178

080138a0 <TlCmdEvtReceived>:

static void TlCmdEvtReceived(TL_EvtPacket_t *shcievt)
{
 80138a0:	b580      	push	{r7, lr}
 80138a2:	b082      	sub	sp, #8
 80138a4:	af00      	add	r7, sp, #0
 80138a6:	6078      	str	r0, [r7, #4]
  (void)(shcievt);
  shci_cmd_resp_release(0); /**< Notify the application the Cmd response has been received */
 80138a8:	2000      	movs	r0, #0
 80138aa:	f7f2 ffbd 	bl	8006828 <shci_cmd_resp_release>

  return;
 80138ae:	bf00      	nop
}
 80138b0:	3708      	adds	r7, #8
 80138b2:	46bd      	mov	sp, r7
 80138b4:	bd80      	pop	{r7, pc}
	...

080138b8 <TlUserEvtReceived>:

static void TlUserEvtReceived(TL_EvtPacket_t *shcievt)
{
 80138b8:	b580      	push	{r7, lr}
 80138ba:	b082      	sub	sp, #8
 80138bc:	af00      	add	r7, sp, #0
 80138be:	6078      	str	r0, [r7, #4]
  LST_insert_tail(&SHciAsynchEventQueue, (tListNode *)shcievt);
 80138c0:	6879      	ldr	r1, [r7, #4]
 80138c2:	4805      	ldr	r0, [pc, #20]	; (80138d8 <TlUserEvtReceived+0x20>)
 80138c4:	f001 f81c 	bl	8014900 <LST_insert_tail>
  shci_notify_asynch_evt((void*) &SHciAsynchEventQueue); /**< Notify the application a full HCI event has been received */
 80138c8:	4803      	ldr	r0, [pc, #12]	; (80138d8 <TlUserEvtReceived+0x20>)
 80138ca:	f7f2 ffa1 	bl	8006810 <shci_notify_asynch_evt>

  return;
 80138ce:	bf00      	nop
}
 80138d0:	3708      	adds	r7, #8
 80138d2:	46bd      	mov	sp, r7
 80138d4:	bd80      	pop	{r7, pc}
 80138d6:	bf00      	nop
 80138d8:	20000170 	.word	0x20000170

080138dc <shci_register_io_bus>:
#include "shci_tl.h"
#include "tl.h"


void shci_register_io_bus(tSHciIO* fops)
{
 80138dc:	b480      	push	{r7}
 80138de:	b083      	sub	sp, #12
 80138e0:	af00      	add	r7, sp, #0
 80138e2:	6078      	str	r0, [r7, #4]
  /* Register IO bus services */
  fops->Init    = TL_SYS_Init;
 80138e4:	687b      	ldr	r3, [r7, #4]
 80138e6:	4a05      	ldr	r2, [pc, #20]	; (80138fc <shci_register_io_bus+0x20>)
 80138e8:	601a      	str	r2, [r3, #0]
  fops->Send    = TL_SYS_SendCmd;
 80138ea:	687b      	ldr	r3, [r7, #4]
 80138ec:	4a04      	ldr	r2, [pc, #16]	; (8013900 <shci_register_io_bus+0x24>)
 80138ee:	611a      	str	r2, [r3, #16]

  return;
 80138f0:	bf00      	nop
}
 80138f2:	370c      	adds	r7, #12
 80138f4:	46bd      	mov	sp, r7
 80138f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80138fa:	4770      	bx	lr
 80138fc:	080139f9 	.word	0x080139f9
 8013900:	08013a4d 	.word	0x08013a4d

08013904 <TL_Enable>:

/******************************************************************************
 * GENERAL - refer to AN5289 for functions description.
 ******************************************************************************/
void TL_Enable( void )
{
 8013904:	b580      	push	{r7, lr}
 8013906:	af00      	add	r7, sp, #0
  HW_IPCC_Enable();
 8013908:	f7f5 fb0a 	bl	8008f20 <HW_IPCC_Enable>

  return;
 801390c:	bf00      	nop
}
 801390e:	bd80      	pop	{r7, pc}

08013910 <TL_Init>:


void TL_Init( void )
{
 8013910:	b580      	push	{r7, lr}
 8013912:	af00      	add	r7, sp, #0
  TL_RefTable.p_device_info_table = &TL_DeviceInfoTable;
 8013914:	4b10      	ldr	r3, [pc, #64]	; (8013958 <TL_Init+0x48>)
 8013916:	4a11      	ldr	r2, [pc, #68]	; (801395c <TL_Init+0x4c>)
 8013918:	601a      	str	r2, [r3, #0]
  TL_RefTable.p_ble_table = &TL_BleTable;
 801391a:	4b0f      	ldr	r3, [pc, #60]	; (8013958 <TL_Init+0x48>)
 801391c:	4a10      	ldr	r2, [pc, #64]	; (8013960 <TL_Init+0x50>)
 801391e:	605a      	str	r2, [r3, #4]
  TL_RefTable.p_thread_table = &TL_ThreadTable;
 8013920:	4b0d      	ldr	r3, [pc, #52]	; (8013958 <TL_Init+0x48>)
 8013922:	4a10      	ldr	r2, [pc, #64]	; (8013964 <TL_Init+0x54>)
 8013924:	609a      	str	r2, [r3, #8]
  TL_RefTable.p_lld_tests_table = &TL_LldTestsTable;
 8013926:	4b0c      	ldr	r3, [pc, #48]	; (8013958 <TL_Init+0x48>)
 8013928:	4a0f      	ldr	r2, [pc, #60]	; (8013968 <TL_Init+0x58>)
 801392a:	621a      	str	r2, [r3, #32]
  TL_RefTable.p_ble_lld_table = &TL_BleLldTable;
 801392c:	4b0a      	ldr	r3, [pc, #40]	; (8013958 <TL_Init+0x48>)
 801392e:	4a0f      	ldr	r2, [pc, #60]	; (801396c <TL_Init+0x5c>)
 8013930:	625a      	str	r2, [r3, #36]	; 0x24
  TL_RefTable.p_sys_table = &TL_SysTable;
 8013932:	4b09      	ldr	r3, [pc, #36]	; (8013958 <TL_Init+0x48>)
 8013934:	4a0e      	ldr	r2, [pc, #56]	; (8013970 <TL_Init+0x60>)
 8013936:	60da      	str	r2, [r3, #12]
  TL_RefTable.p_mem_manager_table = &TL_MemManagerTable;
 8013938:	4b07      	ldr	r3, [pc, #28]	; (8013958 <TL_Init+0x48>)
 801393a:	4a0e      	ldr	r2, [pc, #56]	; (8013974 <TL_Init+0x64>)
 801393c:	611a      	str	r2, [r3, #16]
  TL_RefTable.p_traces_table = &TL_TracesTable;
 801393e:	4b06      	ldr	r3, [pc, #24]	; (8013958 <TL_Init+0x48>)
 8013940:	4a0d      	ldr	r2, [pc, #52]	; (8013978 <TL_Init+0x68>)
 8013942:	615a      	str	r2, [r3, #20]
  TL_RefTable.p_mac_802_15_4_table = &TL_Mac_802_15_4_Table;
 8013944:	4b04      	ldr	r3, [pc, #16]	; (8013958 <TL_Init+0x48>)
 8013946:	4a0d      	ldr	r2, [pc, #52]	; (801397c <TL_Init+0x6c>)
 8013948:	619a      	str	r2, [r3, #24]
  TL_RefTable.p_zigbee_table = &TL_Zigbee_Table;
 801394a:	4b03      	ldr	r3, [pc, #12]	; (8013958 <TL_Init+0x48>)
 801394c:	4a0c      	ldr	r2, [pc, #48]	; (8013980 <TL_Init+0x70>)
 801394e:	61da      	str	r2, [r3, #28]
  HW_IPCC_Init();
 8013950:	f7f5 fafa 	bl	8008f48 <HW_IPCC_Init>

  return;
 8013954:	bf00      	nop
}
 8013956:	bd80      	pop	{r7, pc}
 8013958:	20030000 	.word	0x20030000
 801395c:	20030034 	.word	0x20030034
 8013960:	20030054 	.word	0x20030054
 8013964:	20030064 	.word	0x20030064
 8013968:	20030074 	.word	0x20030074
 801396c:	2003007c 	.word	0x2003007c
 8013970:	20030084 	.word	0x20030084
 8013974:	2003008c 	.word	0x2003008c
 8013978:	200300a8 	.word	0x200300a8
 801397c:	200300ac 	.word	0x200300ac
 8013980:	200300b8 	.word	0x200300b8

08013984 <HW_IPCC_BLE_RxEvtNot>:

  return 0;
}

void HW_IPCC_BLE_RxEvtNot(void)
{
 8013984:	b580      	push	{r7, lr}
 8013986:	b082      	sub	sp, #8
 8013988:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&EvtQueue) == FALSE)
 801398a:	e01c      	b.n	80139c6 <HW_IPCC_BLE_RxEvtNot+0x42>
  {
    LST_remove_head (&EvtQueue, (tListNode **)&phcievt);
 801398c:	1d3b      	adds	r3, r7, #4
 801398e:	4619      	mov	r1, r3
 8013990:	4812      	ldr	r0, [pc, #72]	; (80139dc <HW_IPCC_BLE_RxEvtNot+0x58>)
 8013992:	f000 fffc 	bl	801498e <LST_remove_head>

    if ( ((phcievt->evtserial.evt.evtcode) == TL_BLEEVT_CS_OPCODE) || ((phcievt->evtserial.evt.evtcode) == TL_BLEEVT_CC_OPCODE ) )
 8013996:	687b      	ldr	r3, [r7, #4]
 8013998:	7a5b      	ldrb	r3, [r3, #9]
 801399a:	2b0f      	cmp	r3, #15
 801399c:	d003      	beq.n	80139a6 <HW_IPCC_BLE_RxEvtNot+0x22>
 801399e:	687b      	ldr	r3, [r7, #4]
 80139a0:	7a5b      	ldrb	r3, [r3, #9]
 80139a2:	2b0e      	cmp	r3, #14
 80139a4:	d105      	bne.n	80139b2 <HW_IPCC_BLE_RxEvtNot+0x2e>
    {
      OutputDbgTrace(TL_MB_BLE_CMD_RSP, (uint8_t*)phcievt);
 80139a6:	687b      	ldr	r3, [r7, #4]
 80139a8:	4619      	mov	r1, r3
 80139aa:	2002      	movs	r0, #2
 80139ac:	f000 f9ac 	bl	8013d08 <OutputDbgTrace>
 80139b0:	e004      	b.n	80139bc <HW_IPCC_BLE_RxEvtNot+0x38>
    }
    else
    {
      OutputDbgTrace(TL_MB_BLE_ASYNCH_EVT, (uint8_t*)phcievt);
 80139b2:	687b      	ldr	r3, [r7, #4]
 80139b4:	4619      	mov	r1, r3
 80139b6:	2003      	movs	r0, #3
 80139b8:	f000 f9a6 	bl	8013d08 <OutputDbgTrace>
    }

    BLE_IoBusEvtCallBackFunction(phcievt);
 80139bc:	4b08      	ldr	r3, [pc, #32]	; (80139e0 <HW_IPCC_BLE_RxEvtNot+0x5c>)
 80139be:	681b      	ldr	r3, [r3, #0]
 80139c0:	687a      	ldr	r2, [r7, #4]
 80139c2:	4610      	mov	r0, r2
 80139c4:	4798      	blx	r3
  while(LST_is_empty(&EvtQueue) == FALSE)
 80139c6:	4805      	ldr	r0, [pc, #20]	; (80139dc <HW_IPCC_BLE_RxEvtNot+0x58>)
 80139c8:	f000 ff52 	bl	8014870 <LST_is_empty>
 80139cc:	4603      	mov	r3, r0
 80139ce:	2b00      	cmp	r3, #0
 80139d0:	d0dc      	beq.n	801398c <HW_IPCC_BLE_RxEvtNot+0x8>
  }

  return;
 80139d2:	bf00      	nop
}
 80139d4:	3708      	adds	r7, #8
 80139d6:	46bd      	mov	sp, r7
 80139d8:	bd80      	pop	{r7, pc}
 80139da:	bf00      	nop
 80139dc:	200300d4 	.word	0x200300d4
 80139e0:	20000dfc 	.word	0x20000dfc

080139e4 <HW_IPCC_BLE_AclDataAckNot>:

  return 0;
}

void HW_IPCC_BLE_AclDataAckNot(void)
{
 80139e4:	b580      	push	{r7, lr}
 80139e6:	af00      	add	r7, sp, #0
  BLE_IoBusAclDataTxAck( );
 80139e8:	4b02      	ldr	r3, [pc, #8]	; (80139f4 <HW_IPCC_BLE_AclDataAckNot+0x10>)
 80139ea:	681b      	ldr	r3, [r3, #0]
 80139ec:	4798      	blx	r3

  return;
 80139ee:	bf00      	nop
}
 80139f0:	bd80      	pop	{r7, pc}
 80139f2:	bf00      	nop
 80139f4:	20000e00 	.word	0x20000e00

080139f8 <TL_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
int32_t TL_SYS_Init( void* pConf  )
{
 80139f8:	b580      	push	{r7, lr}
 80139fa:	b084      	sub	sp, #16
 80139fc:	af00      	add	r7, sp, #0
 80139fe:	6078      	str	r0, [r7, #4]
  MB_SysTable_t  * p_systable;

  TL_SYS_InitConf_t *pInitHciConf = (TL_SYS_InitConf_t *) pConf;
 8013a00:	687b      	ldr	r3, [r7, #4]
 8013a02:	60fb      	str	r3, [r7, #12]

  LST_init_head (&SystemEvtQueue);
 8013a04:	480d      	ldr	r0, [pc, #52]	; (8013a3c <TL_SYS_Init+0x44>)
 8013a06:	f000 ff23 	bl	8014850 <LST_init_head>
  p_systable = TL_RefTable.p_sys_table;
 8013a0a:	4b0d      	ldr	r3, [pc, #52]	; (8013a40 <TL_SYS_Init+0x48>)
 8013a0c:	68db      	ldr	r3, [r3, #12]
 8013a0e:	60bb      	str	r3, [r7, #8]
  p_systable->pcmd_buffer = pInitHciConf->p_cmdbuffer;
 8013a10:	68fb      	ldr	r3, [r7, #12]
 8013a12:	689a      	ldr	r2, [r3, #8]
 8013a14:	68bb      	ldr	r3, [r7, #8]
 8013a16:	601a      	str	r2, [r3, #0]
  p_systable->sys_queue = (uint8_t*)&SystemEvtQueue;
 8013a18:	68bb      	ldr	r3, [r7, #8]
 8013a1a:	4a08      	ldr	r2, [pc, #32]	; (8013a3c <TL_SYS_Init+0x44>)
 8013a1c:	605a      	str	r2, [r3, #4]

  HW_IPCC_SYS_Init();
 8013a1e:	f7f5 fac1 	bl	8008fa4 <HW_IPCC_SYS_Init>

  SYS_CMD_IoBusCallBackFunction = pInitHciConf->IoBusCallBackCmdEvt;
 8013a22:	68fb      	ldr	r3, [r7, #12]
 8013a24:	681b      	ldr	r3, [r3, #0]
 8013a26:	4a07      	ldr	r2, [pc, #28]	; (8013a44 <TL_SYS_Init+0x4c>)
 8013a28:	6013      	str	r3, [r2, #0]
  SYS_EVT_IoBusCallBackFunction = pInitHciConf->IoBusCallBackUserEvt;
 8013a2a:	68fb      	ldr	r3, [r7, #12]
 8013a2c:	685b      	ldr	r3, [r3, #4]
 8013a2e:	4a06      	ldr	r2, [pc, #24]	; (8013a48 <TL_SYS_Init+0x50>)
 8013a30:	6013      	str	r3, [r2, #0]

  return 0;
 8013a32:	2300      	movs	r3, #0
}
 8013a34:	4618      	mov	r0, r3
 8013a36:	3710      	adds	r7, #16
 8013a38:	46bd      	mov	sp, r7
 8013a3a:	bd80      	pop	{r7, pc}
 8013a3c:	200300dc 	.word	0x200300dc
 8013a40:	20030000 	.word	0x20030000
 8013a44:	20000e04 	.word	0x20000e04
 8013a48:	20000e08 	.word	0x20000e08

08013a4c <TL_SYS_SendCmd>:

int32_t TL_SYS_SendCmd( uint8_t* buffer, uint16_t size )
{
 8013a4c:	b580      	push	{r7, lr}
 8013a4e:	b082      	sub	sp, #8
 8013a50:	af00      	add	r7, sp, #0
 8013a52:	6078      	str	r0, [r7, #4]
 8013a54:	460b      	mov	r3, r1
 8013a56:	807b      	strh	r3, [r7, #2]
  (void)(buffer);
  (void)(size);

  ((TL_CmdPacket_t *)(TL_RefTable.p_sys_table->pcmd_buffer))->cmdserial.type = TL_SYSCMD_PKT_TYPE;
 8013a58:	4b09      	ldr	r3, [pc, #36]	; (8013a80 <TL_SYS_SendCmd+0x34>)
 8013a5a:	68db      	ldr	r3, [r3, #12]
 8013a5c:	681b      	ldr	r3, [r3, #0]
 8013a5e:	2210      	movs	r2, #16
 8013a60:	721a      	strb	r2, [r3, #8]

  OutputDbgTrace(TL_MB_SYS_CMD, TL_RefTable.p_sys_table->pcmd_buffer);
 8013a62:	4b07      	ldr	r3, [pc, #28]	; (8013a80 <TL_SYS_SendCmd+0x34>)
 8013a64:	68db      	ldr	r3, [r3, #12]
 8013a66:	681b      	ldr	r3, [r3, #0]
 8013a68:	4619      	mov	r1, r3
 8013a6a:	2004      	movs	r0, #4
 8013a6c:	f000 f94c 	bl	8013d08 <OutputDbgTrace>

  HW_IPCC_SYS_SendCmd();
 8013a70:	f7f5 faa2 	bl	8008fb8 <HW_IPCC_SYS_SendCmd>

  return 0;
 8013a74:	2300      	movs	r3, #0
}
 8013a76:	4618      	mov	r0, r3
 8013a78:	3708      	adds	r7, #8
 8013a7a:	46bd      	mov	sp, r7
 8013a7c:	bd80      	pop	{r7, pc}
 8013a7e:	bf00      	nop
 8013a80:	20030000 	.word	0x20030000

08013a84 <HW_IPCC_SYS_CmdEvtNot>:

void HW_IPCC_SYS_CmdEvtNot(void)
{
 8013a84:	b580      	push	{r7, lr}
 8013a86:	af00      	add	r7, sp, #0
  OutputDbgTrace(TL_MB_SYS_CMD_RSP, (uint8_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 8013a88:	4b07      	ldr	r3, [pc, #28]	; (8013aa8 <HW_IPCC_SYS_CmdEvtNot+0x24>)
 8013a8a:	68db      	ldr	r3, [r3, #12]
 8013a8c:	681b      	ldr	r3, [r3, #0]
 8013a8e:	4619      	mov	r1, r3
 8013a90:	2005      	movs	r0, #5
 8013a92:	f000 f939 	bl	8013d08 <OutputDbgTrace>

  SYS_CMD_IoBusCallBackFunction( (TL_EvtPacket_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 8013a96:	4b05      	ldr	r3, [pc, #20]	; (8013aac <HW_IPCC_SYS_CmdEvtNot+0x28>)
 8013a98:	681b      	ldr	r3, [r3, #0]
 8013a9a:	4a03      	ldr	r2, [pc, #12]	; (8013aa8 <HW_IPCC_SYS_CmdEvtNot+0x24>)
 8013a9c:	68d2      	ldr	r2, [r2, #12]
 8013a9e:	6812      	ldr	r2, [r2, #0]
 8013aa0:	4610      	mov	r0, r2
 8013aa2:	4798      	blx	r3

  return;
 8013aa4:	bf00      	nop
}
 8013aa6:	bd80      	pop	{r7, pc}
 8013aa8:	20030000 	.word	0x20030000
 8013aac:	20000e04 	.word	0x20000e04

08013ab0 <HW_IPCC_SYS_EvtNot>:

void HW_IPCC_SYS_EvtNot( void )
{
 8013ab0:	b580      	push	{r7, lr}
 8013ab2:	b082      	sub	sp, #8
 8013ab4:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *p_evt;

  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 8013ab6:	e00e      	b.n	8013ad6 <HW_IPCC_SYS_EvtNot+0x26>
  {
    LST_remove_head (&SystemEvtQueue, (tListNode **)&p_evt);
 8013ab8:	1d3b      	adds	r3, r7, #4
 8013aba:	4619      	mov	r1, r3
 8013abc:	480b      	ldr	r0, [pc, #44]	; (8013aec <HW_IPCC_SYS_EvtNot+0x3c>)
 8013abe:	f000 ff66 	bl	801498e <LST_remove_head>

    OutputDbgTrace(TL_MB_SYS_ASYNCH_EVT, (uint8_t*)p_evt );
 8013ac2:	687b      	ldr	r3, [r7, #4]
 8013ac4:	4619      	mov	r1, r3
 8013ac6:	2006      	movs	r0, #6
 8013ac8:	f000 f91e 	bl	8013d08 <OutputDbgTrace>

    SYS_EVT_IoBusCallBackFunction( p_evt );
 8013acc:	4b08      	ldr	r3, [pc, #32]	; (8013af0 <HW_IPCC_SYS_EvtNot+0x40>)
 8013ace:	681b      	ldr	r3, [r3, #0]
 8013ad0:	687a      	ldr	r2, [r7, #4]
 8013ad2:	4610      	mov	r0, r2
 8013ad4:	4798      	blx	r3
  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 8013ad6:	4805      	ldr	r0, [pc, #20]	; (8013aec <HW_IPCC_SYS_EvtNot+0x3c>)
 8013ad8:	f000 feca 	bl	8014870 <LST_is_empty>
 8013adc:	4603      	mov	r3, r0
 8013ade:	2b00      	cmp	r3, #0
 8013ae0:	d0ea      	beq.n	8013ab8 <HW_IPCC_SYS_EvtNot+0x8>
  }

  return;
 8013ae2:	bf00      	nop
}
 8013ae4:	3708      	adds	r7, #8
 8013ae6:	46bd      	mov	sp, r7
 8013ae8:	bd80      	pop	{r7, pc}
 8013aea:	bf00      	nop
 8013aec:	200300dc 	.word	0x200300dc
 8013af0:	20000e08 	.word	0x20000e08

08013af4 <TL_ZIGBEE_Init>:
#ifdef ZIGBEE_WB
/******************************************************************************
 * ZIGBEE
 ******************************************************************************/
void TL_ZIGBEE_Init( TL_ZIGBEE_Config_t *p_Config )
{
 8013af4:	b580      	push	{r7, lr}
 8013af6:	b084      	sub	sp, #16
 8013af8:	af00      	add	r7, sp, #0
 8013afa:	6078      	str	r0, [r7, #4]
  MB_ZigbeeTable_t  * p_zigbee_table;

  p_zigbee_table = TL_RefTable.p_zigbee_table;
 8013afc:	4b0a      	ldr	r3, [pc, #40]	; (8013b28 <TL_ZIGBEE_Init+0x34>)
 8013afe:	69db      	ldr	r3, [r3, #28]
 8013b00:	60fb      	str	r3, [r7, #12]
  p_zigbee_table->appliCmdM4toM0_buffer = p_Config->p_ZigbeeOtCmdRspBuffer;
 8013b02:	687b      	ldr	r3, [r7, #4]
 8013b04:	681a      	ldr	r2, [r3, #0]
 8013b06:	68fb      	ldr	r3, [r7, #12]
 8013b08:	605a      	str	r2, [r3, #4]
  p_zigbee_table->notifM0toM4_buffer = p_Config->p_ZigbeeNotAckBuffer;
 8013b0a:	687b      	ldr	r3, [r7, #4]
 8013b0c:	685a      	ldr	r2, [r3, #4]
 8013b0e:	68fb      	ldr	r3, [r7, #12]
 8013b10:	601a      	str	r2, [r3, #0]
  p_zigbee_table->requestM0toM4_buffer = p_Config->p_ZigbeeNotifRequestBuffer;
 8013b12:	687b      	ldr	r3, [r7, #4]
 8013b14:	689a      	ldr	r2, [r3, #8]
 8013b16:	68fb      	ldr	r3, [r7, #12]
 8013b18:	609a      	str	r2, [r3, #8]

  HW_IPCC_ZIGBEE_Init();
 8013b1a:	f7f5 fa73 	bl	8009004 <HW_IPCC_ZIGBEE_Init>

  return;
 8013b1e:	bf00      	nop
}
 8013b20:	3710      	adds	r7, #16
 8013b22:	46bd      	mov	sp, r7
 8013b24:	bd80      	pop	{r7, pc}
 8013b26:	bf00      	nop
 8013b28:	20030000 	.word	0x20030000

08013b2c <TL_ZIGBEE_SendM4RequestToM0>:

/* Zigbee M4 to M0 Request */
void TL_ZIGBEE_SendM4RequestToM0( void )
{
 8013b2c:	b580      	push	{r7, lr}
 8013b2e:	af00      	add	r7, sp, #0
  ((TL_CmdPacket_t *)(TL_RefTable.p_zigbee_table->appliCmdM4toM0_buffer))->cmdserial.type = TL_OTCMD_PKT_TYPE;
 8013b30:	4b04      	ldr	r3, [pc, #16]	; (8013b44 <TL_ZIGBEE_SendM4RequestToM0+0x18>)
 8013b32:	69db      	ldr	r3, [r3, #28]
 8013b34:	685b      	ldr	r3, [r3, #4]
 8013b36:	2208      	movs	r2, #8
 8013b38:	721a      	strb	r2, [r3, #8]

  HW_IPCC_ZIGBEE_SendM4RequestToM0();
 8013b3a:	f7f5 fa71 	bl	8009020 <HW_IPCC_ZIGBEE_SendM4RequestToM0>

  return;
 8013b3e:	bf00      	nop
}
 8013b40:	bd80      	pop	{r7, pc}
 8013b42:	bf00      	nop
 8013b44:	20030000 	.word	0x20030000

08013b48 <HW_IPCC_ZIGBEE_RecvAppliAckFromM0>:

/* Used to receive an ACK from the M0 */
void HW_IPCC_ZIGBEE_RecvAppliAckFromM0(void)
{
 8013b48:	b580      	push	{r7, lr}
 8013b4a:	af00      	add	r7, sp, #0
  TL_ZIGBEE_CmdEvtReceived( (TL_EvtPacket_t*)(TL_RefTable.p_zigbee_table->appliCmdM4toM0_buffer) );
 8013b4c:	4b03      	ldr	r3, [pc, #12]	; (8013b5c <HW_IPCC_ZIGBEE_RecvAppliAckFromM0+0x14>)
 8013b4e:	69db      	ldr	r3, [r3, #28]
 8013b50:	685b      	ldr	r3, [r3, #4]
 8013b52:	4618      	mov	r0, r3
 8013b54:	f7f4 ff9e 	bl	8008a94 <TL_ZIGBEE_CmdEvtReceived>

  return;
 8013b58:	bf00      	nop
}
 8013b5a:	bd80      	pop	{r7, pc}
 8013b5c:	20030000 	.word	0x20030000

08013b60 <HW_IPCC_ZIGBEE_RecvM0NotifyToM4>:

/* Zigbee notification from M0 to M4 */
void HW_IPCC_ZIGBEE_RecvM0NotifyToM4( void )
{
 8013b60:	b580      	push	{r7, lr}
 8013b62:	af00      	add	r7, sp, #0
  TL_ZIGBEE_NotReceived( (TL_EvtPacket_t*)(TL_RefTable.p_zigbee_table->notifM0toM4_buffer) );
 8013b64:	4b03      	ldr	r3, [pc, #12]	; (8013b74 <HW_IPCC_ZIGBEE_RecvM0NotifyToM4+0x14>)
 8013b66:	69db      	ldr	r3, [r3, #28]
 8013b68:	681b      	ldr	r3, [r3, #0]
 8013b6a:	4618      	mov	r0, r3
 8013b6c:	f7f4 ff9c 	bl	8008aa8 <TL_ZIGBEE_NotReceived>

  return;
 8013b70:	bf00      	nop
}
 8013b72:	bd80      	pop	{r7, pc}
 8013b74:	20030000 	.word	0x20030000

08013b78 <TL_ZIGBEE_SendM4AckToM0Notify>:

/* Send an ACK to the M0 for a Notification */
void TL_ZIGBEE_SendM4AckToM0Notify ( void )
{
 8013b78:	b580      	push	{r7, lr}
 8013b7a:	af00      	add	r7, sp, #0
  ((TL_CmdPacket_t *)(TL_RefTable.p_zigbee_table->notifM0toM4_buffer))->cmdserial.type = TL_OTACK_PKT_TYPE;
 8013b7c:	4b04      	ldr	r3, [pc, #16]	; (8013b90 <TL_ZIGBEE_SendM4AckToM0Notify+0x18>)
 8013b7e:	69db      	ldr	r3, [r3, #28]
 8013b80:	681b      	ldr	r3, [r3, #0]
 8013b82:	220d      	movs	r2, #13
 8013b84:	721a      	strb	r2, [r3, #8]

  HW_IPCC_ZIGBEE_SendM4AckToM0Notify();
 8013b86:	f7f5 fa59 	bl	800903c <HW_IPCC_ZIGBEE_SendM4AckToM0Notify>

  return;
 8013b8a:	bf00      	nop
}
 8013b8c:	bd80      	pop	{r7, pc}
 8013b8e:	bf00      	nop
 8013b90:	20030000 	.word	0x20030000

08013b94 <HW_IPCC_ZIGBEE_RecvM0RequestToM4>:

/* Zigbee M0 to M4 Request */
void HW_IPCC_ZIGBEE_RecvM0RequestToM4( void )
{
 8013b94:	b580      	push	{r7, lr}
 8013b96:	af00      	add	r7, sp, #0
  TL_ZIGBEE_M0RequestReceived( (TL_EvtPacket_t*)(TL_RefTable.p_zigbee_table->requestM0toM4_buffer) );
 8013b98:	4b03      	ldr	r3, [pc, #12]	; (8013ba8 <HW_IPCC_ZIGBEE_RecvM0RequestToM4+0x14>)
 8013b9a:	69db      	ldr	r3, [r3, #28]
 8013b9c:	689b      	ldr	r3, [r3, #8]
 8013b9e:	4618      	mov	r0, r3
 8013ba0:	f7f4 ffb8 	bl	8008b14 <TL_ZIGBEE_M0RequestReceived>

  return;
 8013ba4:	bf00      	nop
}
 8013ba6:	bd80      	pop	{r7, pc}
 8013ba8:	20030000 	.word	0x20030000

08013bac <TL_ZIGBEE_SendM4AckToM0Request>:

/* Send an ACK to the M0 for a Request */
void TL_ZIGBEE_SendM4AckToM0Request(void)
{
 8013bac:	b580      	push	{r7, lr}
 8013bae:	af00      	add	r7, sp, #0
  ((TL_CmdPacket_t *)(TL_RefTable.p_zigbee_table->requestM0toM4_buffer))->cmdserial.type = TL_OTACK_PKT_TYPE;
 8013bb0:	4b04      	ldr	r3, [pc, #16]	; (8013bc4 <TL_ZIGBEE_SendM4AckToM0Request+0x18>)
 8013bb2:	69db      	ldr	r3, [r3, #28]
 8013bb4:	689b      	ldr	r3, [r3, #8]
 8013bb6:	220d      	movs	r2, #13
 8013bb8:	721a      	strb	r2, [r3, #8]

  HW_IPCC_ZIGBEE_SendM4AckToM0Request();
 8013bba:	f7f5 fa71 	bl	80090a0 <HW_IPCC_ZIGBEE_SendM4AckToM0Request>

  return;
 8013bbe:	bf00      	nop
}
 8013bc0:	bd80      	pop	{r7, pc}
 8013bc2:	bf00      	nop
 8013bc4:	20030000 	.word	0x20030000

08013bc8 <TL_MM_Init>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void TL_MM_Init( TL_MM_Config_t *p_Config )
{
 8013bc8:	b580      	push	{r7, lr}
 8013bca:	b082      	sub	sp, #8
 8013bcc:	af00      	add	r7, sp, #0
 8013bce:	6078      	str	r0, [r7, #4]
  static MB_MemManagerTable_t  * p_mem_manager_table;

  LST_init_head (&FreeBufQueue);
 8013bd0:	4817      	ldr	r0, [pc, #92]	; (8013c30 <TL_MM_Init+0x68>)
 8013bd2:	f000 fe3d 	bl	8014850 <LST_init_head>
  LST_init_head (&LocalFreeBufQueue);
 8013bd6:	4817      	ldr	r0, [pc, #92]	; (8013c34 <TL_MM_Init+0x6c>)
 8013bd8:	f000 fe3a 	bl	8014850 <LST_init_head>

  p_mem_manager_table = TL_RefTable.p_mem_manager_table;
 8013bdc:	4b16      	ldr	r3, [pc, #88]	; (8013c38 <TL_MM_Init+0x70>)
 8013bde:	691b      	ldr	r3, [r3, #16]
 8013be0:	4a16      	ldr	r2, [pc, #88]	; (8013c3c <TL_MM_Init+0x74>)
 8013be2:	6013      	str	r3, [r2, #0]

  p_mem_manager_table->blepool = p_Config->p_AsynchEvtPool;
 8013be4:	4b15      	ldr	r3, [pc, #84]	; (8013c3c <TL_MM_Init+0x74>)
 8013be6:	681b      	ldr	r3, [r3, #0]
 8013be8:	687a      	ldr	r2, [r7, #4]
 8013bea:	6892      	ldr	r2, [r2, #8]
 8013bec:	609a      	str	r2, [r3, #8]
  p_mem_manager_table->blepoolsize = p_Config->AsynchEvtPoolSize;
 8013bee:	4b13      	ldr	r3, [pc, #76]	; (8013c3c <TL_MM_Init+0x74>)
 8013bf0:	681b      	ldr	r3, [r3, #0]
 8013bf2:	687a      	ldr	r2, [r7, #4]
 8013bf4:	68d2      	ldr	r2, [r2, #12]
 8013bf6:	60da      	str	r2, [r3, #12]
  p_mem_manager_table->pevt_free_buffer_queue = (uint8_t*)&FreeBufQueue;
 8013bf8:	4b10      	ldr	r3, [pc, #64]	; (8013c3c <TL_MM_Init+0x74>)
 8013bfa:	681b      	ldr	r3, [r3, #0]
 8013bfc:	4a0c      	ldr	r2, [pc, #48]	; (8013c30 <TL_MM_Init+0x68>)
 8013bfe:	611a      	str	r2, [r3, #16]
  p_mem_manager_table->spare_ble_buffer = p_Config->p_BleSpareEvtBuffer;
 8013c00:	4b0e      	ldr	r3, [pc, #56]	; (8013c3c <TL_MM_Init+0x74>)
 8013c02:	681b      	ldr	r3, [r3, #0]
 8013c04:	687a      	ldr	r2, [r7, #4]
 8013c06:	6812      	ldr	r2, [r2, #0]
 8013c08:	601a      	str	r2, [r3, #0]
  p_mem_manager_table->spare_sys_buffer = p_Config->p_SystemSpareEvtBuffer;
 8013c0a:	4b0c      	ldr	r3, [pc, #48]	; (8013c3c <TL_MM_Init+0x74>)
 8013c0c:	681b      	ldr	r3, [r3, #0]
 8013c0e:	687a      	ldr	r2, [r7, #4]
 8013c10:	6852      	ldr	r2, [r2, #4]
 8013c12:	605a      	str	r2, [r3, #4]
  p_mem_manager_table->traces_evt_pool = p_Config->p_TracesEvtPool;
 8013c14:	4b09      	ldr	r3, [pc, #36]	; (8013c3c <TL_MM_Init+0x74>)
 8013c16:	681b      	ldr	r3, [r3, #0]
 8013c18:	687a      	ldr	r2, [r7, #4]
 8013c1a:	6912      	ldr	r2, [r2, #16]
 8013c1c:	615a      	str	r2, [r3, #20]
  p_mem_manager_table->tracespoolsize = p_Config->TracesEvtPoolSize;
 8013c1e:	4b07      	ldr	r3, [pc, #28]	; (8013c3c <TL_MM_Init+0x74>)
 8013c20:	681b      	ldr	r3, [r3, #0]
 8013c22:	687a      	ldr	r2, [r7, #4]
 8013c24:	6952      	ldr	r2, [r2, #20]
 8013c26:	619a      	str	r2, [r3, #24]

  return;
 8013c28:	bf00      	nop
}
 8013c2a:	3708      	adds	r7, #8
 8013c2c:	46bd      	mov	sp, r7
 8013c2e:	bd80      	pop	{r7, pc}
 8013c30:	200300c4 	.word	0x200300c4
 8013c34:	20000df4 	.word	0x20000df4
 8013c38:	20030000 	.word	0x20030000
 8013c3c:	20000e0c 	.word	0x20000e0c

08013c40 <TL_MM_EvtDone>:

void TL_MM_EvtDone(TL_EvtPacket_t * phcievt)
{
 8013c40:	b580      	push	{r7, lr}
 8013c42:	b082      	sub	sp, #8
 8013c44:	af00      	add	r7, sp, #0
 8013c46:	6078      	str	r0, [r7, #4]
  LST_insert_tail(&LocalFreeBufQueue, (tListNode *)phcievt);
 8013c48:	6879      	ldr	r1, [r7, #4]
 8013c4a:	4807      	ldr	r0, [pc, #28]	; (8013c68 <TL_MM_EvtDone+0x28>)
 8013c4c:	f000 fe58 	bl	8014900 <LST_insert_tail>

  OutputDbgTrace(TL_MB_MM_RELEASE_BUFFER, (uint8_t*)phcievt);
 8013c50:	6879      	ldr	r1, [r7, #4]
 8013c52:	2000      	movs	r0, #0
 8013c54:	f000 f858 	bl	8013d08 <OutputDbgTrace>

  HW_IPCC_MM_SendFreeBuf( SendFreeBuf );
 8013c58:	4804      	ldr	r0, [pc, #16]	; (8013c6c <TL_MM_EvtDone+0x2c>)
 8013c5a:	f7f5 fa2f 	bl	80090bc <HW_IPCC_MM_SendFreeBuf>

  return;
 8013c5e:	bf00      	nop
}
 8013c60:	3708      	adds	r7, #8
 8013c62:	46bd      	mov	sp, r7
 8013c64:	bd80      	pop	{r7, pc}
 8013c66:	bf00      	nop
 8013c68:	20000df4 	.word	0x20000df4
 8013c6c:	08013c71 	.word	0x08013c71

08013c70 <SendFreeBuf>:

static void SendFreeBuf( void )
{
 8013c70:	b580      	push	{r7, lr}
 8013c72:	b082      	sub	sp, #8
 8013c74:	af00      	add	r7, sp, #0
  tListNode *p_node;

  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 8013c76:	e00c      	b.n	8013c92 <SendFreeBuf+0x22>
  {
    LST_remove_head( &LocalFreeBufQueue, (tListNode **)&p_node );
 8013c78:	1d3b      	adds	r3, r7, #4
 8013c7a:	4619      	mov	r1, r3
 8013c7c:	480a      	ldr	r0, [pc, #40]	; (8013ca8 <SendFreeBuf+0x38>)
 8013c7e:	f000 fe86 	bl	801498e <LST_remove_head>
    LST_insert_tail( (tListNode*)(TL_RefTable.p_mem_manager_table->pevt_free_buffer_queue), p_node );
 8013c82:	4b0a      	ldr	r3, [pc, #40]	; (8013cac <SendFreeBuf+0x3c>)
 8013c84:	691b      	ldr	r3, [r3, #16]
 8013c86:	691b      	ldr	r3, [r3, #16]
 8013c88:	687a      	ldr	r2, [r7, #4]
 8013c8a:	4611      	mov	r1, r2
 8013c8c:	4618      	mov	r0, r3
 8013c8e:	f000 fe37 	bl	8014900 <LST_insert_tail>
  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 8013c92:	4805      	ldr	r0, [pc, #20]	; (8013ca8 <SendFreeBuf+0x38>)
 8013c94:	f000 fdec 	bl	8014870 <LST_is_empty>
 8013c98:	4603      	mov	r3, r0
 8013c9a:	2b00      	cmp	r3, #0
 8013c9c:	d0ec      	beq.n	8013c78 <SendFreeBuf+0x8>
  }

  return;
 8013c9e:	bf00      	nop
}
 8013ca0:	3708      	adds	r7, #8
 8013ca2:	46bd      	mov	sp, r7
 8013ca4:	bd80      	pop	{r7, pc}
 8013ca6:	bf00      	nop
 8013ca8:	20000df4 	.word	0x20000df4
 8013cac:	20030000 	.word	0x20030000

08013cb0 <TL_TRACES_Init>:

/******************************************************************************
 * TRACES
 ******************************************************************************/
void TL_TRACES_Init( void )
{
 8013cb0:	b580      	push	{r7, lr}
 8013cb2:	af00      	add	r7, sp, #0
  LST_init_head (&TracesEvtQueue);
 8013cb4:	4805      	ldr	r0, [pc, #20]	; (8013ccc <TL_TRACES_Init+0x1c>)
 8013cb6:	f000 fdcb 	bl	8014850 <LST_init_head>

  TL_RefTable.p_traces_table->traces_queue = (uint8_t*)&TracesEvtQueue;
 8013cba:	4b05      	ldr	r3, [pc, #20]	; (8013cd0 <TL_TRACES_Init+0x20>)
 8013cbc:	695b      	ldr	r3, [r3, #20]
 8013cbe:	4a03      	ldr	r2, [pc, #12]	; (8013ccc <TL_TRACES_Init+0x1c>)
 8013cc0:	601a      	str	r2, [r3, #0]

  HW_IPCC_TRACES_Init();
 8013cc2:	f7f5 fa31 	bl	8009128 <HW_IPCC_TRACES_Init>

  return;
 8013cc6:	bf00      	nop
}
 8013cc8:	bd80      	pop	{r7, pc}
 8013cca:	bf00      	nop
 8013ccc:	200300cc 	.word	0x200300cc
 8013cd0:	20030000 	.word	0x20030000

08013cd4 <HW_IPCC_TRACES_EvtNot>:

void HW_IPCC_TRACES_EvtNot(void)
{
 8013cd4:	b580      	push	{r7, lr}
 8013cd6:	b082      	sub	sp, #8
 8013cd8:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 8013cda:	e008      	b.n	8013cee <HW_IPCC_TRACES_EvtNot+0x1a>
  {
    LST_remove_head (&TracesEvtQueue, (tListNode **)&phcievt);
 8013cdc:	1d3b      	adds	r3, r7, #4
 8013cde:	4619      	mov	r1, r3
 8013ce0:	4808      	ldr	r0, [pc, #32]	; (8013d04 <HW_IPCC_TRACES_EvtNot+0x30>)
 8013ce2:	f000 fe54 	bl	801498e <LST_remove_head>
    TL_TRACES_EvtReceived( phcievt );
 8013ce6:	687b      	ldr	r3, [r7, #4]
 8013ce8:	4618      	mov	r0, r3
 8013cea:	f7f2 fdb3 	bl	8006854 <TL_TRACES_EvtReceived>
  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 8013cee:	4805      	ldr	r0, [pc, #20]	; (8013d04 <HW_IPCC_TRACES_EvtNot+0x30>)
 8013cf0:	f000 fdbe 	bl	8014870 <LST_is_empty>
 8013cf4:	4603      	mov	r3, r0
 8013cf6:	2b00      	cmp	r3, #0
 8013cf8:	d0f0      	beq.n	8013cdc <HW_IPCC_TRACES_EvtNot+0x8>
  }

  return;
 8013cfa:	bf00      	nop
}
 8013cfc:	3708      	adds	r7, #8
 8013cfe:	46bd      	mov	sp, r7
 8013d00:	bd80      	pop	{r7, pc}
 8013d02:	bf00      	nop
 8013d04:	200300cc 	.word	0x200300cc

08013d08 <OutputDbgTrace>:

/******************************************************************************
 * DEBUG INFORMATION
 ******************************************************************************/
static void OutputDbgTrace(TL_MB_PacketType_t packet_type, uint8_t* buffer)
{
 8013d08:	b480      	push	{r7}
 8013d0a:	b085      	sub	sp, #20
 8013d0c:	af00      	add	r7, sp, #0
 8013d0e:	4603      	mov	r3, r0
 8013d10:	6039      	str	r1, [r7, #0]
 8013d12:	71fb      	strb	r3, [r7, #7]
  TL_EvtPacket_t *p_evt_packet;
  TL_CmdPacket_t *p_cmd_packet;

  switch(packet_type)
 8013d14:	79fb      	ldrb	r3, [r7, #7]
 8013d16:	2b06      	cmp	r3, #6
 8013d18:	d845      	bhi.n	8013da6 <OutputDbgTrace+0x9e>
 8013d1a:	a201      	add	r2, pc, #4	; (adr r2, 8013d20 <OutputDbgTrace+0x18>)
 8013d1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013d20:	08013d3d 	.word	0x08013d3d
 8013d24:	08013d61 	.word	0x08013d61
 8013d28:	08013d67 	.word	0x08013d67
 8013d2c:	08013d7b 	.word	0x08013d7b
 8013d30:	08013d87 	.word	0x08013d87
 8013d34:	08013d8d 	.word	0x08013d8d
 8013d38:	08013d9b 	.word	0x08013d9b
  {
    case TL_MB_MM_RELEASE_BUFFER:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013d3c:	683b      	ldr	r3, [r7, #0]
 8013d3e:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 8013d40:	68fb      	ldr	r3, [r7, #12]
 8013d42:	7a5b      	ldrb	r3, [r3, #9]
 8013d44:	2bff      	cmp	r3, #255	; 0xff
 8013d46:	d005      	beq.n	8013d54 <OutputDbgTrace+0x4c>
 8013d48:	2bff      	cmp	r3, #255	; 0xff
 8013d4a:	dc05      	bgt.n	8013d58 <OutputDbgTrace+0x50>
 8013d4c:	2b0e      	cmp	r3, #14
 8013d4e:	d005      	beq.n	8013d5c <OutputDbgTrace+0x54>
 8013d50:	2b0f      	cmp	r3, #15
          break;

        default:
          TL_MM_DBG_MSG("mm evt released: 0x%02X", p_evt_packet->evtserial.evt.evtcode);
          TL_MM_DBG_MSG(" buffer addr: 0x%08X", p_evt_packet);
          break;
 8013d52:	e001      	b.n	8013d58 <OutputDbgTrace+0x50>
          break;
 8013d54:	bf00      	nop
 8013d56:	e027      	b.n	8013da8 <OutputDbgTrace+0xa0>
          break;
 8013d58:	bf00      	nop
 8013d5a:	e025      	b.n	8013da8 <OutputDbgTrace+0xa0>
          break;
 8013d5c:	bf00      	nop
      }

      TL_MM_DBG_MSG("\r\n");
      break;
 8013d5e:	e023      	b.n	8013da8 <OutputDbgTrace+0xa0>

    case TL_MB_BLE_CMD:
      p_cmd_packet = (TL_CmdPacket_t*)buffer;
 8013d60:	683b      	ldr	r3, [r7, #0]
 8013d62:	60bb      	str	r3, [r7, #8]
        TL_HCI_CMD_DBG_BUF(p_cmd_packet->cmdserial.cmd.payload, p_cmd_packet->cmdserial.cmd.plen, "");
      }
      TL_HCI_CMD_DBG_MSG("\r\n");

      TL_HCI_CMD_DBG_RAW(&p_cmd_packet->cmdserial, p_cmd_packet->cmdserial.cmd.plen+TL_CMD_HDR_SIZE);
      break;
 8013d64:	e020      	b.n	8013da8 <OutputDbgTrace+0xa0>

    case TL_MB_BLE_CMD_RSP:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013d66:	683b      	ldr	r3, [r7, #0]
 8013d68:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 8013d6a:	68fb      	ldr	r3, [r7, #12]
 8013d6c:	7a5b      	ldrb	r3, [r3, #9]
 8013d6e:	2b0e      	cmp	r3, #14
 8013d70:	d001      	beq.n	8013d76 <OutputDbgTrace+0x6e>
 8013d72:	2b0f      	cmp	r3, #15
          }
          break;

        default:
          TL_HCI_CMD_DBG_MSG("unknown ble rsp received: %02X", p_evt_packet->evtserial.evt.evtcode);
          break;
 8013d74:	e000      	b.n	8013d78 <OutputDbgTrace+0x70>
          break;
 8013d76:	bf00      	nop
      }

      TL_HCI_CMD_DBG_MSG("\r\n");

      TL_HCI_CMD_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013d78:	e016      	b.n	8013da8 <OutputDbgTrace+0xa0>

    case TL_MB_BLE_ASYNCH_EVT:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013d7a:	683b      	ldr	r3, [r7, #0]
 8013d7c:	60fb      	str	r3, [r7, #12]
      if(p_evt_packet->evtserial.evt.evtcode != TL_BLEEVT_VS_OPCODE)
 8013d7e:	68fb      	ldr	r3, [r7, #12]
 8013d80:	7a5b      	ldrb	r3, [r3, #9]
 8013d82:	2bff      	cmp	r3, #255	; 0xff
      }

      TL_HCI_EVT_DBG_MSG("\r\n");

      TL_HCI_EVT_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013d84:	e010      	b.n	8013da8 <OutputDbgTrace+0xa0>

    case TL_MB_SYS_CMD:
      p_cmd_packet = (TL_CmdPacket_t*)buffer;
 8013d86:	683b      	ldr	r3, [r7, #0]
 8013d88:	60bb      	str	r3, [r7, #8]
        TL_SHCI_CMD_DBG_BUF(p_cmd_packet->cmdserial.cmd.payload, p_cmd_packet->cmdserial.cmd.plen, "");
      }
      TL_SHCI_CMD_DBG_MSG("\r\n");

      TL_SHCI_CMD_DBG_RAW(&p_cmd_packet->cmdserial, p_cmd_packet->cmdserial.cmd.plen+TL_CMD_HDR_SIZE);
      break;
 8013d8a:	e00d      	b.n	8013da8 <OutputDbgTrace+0xa0>

    case TL_MB_SYS_CMD_RSP:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013d8c:	683b      	ldr	r3, [r7, #0]
 8013d8e:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 8013d90:	68fb      	ldr	r3, [r7, #12]
 8013d92:	7a5b      	ldrb	r3, [r3, #9]
 8013d94:	2b0e      	cmp	r3, #14
          }
          break;

        default:
          TL_SHCI_CMD_DBG_MSG("unknown sys rsp received: %02X", p_evt_packet->evtserial.evt.evtcode);
          break;
 8013d96:	bf00      	nop
      }

      TL_SHCI_CMD_DBG_MSG("\r\n");

      TL_SHCI_CMD_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013d98:	e006      	b.n	8013da8 <OutputDbgTrace+0xa0>

    case  TL_MB_SYS_ASYNCH_EVT:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013d9a:	683b      	ldr	r3, [r7, #0]
 8013d9c:	60fb      	str	r3, [r7, #12]
      if(p_evt_packet->evtserial.evt.evtcode != TL_BLEEVT_VS_OPCODE)
 8013d9e:	68fb      	ldr	r3, [r7, #12]
 8013da0:	7a5b      	ldrb	r3, [r3, #9]
 8013da2:	2bff      	cmp	r3, #255	; 0xff
      }

      TL_SHCI_EVT_DBG_MSG("\r\n");

      TL_SHCI_EVT_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013da4:	e000      	b.n	8013da8 <OutputDbgTrace+0xa0>

    default:
      break;
 8013da6:	bf00      	nop
  }

  return;
 8013da8:	bf00      	nop
}
 8013daa:	3714      	adds	r7, #20
 8013dac:	46bd      	mov	sp, r7
 8013dae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013db2:	4770      	bx	lr

08013db4 <Post_ZigbeeCmdProcessing>:
/* Private function prototypes -----------------------------------------------*/


/* Private functions ----------------------------------------------------------*/
__weak void Pre_ZigbeeCmdProcessing(void){return;}
__weak void Post_ZigbeeCmdProcessing(void){return;}
 8013db4:	b480      	push	{r7}
 8013db6:	af00      	add	r7, sp, #0
 8013db8:	bf00      	nop
 8013dba:	46bd      	mov	sp, r7
 8013dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013dc0:	4770      	bx	lr

08013dc2 <LL_APB1_GRP1_EnableClock>:
{
 8013dc2:	b480      	push	{r7}
 8013dc4:	b085      	sub	sp, #20
 8013dc6:	af00      	add	r7, sp, #0
 8013dc8:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR1, Periphs);
 8013dca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8013dce:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8013dd0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8013dd4:	687b      	ldr	r3, [r7, #4]
 8013dd6:	4313      	orrs	r3, r2
 8013dd8:	658b      	str	r3, [r1, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8013dda:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8013dde:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8013de0:	687b      	ldr	r3, [r7, #4]
 8013de2:	4013      	ands	r3, r2
 8013de4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8013de6:	68fb      	ldr	r3, [r7, #12]
}
 8013de8:	bf00      	nop
 8013dea:	3714      	adds	r7, #20
 8013dec:	46bd      	mov	sp, r7
 8013dee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013df2:	4770      	bx	lr

08013df4 <HAL_PCD_MspInit>:
 * @brief  Initializes the PCD MSP.
 * @param  hpcd: PCD handle
 * @retval None
 */
void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
{
 8013df4:	b580      	push	{r7, lr}
 8013df6:	b082      	sub	sp, #8
 8013df8:	af00      	add	r7, sp, #0
 8013dfa:	6078      	str	r0, [r7, #4]
    /* Enable USB FS Clock */
    __HAL_RCC_USB_CLK_ENABLE();
 8013dfc:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8013e00:	f7ff ffdf 	bl	8013dc2 <LL_APB1_GRP1_EnableClock>

    /* Set USB FS Interrupt priority */
    HAL_NVIC_SetPriority(USB_LP_IRQn, 0x06, 0);
 8013e04:	2200      	movs	r2, #0
 8013e06:	2106      	movs	r1, #6
 8013e08:	2014      	movs	r0, #20
 8013e0a:	f7f5 fd08 	bl	800981e <HAL_NVIC_SetPriority>

    /* Enable USB FS Interrupt */
    HAL_NVIC_EnableIRQ(USB_LP_IRQn);
 8013e0e:	2014      	movs	r0, #20
 8013e10:	f7f5 fd1f 	bl	8009852 <HAL_NVIC_EnableIRQ>
}
 8013e14:	bf00      	nop
 8013e16:	3708      	adds	r7, #8
 8013e18:	46bd      	mov	sp, r7
 8013e1a:	bd80      	pop	{r7, pc}

08013e1c <HAL_PCD_SetupStageCallback>:
 * @brief  SetupStage callback.
 * @param  hpcd: PCD handle
 * @retval None
 */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef * hpcd)
{
 8013e1c:	b580      	push	{r7, lr}
 8013e1e:	b082      	sub	sp, #8
 8013e20:	af00      	add	r7, sp, #0
 8013e22:	6078      	str	r0, [r7, #4]
    USBD_LL_SetupStage(hpcd->pData, (uint8_t *) hpcd->Setup);
 8013e24:	687b      	ldr	r3, [r7, #4]
 8013e26:	f8d3 22d8 	ldr.w	r2, [r3, #728]	; 0x2d8
 8013e2a:	687b      	ldr	r3, [r7, #4]
 8013e2c:	f503 7326 	add.w	r3, r3, #664	; 0x298
 8013e30:	4619      	mov	r1, r3
 8013e32:	4610      	mov	r0, r2
 8013e34:	f7fe f9b9 	bl	80121aa <USBD_LL_SetupStage>
}
 8013e38:	bf00      	nop
 8013e3a:	3708      	adds	r7, #8
 8013e3c:	46bd      	mov	sp, r7
 8013e3e:	bd80      	pop	{r7, pc}

08013e40 <HAL_PCD_DataOutStageCallback>:
 * @param  hpcd: PCD handle
 * @param  epnum: Endpoint Number
 * @retval None
 */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef * hpcd, uint8_t epnum)
{
 8013e40:	b580      	push	{r7, lr}
 8013e42:	b082      	sub	sp, #8
 8013e44:	af00      	add	r7, sp, #0
 8013e46:	6078      	str	r0, [r7, #4]
 8013e48:	460b      	mov	r3, r1
 8013e4a:	70fb      	strb	r3, [r7, #3]
    USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8013e4c:	687b      	ldr	r3, [r7, #4]
 8013e4e:	f8d3 02d8 	ldr.w	r0, [r3, #728]	; 0x2d8
 8013e52:	78fa      	ldrb	r2, [r7, #3]
 8013e54:	6879      	ldr	r1, [r7, #4]
 8013e56:	4613      	mov	r3, r2
 8013e58:	009b      	lsls	r3, r3, #2
 8013e5a:	4413      	add	r3, r2
 8013e5c:	00db      	lsls	r3, r3, #3
 8013e5e:	440b      	add	r3, r1
 8013e60:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 8013e64:	681a      	ldr	r2, [r3, #0]
 8013e66:	78fb      	ldrb	r3, [r7, #3]
 8013e68:	4619      	mov	r1, r3
 8013e6a:	f7fe f9f3 	bl	8012254 <USBD_LL_DataOutStage>
}
 8013e6e:	bf00      	nop
 8013e70:	3708      	adds	r7, #8
 8013e72:	46bd      	mov	sp, r7
 8013e74:	bd80      	pop	{r7, pc}

08013e76 <HAL_PCD_DataInStageCallback>:
 * @param  hpcd: PCD handle
 * @param  epnum: Endpoint Number
 * @retval None
 */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef * hpcd, uint8_t epnum)
{
 8013e76:	b580      	push	{r7, lr}
 8013e78:	b082      	sub	sp, #8
 8013e7a:	af00      	add	r7, sp, #0
 8013e7c:	6078      	str	r0, [r7, #4]
 8013e7e:	460b      	mov	r3, r1
 8013e80:	70fb      	strb	r3, [r7, #3]
    USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8013e82:	687b      	ldr	r3, [r7, #4]
 8013e84:	f8d3 02d8 	ldr.w	r0, [r3, #728]	; 0x2d8
 8013e88:	78fa      	ldrb	r2, [r7, #3]
 8013e8a:	6879      	ldr	r1, [r7, #4]
 8013e8c:	4613      	mov	r3, r2
 8013e8e:	009b      	lsls	r3, r3, #2
 8013e90:	4413      	add	r3, r2
 8013e92:	00db      	lsls	r3, r3, #3
 8013e94:	440b      	add	r3, r1
 8013e96:	3324      	adds	r3, #36	; 0x24
 8013e98:	681a      	ldr	r2, [r3, #0]
 8013e9a:	78fb      	ldrb	r3, [r7, #3]
 8013e9c:	4619      	mov	r1, r3
 8013e9e:	f7fe fa8c 	bl	80123ba <USBD_LL_DataInStage>
}
 8013ea2:	bf00      	nop
 8013ea4:	3708      	adds	r7, #8
 8013ea6:	46bd      	mov	sp, r7
 8013ea8:	bd80      	pop	{r7, pc}

08013eaa <HAL_PCD_SOFCallback>:
 * @brief  SOF callback.
 * @param  hpcd: PCD handle
 * @retval None
 */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef * hpcd)
{
 8013eaa:	b580      	push	{r7, lr}
 8013eac:	b082      	sub	sp, #8
 8013eae:	af00      	add	r7, sp, #0
 8013eb0:	6078      	str	r0, [r7, #4]
    USBD_LL_SOF(hpcd->pData);
 8013eb2:	687b      	ldr	r3, [r7, #4]
 8013eb4:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 8013eb8:	4618      	mov	r0, r3
 8013eba:	f7fe fbc6 	bl	801264a <USBD_LL_SOF>
}
 8013ebe:	bf00      	nop
 8013ec0:	3708      	adds	r7, #8
 8013ec2:	46bd      	mov	sp, r7
 8013ec4:	bd80      	pop	{r7, pc}

08013ec6 <HAL_PCD_ResetCallback>:
 * @brief  Reset callback.
 * @param  hpcd: PCD handle
 * @retval None
 */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef * hpcd)
{
 8013ec6:	b580      	push	{r7, lr}
 8013ec8:	b082      	sub	sp, #8
 8013eca:	af00      	add	r7, sp, #0
 8013ecc:	6078      	str	r0, [r7, #4]
    /* Reset Device */
    USBD_LL_Reset(hpcd->pData);
 8013ece:	687b      	ldr	r3, [r7, #4]
 8013ed0:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 8013ed4:	4618      	mov	r0, r3
 8013ed6:	f7fe fb22 	bl	801251e <USBD_LL_Reset>

    /* Set USB Current Speed */
    USBD_LL_SetSpeed(hpcd->pData, USBD_SPEED_FULL);
 8013eda:	687b      	ldr	r3, [r7, #4]
 8013edc:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 8013ee0:	2101      	movs	r1, #1
 8013ee2:	4618      	mov	r0, r3
 8013ee4:	f7fe fb6d 	bl	80125c2 <USBD_LL_SetSpeed>
}
 8013ee8:	bf00      	nop
 8013eea:	3708      	adds	r7, #8
 8013eec:	46bd      	mov	sp, r7
 8013eee:	bd80      	pop	{r7, pc}

08013ef0 <HAL_PCD_SuspendCallback>:
 * @brief  Suspend callback.
 * @param  hpcd: PCD handle
 * @retval None
 */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef * hpcd)
{
 8013ef0:	b580      	push	{r7, lr}
 8013ef2:	b082      	sub	sp, #8
 8013ef4:	af00      	add	r7, sp, #0
 8013ef6:	6078      	str	r0, [r7, #4]
    /* Inform USB library that core enters in suspend Mode */
    USBD_LL_Suspend(hpcd->pData);
 8013ef8:	687b      	ldr	r3, [r7, #4]
 8013efa:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 8013efe:	4618      	mov	r0, r3
 8013f00:	f7fe fb6f 	bl	80125e2 <USBD_LL_Suspend>
}
 8013f04:	bf00      	nop
 8013f06:	3708      	adds	r7, #8
 8013f08:	46bd      	mov	sp, r7
 8013f0a:	bd80      	pop	{r7, pc}

08013f0c <HAL_PCD_ResumeCallback>:
 * @brief  Resume callback.
 * @param  hpcd: PCD handle
 * @retval None
 */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef * hpcd)
{
 8013f0c:	b580      	push	{r7, lr}
 8013f0e:	b082      	sub	sp, #8
 8013f10:	af00      	add	r7, sp, #0
 8013f12:	6078      	str	r0, [r7, #4]
    USBD_LL_Resume(hpcd->pData);
 8013f14:	687b      	ldr	r3, [r7, #4]
 8013f16:	f8d3 32d8 	ldr.w	r3, [r3, #728]	; 0x2d8
 8013f1a:	4618      	mov	r0, r3
 8013f1c:	f7fe fb7d 	bl	801261a <USBD_LL_Resume>
}
 8013f20:	bf00      	nop
 8013f22:	3708      	adds	r7, #8
 8013f24:	46bd      	mov	sp, r7
 8013f26:	bd80      	pop	{r7, pc}

08013f28 <USBD_LL_Init>:
 * @brief  Initializes the Low Level portion of the Device driver.
 * @param  pdev: Device handle
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{    
 8013f28:	b580      	push	{r7, lr}
 8013f2a:	b082      	sub	sp, #8
 8013f2c:	af00      	add	r7, sp, #0
 8013f2e:	6078      	str	r0, [r7, #4]
    /* Set LL Driver parameters */
    hpcd.Instance = USB;
 8013f30:	4b1d      	ldr	r3, [pc, #116]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f32:	4a1e      	ldr	r2, [pc, #120]	; (8013fac <USBD_LL_Init+0x84>)
 8013f34:	601a      	str	r2, [r3, #0]
    hpcd.Init.dev_endpoints = 8;
 8013f36:	4b1c      	ldr	r3, [pc, #112]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f38:	2208      	movs	r2, #8
 8013f3a:	711a      	strb	r2, [r3, #4]
    hpcd.Init.ep0_mps = PCD_EP0MPS_64;
 8013f3c:	4b1a      	ldr	r3, [pc, #104]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f3e:	2200      	movs	r2, #0
 8013f40:	719a      	strb	r2, [r3, #6]
    hpcd.Init.phy_itface = PCD_PHY_EMBEDDED;
 8013f42:	4b19      	ldr	r3, [pc, #100]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f44:	2202      	movs	r2, #2
 8013f46:	71da      	strb	r2, [r3, #7]
    hpcd.Init.speed = PCD_SPEED_FULL;
 8013f48:	4b17      	ldr	r3, [pc, #92]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f4a:	2202      	movs	r2, #2
 8013f4c:	715a      	strb	r2, [r3, #5]
    hpcd.Init.low_power_enable = 0;
 8013f4e:	4b16      	ldr	r3, [pc, #88]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f50:	2200      	movs	r2, #0
 8013f52:	725a      	strb	r2, [r3, #9]
    /* Link The driver to the stack */
    hpcd.pData = pdev;
 8013f54:	4a14      	ldr	r2, [pc, #80]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f56:	687b      	ldr	r3, [r7, #4]
 8013f58:	f8c2 32d8 	str.w	r3, [r2, #728]	; 0x2d8
    pdev->pData = &hpcd;
 8013f5c:	687b      	ldr	r3, [r7, #4]
 8013f5e:	4a12      	ldr	r2, [pc, #72]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f60:	f8c3 22c8 	str.w	r2, [r3, #712]	; 0x2c8

    /* Initialize LL Driver */
    HAL_PCD_Init(&hpcd);
 8013f64:	4810      	ldr	r0, [pc, #64]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f66:	f7f6 f8e3 	bl	800a130 <HAL_PCD_Init>

    HAL_PCDEx_PMAConfig(&hpcd , 0x00 , PCD_SNG_BUF, 0x18);
 8013f6a:	2318      	movs	r3, #24
 8013f6c:	2200      	movs	r2, #0
 8013f6e:	2100      	movs	r1, #0
 8013f70:	480d      	ldr	r0, [pc, #52]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f72:	f7f7 fda4 	bl	800babe <HAL_PCDEx_PMAConfig>
    HAL_PCDEx_PMAConfig(&hpcd , 0x80 , PCD_SNG_BUF, 0x58);
 8013f76:	2358      	movs	r3, #88	; 0x58
 8013f78:	2200      	movs	r2, #0
 8013f7a:	2180      	movs	r1, #128	; 0x80
 8013f7c:	480a      	ldr	r0, [pc, #40]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f7e:	f7f7 fd9e 	bl	800babe <HAL_PCDEx_PMAConfig>
    HAL_PCDEx_PMAConfig(&hpcd , CDC_IN_EP , PCD_SNG_BUF, 0xC0);
 8013f82:	23c0      	movs	r3, #192	; 0xc0
 8013f84:	2200      	movs	r2, #0
 8013f86:	2181      	movs	r1, #129	; 0x81
 8013f88:	4807      	ldr	r0, [pc, #28]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f8a:	f7f7 fd98 	bl	800babe <HAL_PCDEx_PMAConfig>
    HAL_PCDEx_PMAConfig(&hpcd , CDC_OUT_EP , PCD_SNG_BUF, 0x110);
 8013f8e:	f44f 7388 	mov.w	r3, #272	; 0x110
 8013f92:	2200      	movs	r2, #0
 8013f94:	2101      	movs	r1, #1
 8013f96:	4804      	ldr	r0, [pc, #16]	; (8013fa8 <USBD_LL_Init+0x80>)
 8013f98:	f7f7 fd91 	bl	800babe <HAL_PCDEx_PMAConfig>

    return USBD_OK;
 8013f9c:	2300      	movs	r3, #0
}
 8013f9e:	4618      	mov	r0, r3
 8013fa0:	3708      	adds	r7, #8
 8013fa2:	46bd      	mov	sp, r7
 8013fa4:	bd80      	pop	{r7, pc}
 8013fa6:	bf00      	nop
 8013fa8:	20000e10 	.word	0x20000e10
 8013fac:	40006800 	.word	0x40006800

08013fb0 <USBD_LL_Start>:
 * @brief  Starts the Low Level portion of the Device driver.
 * @param  pdev: Device handle
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef * pdev)
{
 8013fb0:	b580      	push	{r7, lr}
 8013fb2:	b082      	sub	sp, #8
 8013fb4:	af00      	add	r7, sp, #0
 8013fb6:	6078      	str	r0, [r7, #4]
    HAL_PCD_Start(pdev->pData);
 8013fb8:	687b      	ldr	r3, [r7, #4]
 8013fba:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 8013fbe:	4618      	mov	r0, r3
 8013fc0:	f7f6 f984 	bl	800a2cc <HAL_PCD_Start>
    return USBD_OK;
 8013fc4:	2300      	movs	r3, #0
}
 8013fc6:	4618      	mov	r0, r3
 8013fc8:	3708      	adds	r7, #8
 8013fca:	46bd      	mov	sp, r7
 8013fcc:	bd80      	pop	{r7, pc}

08013fce <USBD_LL_OpenEP>:
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef * pdev,
        uint8_t ep_addr,
        uint8_t ep_type, uint16_t ep_mps)
{
 8013fce:	b580      	push	{r7, lr}
 8013fd0:	b082      	sub	sp, #8
 8013fd2:	af00      	add	r7, sp, #0
 8013fd4:	6078      	str	r0, [r7, #4]
 8013fd6:	4608      	mov	r0, r1
 8013fd8:	4611      	mov	r1, r2
 8013fda:	461a      	mov	r2, r3
 8013fdc:	4603      	mov	r3, r0
 8013fde:	70fb      	strb	r3, [r7, #3]
 8013fe0:	460b      	mov	r3, r1
 8013fe2:	70bb      	strb	r3, [r7, #2]
 8013fe4:	4613      	mov	r3, r2
 8013fe6:	803b      	strh	r3, [r7, #0]
    HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8013fe8:	687b      	ldr	r3, [r7, #4]
 8013fea:	f8d3 02c8 	ldr.w	r0, [r3, #712]	; 0x2c8
 8013fee:	78bb      	ldrb	r3, [r7, #2]
 8013ff0:	883a      	ldrh	r2, [r7, #0]
 8013ff2:	78f9      	ldrb	r1, [r7, #3]
 8013ff4:	f7f6 fad7 	bl	800a5a6 <HAL_PCD_EP_Open>

    return USBD_OK;
 8013ff8:	2300      	movs	r3, #0
}
 8013ffa:	4618      	mov	r0, r3
 8013ffc:	3708      	adds	r7, #8
 8013ffe:	46bd      	mov	sp, r7
 8014000:	bd80      	pop	{r7, pc}

08014002 <USBD_LL_CloseEP>:
 * @param  pdev: Device handle
 * @param  ep_addr: Endpoint Number
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef * pdev, uint8_t ep_addr)
{
 8014002:	b580      	push	{r7, lr}
 8014004:	b082      	sub	sp, #8
 8014006:	af00      	add	r7, sp, #0
 8014008:	6078      	str	r0, [r7, #4]
 801400a:	460b      	mov	r3, r1
 801400c:	70fb      	strb	r3, [r7, #3]
    HAL_PCD_EP_Close(pdev->pData, ep_addr);
 801400e:	687b      	ldr	r3, [r7, #4]
 8014010:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 8014014:	78fa      	ldrb	r2, [r7, #3]
 8014016:	4611      	mov	r1, r2
 8014018:	4618      	mov	r0, r3
 801401a:	f7f6 fb21 	bl	800a660 <HAL_PCD_EP_Close>
    return USBD_OK;
 801401e:	2300      	movs	r3, #0
}
 8014020:	4618      	mov	r0, r3
 8014022:	3708      	adds	r7, #8
 8014024:	46bd      	mov	sp, r7
 8014026:	bd80      	pop	{r7, pc}

08014028 <USBD_LL_StallEP>:
 * @param  pdev: Device handle
 * @param  ep_addr: Endpoint Number
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef * pdev, uint8_t ep_addr)
{
 8014028:	b580      	push	{r7, lr}
 801402a:	b082      	sub	sp, #8
 801402c:	af00      	add	r7, sp, #0
 801402e:	6078      	str	r0, [r7, #4]
 8014030:	460b      	mov	r3, r1
 8014032:	70fb      	strb	r3, [r7, #3]
    HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8014034:	687b      	ldr	r3, [r7, #4]
 8014036:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 801403a:	78fa      	ldrb	r2, [r7, #3]
 801403c:	4611      	mov	r1, r2
 801403e:	4618      	mov	r0, r3
 8014040:	f7f6 fbd6 	bl	800a7f0 <HAL_PCD_EP_SetStall>
    return USBD_OK;
 8014044:	2300      	movs	r3, #0
}
 8014046:	4618      	mov	r0, r3
 8014048:	3708      	adds	r7, #8
 801404a:	46bd      	mov	sp, r7
 801404c:	bd80      	pop	{r7, pc}

0801404e <USBD_LL_ClearStallEP>:
 * @param  ep_addr: Endpoint Number
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef * pdev,
        uint8_t ep_addr)
{
 801404e:	b580      	push	{r7, lr}
 8014050:	b082      	sub	sp, #8
 8014052:	af00      	add	r7, sp, #0
 8014054:	6078      	str	r0, [r7, #4]
 8014056:	460b      	mov	r3, r1
 8014058:	70fb      	strb	r3, [r7, #3]
    HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 801405a:	687b      	ldr	r3, [r7, #4]
 801405c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 8014060:	78fa      	ldrb	r2, [r7, #3]
 8014062:	4611      	mov	r1, r2
 8014064:	4618      	mov	r0, r3
 8014066:	f7f6 fc15 	bl	800a894 <HAL_PCD_EP_ClrStall>
    return USBD_OK;
 801406a:	2300      	movs	r3, #0
}
 801406c:	4618      	mov	r0, r3
 801406e:	3708      	adds	r7, #8
 8014070:	46bd      	mov	sp, r7
 8014072:	bd80      	pop	{r7, pc}

08014074 <USBD_LL_IsStallEP>:
 * @param  pdev: Device handle
 * @param  ep_addr: Endpoint Number
 * @retval Stall (1: Yes, 0: No)
 */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef * pdev, uint8_t ep_addr)
{
 8014074:	b480      	push	{r7}
 8014076:	b085      	sub	sp, #20
 8014078:	af00      	add	r7, sp, #0
 801407a:	6078      	str	r0, [r7, #4]
 801407c:	460b      	mov	r3, r1
 801407e:	70fb      	strb	r3, [r7, #3]
    PCD_HandleTypeDef *hpcd = pdev->pData;
 8014080:	687b      	ldr	r3, [r7, #4]
 8014082:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 8014086:	60fb      	str	r3, [r7, #12]

    if ((ep_addr & 0x80) == 0x80)
 8014088:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801408c:	2b00      	cmp	r3, #0
 801408e:	da0b      	bge.n	80140a8 <USBD_LL_IsStallEP+0x34>
    {
        return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8014090:	78fb      	ldrb	r3, [r7, #3]
 8014092:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8014096:	68f9      	ldr	r1, [r7, #12]
 8014098:	4613      	mov	r3, r2
 801409a:	009b      	lsls	r3, r3, #2
 801409c:	4413      	add	r3, r2
 801409e:	00db      	lsls	r3, r3, #3
 80140a0:	440b      	add	r3, r1
 80140a2:	3312      	adds	r3, #18
 80140a4:	781b      	ldrb	r3, [r3, #0]
 80140a6:	e00b      	b.n	80140c0 <USBD_LL_IsStallEP+0x4c>
    }
    else
    {
        return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 80140a8:	78fb      	ldrb	r3, [r7, #3]
 80140aa:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80140ae:	68f9      	ldr	r1, [r7, #12]
 80140b0:	4613      	mov	r3, r2
 80140b2:	009b      	lsls	r3, r3, #2
 80140b4:	4413      	add	r3, r2
 80140b6:	00db      	lsls	r3, r3, #3
 80140b8:	440b      	add	r3, r1
 80140ba:	f503 73a9 	add.w	r3, r3, #338	; 0x152
 80140be:	781b      	ldrb	r3, [r3, #0]
    }
}
 80140c0:	4618      	mov	r0, r3
 80140c2:	3714      	adds	r7, #20
 80140c4:	46bd      	mov	sp, r7
 80140c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140ca:	4770      	bx	lr

080140cc <USBD_LL_SetUSBAddress>:
 * @param  ep_addr: Endpoint Number
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef * pdev,
        uint8_t dev_addr)
{
 80140cc:	b580      	push	{r7, lr}
 80140ce:	b082      	sub	sp, #8
 80140d0:	af00      	add	r7, sp, #0
 80140d2:	6078      	str	r0, [r7, #4]
 80140d4:	460b      	mov	r3, r1
 80140d6:	70fb      	strb	r3, [r7, #3]
    HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80140d8:	687b      	ldr	r3, [r7, #4]
 80140da:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 80140de:	78fa      	ldrb	r2, [r7, #3]
 80140e0:	4611      	mov	r1, r2
 80140e2:	4618      	mov	r0, r3
 80140e4:	f7f6 fa3b 	bl	800a55e <HAL_PCD_SetAddress>
    return USBD_OK;
 80140e8:	2300      	movs	r3, #0
}
 80140ea:	4618      	mov	r0, r3
 80140ec:	3708      	adds	r7, #8
 80140ee:	46bd      	mov	sp, r7
 80140f0:	bd80      	pop	{r7, pc}

080140f2 <USBD_LL_Transmit>:
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef * pdev,
        uint8_t ep_addr,
        uint8_t * pbuf, uint32_t size)
{
 80140f2:	b580      	push	{r7, lr}
 80140f4:	b084      	sub	sp, #16
 80140f6:	af00      	add	r7, sp, #0
 80140f8:	60f8      	str	r0, [r7, #12]
 80140fa:	607a      	str	r2, [r7, #4]
 80140fc:	603b      	str	r3, [r7, #0]
 80140fe:	460b      	mov	r3, r1
 8014100:	72fb      	strb	r3, [r7, #11]
    HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8014102:	68fb      	ldr	r3, [r7, #12]
 8014104:	f8d3 02c8 	ldr.w	r0, [r3, #712]	; 0x2c8
 8014108:	7af9      	ldrb	r1, [r7, #11]
 801410a:	683b      	ldr	r3, [r7, #0]
 801410c:	687a      	ldr	r2, [r7, #4]
 801410e:	f7f6 fb38 	bl	800a782 <HAL_PCD_EP_Transmit>
    return USBD_OK;
 8014112:	2300      	movs	r3, #0
}
 8014114:	4618      	mov	r0, r3
 8014116:	3710      	adds	r7, #16
 8014118:	46bd      	mov	sp, r7
 801411a:	bd80      	pop	{r7, pc}

0801411c <USBD_LL_PrepareReceive>:
 * @retval USBD Status
 */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef * pdev,
        uint8_t ep_addr,
        uint8_t * pbuf, uint32_t size)
{
 801411c:	b580      	push	{r7, lr}
 801411e:	b084      	sub	sp, #16
 8014120:	af00      	add	r7, sp, #0
 8014122:	60f8      	str	r0, [r7, #12]
 8014124:	607a      	str	r2, [r7, #4]
 8014126:	603b      	str	r3, [r7, #0]
 8014128:	460b      	mov	r3, r1
 801412a:	72fb      	strb	r3, [r7, #11]
    HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 801412c:	68fb      	ldr	r3, [r7, #12]
 801412e:	f8d3 02c8 	ldr.w	r0, [r3, #712]	; 0x2c8
 8014132:	7af9      	ldrb	r1, [r7, #11]
 8014134:	683b      	ldr	r3, [r7, #0]
 8014136:	687a      	ldr	r2, [r7, #4]
 8014138:	f7f6 fada 	bl	800a6f0 <HAL_PCD_EP_Receive>
    return USBD_OK;
 801413c:	2300      	movs	r3, #0
}
 801413e:	4618      	mov	r0, r3
 8014140:	3710      	adds	r7, #16
 8014142:	46bd      	mov	sp, r7
 8014144:	bd80      	pop	{r7, pc}

08014146 <USBD_LL_GetRxDataSize>:
 * @param  pdev: Device handle
 * @param  ep_addr: Endpoint Number
 * @retval Received Data Size
 */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8014146:	b580      	push	{r7, lr}
 8014148:	b082      	sub	sp, #8
 801414a:	af00      	add	r7, sp, #0
 801414c:	6078      	str	r0, [r7, #4]
 801414e:	460b      	mov	r3, r1
 8014150:	70fb      	strb	r3, [r7, #3]
    return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 8014152:	687b      	ldr	r3, [r7, #4]
 8014154:	f8d3 32c8 	ldr.w	r3, [r3, #712]	; 0x2c8
 8014158:	78fa      	ldrb	r2, [r7, #3]
 801415a:	4611      	mov	r1, r2
 801415c:	4618      	mov	r0, r3
 801415e:	f7f6 faf8 	bl	800a752 <HAL_PCD_EP_GetRxCount>
 8014162:	4603      	mov	r3, r0
}
 8014164:	4618      	mov	r0, r3
 8014166:	3708      	adds	r7, #8
 8014168:	46bd      	mov	sp, r7
 801416a:	bd80      	pop	{r7, pc}

0801416c <USBD_VCP_DeviceDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801416c:	b480      	push	{r7}
 801416e:	b083      	sub	sp, #12
 8014170:	af00      	add	r7, sp, #0
 8014172:	4603      	mov	r3, r0
 8014174:	6039      	str	r1, [r7, #0]
 8014176:	71fb      	strb	r3, [r7, #7]
  *length = sizeof(USBD_DeviceDesc);
 8014178:	683b      	ldr	r3, [r7, #0]
 801417a:	2212      	movs	r2, #18
 801417c:	801a      	strh	r2, [r3, #0]
  return (uint8_t*)USBD_DeviceDesc;
 801417e:	4b03      	ldr	r3, [pc, #12]	; (801418c <USBD_VCP_DeviceDescriptor+0x20>)
}
 8014180:	4618      	mov	r0, r3
 8014182:	370c      	adds	r7, #12
 8014184:	46bd      	mov	sp, r7
 8014186:	f85d 7b04 	ldr.w	r7, [sp], #4
 801418a:	4770      	bx	lr
 801418c:	08019a88 	.word	0x08019a88

08014190 <USBD_VCP_LangIDStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014190:	b480      	push	{r7}
 8014192:	b083      	sub	sp, #12
 8014194:	af00      	add	r7, sp, #0
 8014196:	4603      	mov	r3, r0
 8014198:	6039      	str	r1, [r7, #0]
 801419a:	71fb      	strb	r3, [r7, #7]
  *length = sizeof(USBD_LangIDDesc);  
 801419c:	683b      	ldr	r3, [r7, #0]
 801419e:	2204      	movs	r2, #4
 80141a0:	801a      	strh	r2, [r3, #0]
  return (uint8_t*)USBD_LangIDDesc;
 80141a2:	4b03      	ldr	r3, [pc, #12]	; (80141b0 <USBD_VCP_LangIDStrDescriptor+0x20>)
}
 80141a4:	4618      	mov	r0, r3
 80141a6:	370c      	adds	r7, #12
 80141a8:	46bd      	mov	sp, r7
 80141aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80141ae:	4770      	bx	lr
 80141b0:	08019a9c 	.word	0x08019a9c

080141b4 <USBD_VCP_ProductStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80141b4:	b580      	push	{r7, lr}
 80141b6:	b082      	sub	sp, #8
 80141b8:	af00      	add	r7, sp, #0
 80141ba:	4603      	mov	r3, r0
 80141bc:	6039      	str	r1, [r7, #0]
 80141be:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);    
 80141c0:	683a      	ldr	r2, [r7, #0]
 80141c2:	4904      	ldr	r1, [pc, #16]	; (80141d4 <USBD_VCP_ProductStrDescriptor+0x20>)
 80141c4:	4804      	ldr	r0, [pc, #16]	; (80141d8 <USBD_VCP_ProductStrDescriptor+0x24>)
 80141c6:	f7ff f8c3 	bl	8013350 <USBD_GetString>
  return USBD_StrDesc;
 80141ca:	4b02      	ldr	r3, [pc, #8]	; (80141d4 <USBD_VCP_ProductStrDescriptor+0x20>)
}
 80141cc:	4618      	mov	r0, r3
 80141ce:	3708      	adds	r7, #8
 80141d0:	46bd      	mov	sp, r7
 80141d2:	bd80      	pop	{r7, pc}
 80141d4:	200010ec 	.word	0x200010ec
 80141d8:	080197f4 	.word	0x080197f4

080141dc <USBD_VCP_ManufacturerStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80141dc:	b580      	push	{r7, lr}
 80141de:	b082      	sub	sp, #8
 80141e0:	af00      	add	r7, sp, #0
 80141e2:	4603      	mov	r3, r0
 80141e4:	6039      	str	r1, [r7, #0]
 80141e6:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 80141e8:	683a      	ldr	r2, [r7, #0]
 80141ea:	4904      	ldr	r1, [pc, #16]	; (80141fc <USBD_VCP_ManufacturerStrDescriptor+0x20>)
 80141ec:	4804      	ldr	r0, [pc, #16]	; (8014200 <USBD_VCP_ManufacturerStrDescriptor+0x24>)
 80141ee:	f7ff f8af 	bl	8013350 <USBD_GetString>
  return USBD_StrDesc;
 80141f2:	4b02      	ldr	r3, [pc, #8]	; (80141fc <USBD_VCP_ManufacturerStrDescriptor+0x20>)
}
 80141f4:	4618      	mov	r0, r3
 80141f6:	3708      	adds	r7, #8
 80141f8:	46bd      	mov	sp, r7
 80141fa:	bd80      	pop	{r7, pc}
 80141fc:	200010ec 	.word	0x200010ec
 8014200:	08019818 	.word	0x08019818

08014204 <USBD_VCP_SerialStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014204:	b580      	push	{r7, lr}
 8014206:	b082      	sub	sp, #8
 8014208:	af00      	add	r7, sp, #0
 801420a:	4603      	mov	r3, r0
 801420c:	6039      	str	r1, [r7, #0]
 801420e:	71fb      	strb	r3, [r7, #7]
  *length = USB_SIZ_STRING_SERIAL;
 8014210:	683b      	ldr	r3, [r7, #0]
 8014212:	221a      	movs	r2, #26
 8014214:	801a      	strh	r2, [r3, #0]
  
  /* Update the serial number string descriptor with the data from the unique ID*/
  Get_SerialNum();
 8014216:	f000 f82f 	bl	8014278 <Get_SerialNum>
  
  return USBD_StringSerial;
 801421a:	4b02      	ldr	r3, [pc, #8]	; (8014224 <USBD_VCP_SerialStrDescriptor+0x20>)
}
 801421c:	4618      	mov	r0, r3
 801421e:	3708      	adds	r7, #8
 8014220:	46bd      	mov	sp, r7
 8014222:	bd80      	pop	{r7, pc}
 8014224:	200000cc 	.word	0x200000cc

08014228 <USBD_VCP_ConfigStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014228:	b580      	push	{r7, lr}
 801422a:	b082      	sub	sp, #8
 801422c:	af00      	add	r7, sp, #0
 801422e:	4603      	mov	r3, r0
 8014230:	6039      	str	r1, [r7, #0]
 8014232:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length); 
 8014234:	683a      	ldr	r2, [r7, #0]
 8014236:	4904      	ldr	r1, [pc, #16]	; (8014248 <USBD_VCP_ConfigStrDescriptor+0x20>)
 8014238:	4804      	ldr	r0, [pc, #16]	; (801424c <USBD_VCP_ConfigStrDescriptor+0x24>)
 801423a:	f7ff f889 	bl	8013350 <USBD_GetString>
  return USBD_StrDesc;  
 801423e:	4b02      	ldr	r3, [pc, #8]	; (8014248 <USBD_VCP_ConfigStrDescriptor+0x20>)
}
 8014240:	4618      	mov	r0, r3
 8014242:	3708      	adds	r7, #8
 8014244:	46bd      	mov	sp, r7
 8014246:	bd80      	pop	{r7, pc}
 8014248:	200010ec 	.word	0x200010ec
 801424c:	0801982c 	.word	0x0801982c

08014250 <USBD_VCP_InterfaceStrDescriptor>:
  * @param  speed: Current device speed
  * @param  length: Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_VCP_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8014250:	b580      	push	{r7, lr}
 8014252:	b082      	sub	sp, #8
 8014254:	af00      	add	r7, sp, #0
 8014256:	4603      	mov	r3, r0
 8014258:	6039      	str	r1, [r7, #0]
 801425a:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 801425c:	683a      	ldr	r2, [r7, #0]
 801425e:	4904      	ldr	r1, [pc, #16]	; (8014270 <USBD_VCP_InterfaceStrDescriptor+0x20>)
 8014260:	4804      	ldr	r0, [pc, #16]	; (8014274 <USBD_VCP_InterfaceStrDescriptor+0x24>)
 8014262:	f7ff f875 	bl	8013350 <USBD_GetString>
  return USBD_StrDesc;  
 8014266:	4b02      	ldr	r3, [pc, #8]	; (8014270 <USBD_VCP_InterfaceStrDescriptor+0x20>)
}
 8014268:	4618      	mov	r0, r3
 801426a:	3708      	adds	r7, #8
 801426c:	46bd      	mov	sp, r7
 801426e:	bd80      	pop	{r7, pc}
 8014270:	200010ec 	.word	0x200010ec
 8014274:	08019838 	.word	0x08019838

08014278 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor 
  * @param  None 
  * @retval None
  */
static void Get_SerialNum(void)
{
 8014278:	b580      	push	{r7, lr}
 801427a:	b084      	sub	sp, #16
 801427c:	af00      	add	r7, sp, #0
  uint32_t deviceserial0, deviceserial1, deviceserial2;
  
  deviceserial0 = *(uint32_t*)DEVICE_ID1;
 801427e:	4b0f      	ldr	r3, [pc, #60]	; (80142bc <Get_SerialNum+0x44>)
 8014280:	681b      	ldr	r3, [r3, #0]
 8014282:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t*)DEVICE_ID2;
 8014284:	4b0e      	ldr	r3, [pc, #56]	; (80142c0 <Get_SerialNum+0x48>)
 8014286:	681b      	ldr	r3, [r3, #0]
 8014288:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t*)DEVICE_ID3;
 801428a:	4b0e      	ldr	r3, [pc, #56]	; (80142c4 <Get_SerialNum+0x4c>)
 801428c:	681b      	ldr	r3, [r3, #0]
 801428e:	607b      	str	r3, [r7, #4]
  
  deviceserial0 += deviceserial2;
 8014290:	68fa      	ldr	r2, [r7, #12]
 8014292:	687b      	ldr	r3, [r7, #4]
 8014294:	4413      	add	r3, r2
 8014296:	60fb      	str	r3, [r7, #12]
  
  if (deviceserial0 != 0)
 8014298:	68fb      	ldr	r3, [r7, #12]
 801429a:	2b00      	cmp	r3, #0
 801429c:	d009      	beq.n	80142b2 <Get_SerialNum+0x3a>
  {
    IntToUnicode (deviceserial0, &USBD_StringSerial[2] ,8);
 801429e:	2208      	movs	r2, #8
 80142a0:	4909      	ldr	r1, [pc, #36]	; (80142c8 <Get_SerialNum+0x50>)
 80142a2:	68f8      	ldr	r0, [r7, #12]
 80142a4:	f000 f814 	bl	80142d0 <IntToUnicode>
    IntToUnicode (deviceserial1, &USBD_StringSerial[18] ,4);
 80142a8:	2204      	movs	r2, #4
 80142aa:	4908      	ldr	r1, [pc, #32]	; (80142cc <Get_SerialNum+0x54>)
 80142ac:	68b8      	ldr	r0, [r7, #8]
 80142ae:	f000 f80f 	bl	80142d0 <IntToUnicode>
  }
}
 80142b2:	bf00      	nop
 80142b4:	3710      	adds	r7, #16
 80142b6:	46bd      	mov	sp, r7
 80142b8:	bd80      	pop	{r7, pc}
 80142ba:	bf00      	nop
 80142bc:	1fff7a10 	.word	0x1fff7a10
 80142c0:	1fff7a14 	.word	0x1fff7a14
 80142c4:	1fff7a18 	.word	0x1fff7a18
 80142c8:	200000ce 	.word	0x200000ce
 80142cc:	200000de 	.word	0x200000de

080142d0 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer 
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
{
 80142d0:	b480      	push	{r7}
 80142d2:	b087      	sub	sp, #28
 80142d4:	af00      	add	r7, sp, #0
 80142d6:	60f8      	str	r0, [r7, #12]
 80142d8:	60b9      	str	r1, [r7, #8]
 80142da:	4613      	mov	r3, r2
 80142dc:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 80142de:	2300      	movs	r3, #0
 80142e0:	75fb      	strb	r3, [r7, #23]
  
  for( idx = 0 ; idx < len ; idx ++)
 80142e2:	2300      	movs	r3, #0
 80142e4:	75fb      	strb	r3, [r7, #23]
 80142e6:	e027      	b.n	8014338 <IntToUnicode+0x68>
  {
    if( ((value >> 28)) < 0xA )
 80142e8:	68fb      	ldr	r3, [r7, #12]
 80142ea:	0f1b      	lsrs	r3, r3, #28
 80142ec:	2b09      	cmp	r3, #9
 80142ee:	d80b      	bhi.n	8014308 <IntToUnicode+0x38>
    {
      pbuf[ 2* idx] = (value >> 28) + '0';
 80142f0:	68fb      	ldr	r3, [r7, #12]
 80142f2:	0f1b      	lsrs	r3, r3, #28
 80142f4:	b2da      	uxtb	r2, r3
 80142f6:	7dfb      	ldrb	r3, [r7, #23]
 80142f8:	005b      	lsls	r3, r3, #1
 80142fa:	4619      	mov	r1, r3
 80142fc:	68bb      	ldr	r3, [r7, #8]
 80142fe:	440b      	add	r3, r1
 8014300:	3230      	adds	r2, #48	; 0x30
 8014302:	b2d2      	uxtb	r2, r2
 8014304:	701a      	strb	r2, [r3, #0]
 8014306:	e00a      	b.n	801431e <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2* idx] = (value >> 28) + 'A' - 10; 
 8014308:	68fb      	ldr	r3, [r7, #12]
 801430a:	0f1b      	lsrs	r3, r3, #28
 801430c:	b2da      	uxtb	r2, r3
 801430e:	7dfb      	ldrb	r3, [r7, #23]
 8014310:	005b      	lsls	r3, r3, #1
 8014312:	4619      	mov	r1, r3
 8014314:	68bb      	ldr	r3, [r7, #8]
 8014316:	440b      	add	r3, r1
 8014318:	3237      	adds	r2, #55	; 0x37
 801431a:	b2d2      	uxtb	r2, r2
 801431c:	701a      	strb	r2, [r3, #0]
    }
    
    value = value << 4;
 801431e:	68fb      	ldr	r3, [r7, #12]
 8014320:	011b      	lsls	r3, r3, #4
 8014322:	60fb      	str	r3, [r7, #12]
    
    pbuf[ 2* idx + 1] = 0;
 8014324:	7dfb      	ldrb	r3, [r7, #23]
 8014326:	005b      	lsls	r3, r3, #1
 8014328:	3301      	adds	r3, #1
 801432a:	68ba      	ldr	r2, [r7, #8]
 801432c:	4413      	add	r3, r2
 801432e:	2200      	movs	r2, #0
 8014330:	701a      	strb	r2, [r3, #0]
  for( idx = 0 ; idx < len ; idx ++)
 8014332:	7dfb      	ldrb	r3, [r7, #23]
 8014334:	3301      	adds	r3, #1
 8014336:	75fb      	strb	r3, [r7, #23]
 8014338:	7dfa      	ldrb	r2, [r7, #23]
 801433a:	79fb      	ldrb	r3, [r7, #7]
 801433c:	429a      	cmp	r2, r3
 801433e:	d3d3      	bcc.n	80142e8 <IntToUnicode+0x18>
  }
}
 8014340:	bf00      	nop
 8014342:	bf00      	nop
 8014344:	371c      	adds	r7, #28
 8014346:	46bd      	mov	sp, r7
 8014348:	f85d 7b04 	ldr.w	r7, [sp], #4
 801434c:	4770      	bx	lr
	...

08014350 <VCP_Init>:
static void SendData( void );
static void EnableTxPath( void );

/* Functions Definition ------------------------------------------------------*/
void VCP_Init( uint8_t *p_tx_buffer , uint8_t *p_rx_buffer )
{
 8014350:	b580      	push	{r7, lr}
 8014352:	b082      	sub	sp, #8
 8014354:	af00      	add	r7, sp, #0
 8014356:	6078      	str	r0, [r7, #4]
 8014358:	6039      	str	r1, [r7, #0]
  VCP_Context.VcpStatus = VCP_TX_NOT_READY;
 801435a:	4b12      	ldr	r3, [pc, #72]	; (80143a4 <VCP_Init+0x54>)
 801435c:	2200      	movs	r2, #0
 801435e:	731a      	strb	r2, [r3, #12]
  VCP_Context.TxDataStatus = TX_DATA_NOT_PENDING;
 8014360:	4b10      	ldr	r3, [pc, #64]	; (80143a4 <VCP_Init+0x54>)
 8014362:	2200      	movs	r2, #0
 8014364:	735a      	strb	r2, [r3, #13]
  VCP_Context.pTxBuffer = p_tx_buffer;
 8014366:	4a0f      	ldr	r2, [pc, #60]	; (80143a4 <VCP_Init+0x54>)
 8014368:	687b      	ldr	r3, [r7, #4]
 801436a:	6013      	str	r3, [r2, #0]
  VCP_Context.pRxBuffer = p_rx_buffer;
 801436c:	4a0d      	ldr	r2, [pc, #52]	; (80143a4 <VCP_Init+0x54>)
 801436e:	683b      	ldr	r3, [r7, #0]
 8014370:	6053      	str	r3, [r2, #4]

  /* Init Device Library */
  USBD_Init(&VCP_Device, &VCP_Desc, 0);
 8014372:	2200      	movs	r2, #0
 8014374:	490c      	ldr	r1, [pc, #48]	; (80143a8 <VCP_Init+0x58>)
 8014376:	480d      	ldr	r0, [pc, #52]	; (80143ac <VCP_Init+0x5c>)
 8014378:	f7fd fe64 	bl	8012044 <USBD_Init>

  /* Register the CDC class */
  USBD_RegisterClass(&VCP_Device, &USBD_CDC);
 801437c:	490c      	ldr	r1, [pc, #48]	; (80143b0 <VCP_Init+0x60>)
 801437e:	480b      	ldr	r0, [pc, #44]	; (80143ac <VCP_Init+0x5c>)
 8014380:	f7fd fe90 	bl	80120a4 <USBD_RegisterClass>

  /* Add CDC Interface Class */
  USBD_CDC_RegisterInterface(&VCP_Device, &VCP_CDC_fops);
 8014384:	490b      	ldr	r1, [pc, #44]	; (80143b4 <VCP_Init+0x64>)
 8014386:	4809      	ldr	r0, [pc, #36]	; (80143ac <VCP_Init+0x5c>)
 8014388:	f7fd fd8c 	bl	8011ea4 <USBD_CDC_RegisterInterface>

  /* Start Device Process */
  USBD_Start(&VCP_Device);
 801438c:	4807      	ldr	r0, [pc, #28]	; (80143ac <VCP_Init+0x5c>)
 801438e:	f7fd febf 	bl	8012110 <USBD_Start>

#ifdef  VCP_TX_PATH_INTERFACE_READY_SETUP_TIME
  HW_TS_Create(VCP_TIMER_PROC_ID, &VCP_Context.VcpTxReadyTid, hw_ts_SingleShot, EnableTxPath);
#endif

  UTIL_SEQ_RegTask(1<<VCP_TASK_ID, UTIL_SEQ_RFU, SendData);
 8014392:	4a09      	ldr	r2, [pc, #36]	; (80143b8 <VCP_Init+0x68>)
 8014394:	2100      	movs	r1, #0
 8014396:	2040      	movs	r0, #64	; 0x40
 8014398:	f003 fcf4 	bl	8017d84 <UTIL_SEQ_RegTask>
  
  return;
 801439c:	bf00      	nop
}
 801439e:	3708      	adds	r7, #8
 80143a0:	46bd      	mov	sp, r7
 80143a2:	bd80      	pop	{r7, pc}
 80143a4:	200011ec 	.word	0x200011ec
 80143a8:	200000b0 	.word	0x200000b0
 80143ac:	20001200 	.word	0x20001200
 80143b0:	20000030 	.word	0x20000030
 80143b4:	200000f0 	.word	0x200000f0
 80143b8:	08014425 	.word	0x08014425

080143bc <VCP_SendData>:

void VCP_SendData( uint8_t *p_data , uint16_t size , void (*cb)( void ) )
{
 80143bc:	b580      	push	{r7, lr}
 80143be:	b088      	sub	sp, #32
 80143c0:	af00      	add	r7, sp, #0
 80143c2:	60f8      	str	r0, [r7, #12]
 80143c4:	460b      	mov	r3, r1
 80143c6:	607a      	str	r2, [r7, #4]
 80143c8:	817b      	strh	r3, [r7, #10]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80143ca:	f3ef 8310 	mrs	r3, PRIMASK
 80143ce:	61bb      	str	r3, [r7, #24]
  return(result);
 80143d0:	69bb      	ldr	r3, [r7, #24]
  BACKUP_PRIMASK();
 80143d2:	61fb      	str	r3, [r7, #28]

  memcpy(VCP_Context.pTxBuffer, p_data, size);
 80143d4:	4b12      	ldr	r3, [pc, #72]	; (8014420 <VCP_SendData+0x64>)
 80143d6:	681b      	ldr	r3, [r3, #0]
 80143d8:	897a      	ldrh	r2, [r7, #10]
 80143da:	68f9      	ldr	r1, [r7, #12]
 80143dc:	4618      	mov	r0, r3
 80143de:	f004 f8da 	bl	8018596 <memcpy>

  VCP_Context.pf_CallBack = cb;
 80143e2:	4a0f      	ldr	r2, [pc, #60]	; (8014420 <VCP_SendData+0x64>)
 80143e4:	687b      	ldr	r3, [r7, #4]
 80143e6:	6093      	str	r3, [r2, #8]
  VCP_Context.TxDataSize = size;
 80143e8:	4a0d      	ldr	r2, [pc, #52]	; (8014420 <VCP_SendData+0x64>)
 80143ea:	897b      	ldrh	r3, [r7, #10]
 80143ec:	81d3      	strh	r3, [r2, #14]
  __ASM volatile ("cpsid i" : : : "memory");
 80143ee:	b672      	cpsid	i
}
 80143f0:	bf00      	nop

  DISABLE_IRQ();
  if (VCP_Context.VcpStatus != VCP_TX_NOT_READY)
 80143f2:	4b0b      	ldr	r3, [pc, #44]	; (8014420 <VCP_SendData+0x64>)
 80143f4:	7b1b      	ldrb	r3, [r3, #12]
 80143f6:	2b00      	cmp	r3, #0
 80143f8:	d004      	beq.n	8014404 <VCP_SendData+0x48>
  {
    UTIL_SEQ_SetTask(1 << VCP_TASK_ID, VCP_TASK_PRIO);
 80143fa:	2101      	movs	r1, #1
 80143fc:	2040      	movs	r0, #64	; 0x40
 80143fe:	f003 fce3 	bl	8017dc8 <UTIL_SEQ_SetTask>
 8014402:	e002      	b.n	801440a <VCP_SendData+0x4e>
  }
  else
  {
    VCP_Context.TxDataStatus = TX_DATA_PENDING;
 8014404:	4b06      	ldr	r3, [pc, #24]	; (8014420 <VCP_SendData+0x64>)
 8014406:	2201      	movs	r2, #1
 8014408:	735a      	strb	r2, [r3, #13]
 801440a:	69fb      	ldr	r3, [r7, #28]
 801440c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801440e:	697b      	ldr	r3, [r7, #20]
 8014410:	f383 8810 	msr	PRIMASK, r3
}
 8014414:	bf00      	nop
  }
  RESTORE_PRIMASK();

  return;
 8014416:	bf00      	nop
}
 8014418:	3720      	adds	r7, #32
 801441a:	46bd      	mov	sp, r7
 801441c:	bd80      	pop	{r7, pc}
 801441e:	bf00      	nop
 8014420:	200011ec 	.word	0x200011ec

08014424 <SendData>:
 *
 * LOCAL FUNCTIONS
 *
 *************************************************************/
static void SendData( void )
{
 8014424:	b580      	push	{r7, lr}
 8014426:	af00      	add	r7, sp, #0
  USBD_CDC_SetTxBuffer(&VCP_Device, VCP_Context.pTxBuffer, VCP_Context.TxDataSize);
 8014428:	4b0b      	ldr	r3, [pc, #44]	; (8014458 <SendData+0x34>)
 801442a:	681b      	ldr	r3, [r3, #0]
 801442c:	4a0a      	ldr	r2, [pc, #40]	; (8014458 <SendData+0x34>)
 801442e:	89d2      	ldrh	r2, [r2, #14]
 8014430:	4619      	mov	r1, r3
 8014432:	480a      	ldr	r0, [pc, #40]	; (801445c <SendData+0x38>)
 8014434:	f7fd fd50 	bl	8011ed8 <USBD_CDC_SetTxBuffer>

  if (USBD_CDC_TransmitPacket(&VCP_Device) != USBD_OK)
 8014438:	4808      	ldr	r0, [pc, #32]	; (801445c <SendData+0x38>)
 801443a:	f7fd fd8d 	bl	8011f58 <USBD_CDC_TransmitPacket>
 801443e:	4603      	mov	r3, r0
 8014440:	2b00      	cmp	r3, #0
 8014442:	d004      	beq.n	801444e <SendData+0x2a>
  {
    UTIL_SEQ_SetTask(1 << VCP_TASK_ID, VCP_TASK_PRIO);
 8014444:	2101      	movs	r1, #1
 8014446:	2040      	movs	r0, #64	; 0x40
 8014448:	f003 fcbe 	bl	8017dc8 <UTIL_SEQ_SetTask>
  else
  {
    VCP_Context.pf_CallBack();
  }

  return;
 801444c:	e003      	b.n	8014456 <SendData+0x32>
    VCP_Context.pf_CallBack();
 801444e:	4b02      	ldr	r3, [pc, #8]	; (8014458 <SendData+0x34>)
 8014450:	689b      	ldr	r3, [r3, #8]
 8014452:	4798      	blx	r3
  return;
 8014454:	bf00      	nop
}
 8014456:	bd80      	pop	{r7, pc}
 8014458:	200011ec 	.word	0x200011ec
 801445c:	20001200 	.word	0x20001200

08014460 <EnableTxPath>:

static void EnableTxPath( void )
{
 8014460:	b580      	push	{r7, lr}
 8014462:	b084      	sub	sp, #16
 8014464:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014466:	f3ef 8310 	mrs	r3, PRIMASK
 801446a:	60bb      	str	r3, [r7, #8]
  return(result);
 801446c:	68bb      	ldr	r3, [r7, #8]
  BACKUP_PRIMASK();
 801446e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
 8014470:	b672      	cpsid	i
}
 8014472:	bf00      	nop

  DISABLE_IRQ();
  VCP_Context.VcpStatus = VCP_TX_READY;
 8014474:	4b0a      	ldr	r3, [pc, #40]	; (80144a0 <EnableTxPath+0x40>)
 8014476:	2201      	movs	r2, #1
 8014478:	731a      	strb	r2, [r3, #12]

  if (VCP_Context.TxDataStatus != TX_DATA_NOT_PENDING)
 801447a:	4b09      	ldr	r3, [pc, #36]	; (80144a0 <EnableTxPath+0x40>)
 801447c:	7b5b      	ldrb	r3, [r3, #13]
 801447e:	2b00      	cmp	r3, #0
 8014480:	d003      	beq.n	801448a <EnableTxPath+0x2a>
  {
    UTIL_SEQ_SetTask(1 << VCP_TASK_ID, VCP_TASK_PRIO);
 8014482:	2101      	movs	r1, #1
 8014484:	2040      	movs	r0, #64	; 0x40
 8014486:	f003 fc9f 	bl	8017dc8 <UTIL_SEQ_SetTask>
 801448a:	68fb      	ldr	r3, [r7, #12]
 801448c:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801448e:	687b      	ldr	r3, [r7, #4]
 8014490:	f383 8810 	msr	PRIMASK, r3
}
 8014494:	bf00      	nop

#ifdef  VCP_TX_PATH_INTERFACE_READY_SETUP_TIME
  HW_TS_Delete(VCP_Context.VcpTxReadyTid);
#endif

  return;
 8014496:	bf00      	nop
}
 8014498:	3710      	adds	r7, #16
 801449a:	46bd      	mov	sp, r7
 801449c:	bd80      	pop	{r7, pc}
 801449e:	bf00      	nop
 80144a0:	200011ec 	.word	0x200011ec

080144a4 <Vcp_Itf_Init>:
 *         Initializes the CDC media low layer
 * @param  None
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
static int8_t Vcp_Itf_Init( void )
{
 80144a4:	b580      	push	{r7, lr}
 80144a6:	af00      	add	r7, sp, #0
  USBD_CDC_SetRxBuffer(&VCP_Device, VCP_Context.pRxBuffer);
 80144a8:	4b06      	ldr	r3, [pc, #24]	; (80144c4 <Vcp_Itf_Init+0x20>)
 80144aa:	685b      	ldr	r3, [r3, #4]
 80144ac:	4619      	mov	r1, r3
 80144ae:	4806      	ldr	r0, [pc, #24]	; (80144c8 <Vcp_Itf_Init+0x24>)
 80144b0:	f7fd fd34 	bl	8011f1c <USBD_CDC_SetRxBuffer>

  /* Initiate next USB packet transfer */
  USBD_CDC_ReceivePacket(&VCP_Device);
 80144b4:	4804      	ldr	r0, [pc, #16]	; (80144c8 <Vcp_Itf_Init+0x24>)
 80144b6:	f7fd fd8f 	bl	8011fd8 <USBD_CDC_ReceivePacket>

#ifdef  VCP_TX_PATH_INTERFACE_READY_SETUP_TIME
  HW_TS_Start(VCP_Context.VcpTxReadyTid, VCP_TX_PATH_INTERFACE_READY_SETUP_TIME);
#else
  EnableTxPath();
 80144ba:	f7ff ffd1 	bl	8014460 <EnableTxPath>
#endif

  return (USBD_OK);
 80144be:	2300      	movs	r3, #0
}
 80144c0:	4618      	mov	r0, r3
 80144c2:	bd80      	pop	{r7, pc}
 80144c4:	200011ec 	.word	0x200011ec
 80144c8:	20001200 	.word	0x20001200

080144cc <Vcp_Itf_DeInit>:
 *         DeInitializes the CDC media low layer
 * @param  None
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
static int8_t Vcp_Itf_DeInit( void )
{
 80144cc:	b480      	push	{r7}
 80144ce:	af00      	add	r7, sp, #0
  return (USBD_OK);
 80144d0:	2300      	movs	r3, #0
}
 80144d2:	4618      	mov	r0, r3
 80144d4:	46bd      	mov	sp, r7
 80144d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80144da:	4770      	bx	lr

080144dc <Vcp_Itf_Control>:
 * @param  Buf: Buffer containing command data (request parameters)
 * @param  Len: Number of data to be sent (in bytes)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
static int8_t Vcp_Itf_Control( uint8_t cmd , uint8_t* pbuf , uint16_t length )
{
 80144dc:	b480      	push	{r7}
 80144de:	b083      	sub	sp, #12
 80144e0:	af00      	add	r7, sp, #0
 80144e2:	4603      	mov	r3, r0
 80144e4:	6039      	str	r1, [r7, #0]
 80144e6:	71fb      	strb	r3, [r7, #7]
 80144e8:	4613      	mov	r3, r2
 80144ea:	80bb      	strh	r3, [r7, #4]
  switch (cmd)
 80144ec:	79fb      	ldrb	r3, [r7, #7]
 80144ee:	2b23      	cmp	r3, #35	; 0x23
 80144f0:	f200 8098 	bhi.w	8014624 <Vcp_Itf_Control+0x148>
 80144f4:	a201      	add	r2, pc, #4	; (adr r2, 80144fc <Vcp_Itf_Control+0x20>)
 80144f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80144fa:	bf00      	nop
 80144fc:	08014625 	.word	0x08014625
 8014500:	08014625 	.word	0x08014625
 8014504:	08014625 	.word	0x08014625
 8014508:	08014625 	.word	0x08014625
 801450c:	08014625 	.word	0x08014625
 8014510:	08014625 	.word	0x08014625
 8014514:	08014625 	.word	0x08014625
 8014518:	08014625 	.word	0x08014625
 801451c:	08014625 	.word	0x08014625
 8014520:	08014625 	.word	0x08014625
 8014524:	08014625 	.word	0x08014625
 8014528:	08014625 	.word	0x08014625
 801452c:	08014625 	.word	0x08014625
 8014530:	08014625 	.word	0x08014625
 8014534:	08014625 	.word	0x08014625
 8014538:	08014625 	.word	0x08014625
 801453c:	08014625 	.word	0x08014625
 8014540:	08014625 	.word	0x08014625
 8014544:	08014625 	.word	0x08014625
 8014548:	08014625 	.word	0x08014625
 801454c:	08014625 	.word	0x08014625
 8014550:	08014625 	.word	0x08014625
 8014554:	08014625 	.word	0x08014625
 8014558:	08014625 	.word	0x08014625
 801455c:	08014625 	.word	0x08014625
 8014560:	08014625 	.word	0x08014625
 8014564:	08014625 	.word	0x08014625
 8014568:	08014625 	.word	0x08014625
 801456c:	08014625 	.word	0x08014625
 8014570:	08014625 	.word	0x08014625
 8014574:	08014625 	.word	0x08014625
 8014578:	08014625 	.word	0x08014625
 801457c:	0801458d 	.word	0x0801458d
 8014580:	080145d1 	.word	0x080145d1
 8014584:	08014625 	.word	0x08014625
 8014588:	08014625 	.word	0x08014625
    case CDC_CLEAR_COMM_FEATURE:
      /* Add your code here */
      break;

    case CDC_SET_LINE_CODING:
      LineCoding.bitrate = (uint32_t)(pbuf[0] | (pbuf[1] << 8) |\
 801458c:	683b      	ldr	r3, [r7, #0]
 801458e:	781b      	ldrb	r3, [r3, #0]
 8014590:	461a      	mov	r2, r3
 8014592:	683b      	ldr	r3, [r7, #0]
 8014594:	3301      	adds	r3, #1
 8014596:	781b      	ldrb	r3, [r3, #0]
 8014598:	021b      	lsls	r3, r3, #8
 801459a:	431a      	orrs	r2, r3
 (pbuf[2] << 16) | (pbuf[3] << 24));
 801459c:	683b      	ldr	r3, [r7, #0]
 801459e:	3302      	adds	r3, #2
 80145a0:	781b      	ldrb	r3, [r3, #0]
 80145a2:	041b      	lsls	r3, r3, #16
      LineCoding.bitrate = (uint32_t)(pbuf[0] | (pbuf[1] << 8) |\
 80145a4:	431a      	orrs	r2, r3
 (pbuf[2] << 16) | (pbuf[3] << 24));
 80145a6:	683b      	ldr	r3, [r7, #0]
 80145a8:	3303      	adds	r3, #3
 80145aa:	781b      	ldrb	r3, [r3, #0]
 80145ac:	061b      	lsls	r3, r3, #24
 80145ae:	4313      	orrs	r3, r2
      LineCoding.bitrate = (uint32_t)(pbuf[0] | (pbuf[1] << 8) |\
 80145b0:	461a      	mov	r2, r3
 80145b2:	4b20      	ldr	r3, [pc, #128]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145b4:	601a      	str	r2, [r3, #0]
      LineCoding.format = pbuf[4];
 80145b6:	683b      	ldr	r3, [r7, #0]
 80145b8:	791a      	ldrb	r2, [r3, #4]
 80145ba:	4b1e      	ldr	r3, [pc, #120]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145bc:	711a      	strb	r2, [r3, #4]
      LineCoding.paritytype = pbuf[5];
 80145be:	683b      	ldr	r3, [r7, #0]
 80145c0:	795a      	ldrb	r2, [r3, #5]
 80145c2:	4b1c      	ldr	r3, [pc, #112]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145c4:	715a      	strb	r2, [r3, #5]
      LineCoding.datatype = pbuf[6];
 80145c6:	683b      	ldr	r3, [r7, #0]
 80145c8:	799a      	ldrb	r2, [r3, #6]
 80145ca:	4b1a      	ldr	r3, [pc, #104]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145cc:	719a      	strb	r2, [r3, #6]

      break;
 80145ce:	e02a      	b.n	8014626 <Vcp_Itf_Control+0x14a>

    case CDC_GET_LINE_CODING:
      pbuf[0] = (uint8_t) (LineCoding.bitrate);
 80145d0:	4b18      	ldr	r3, [pc, #96]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145d2:	681b      	ldr	r3, [r3, #0]
 80145d4:	b2da      	uxtb	r2, r3
 80145d6:	683b      	ldr	r3, [r7, #0]
 80145d8:	701a      	strb	r2, [r3, #0]
      pbuf[1] = (uint8_t) (LineCoding.bitrate >> 8);
 80145da:	4b16      	ldr	r3, [pc, #88]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145dc:	681b      	ldr	r3, [r3, #0]
 80145de:	0a1a      	lsrs	r2, r3, #8
 80145e0:	683b      	ldr	r3, [r7, #0]
 80145e2:	3301      	adds	r3, #1
 80145e4:	b2d2      	uxtb	r2, r2
 80145e6:	701a      	strb	r2, [r3, #0]
      pbuf[2] = (uint8_t) (LineCoding.bitrate >> 16);
 80145e8:	4b12      	ldr	r3, [pc, #72]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145ea:	681b      	ldr	r3, [r3, #0]
 80145ec:	0c1a      	lsrs	r2, r3, #16
 80145ee:	683b      	ldr	r3, [r7, #0]
 80145f0:	3302      	adds	r3, #2
 80145f2:	b2d2      	uxtb	r2, r2
 80145f4:	701a      	strb	r2, [r3, #0]
      pbuf[3] = (uint8_t) (LineCoding.bitrate >> 24);
 80145f6:	4b0f      	ldr	r3, [pc, #60]	; (8014634 <Vcp_Itf_Control+0x158>)
 80145f8:	681b      	ldr	r3, [r3, #0]
 80145fa:	0e1a      	lsrs	r2, r3, #24
 80145fc:	683b      	ldr	r3, [r7, #0]
 80145fe:	3303      	adds	r3, #3
 8014600:	b2d2      	uxtb	r2, r2
 8014602:	701a      	strb	r2, [r3, #0]
      pbuf[4] = LineCoding.format;
 8014604:	683b      	ldr	r3, [r7, #0]
 8014606:	3304      	adds	r3, #4
 8014608:	4a0a      	ldr	r2, [pc, #40]	; (8014634 <Vcp_Itf_Control+0x158>)
 801460a:	7912      	ldrb	r2, [r2, #4]
 801460c:	701a      	strb	r2, [r3, #0]
      pbuf[5] = LineCoding.paritytype;
 801460e:	683b      	ldr	r3, [r7, #0]
 8014610:	3305      	adds	r3, #5
 8014612:	4a08      	ldr	r2, [pc, #32]	; (8014634 <Vcp_Itf_Control+0x158>)
 8014614:	7952      	ldrb	r2, [r2, #5]
 8014616:	701a      	strb	r2, [r3, #0]
      pbuf[6] = LineCoding.datatype;
 8014618:	683b      	ldr	r3, [r7, #0]
 801461a:	3306      	adds	r3, #6
 801461c:	4a05      	ldr	r2, [pc, #20]	; (8014634 <Vcp_Itf_Control+0x158>)
 801461e:	7992      	ldrb	r2, [r2, #6]
 8014620:	701a      	strb	r2, [r3, #0]
      break;
 8014622:	e000      	b.n	8014626 <Vcp_Itf_Control+0x14a>
    case CDC_SEND_BREAK:
      /* Add your code here */
      break;

    default:
      break;
 8014624:	bf00      	nop
  }

  return (USBD_OK);
 8014626:	2300      	movs	r3, #0
}
 8014628:	4618      	mov	r0, r3
 801462a:	370c      	adds	r7, #12
 801462c:	46bd      	mov	sp, r7
 801462e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014632:	4770      	bx	lr
 8014634:	200000e8 	.word	0x200000e8

08014638 <Vcp_Itf_Receive>:
 * @param  Buf: Buffer of data to be transmitted
 * @param  Len: Number of data received (in bytes)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
static int8_t Vcp_Itf_Receive( uint8_t* Buf , uint32_t *Len )
{
 8014638:	b580      	push	{r7, lr}
 801463a:	b082      	sub	sp, #8
 801463c:	af00      	add	r7, sp, #0
 801463e:	6078      	str	r0, [r7, #4]
 8014640:	6039      	str	r1, [r7, #0]
  VCP_DataReceived(Buf, Len);
 8014642:	6839      	ldr	r1, [r7, #0]
 8014644:	6878      	ldr	r0, [r7, #4]
 8014646:	f000 f80b 	bl	8014660 <VCP_DataReceived>

  /* Initiate next USB packet transfer */
  USBD_CDC_ReceivePacket(&VCP_Device);
 801464a:	4804      	ldr	r0, [pc, #16]	; (801465c <Vcp_Itf_Receive+0x24>)
 801464c:	f7fd fcc4 	bl	8011fd8 <USBD_CDC_ReceivePacket>

  return (USBD_OK);
 8014650:	2300      	movs	r3, #0
}
 8014652:	4618      	mov	r0, r3
 8014654:	3708      	adds	r7, #8
 8014656:	46bd      	mov	sp, r7
 8014658:	bd80      	pop	{r7, pc}
 801465a:	bf00      	nop
 801465c:	20001200 	.word	0x20001200

08014660 <VCP_DataReceived>:

__weak void VCP_DataReceived( uint8_t* Buf , uint32_t *Len )
{
 8014660:	b480      	push	{r7}
 8014662:	b083      	sub	sp, #12
 8014664:	af00      	add	r7, sp, #0
 8014666:	6078      	str	r0, [r7, #4]
 8014668:	6039      	str	r1, [r7, #0]
  return;
 801466a:	bf00      	nop
}
 801466c:	370c      	adds	r7, #12
 801466e:	46bd      	mov	sp, r7
 8014670:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014674:	4770      	bx	lr

08014676 <VCP_TransmitCplt>:
__weak int8_t VCP_TransmitCplt( uint8_t *Buf, uint32_t *Len, uint8_t epnum )
{
 8014676:	b480      	push	{r7}
 8014678:	b085      	sub	sp, #20
 801467a:	af00      	add	r7, sp, #0
 801467c:	60f8      	str	r0, [r7, #12]
 801467e:	60b9      	str	r1, [r7, #8]
 8014680:	4613      	mov	r3, r2
 8014682:	71fb      	strb	r3, [r7, #7]
  return(USBD_OK);
 8014684:	2300      	movs	r3, #0
}
 8014686:	4618      	mov	r0, r3
 8014688:	3714      	adds	r7, #20
 801468a:	46bd      	mov	sp, r7
 801468c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014690:	4770      	bx	lr
	...

08014694 <DbgTrace_TxCpltCallback>:
 * @note   Indicate the end of the transmission of a DBG_TRACE trace buffer to DBG_TRACE USART. If queue
 *         contains new trace data to transmit, start a new transmission.
 * @retval None
 */
static void DbgTrace_TxCpltCallback(void)
{
 8014694:	b580      	push	{r7, lr}
 8014696:	b086      	sub	sp, #24
 8014698:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801469a:	f3ef 8310 	mrs	r3, PRIMASK
 801469e:	60fb      	str	r3, [r7, #12]
  return(result);
 80146a0:	68fb      	ldr	r3, [r7, #12]
#if (DBG_TRACE_USE_CIRCULAR_QUEUE != 0)
  uint8_t* buf;
  uint16_t bufSize;

  BACKUP_PRIMASK();
 80146a2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80146a4:	b672      	cpsid	i
}
 80146a6:	bf00      	nop

  DISABLE_IRQ();			/**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  /* Remove element just sent to UART */
  CircularQueue_Remove(&MsgDbgTraceQueue,&bufSize);
 80146a8:	1cbb      	adds	r3, r7, #2
 80146aa:	4619      	mov	r1, r3
 80146ac:	4812      	ldr	r0, [pc, #72]	; (80146f8 <DbgTrace_TxCpltCallback+0x64>)
 80146ae:	f000 fbe6 	bl	8014e7e <CircularQueue_Remove>

  /* Sense if new data to be sent */
  buf=CircularQueue_Sense(&MsgDbgTraceQueue,&bufSize);
 80146b2:	1cbb      	adds	r3, r7, #2
 80146b4:	4619      	mov	r1, r3
 80146b6:	4810      	ldr	r0, [pc, #64]	; (80146f8 <DbgTrace_TxCpltCallback+0x64>)
 80146b8:	f000 fcd2 	bl	8015060 <CircularQueue_Sense>
 80146bc:	6138      	str	r0, [r7, #16]


  if ( buf != NULL) 
 80146be:	693b      	ldr	r3, [r7, #16]
 80146c0:	2b00      	cmp	r3, #0
 80146c2:	d00c      	beq.n	80146de <DbgTrace_TxCpltCallback+0x4a>
 80146c4:	697b      	ldr	r3, [r7, #20]
 80146c6:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80146c8:	68bb      	ldr	r3, [r7, #8]
 80146ca:	f383 8810 	msr	PRIMASK, r3
}
 80146ce:	bf00      	nop
  {
    RESTORE_PRIMASK();
    DbgOutputTraces((uint8_t*)buf, bufSize, DbgTrace_TxCpltCallback);
 80146d0:	887b      	ldrh	r3, [r7, #2]
 80146d2:	4a0a      	ldr	r2, [pc, #40]	; (80146fc <DbgTrace_TxCpltCallback+0x68>)
 80146d4:	4619      	mov	r1, r3
 80146d6:	6938      	ldr	r0, [r7, #16]
 80146d8:	f7f2 f8de 	bl	8006898 <DbgOutputTraces>

  DbgTracePeripheralReady = SET;

  RESTORE_PRIMASK();
#endif
}
 80146dc:	e008      	b.n	80146f0 <DbgTrace_TxCpltCallback+0x5c>
    DbgTracePeripheralReady = SET;
 80146de:	4b08      	ldr	r3, [pc, #32]	; (8014700 <DbgTrace_TxCpltCallback+0x6c>)
 80146e0:	2201      	movs	r2, #1
 80146e2:	701a      	strb	r2, [r3, #0]
 80146e4:	697b      	ldr	r3, [r7, #20]
 80146e6:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80146e8:	687b      	ldr	r3, [r7, #4]
 80146ea:	f383 8810 	msr	PRIMASK, r3
}
 80146ee:	bf00      	nop
}
 80146f0:	bf00      	nop
 80146f2:	3718      	adds	r7, #24
 80146f4:	46bd      	mov	sp, r7
 80146f6:	bd80      	pop	{r7, pc}
 80146f8:	200014dc 	.word	0x200014dc
 80146fc:	08014695 	.word	0x08014695
 8014700:	20000104 	.word	0x20000104

08014704 <DbgTraceInit>:
#endif

void DbgTraceInit( void )
{
 8014704:	b580      	push	{r7, lr}
 8014706:	b082      	sub	sp, #8
 8014708:	af02      	add	r7, sp, #8
#if (( CFG_DEBUG_TRACE_FULL != 0 ) || ( CFG_DEBUG_TRACE_LIGHT != 0 ))
  DbgOutputInit();
 801470a:	f7f2 f8b9 	bl	8006880 <DbgOutputInit>
#if (DBG_TRACE_USE_CIRCULAR_QUEUE != 0)
  CircularQueue_Init(&MsgDbgTraceQueue, MsgDbgTraceQueueBuff, DBG_TRACE_MSG_QUEUE_SIZE, 0, CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG);
 801470e:	2302      	movs	r3, #2
 8014710:	9300      	str	r3, [sp, #0]
 8014712:	2300      	movs	r3, #0
 8014714:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8014718:	4903      	ldr	r1, [pc, #12]	; (8014728 <DbgTraceInit+0x24>)
 801471a:	4804      	ldr	r0, [pc, #16]	; (801472c <DbgTraceInit+0x28>)
 801471c:	f000 f956 	bl	80149cc <CircularQueue_Init>
#endif 
#endif
  return;
 8014720:	bf00      	nop
}
 8014722:	46bd      	mov	sp, r7
 8014724:	bd80      	pop	{r7, pc}
 8014726:	bf00      	nop
 8014728:	200014fc 	.word	0x200014fc
 801472c:	200014dc 	.word	0x200014dc

08014730 <_write>:
 * @param	bufsize buffer size
 * @param	...: arguments to be formatted in format string
 * @retval none
 */
size_t _write(int handle, const unsigned char * buf, size_t bufSize)
{
 8014730:	b580      	push	{r7, lr}
 8014732:	b084      	sub	sp, #16
 8014734:	af00      	add	r7, sp, #0
 8014736:	60f8      	str	r0, [r7, #12]
 8014738:	60b9      	str	r1, [r7, #8]
 801473a:	607a      	str	r2, [r7, #4]
  return ( DbgTraceWrite(handle, buf, bufSize) );
 801473c:	687a      	ldr	r2, [r7, #4]
 801473e:	68b9      	ldr	r1, [r7, #8]
 8014740:	68f8      	ldr	r0, [r7, #12]
 8014742:	f000 f805 	bl	8014750 <DbgTraceWrite>
 8014746:	4603      	mov	r3, r0
}
 8014748:	4618      	mov	r0, r3
 801474a:	3710      	adds	r7, #16
 801474c:	46bd      	mov	sp, r7
 801474e:	bd80      	pop	{r7, pc}

08014750 <DbgTraceWrite>:
 * @param buf buffer to write
 * @param bufsize buffer size
 * @retval Number of elements written
 */
size_t DbgTraceWrite(int handle, const unsigned char * buf, size_t bufSize)
{
 8014750:	b580      	push	{r7, lr}
 8014752:	b08a      	sub	sp, #40	; 0x28
 8014754:	af00      	add	r7, sp, #0
 8014756:	60f8      	str	r0, [r7, #12]
 8014758:	60b9      	str	r1, [r7, #8]
 801475a:	607a      	str	r2, [r7, #4]
  size_t chars_written = 0;
 801475c:	2300      	movs	r3, #0
 801475e:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014760:	f3ef 8310 	mrs	r3, PRIMASK
 8014764:	61bb      	str	r3, [r7, #24]
  return(result);
 8014766:	69bb      	ldr	r3, [r7, #24]
  uint8_t* buffer;

  BACKUP_PRIMASK();
 8014768:	623b      	str	r3, [r7, #32]

  /* Ignore flushes */
  if ( handle == -1 )
 801476a:	68fb      	ldr	r3, [r7, #12]
 801476c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014770:	d102      	bne.n	8014778 <DbgTraceWrite+0x28>
  {
    chars_written = ( size_t ) 0;
 8014772:	2300      	movs	r3, #0
 8014774:	627b      	str	r3, [r7, #36]	; 0x24
 8014776:	e037      	b.n	80147e8 <DbgTraceWrite+0x98>
  }
  /* Only allow stdout/stderr output */
  else if ( ( handle != 1 ) && ( handle != 2 ) )
 8014778:	68fb      	ldr	r3, [r7, #12]
 801477a:	2b01      	cmp	r3, #1
 801477c:	d006      	beq.n	801478c <DbgTraceWrite+0x3c>
 801477e:	68fb      	ldr	r3, [r7, #12]
 8014780:	2b02      	cmp	r3, #2
 8014782:	d003      	beq.n	801478c <DbgTraceWrite+0x3c>
  {
    chars_written = ( size_t ) - 1;
 8014784:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8014788:	627b      	str	r3, [r7, #36]	; 0x24
 801478a:	e02d      	b.n	80147e8 <DbgTraceWrite+0x98>
  }
  /* Parameters OK, call the low-level character output routine */
  else if (bufSize != 0)
 801478c:	687b      	ldr	r3, [r7, #4]
 801478e:	2b00      	cmp	r3, #0
 8014790:	d02a      	beq.n	80147e8 <DbgTraceWrite+0x98>
  {
    chars_written = bufSize;
 8014792:	687b      	ldr	r3, [r7, #4]
 8014794:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("cpsid i" : : : "memory");
 8014796:	b672      	cpsid	i
}
 8014798:	bf00      	nop
    /* If queue emepty and TX free, send directly */
    /* CS Start */

#if (DBG_TRACE_USE_CIRCULAR_QUEUE != 0)
    DISABLE_IRQ();      /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
    buffer=CircularQueue_Add(&MsgDbgTraceQueue,(uint8_t*)buf, bufSize,1);
 801479a:	687b      	ldr	r3, [r7, #4]
 801479c:	b29a      	uxth	r2, r3
 801479e:	2301      	movs	r3, #1
 80147a0:	68b9      	ldr	r1, [r7, #8]
 80147a2:	4814      	ldr	r0, [pc, #80]	; (80147f4 <DbgTraceWrite+0xa4>)
 80147a4:	f000 f944 	bl	8014a30 <CircularQueue_Add>
 80147a8:	61f8      	str	r0, [r7, #28]
    if (buffer && DbgTracePeripheralReady)
 80147aa:	69fb      	ldr	r3, [r7, #28]
 80147ac:	2b00      	cmp	r3, #0
 80147ae:	d015      	beq.n	80147dc <DbgTraceWrite+0x8c>
 80147b0:	4b11      	ldr	r3, [pc, #68]	; (80147f8 <DbgTraceWrite+0xa8>)
 80147b2:	781b      	ldrb	r3, [r3, #0]
 80147b4:	b2db      	uxtb	r3, r3
 80147b6:	2b00      	cmp	r3, #0
 80147b8:	d010      	beq.n	80147dc <DbgTraceWrite+0x8c>
    {
      DbgTracePeripheralReady = RESET;
 80147ba:	4b0f      	ldr	r3, [pc, #60]	; (80147f8 <DbgTraceWrite+0xa8>)
 80147bc:	2200      	movs	r2, #0
 80147be:	701a      	strb	r2, [r3, #0]
 80147c0:	6a3b      	ldr	r3, [r7, #32]
 80147c2:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80147c4:	697b      	ldr	r3, [r7, #20]
 80147c6:	f383 8810 	msr	PRIMASK, r3
}
 80147ca:	bf00      	nop
      RESTORE_PRIMASK();
      DbgOutputTraces((uint8_t*)buffer, bufSize, DbgTrace_TxCpltCallback);
 80147cc:	687b      	ldr	r3, [r7, #4]
 80147ce:	b29b      	uxth	r3, r3
 80147d0:	4a0a      	ldr	r2, [pc, #40]	; (80147fc <DbgTraceWrite+0xac>)
 80147d2:	4619      	mov	r1, r3
 80147d4:	69f8      	ldr	r0, [r7, #28]
 80147d6:	f7f2 f85f 	bl	8006898 <DbgOutputTraces>
 80147da:	e005      	b.n	80147e8 <DbgTraceWrite+0x98>
 80147dc:	6a3b      	ldr	r3, [r7, #32]
 80147de:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80147e0:	693b      	ldr	r3, [r7, #16]
 80147e2:	f383 8810 	msr	PRIMASK, r3
}
 80147e6:	bf00      	nop
    DbgOutputTraces((uint8_t*)buf, bufSize, DbgTrace_TxCpltCallback);
    while (!DbgTracePeripheralReady);
#endif
    /* CS END */
  }
  return ( chars_written );
 80147e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80147ea:	4618      	mov	r0, r3
 80147ec:	3728      	adds	r7, #40	; 0x28
 80147ee:	46bd      	mov	sp, r7
 80147f0:	bd80      	pop	{r7, pc}
 80147f2:	bf00      	nop
 80147f4:	200014dc 	.word	0x200014dc
 80147f8:	20000104 	.word	0x20000104
 80147fc:	08014695 	.word	0x08014695

08014800 <OTP_Read>:
/* Global variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Functions Definition ------------------------------------------------------*/

uint8_t * OTP_Read( uint8_t id )
{
 8014800:	b480      	push	{r7}
 8014802:	b085      	sub	sp, #20
 8014804:	af00      	add	r7, sp, #0
 8014806:	4603      	mov	r3, r0
 8014808:	71fb      	strb	r3, [r7, #7]
  uint8_t *p_id;

  p_id = (uint8_t*)(CFG_OTP_END_ADRESS - 7) ;
 801480a:	4b0f      	ldr	r3, [pc, #60]	; (8014848 <OTP_Read+0x48>)
 801480c:	60fb      	str	r3, [r7, #12]

  while( ((*( p_id + 7 )) != id) && ( p_id != (uint8_t*)CFG_OTP_BASE_ADDRESS) )
 801480e:	e002      	b.n	8014816 <OTP_Read+0x16>
  {
    p_id -= 8 ;
 8014810:	68fb      	ldr	r3, [r7, #12]
 8014812:	3b08      	subs	r3, #8
 8014814:	60fb      	str	r3, [r7, #12]
  while( ((*( p_id + 7 )) != id) && ( p_id != (uint8_t*)CFG_OTP_BASE_ADDRESS) )
 8014816:	68fb      	ldr	r3, [r7, #12]
 8014818:	3307      	adds	r3, #7
 801481a:	781b      	ldrb	r3, [r3, #0]
 801481c:	79fa      	ldrb	r2, [r7, #7]
 801481e:	429a      	cmp	r2, r3
 8014820:	d003      	beq.n	801482a <OTP_Read+0x2a>
 8014822:	68fb      	ldr	r3, [r7, #12]
 8014824:	4a09      	ldr	r2, [pc, #36]	; (801484c <OTP_Read+0x4c>)
 8014826:	4293      	cmp	r3, r2
 8014828:	d1f2      	bne.n	8014810 <OTP_Read+0x10>
  }

  if((*( p_id + 7 )) != id)
 801482a:	68fb      	ldr	r3, [r7, #12]
 801482c:	3307      	adds	r3, #7
 801482e:	781b      	ldrb	r3, [r3, #0]
 8014830:	79fa      	ldrb	r2, [r7, #7]
 8014832:	429a      	cmp	r2, r3
 8014834:	d001      	beq.n	801483a <OTP_Read+0x3a>
  {
    p_id = 0 ;
 8014836:	2300      	movs	r3, #0
 8014838:	60fb      	str	r3, [r7, #12]
  }

  return p_id ;
 801483a:	68fb      	ldr	r3, [r7, #12]
}
 801483c:	4618      	mov	r0, r3
 801483e:	3714      	adds	r7, #20
 8014840:	46bd      	mov	sp, r7
 8014842:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014846:	4770      	bx	lr
 8014848:	1fff73f8 	.word	0x1fff73f8
 801484c:	1fff7000 	.word	0x1fff7000

08014850 <LST_init_head>:

/******************************************************************************
 * Function Definitions 
 ******************************************************************************/
void LST_init_head (tListNode * listHead)
{
 8014850:	b480      	push	{r7}
 8014852:	b083      	sub	sp, #12
 8014854:	af00      	add	r7, sp, #0
 8014856:	6078      	str	r0, [r7, #4]
  listHead->next = listHead;
 8014858:	687b      	ldr	r3, [r7, #4]
 801485a:	687a      	ldr	r2, [r7, #4]
 801485c:	601a      	str	r2, [r3, #0]
  listHead->prev = listHead;
 801485e:	687b      	ldr	r3, [r7, #4]
 8014860:	687a      	ldr	r2, [r7, #4]
 8014862:	605a      	str	r2, [r3, #4]
}
 8014864:	bf00      	nop
 8014866:	370c      	adds	r7, #12
 8014868:	46bd      	mov	sp, r7
 801486a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801486e:	4770      	bx	lr

08014870 <LST_is_empty>:

uint8_t LST_is_empty (tListNode * listHead)
{
 8014870:	b480      	push	{r7}
 8014872:	b087      	sub	sp, #28
 8014874:	af00      	add	r7, sp, #0
 8014876:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014878:	f3ef 8310 	mrs	r3, PRIMASK
 801487c:	60fb      	str	r3, [r7, #12]
  return(result);
 801487e:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;
  uint8_t return_value;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 8014880:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 8014882:	b672      	cpsid	i
}
 8014884:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  if(listHead->next == listHead)
 8014886:	687b      	ldr	r3, [r7, #4]
 8014888:	681b      	ldr	r3, [r3, #0]
 801488a:	687a      	ldr	r2, [r7, #4]
 801488c:	429a      	cmp	r2, r3
 801488e:	d102      	bne.n	8014896 <LST_is_empty+0x26>
  {
    return_value = TRUE;
 8014890:	2301      	movs	r3, #1
 8014892:	75fb      	strb	r3, [r7, #23]
 8014894:	e001      	b.n	801489a <LST_is_empty+0x2a>
  }
  else
  {
    return_value = FALSE;
 8014896:	2300      	movs	r3, #0
 8014898:	75fb      	strb	r3, [r7, #23]
 801489a:	693b      	ldr	r3, [r7, #16]
 801489c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801489e:	68bb      	ldr	r3, [r7, #8]
 80148a0:	f383 8810 	msr	PRIMASK, r3
}
 80148a4:	bf00      	nop
  }
  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/

  return return_value;
 80148a6:	7dfb      	ldrb	r3, [r7, #23]
}
 80148a8:	4618      	mov	r0, r3
 80148aa:	371c      	adds	r7, #28
 80148ac:	46bd      	mov	sp, r7
 80148ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148b2:	4770      	bx	lr

080148b4 <LST_insert_head>:

void LST_insert_head (tListNode * listHead, tListNode * node)
{
 80148b4:	b480      	push	{r7}
 80148b6:	b087      	sub	sp, #28
 80148b8:	af00      	add	r7, sp, #0
 80148ba:	6078      	str	r0, [r7, #4]
 80148bc:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80148be:	f3ef 8310 	mrs	r3, PRIMASK
 80148c2:	60fb      	str	r3, [r7, #12]
  return(result);
 80148c4:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80148c6:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80148c8:	b672      	cpsid	i
}
 80148ca:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead->next;
 80148cc:	687b      	ldr	r3, [r7, #4]
 80148ce:	681a      	ldr	r2, [r3, #0]
 80148d0:	683b      	ldr	r3, [r7, #0]
 80148d2:	601a      	str	r2, [r3, #0]
  node->prev = listHead;
 80148d4:	683b      	ldr	r3, [r7, #0]
 80148d6:	687a      	ldr	r2, [r7, #4]
 80148d8:	605a      	str	r2, [r3, #4]
  listHead->next = node;
 80148da:	687b      	ldr	r3, [r7, #4]
 80148dc:	683a      	ldr	r2, [r7, #0]
 80148de:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node;
 80148e0:	683b      	ldr	r3, [r7, #0]
 80148e2:	681b      	ldr	r3, [r3, #0]
 80148e4:	683a      	ldr	r2, [r7, #0]
 80148e6:	605a      	str	r2, [r3, #4]
 80148e8:	697b      	ldr	r3, [r7, #20]
 80148ea:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80148ec:	693b      	ldr	r3, [r7, #16]
 80148ee:	f383 8810 	msr	PRIMASK, r3
}
 80148f2:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 80148f4:	bf00      	nop
 80148f6:	371c      	adds	r7, #28
 80148f8:	46bd      	mov	sp, r7
 80148fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80148fe:	4770      	bx	lr

08014900 <LST_insert_tail>:


void LST_insert_tail (tListNode * listHead, tListNode * node)
{
 8014900:	b480      	push	{r7}
 8014902:	b087      	sub	sp, #28
 8014904:	af00      	add	r7, sp, #0
 8014906:	6078      	str	r0, [r7, #4]
 8014908:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801490a:	f3ef 8310 	mrs	r3, PRIMASK
 801490e:	60fb      	str	r3, [r7, #12]
  return(result);
 8014910:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 8014912:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8014914:	b672      	cpsid	i
}
 8014916:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead;
 8014918:	683b      	ldr	r3, [r7, #0]
 801491a:	687a      	ldr	r2, [r7, #4]
 801491c:	601a      	str	r2, [r3, #0]
  node->prev = listHead->prev;
 801491e:	687b      	ldr	r3, [r7, #4]
 8014920:	685a      	ldr	r2, [r3, #4]
 8014922:	683b      	ldr	r3, [r7, #0]
 8014924:	605a      	str	r2, [r3, #4]
  listHead->prev = node;
 8014926:	687b      	ldr	r3, [r7, #4]
 8014928:	683a      	ldr	r2, [r7, #0]
 801492a:	605a      	str	r2, [r3, #4]
  (node->prev)->next = node;
 801492c:	683b      	ldr	r3, [r7, #0]
 801492e:	685b      	ldr	r3, [r3, #4]
 8014930:	683a      	ldr	r2, [r7, #0]
 8014932:	601a      	str	r2, [r3, #0]
 8014934:	697b      	ldr	r3, [r7, #20]
 8014936:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014938:	693b      	ldr	r3, [r7, #16]
 801493a:	f383 8810 	msr	PRIMASK, r3
}
 801493e:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8014940:	bf00      	nop
 8014942:	371c      	adds	r7, #28
 8014944:	46bd      	mov	sp, r7
 8014946:	f85d 7b04 	ldr.w	r7, [sp], #4
 801494a:	4770      	bx	lr

0801494c <LST_remove_node>:


void LST_remove_node (tListNode * node)
{
 801494c:	b480      	push	{r7}
 801494e:	b087      	sub	sp, #28
 8014950:	af00      	add	r7, sp, #0
 8014952:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014954:	f3ef 8310 	mrs	r3, PRIMASK
 8014958:	60fb      	str	r3, [r7, #12]
  return(result);
 801495a:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801495c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801495e:	b672      	cpsid	i
}
 8014960:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  (node->prev)->next = node->next;
 8014962:	687b      	ldr	r3, [r7, #4]
 8014964:	685b      	ldr	r3, [r3, #4]
 8014966:	687a      	ldr	r2, [r7, #4]
 8014968:	6812      	ldr	r2, [r2, #0]
 801496a:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node->prev;
 801496c:	687b      	ldr	r3, [r7, #4]
 801496e:	681b      	ldr	r3, [r3, #0]
 8014970:	687a      	ldr	r2, [r7, #4]
 8014972:	6852      	ldr	r2, [r2, #4]
 8014974:	605a      	str	r2, [r3, #4]
 8014976:	697b      	ldr	r3, [r7, #20]
 8014978:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801497a:	693b      	ldr	r3, [r7, #16]
 801497c:	f383 8810 	msr	PRIMASK, r3
}
 8014980:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8014982:	bf00      	nop
 8014984:	371c      	adds	r7, #28
 8014986:	46bd      	mov	sp, r7
 8014988:	f85d 7b04 	ldr.w	r7, [sp], #4
 801498c:	4770      	bx	lr

0801498e <LST_remove_head>:


void LST_remove_head (tListNode * listHead, tListNode ** node )
{
 801498e:	b580      	push	{r7, lr}
 8014990:	b086      	sub	sp, #24
 8014992:	af00      	add	r7, sp, #0
 8014994:	6078      	str	r0, [r7, #4]
 8014996:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014998:	f3ef 8310 	mrs	r3, PRIMASK
 801499c:	60fb      	str	r3, [r7, #12]
  return(result);
 801499e:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80149a0:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80149a2:	b672      	cpsid	i
}
 80149a4:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  *node = listHead->next;
 80149a6:	687b      	ldr	r3, [r7, #4]
 80149a8:	681a      	ldr	r2, [r3, #0]
 80149aa:	683b      	ldr	r3, [r7, #0]
 80149ac:	601a      	str	r2, [r3, #0]
  LST_remove_node (listHead->next);
 80149ae:	687b      	ldr	r3, [r7, #4]
 80149b0:	681b      	ldr	r3, [r3, #0]
 80149b2:	4618      	mov	r0, r3
 80149b4:	f7ff ffca 	bl	801494c <LST_remove_node>
 80149b8:	697b      	ldr	r3, [r7, #20]
 80149ba:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80149bc:	693b      	ldr	r3, [r7, #16]
 80149be:	f383 8810 	msr	PRIMASK, r3
}
 80149c2:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 80149c4:	bf00      	nop
 80149c6:	3718      	adds	r7, #24
 80149c8:	46bd      	mov	sp, r7
 80149ca:	bd80      	pop	{r7, pc}

080149cc <CircularQueue_Init>:
  * @param  queueSize:  Size of Queue Buffer
  * @param  elementSize: Size of an element in the queue. if =0, the queue will manage variable sizze elements
  * @retval   always 0
  */
int CircularQueue_Init(queue_t *q, uint8_t* queueBuffer, uint32_t queueSize, uint16_t elementSize, uint8_t optionFlags)
{
 80149cc:	b480      	push	{r7}
 80149ce:	b085      	sub	sp, #20
 80149d0:	af00      	add	r7, sp, #0
 80149d2:	60f8      	str	r0, [r7, #12]
 80149d4:	60b9      	str	r1, [r7, #8]
 80149d6:	607a      	str	r2, [r7, #4]
 80149d8:	807b      	strh	r3, [r7, #2]
  q->qBuff = queueBuffer;
 80149da:	68fb      	ldr	r3, [r7, #12]
 80149dc:	68ba      	ldr	r2, [r7, #8]
 80149de:	601a      	str	r2, [r3, #0]
  q->first = 0;
 80149e0:	68fb      	ldr	r3, [r7, #12]
 80149e2:	2200      	movs	r2, #0
 80149e4:	60da      	str	r2, [r3, #12]
  q->last = 0; /* queueSize-1; */
 80149e6:	68fb      	ldr	r3, [r7, #12]
 80149e8:	2200      	movs	r2, #0
 80149ea:	611a      	str	r2, [r3, #16]
  q->byteCount = 0;
 80149ec:	68fb      	ldr	r3, [r7, #12]
 80149ee:	2200      	movs	r2, #0
 80149f0:	615a      	str	r2, [r3, #20]
  q->elementCount = 0;
 80149f2:	68fb      	ldr	r3, [r7, #12]
 80149f4:	2200      	movs	r2, #0
 80149f6:	619a      	str	r2, [r3, #24]
  q->queueMaxSize = queueSize;
 80149f8:	68fb      	ldr	r3, [r7, #12]
 80149fa:	687a      	ldr	r2, [r7, #4]
 80149fc:	605a      	str	r2, [r3, #4]
  q->elementSize = elementSize;
 80149fe:	68fb      	ldr	r3, [r7, #12]
 8014a00:	887a      	ldrh	r2, [r7, #2]
 8014a02:	811a      	strh	r2, [r3, #8]
  q->optionFlags = optionFlags;
 8014a04:	68fb      	ldr	r3, [r7, #12]
 8014a06:	7e3a      	ldrb	r2, [r7, #24]
 8014a08:	771a      	strb	r2, [r3, #28]

   if ((optionFlags & CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG) && q-> elementSize)
 8014a0a:	7e3b      	ldrb	r3, [r7, #24]
 8014a0c:	f003 0302 	and.w	r3, r3, #2
 8014a10:	2b00      	cmp	r3, #0
 8014a12:	d006      	beq.n	8014a22 <CircularQueue_Init+0x56>
 8014a14:	68fb      	ldr	r3, [r7, #12]
 8014a16:	891b      	ldrh	r3, [r3, #8]
 8014a18:	2b00      	cmp	r3, #0
 8014a1a:	d002      	beq.n	8014a22 <CircularQueue_Init+0x56>
   {
    /* can not deal with splitting at the end of buffer with fixed size element */
    return -1;
 8014a1c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8014a20:	e000      	b.n	8014a24 <CircularQueue_Init+0x58>
  }
  return 0;
 8014a22:	2300      	movs	r3, #0
}
 8014a24:	4618      	mov	r0, r3
 8014a26:	3714      	adds	r7, #20
 8014a28:	46bd      	mov	sp, r7
 8014a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a2e:	4770      	bx	lr

08014a30 <CircularQueue_Add>:
  * @param  elementSize:  Size of element to be added to the queue. Only used if the queue manage variable size elements
  * @param  nbElements:  number of elements in the in buffer pointed by x
  * @retval  pointer on last element just added to the queue, NULL if the element to be added do not fit in the queue (too big)
  */
uint8_t* CircularQueue_Add(queue_t *q, uint8_t* x, uint16_t elementSize, uint32_t nbElements)
{
 8014a30:	b580      	push	{r7, lr}
 8014a32:	b08e      	sub	sp, #56	; 0x38
 8014a34:	af00      	add	r7, sp, #0
 8014a36:	60f8      	str	r0, [r7, #12]
 8014a38:	60b9      	str	r1, [r7, #8]
 8014a3a:	603b      	str	r3, [r7, #0]
 8014a3c:	4613      	mov	r3, r2
 8014a3e:	80fb      	strh	r3, [r7, #6]

  uint8_t* ptr = NULL;                      /* fct return ptr to the element freshly added, if no room fct return NULL */
 8014a40:	2300      	movs	r3, #0
 8014a42:	623b      	str	r3, [r7, #32]
  uint16_t curElementSize = 0;              /* the size of the element currently  stored at q->last position */
 8014a44:	2300      	movs	r3, #0
 8014a46:	86fb      	strh	r3, [r7, #54]	; 0x36
  uint8_t  elemSizeStorageRoom  = 0 ;       /* Indicate the header (which contain only size) of element in case of varaibale size element (q->elementsize == 0) */
 8014a48:	2300      	movs	r3, #0
 8014a4a:	77fb      	strb	r3, [r7, #31]
  uint32_t curBuffPosition;                  /* the current position in the queue buffer */
  uint32_t i;                               /* loop counter */
  uint32_t NbBytesToCopy = 0, NbCopiedBytes = 0 ; /* Indicators for copying bytes in queue */
 8014a4c:	2300      	movs	r3, #0
 8014a4e:	62bb      	str	r3, [r7, #40]	; 0x28
 8014a50:	2300      	movs	r3, #0
 8014a52:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t eob_free_size;                         /* Eof End of Quque Buffer Free Size */
  uint8_t  wrap_will_occur = 0;                   /* indicate if a wrap around will occurs */
 8014a54:	2300      	movs	r3, #0
 8014a56:	77bb      	strb	r3, [r7, #30]
  uint8_t  wrapped_element_eob_size;              /* In case of Wrap around, indicate size of parta of element that fit at thened of the queuue  buffer */
  uint16_t overhead = 0;                          /* In case of CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG or CIRCULAR_QUEUE_NO_WRAP_FLAG options, 
 8014a58:	2300      	movs	r3, #0
 8014a5a:	83bb      	strh	r3, [r7, #28]
                                                     indcate the size overhead that will be generated by adding the element with wrap management (split or no wrap ) */ 
  
  
  elemSizeStorageRoom  = (q->elementSize == 0) ? 2 : 0;
 8014a5c:	68fb      	ldr	r3, [r7, #12]
 8014a5e:	891b      	ldrh	r3, [r3, #8]
 8014a60:	2b00      	cmp	r3, #0
 8014a62:	d101      	bne.n	8014a68 <CircularQueue_Add+0x38>
 8014a64:	2302      	movs	r3, #2
 8014a66:	e000      	b.n	8014a6a <CircularQueue_Add+0x3a>
 8014a68:	2300      	movs	r3, #0
 8014a6a:	77fb      	strb	r3, [r7, #31]
  /* retrieve the size of last element sored: the value stored at the beginning of the queue element if element size is variable otherwise take it from fixed element Size member */
  if (q->byteCount)
 8014a6c:	68fb      	ldr	r3, [r7, #12]
 8014a6e:	695b      	ldr	r3, [r3, #20]
 8014a70:	2b00      	cmp	r3, #0
 8014a72:	d02a      	beq.n	8014aca <CircularQueue_Add+0x9a>
  {
    curElementSize = (q->elementSize == 0) ? q->qBuff[q->last] + ((q->qBuff[MOD((q->last+1), q->queueMaxSize)])<<8) + 2 : q->elementSize;
 8014a74:	68fb      	ldr	r3, [r7, #12]
 8014a76:	891b      	ldrh	r3, [r3, #8]
 8014a78:	2b00      	cmp	r3, #0
 8014a7a:	d123      	bne.n	8014ac4 <CircularQueue_Add+0x94>
 8014a7c:	68fb      	ldr	r3, [r7, #12]
 8014a7e:	681a      	ldr	r2, [r3, #0]
 8014a80:	68fb      	ldr	r3, [r7, #12]
 8014a82:	691b      	ldr	r3, [r3, #16]
 8014a84:	4413      	add	r3, r2
 8014a86:	781b      	ldrb	r3, [r3, #0]
 8014a88:	b29a      	uxth	r2, r3
 8014a8a:	68fb      	ldr	r3, [r7, #12]
 8014a8c:	6819      	ldr	r1, [r3, #0]
 8014a8e:	68fb      	ldr	r3, [r7, #12]
 8014a90:	691b      	ldr	r3, [r3, #16]
 8014a92:	1c58      	adds	r0, r3, #1
 8014a94:	68fb      	ldr	r3, [r7, #12]
 8014a96:	685b      	ldr	r3, [r3, #4]
 8014a98:	4298      	cmp	r0, r3
 8014a9a:	d306      	bcc.n	8014aaa <CircularQueue_Add+0x7a>
 8014a9c:	68fb      	ldr	r3, [r7, #12]
 8014a9e:	6918      	ldr	r0, [r3, #16]
 8014aa0:	68fb      	ldr	r3, [r7, #12]
 8014aa2:	685b      	ldr	r3, [r3, #4]
 8014aa4:	1ac3      	subs	r3, r0, r3
 8014aa6:	3301      	adds	r3, #1
 8014aa8:	e002      	b.n	8014ab0 <CircularQueue_Add+0x80>
 8014aaa:	68fb      	ldr	r3, [r7, #12]
 8014aac:	691b      	ldr	r3, [r3, #16]
 8014aae:	3301      	adds	r3, #1
 8014ab0:	440b      	add	r3, r1
 8014ab2:	781b      	ldrb	r3, [r3, #0]
 8014ab4:	b29b      	uxth	r3, r3
 8014ab6:	021b      	lsls	r3, r3, #8
 8014ab8:	b29b      	uxth	r3, r3
 8014aba:	4413      	add	r3, r2
 8014abc:	b29b      	uxth	r3, r3
 8014abe:	3302      	adds	r3, #2
 8014ac0:	b29b      	uxth	r3, r3
 8014ac2:	e001      	b.n	8014ac8 <CircularQueue_Add+0x98>
 8014ac4:	68fb      	ldr	r3, [r7, #12]
 8014ac6:	891b      	ldrh	r3, [r3, #8]
 8014ac8:	86fb      	strh	r3, [r7, #54]	; 0x36
  }
  /* if queue element have fixed size , reset the elementSize arg with fixed element size value */
  if (q->elementSize > 0)               
 8014aca:	68fb      	ldr	r3, [r7, #12]
 8014acc:	891b      	ldrh	r3, [r3, #8]
 8014ace:	2b00      	cmp	r3, #0
 8014ad0:	d002      	beq.n	8014ad8 <CircularQueue_Add+0xa8>
  {
    elementSize = q->elementSize;
 8014ad2:	68fb      	ldr	r3, [r7, #12]
 8014ad4:	891b      	ldrh	r3, [r3, #8]
 8014ad6:	80fb      	strh	r3, [r7, #6]
  }

   eob_free_size = (q->last >= q->first) ? q->queueMaxSize - (q->last + curElementSize) : 0;
 8014ad8:	68fb      	ldr	r3, [r7, #12]
 8014ada:	691a      	ldr	r2, [r3, #16]
 8014adc:	68fb      	ldr	r3, [r7, #12]
 8014ade:	68db      	ldr	r3, [r3, #12]
 8014ae0:	429a      	cmp	r2, r3
 8014ae2:	d307      	bcc.n	8014af4 <CircularQueue_Add+0xc4>
 8014ae4:	68fb      	ldr	r3, [r7, #12]
 8014ae6:	685a      	ldr	r2, [r3, #4]
 8014ae8:	68fb      	ldr	r3, [r7, #12]
 8014aea:	6919      	ldr	r1, [r3, #16]
 8014aec:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8014aee:	440b      	add	r3, r1
 8014af0:	1ad3      	subs	r3, r2, r3
 8014af2:	e000      	b.n	8014af6 <CircularQueue_Add+0xc6>
 8014af4:	2300      	movs	r3, #0
 8014af6:	61bb      	str	r3, [r7, #24]

   /* check how many bytes of wrapped element (if anay) are at end of buffer */
   wrapped_element_eob_size = (((elementSize + elemSizeStorageRoom )*nbElements) < eob_free_size) ? 0 : (eob_free_size % (elementSize + elemSizeStorageRoom));
 8014af8:	88fa      	ldrh	r2, [r7, #6]
 8014afa:	7ffb      	ldrb	r3, [r7, #31]
 8014afc:	4413      	add	r3, r2
 8014afe:	461a      	mov	r2, r3
 8014b00:	683b      	ldr	r3, [r7, #0]
 8014b02:	fb02 f303 	mul.w	r3, r2, r3
 8014b06:	69ba      	ldr	r2, [r7, #24]
 8014b08:	429a      	cmp	r2, r3
 8014b0a:	d80b      	bhi.n	8014b24 <CircularQueue_Add+0xf4>
 8014b0c:	88fa      	ldrh	r2, [r7, #6]
 8014b0e:	7ffb      	ldrb	r3, [r7, #31]
 8014b10:	4413      	add	r3, r2
 8014b12:	461a      	mov	r2, r3
 8014b14:	69bb      	ldr	r3, [r7, #24]
 8014b16:	fbb3 f1f2 	udiv	r1, r3, r2
 8014b1a:	fb01 f202 	mul.w	r2, r1, r2
 8014b1e:	1a9b      	subs	r3, r3, r2
 8014b20:	b2db      	uxtb	r3, r3
 8014b22:	e000      	b.n	8014b26 <CircularQueue_Add+0xf6>
 8014b24:	2300      	movs	r3, #0
 8014b26:	75fb      	strb	r3, [r7, #23]
   wrap_will_occur  = wrapped_element_eob_size > elemSizeStorageRoom;
 8014b28:	7dfa      	ldrb	r2, [r7, #23]
 8014b2a:	7ffb      	ldrb	r3, [r7, #31]
 8014b2c:	429a      	cmp	r2, r3
 8014b2e:	bf8c      	ite	hi
 8014b30:	2301      	movhi	r3, #1
 8014b32:	2300      	movls	r3, #0
 8014b34:	b2db      	uxtb	r3, r3
 8014b36:	77bb      	strb	r3, [r7, #30]

   overhead = (wrap_will_occur && (q->optionFlags & CIRCULAR_QUEUE_NO_WRAP_FLAG)) ? wrapped_element_eob_size : overhead;
 8014b38:	7fbb      	ldrb	r3, [r7, #30]
 8014b3a:	2b00      	cmp	r3, #0
 8014b3c:	d008      	beq.n	8014b50 <CircularQueue_Add+0x120>
 8014b3e:	68fb      	ldr	r3, [r7, #12]
 8014b40:	7f1b      	ldrb	r3, [r3, #28]
 8014b42:	f003 0301 	and.w	r3, r3, #1
 8014b46:	2b00      	cmp	r3, #0
 8014b48:	d002      	beq.n	8014b50 <CircularQueue_Add+0x120>
 8014b4a:	7dfb      	ldrb	r3, [r7, #23]
 8014b4c:	b29b      	uxth	r3, r3
 8014b4e:	e000      	b.n	8014b52 <CircularQueue_Add+0x122>
 8014b50:	8bbb      	ldrh	r3, [r7, #28]
 8014b52:	83bb      	strh	r3, [r7, #28]
   overhead = (wrap_will_occur && (q->optionFlags & CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG)) ? elemSizeStorageRoom  : overhead;
 8014b54:	7fbb      	ldrb	r3, [r7, #30]
 8014b56:	2b00      	cmp	r3, #0
 8014b58:	d008      	beq.n	8014b6c <CircularQueue_Add+0x13c>
 8014b5a:	68fb      	ldr	r3, [r7, #12]
 8014b5c:	7f1b      	ldrb	r3, [r3, #28]
 8014b5e:	f003 0302 	and.w	r3, r3, #2
 8014b62:	2b00      	cmp	r3, #0
 8014b64:	d002      	beq.n	8014b6c <CircularQueue_Add+0x13c>
 8014b66:	7ffb      	ldrb	r3, [r7, #31]
 8014b68:	b29b      	uxth	r3, r3
 8014b6a:	e000      	b.n	8014b6e <CircularQueue_Add+0x13e>
 8014b6c:	8bbb      	ldrh	r3, [r7, #28]
 8014b6e:	83bb      	strh	r3, [r7, #28]
   
   
  /* Store now the elements if ennough room for all elements */
  if (elementSize && ((q->byteCount + ((elementSize + elemSizeStorageRoom )*nbElements) + overhead) <= q->queueMaxSize)) 
 8014b70:	88fb      	ldrh	r3, [r7, #6]
 8014b72:	2b00      	cmp	r3, #0
 8014b74:	f000 817e 	beq.w	8014e74 <CircularQueue_Add+0x444>
 8014b78:	68fb      	ldr	r3, [r7, #12]
 8014b7a:	695a      	ldr	r2, [r3, #20]
 8014b7c:	88f9      	ldrh	r1, [r7, #6]
 8014b7e:	7ffb      	ldrb	r3, [r7, #31]
 8014b80:	440b      	add	r3, r1
 8014b82:	4619      	mov	r1, r3
 8014b84:	683b      	ldr	r3, [r7, #0]
 8014b86:	fb01 f303 	mul.w	r3, r1, r3
 8014b8a:	441a      	add	r2, r3
 8014b8c:	8bbb      	ldrh	r3, [r7, #28]
 8014b8e:	441a      	add	r2, r3
 8014b90:	68fb      	ldr	r3, [r7, #12]
 8014b92:	685b      	ldr	r3, [r3, #4]
 8014b94:	429a      	cmp	r2, r3
 8014b96:	f200 816d 	bhi.w	8014e74 <CircularQueue_Add+0x444>
  { 
    /* loop to add all elements  */
    for (i=0; i < nbElements; i++) 
 8014b9a:	2300      	movs	r3, #0
 8014b9c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014b9e:	e14a      	b.n	8014e36 <CircularQueue_Add+0x406>
    {
      q->last = MOD ((q->last + curElementSize),q->queueMaxSize);
 8014ba0:	68fb      	ldr	r3, [r7, #12]
 8014ba2:	691a      	ldr	r2, [r3, #16]
 8014ba4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8014ba6:	441a      	add	r2, r3
 8014ba8:	68fb      	ldr	r3, [r7, #12]
 8014baa:	685b      	ldr	r3, [r3, #4]
 8014bac:	429a      	cmp	r2, r3
 8014bae:	d307      	bcc.n	8014bc0 <CircularQueue_Add+0x190>
 8014bb0:	68fb      	ldr	r3, [r7, #12]
 8014bb2:	691a      	ldr	r2, [r3, #16]
 8014bb4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8014bb6:	441a      	add	r2, r3
 8014bb8:	68fb      	ldr	r3, [r7, #12]
 8014bba:	685b      	ldr	r3, [r3, #4]
 8014bbc:	1ad3      	subs	r3, r2, r3
 8014bbe:	e003      	b.n	8014bc8 <CircularQueue_Add+0x198>
 8014bc0:	68fb      	ldr	r3, [r7, #12]
 8014bc2:	691a      	ldr	r2, [r3, #16]
 8014bc4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8014bc6:	4413      	add	r3, r2
 8014bc8:	68fa      	ldr	r2, [r7, #12]
 8014bca:	6113      	str	r3, [r2, #16]
      curBuffPosition = q->last;
 8014bcc:	68fb      	ldr	r3, [r7, #12]
 8014bce:	691b      	ldr	r3, [r3, #16]
 8014bd0:	633b      	str	r3, [r7, #48]	; 0x30
      
      /* store the element  */
      /* store first the element size if element size is variable */
      if (q->elementSize == 0) 
 8014bd2:	68fb      	ldr	r3, [r7, #12]
 8014bd4:	891b      	ldrh	r3, [r3, #8]
 8014bd6:	2b00      	cmp	r3, #0
 8014bd8:	d130      	bne.n	8014c3c <CircularQueue_Add+0x20c>
      {
        q->qBuff[curBuffPosition++]= elementSize & 0xFF;
 8014bda:	68fb      	ldr	r3, [r7, #12]
 8014bdc:	681a      	ldr	r2, [r3, #0]
 8014bde:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014be0:	1c59      	adds	r1, r3, #1
 8014be2:	6339      	str	r1, [r7, #48]	; 0x30
 8014be4:	4413      	add	r3, r2
 8014be6:	88fa      	ldrh	r2, [r7, #6]
 8014be8:	b2d2      	uxtb	r2, r2
 8014bea:	701a      	strb	r2, [r3, #0]
        curBuffPosition = MOD(curBuffPosition, q->queueMaxSize);
 8014bec:	68fb      	ldr	r3, [r7, #12]
 8014bee:	685b      	ldr	r3, [r3, #4]
 8014bf0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014bf2:	429a      	cmp	r2, r3
 8014bf4:	d304      	bcc.n	8014c00 <CircularQueue_Add+0x1d0>
 8014bf6:	68fb      	ldr	r3, [r7, #12]
 8014bf8:	685b      	ldr	r3, [r3, #4]
 8014bfa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014bfc:	1ad3      	subs	r3, r2, r3
 8014bfe:	e000      	b.n	8014c02 <CircularQueue_Add+0x1d2>
 8014c00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c02:	633b      	str	r3, [r7, #48]	; 0x30
        q->qBuff[curBuffPosition++]= (elementSize & 0xFF00) >> 8 ;
 8014c04:	88fb      	ldrh	r3, [r7, #6]
 8014c06:	0a1b      	lsrs	r3, r3, #8
 8014c08:	b298      	uxth	r0, r3
 8014c0a:	68fb      	ldr	r3, [r7, #12]
 8014c0c:	681a      	ldr	r2, [r3, #0]
 8014c0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c10:	1c59      	adds	r1, r3, #1
 8014c12:	6339      	str	r1, [r7, #48]	; 0x30
 8014c14:	4413      	add	r3, r2
 8014c16:	b2c2      	uxtb	r2, r0
 8014c18:	701a      	strb	r2, [r3, #0]
        curBuffPosition = MOD(curBuffPosition, q->queueMaxSize);
 8014c1a:	68fb      	ldr	r3, [r7, #12]
 8014c1c:	685b      	ldr	r3, [r3, #4]
 8014c1e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014c20:	429a      	cmp	r2, r3
 8014c22:	d304      	bcc.n	8014c2e <CircularQueue_Add+0x1fe>
 8014c24:	68fb      	ldr	r3, [r7, #12]
 8014c26:	685b      	ldr	r3, [r3, #4]
 8014c28:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014c2a:	1ad3      	subs	r3, r2, r3
 8014c2c:	e000      	b.n	8014c30 <CircularQueue_Add+0x200>
 8014c2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c30:	633b      	str	r3, [r7, #48]	; 0x30
        q->byteCount += 2;
 8014c32:	68fb      	ldr	r3, [r7, #12]
 8014c34:	695b      	ldr	r3, [r3, #20]
 8014c36:	1c9a      	adds	r2, r3, #2
 8014c38:	68fb      	ldr	r3, [r7, #12]
 8014c3a:	615a      	str	r2, [r3, #20]
      }
      
      /* Identify number of bytes of copy takeing account possible wrap, in this case NbBytesToCopy will contains size that fit at end of the queue buffer */
      NbBytesToCopy = MIN((q->queueMaxSize-curBuffPosition),elementSize);
 8014c3c:	88fa      	ldrh	r2, [r7, #6]
 8014c3e:	68fb      	ldr	r3, [r7, #12]
 8014c40:	6859      	ldr	r1, [r3, #4]
 8014c42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c44:	1acb      	subs	r3, r1, r3
 8014c46:	4293      	cmp	r3, r2
 8014c48:	bf28      	it	cs
 8014c4a:	4613      	movcs	r3, r2
 8014c4c:	62bb      	str	r3, [r7, #40]	; 0x28
      /* check if no wrap (NbBytesToCopy == elementSize) or if Wrap and no spsicf option; 
         In this case part of data will copied at the end of the buffer and the rest a the beginning */
      if ((NbBytesToCopy == elementSize) || ((NbBytesToCopy < elementSize) && (q->optionFlags == CIRCULAR_QUEUE_NO_FLAG)))
 8014c4e:	88fb      	ldrh	r3, [r7, #6]
 8014c50:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014c52:	429a      	cmp	r2, r3
 8014c54:	d007      	beq.n	8014c66 <CircularQueue_Add+0x236>
 8014c56:	88fb      	ldrh	r3, [r7, #6]
 8014c58:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014c5a:	429a      	cmp	r2, r3
 8014c5c:	d225      	bcs.n	8014caa <CircularQueue_Add+0x27a>
 8014c5e:	68fb      	ldr	r3, [r7, #12]
 8014c60:	7f1b      	ldrb	r3, [r3, #28]
 8014c62:	2b00      	cmp	r3, #0
 8014c64:	d121      	bne.n	8014caa <CircularQueue_Add+0x27a>
      {
        /* Copy First part (or emtire buffer ) from current position up to the end of the buffer queue (or before if enough room)  */
        memcpy(&q->qBuff[curBuffPosition],&x[i*elementSize],NbBytesToCopy);
 8014c66:	68fb      	ldr	r3, [r7, #12]
 8014c68:	681a      	ldr	r2, [r3, #0]
 8014c6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c6c:	18d0      	adds	r0, r2, r3
 8014c6e:	88fb      	ldrh	r3, [r7, #6]
 8014c70:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014c72:	fb02 f303 	mul.w	r3, r2, r3
 8014c76:	68ba      	ldr	r2, [r7, #8]
 8014c78:	4413      	add	r3, r2
 8014c7a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014c7c:	4619      	mov	r1, r3
 8014c7e:	f003 fc8a 	bl	8018596 <memcpy>
        /* Adjust bytes count */
        q->byteCount += NbBytesToCopy;
 8014c82:	68fb      	ldr	r3, [r7, #12]
 8014c84:	695a      	ldr	r2, [r3, #20]
 8014c86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014c88:	441a      	add	r2, r3
 8014c8a:	68fb      	ldr	r3, [r7, #12]
 8014c8c:	615a      	str	r2, [r3, #20]
        /* Wrap */
        curBuffPosition = 0; 
 8014c8e:	2300      	movs	r3, #0
 8014c90:	633b      	str	r3, [r7, #48]	; 0x30
        /* set NbCopiedBytes bytes with  ampount copied */
        NbCopiedBytes = NbBytesToCopy;
 8014c92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014c94:	627b      	str	r3, [r7, #36]	; 0x24
        /* set the rest to copy if wrao , if no wrap will be 0 */
        NbBytesToCopy = elementSize - NbBytesToCopy;
 8014c96:	88fa      	ldrh	r2, [r7, #6]
 8014c98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014c9a:	1ad3      	subs	r3, r2, r3
 8014c9c:	62bb      	str	r3, [r7, #40]	; 0x28
        /* set the current element Size, will be used to calaculate next last position at beginning of loop */
        curElementSize = (elementSize) + elemSizeStorageRoom ;
 8014c9e:	7ffb      	ldrb	r3, [r7, #31]
 8014ca0:	b29a      	uxth	r2, r3
 8014ca2:	88fb      	ldrh	r3, [r7, #6]
 8014ca4:	4413      	add	r3, r2
 8014ca6:	86fb      	strh	r3, [r7, #54]	; 0x36
 8014ca8:	e0a4      	b.n	8014df4 <CircularQueue_Add+0x3c4>
      }
      else if (NbBytesToCopy)  /* We have a wrap  to manage */
 8014caa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014cac:	2b00      	cmp	r3, #0
 8014cae:	f000 80a1 	beq.w	8014df4 <CircularQueue_Add+0x3c4>
      {
       /* case of CIRCULAR_QUEUE_NO_WRAP_FLAG option */
         if (q->optionFlags & CIRCULAR_QUEUE_NO_WRAP_FLAG)
 8014cb2:	68fb      	ldr	r3, [r7, #12]
 8014cb4:	7f1b      	ldrb	r3, [r3, #28]
 8014cb6:	f003 0301 	and.w	r3, r3, #1
 8014cba:	2b00      	cmp	r3, #0
 8014cbc:	d03a      	beq.n	8014d34 <CircularQueue_Add+0x304>
        {
          /* if element size are variable and NO_WRAP option, Invalidate end of buffer setting 0xFFFF size*/
          if (q->elementSize == 0)
 8014cbe:	68fb      	ldr	r3, [r7, #12]
 8014cc0:	891b      	ldrh	r3, [r3, #8]
 8014cc2:	2b00      	cmp	r3, #0
 8014cc4:	d10d      	bne.n	8014ce2 <CircularQueue_Add+0x2b2>
          {
             q->qBuff[curBuffPosition-2] = 0xFF;
 8014cc6:	68fb      	ldr	r3, [r7, #12]
 8014cc8:	681a      	ldr	r2, [r3, #0]
 8014cca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014ccc:	3b02      	subs	r3, #2
 8014cce:	4413      	add	r3, r2
 8014cd0:	22ff      	movs	r2, #255	; 0xff
 8014cd2:	701a      	strb	r2, [r3, #0]
             q->qBuff[curBuffPosition-1] = 0xFF;
 8014cd4:	68fb      	ldr	r3, [r7, #12]
 8014cd6:	681a      	ldr	r2, [r3, #0]
 8014cd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014cda:	3b01      	subs	r3, #1
 8014cdc:	4413      	add	r3, r2
 8014cde:	22ff      	movs	r2, #255	; 0xff
 8014ce0:	701a      	strb	r2, [r3, #0]
          }
          q->byteCount += NbBytesToCopy;  /* invalid data at the end of buffer are take into account in byteCount */
 8014ce2:	68fb      	ldr	r3, [r7, #12]
 8014ce4:	695a      	ldr	r2, [r3, #20]
 8014ce6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014ce8:	441a      	add	r2, r3
 8014cea:	68fb      	ldr	r3, [r7, #12]
 8014cec:	615a      	str	r2, [r3, #20]
          /* No bytes coped a the end of buffer */
          NbCopiedBytes = 0;
 8014cee:	2300      	movs	r3, #0
 8014cf0:	627b      	str	r3, [r7, #36]	; 0x24
          /* all element to be copied at the begnning of buffer */
          NbBytesToCopy = elementSize; 
 8014cf2:	88fb      	ldrh	r3, [r7, #6]
 8014cf4:	62bb      	str	r3, [r7, #40]	; 0x28
          /* Wrap */
          curBuffPosition = 0; 
 8014cf6:	2300      	movs	r3, #0
 8014cf8:	633b      	str	r3, [r7, #48]	; 0x30
          /* if variable size element, invalidate end of buffer setting OxFFFF in element header (size) */
          if (q->elementSize == 0)
 8014cfa:	68fb      	ldr	r3, [r7, #12]
 8014cfc:	891b      	ldrh	r3, [r3, #8]
 8014cfe:	2b00      	cmp	r3, #0
 8014d00:	d16f      	bne.n	8014de2 <CircularQueue_Add+0x3b2>
          {
            q->qBuff[curBuffPosition++] = NbBytesToCopy & 0xFF;
 8014d02:	68fb      	ldr	r3, [r7, #12]
 8014d04:	681a      	ldr	r2, [r3, #0]
 8014d06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014d08:	1c59      	adds	r1, r3, #1
 8014d0a:	6339      	str	r1, [r7, #48]	; 0x30
 8014d0c:	4413      	add	r3, r2
 8014d0e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014d10:	b2d2      	uxtb	r2, r2
 8014d12:	701a      	strb	r2, [r3, #0]
            q->qBuff[curBuffPosition++] = (NbBytesToCopy & 0xFF00) >> 8 ;
 8014d14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014d16:	0a18      	lsrs	r0, r3, #8
 8014d18:	68fb      	ldr	r3, [r7, #12]
 8014d1a:	681a      	ldr	r2, [r3, #0]
 8014d1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014d1e:	1c59      	adds	r1, r3, #1
 8014d20:	6339      	str	r1, [r7, #48]	; 0x30
 8014d22:	4413      	add	r3, r2
 8014d24:	b2c2      	uxtb	r2, r0
 8014d26:	701a      	strb	r2, [r3, #0]
            q->byteCount += 2;   
 8014d28:	68fb      	ldr	r3, [r7, #12]
 8014d2a:	695b      	ldr	r3, [r3, #20]
 8014d2c:	1c9a      	adds	r2, r3, #2
 8014d2e:	68fb      	ldr	r3, [r7, #12]
 8014d30:	615a      	str	r2, [r3, #20]
 8014d32:	e056      	b.n	8014de2 <CircularQueue_Add+0x3b2>
          } 
           
        }
        /* case of CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG option */
        else if (q->optionFlags & CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG)
 8014d34:	68fb      	ldr	r3, [r7, #12]
 8014d36:	7f1b      	ldrb	r3, [r3, #28]
 8014d38:	f003 0302 	and.w	r3, r3, #2
 8014d3c:	2b00      	cmp	r3, #0
 8014d3e:	d050      	beq.n	8014de2 <CircularQueue_Add+0x3b2>
        {
          if (q->elementSize == 0)
 8014d40:	68fb      	ldr	r3, [r7, #12]
 8014d42:	891b      	ldrh	r3, [r3, #8]
 8014d44:	2b00      	cmp	r3, #0
 8014d46:	d14a      	bne.n	8014dde <CircularQueue_Add+0x3ae>
          {
            /* reset the size of current element to the nb bytes fitting at the end of buffer */
             q->qBuff[curBuffPosition-2] = NbBytesToCopy & 0xFF;
 8014d48:	68fb      	ldr	r3, [r7, #12]
 8014d4a:	681a      	ldr	r2, [r3, #0]
 8014d4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014d4e:	3b02      	subs	r3, #2
 8014d50:	4413      	add	r3, r2
 8014d52:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014d54:	b2d2      	uxtb	r2, r2
 8014d56:	701a      	strb	r2, [r3, #0]
             q->qBuff[curBuffPosition-1] = (NbBytesToCopy & 0xFF00) >> 8 ;
 8014d58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014d5a:	0a19      	lsrs	r1, r3, #8
 8014d5c:	68fb      	ldr	r3, [r7, #12]
 8014d5e:	681a      	ldr	r2, [r3, #0]
 8014d60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014d62:	3b01      	subs	r3, #1
 8014d64:	4413      	add	r3, r2
 8014d66:	b2ca      	uxtb	r2, r1
 8014d68:	701a      	strb	r2, [r3, #0]
             /* copy the bytes */ 
             memcpy(&q->qBuff[curBuffPosition],&x[i*elementSize],NbBytesToCopy);
 8014d6a:	68fb      	ldr	r3, [r7, #12]
 8014d6c:	681a      	ldr	r2, [r3, #0]
 8014d6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014d70:	18d0      	adds	r0, r2, r3
 8014d72:	88fb      	ldrh	r3, [r7, #6]
 8014d74:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014d76:	fb02 f303 	mul.w	r3, r2, r3
 8014d7a:	68ba      	ldr	r2, [r7, #8]
 8014d7c:	4413      	add	r3, r2
 8014d7e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014d80:	4619      	mov	r1, r3
 8014d82:	f003 fc08 	bl	8018596 <memcpy>
             q->byteCount += NbBytesToCopy; 
 8014d86:	68fb      	ldr	r3, [r7, #12]
 8014d88:	695a      	ldr	r2, [r3, #20]
 8014d8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014d8c:	441a      	add	r2, r3
 8014d8e:	68fb      	ldr	r3, [r7, #12]
 8014d90:	615a      	str	r2, [r3, #20]
             /* set the number of copied bytes */
             NbCopiedBytes = NbBytesToCopy;             
 8014d92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014d94:	627b      	str	r3, [r7, #36]	; 0x24
             /* set rest of data to be copied to begnning of buffer */
             NbBytesToCopy = elementSize - NbBytesToCopy;
 8014d96:	88fa      	ldrh	r2, [r7, #6]
 8014d98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014d9a:	1ad3      	subs	r3, r2, r3
 8014d9c:	62bb      	str	r3, [r7, #40]	; 0x28
             /* one element more dur to split in 2 elements */
             q->elementCount++;
 8014d9e:	68fb      	ldr	r3, [r7, #12]
 8014da0:	699b      	ldr	r3, [r3, #24]
 8014da2:	1c5a      	adds	r2, r3, #1
 8014da4:	68fb      	ldr	r3, [r7, #12]
 8014da6:	619a      	str	r2, [r3, #24]
             /* Wrap */
             curBuffPosition = 0; 
 8014da8:	2300      	movs	r3, #0
 8014daa:	633b      	str	r3, [r7, #48]	; 0x30
             /* Set new size for rest of data */
             q->qBuff[curBuffPosition++] = NbBytesToCopy & 0xFF;
 8014dac:	68fb      	ldr	r3, [r7, #12]
 8014dae:	681a      	ldr	r2, [r3, #0]
 8014db0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014db2:	1c59      	adds	r1, r3, #1
 8014db4:	6339      	str	r1, [r7, #48]	; 0x30
 8014db6:	4413      	add	r3, r2
 8014db8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014dba:	b2d2      	uxtb	r2, r2
 8014dbc:	701a      	strb	r2, [r3, #0]
             q->qBuff[curBuffPosition++] = (NbBytesToCopy & 0xFF00) >> 8 ;
 8014dbe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014dc0:	0a18      	lsrs	r0, r3, #8
 8014dc2:	68fb      	ldr	r3, [r7, #12]
 8014dc4:	681a      	ldr	r2, [r3, #0]
 8014dc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014dc8:	1c59      	adds	r1, r3, #1
 8014dca:	6339      	str	r1, [r7, #48]	; 0x30
 8014dcc:	4413      	add	r3, r2
 8014dce:	b2c2      	uxtb	r2, r0
 8014dd0:	701a      	strb	r2, [r3, #0]
             q->byteCount += 2;              
 8014dd2:	68fb      	ldr	r3, [r7, #12]
 8014dd4:	695b      	ldr	r3, [r3, #20]
 8014dd6:	1c9a      	adds	r2, r3, #2
 8014dd8:	68fb      	ldr	r3, [r7, #12]
 8014dda:	615a      	str	r2, [r3, #20]
 8014ddc:	e001      	b.n	8014de2 <CircularQueue_Add+0x3b2>
          else
          {
            /* Should not occur */
            /* can not manage split Flag on Fixed size element */
            /* Buffer is corrupted */
            return NULL;
 8014dde:	2300      	movs	r3, #0
 8014de0:	e049      	b.n	8014e76 <CircularQueue_Add+0x446>
          }
        }
        curElementSize = (NbBytesToCopy) + elemSizeStorageRoom ;
 8014de2:	7ffb      	ldrb	r3, [r7, #31]
 8014de4:	b29a      	uxth	r2, r3
 8014de6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014de8:	b29b      	uxth	r3, r3
 8014dea:	4413      	add	r3, r2
 8014dec:	86fb      	strh	r3, [r7, #54]	; 0x36
        q->last = 0;        
 8014dee:	68fb      	ldr	r3, [r7, #12]
 8014df0:	2200      	movs	r2, #0
 8014df2:	611a      	str	r2, [r3, #16]
      }  
      
      /* some remaining byte to copy */
      if (NbBytesToCopy)      
 8014df4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014df6:	2b00      	cmp	r3, #0
 8014df8:	d015      	beq.n	8014e26 <CircularQueue_Add+0x3f6>
      {
        memcpy(&q->qBuff[curBuffPosition],&x[(i*elementSize)+NbCopiedBytes],NbBytesToCopy);
 8014dfa:	68fb      	ldr	r3, [r7, #12]
 8014dfc:	681a      	ldr	r2, [r3, #0]
 8014dfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014e00:	18d0      	adds	r0, r2, r3
 8014e02:	88fb      	ldrh	r3, [r7, #6]
 8014e04:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014e06:	fb03 f202 	mul.w	r2, r3, r2
 8014e0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014e0c:	4413      	add	r3, r2
 8014e0e:	68ba      	ldr	r2, [r7, #8]
 8014e10:	4413      	add	r3, r2
 8014e12:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014e14:	4619      	mov	r1, r3
 8014e16:	f003 fbbe 	bl	8018596 <memcpy>
        q->byteCount += NbBytesToCopy;
 8014e1a:	68fb      	ldr	r3, [r7, #12]
 8014e1c:	695a      	ldr	r2, [r3, #20]
 8014e1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014e20:	441a      	add	r2, r3
 8014e22:	68fb      	ldr	r3, [r7, #12]
 8014e24:	615a      	str	r2, [r3, #20]
      }      
      
      /* One more element */
      q->elementCount++;
 8014e26:	68fb      	ldr	r3, [r7, #12]
 8014e28:	699b      	ldr	r3, [r3, #24]
 8014e2a:	1c5a      	adds	r2, r3, #1
 8014e2c:	68fb      	ldr	r3, [r7, #12]
 8014e2e:	619a      	str	r2, [r3, #24]
    for (i=0; i < nbElements; i++) 
 8014e30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014e32:	3301      	adds	r3, #1
 8014e34:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014e36:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014e38:	683b      	ldr	r3, [r7, #0]
 8014e3a:	429a      	cmp	r2, r3
 8014e3c:	f4ff aeb0 	bcc.w	8014ba0 <CircularQueue_Add+0x170>
    }
    
    ptr = q->qBuff + (MOD((q->last+elemSizeStorageRoom ),q->queueMaxSize));
 8014e40:	68fb      	ldr	r3, [r7, #12]
 8014e42:	681a      	ldr	r2, [r3, #0]
 8014e44:	68fb      	ldr	r3, [r7, #12]
 8014e46:	6919      	ldr	r1, [r3, #16]
 8014e48:	7ffb      	ldrb	r3, [r7, #31]
 8014e4a:	4419      	add	r1, r3
 8014e4c:	68fb      	ldr	r3, [r7, #12]
 8014e4e:	685b      	ldr	r3, [r3, #4]
 8014e50:	4299      	cmp	r1, r3
 8014e52:	d307      	bcc.n	8014e64 <CircularQueue_Add+0x434>
 8014e54:	68fb      	ldr	r3, [r7, #12]
 8014e56:	6919      	ldr	r1, [r3, #16]
 8014e58:	7ffb      	ldrb	r3, [r7, #31]
 8014e5a:	4419      	add	r1, r3
 8014e5c:	68fb      	ldr	r3, [r7, #12]
 8014e5e:	685b      	ldr	r3, [r3, #4]
 8014e60:	1acb      	subs	r3, r1, r3
 8014e62:	e003      	b.n	8014e6c <CircularQueue_Add+0x43c>
 8014e64:	68fb      	ldr	r3, [r7, #12]
 8014e66:	6919      	ldr	r1, [r3, #16]
 8014e68:	7ffb      	ldrb	r3, [r7, #31]
 8014e6a:	440b      	add	r3, r1
 8014e6c:	4413      	add	r3, r2
 8014e6e:	623b      	str	r3, [r7, #32]
  /* for Breakpoint only...to remove */
  else
  {
    return NULL;
  }
  return ptr;
 8014e70:	6a3b      	ldr	r3, [r7, #32]
 8014e72:	e000      	b.n	8014e76 <CircularQueue_Add+0x446>
    return NULL;
 8014e74:	2300      	movs	r3, #0
}
 8014e76:	4618      	mov	r0, r3
 8014e78:	3738      	adds	r7, #56	; 0x38
 8014e7a:	46bd      	mov	sp, r7
 8014e7c:	bd80      	pop	{r7, pc}

08014e7e <CircularQueue_Remove>:
  * @param  q: pointer on queue structure  to be handled
  * @param  elementSize: Pointer to return Size of element to be removed (ignored if NULL)
  * @retval Pointer on removed element. NULL if queue was empty
  */
uint8_t* CircularQueue_Remove(queue_t *q, uint16_t* elementSize)
{
 8014e7e:	b480      	push	{r7}
 8014e80:	b085      	sub	sp, #20
 8014e82:	af00      	add	r7, sp, #0
 8014e84:	6078      	str	r0, [r7, #4]
 8014e86:	6039      	str	r1, [r7, #0]
  uint8_t  elemSizeStorageRoom = 0;
 8014e88:	2300      	movs	r3, #0
 8014e8a:	727b      	strb	r3, [r7, #9]
  uint8_t* ptr= NULL;
 8014e8c:	2300      	movs	r3, #0
 8014e8e:	60fb      	str	r3, [r7, #12]
  elemSizeStorageRoom = (q->elementSize == 0) ? 2 : 0;
 8014e90:	687b      	ldr	r3, [r7, #4]
 8014e92:	891b      	ldrh	r3, [r3, #8]
 8014e94:	2b00      	cmp	r3, #0
 8014e96:	d101      	bne.n	8014e9c <CircularQueue_Remove+0x1e>
 8014e98:	2302      	movs	r3, #2
 8014e9a:	e000      	b.n	8014e9e <CircularQueue_Remove+0x20>
 8014e9c:	2300      	movs	r3, #0
 8014e9e:	727b      	strb	r3, [r7, #9]
  uint16_t eltSize = 0;
 8014ea0:	2300      	movs	r3, #0
 8014ea2:	817b      	strh	r3, [r7, #10]
  if (q->byteCount > 0) 
 8014ea4:	687b      	ldr	r3, [r7, #4]
 8014ea6:	695b      	ldr	r3, [r3, #20]
 8014ea8:	2b00      	cmp	r3, #0
 8014eaa:	f000 80cc 	beq.w	8015046 <CircularQueue_Remove+0x1c8>
  {
    /* retrieve element Size */
    eltSize = (q->elementSize == 0) ? q->qBuff[q->first] + ((q->qBuff[MOD((q->first+1), q->queueMaxSize)])<<8) : q->elementSize;
 8014eae:	687b      	ldr	r3, [r7, #4]
 8014eb0:	891b      	ldrh	r3, [r3, #8]
 8014eb2:	2b00      	cmp	r3, #0
 8014eb4:	d121      	bne.n	8014efa <CircularQueue_Remove+0x7c>
 8014eb6:	687b      	ldr	r3, [r7, #4]
 8014eb8:	681a      	ldr	r2, [r3, #0]
 8014eba:	687b      	ldr	r3, [r7, #4]
 8014ebc:	68db      	ldr	r3, [r3, #12]
 8014ebe:	4413      	add	r3, r2
 8014ec0:	781b      	ldrb	r3, [r3, #0]
 8014ec2:	b29a      	uxth	r2, r3
 8014ec4:	687b      	ldr	r3, [r7, #4]
 8014ec6:	6819      	ldr	r1, [r3, #0]
 8014ec8:	687b      	ldr	r3, [r7, #4]
 8014eca:	68db      	ldr	r3, [r3, #12]
 8014ecc:	1c58      	adds	r0, r3, #1
 8014ece:	687b      	ldr	r3, [r7, #4]
 8014ed0:	685b      	ldr	r3, [r3, #4]
 8014ed2:	4298      	cmp	r0, r3
 8014ed4:	d306      	bcc.n	8014ee4 <CircularQueue_Remove+0x66>
 8014ed6:	687b      	ldr	r3, [r7, #4]
 8014ed8:	68d8      	ldr	r0, [r3, #12]
 8014eda:	687b      	ldr	r3, [r7, #4]
 8014edc:	685b      	ldr	r3, [r3, #4]
 8014ede:	1ac3      	subs	r3, r0, r3
 8014ee0:	3301      	adds	r3, #1
 8014ee2:	e002      	b.n	8014eea <CircularQueue_Remove+0x6c>
 8014ee4:	687b      	ldr	r3, [r7, #4]
 8014ee6:	68db      	ldr	r3, [r3, #12]
 8014ee8:	3301      	adds	r3, #1
 8014eea:	440b      	add	r3, r1
 8014eec:	781b      	ldrb	r3, [r3, #0]
 8014eee:	b29b      	uxth	r3, r3
 8014ef0:	021b      	lsls	r3, r3, #8
 8014ef2:	b29b      	uxth	r3, r3
 8014ef4:	4413      	add	r3, r2
 8014ef6:	b29b      	uxth	r3, r3
 8014ef8:	e001      	b.n	8014efe <CircularQueue_Remove+0x80>
 8014efa:	687b      	ldr	r3, [r7, #4]
 8014efc:	891b      	ldrh	r3, [r3, #8]
 8014efe:	817b      	strh	r3, [r7, #10]

     if ((q->optionFlags & CIRCULAR_QUEUE_NO_WRAP_FLAG) && !(q->optionFlags & CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG))
 8014f00:	687b      	ldr	r3, [r7, #4]
 8014f02:	7f1b      	ldrb	r3, [r3, #28]
 8014f04:	f003 0301 	and.w	r3, r3, #1
 8014f08:	2b00      	cmp	r3, #0
 8014f0a:	d057      	beq.n	8014fbc <CircularQueue_Remove+0x13e>
 8014f0c:	687b      	ldr	r3, [r7, #4]
 8014f0e:	7f1b      	ldrb	r3, [r3, #28]
 8014f10:	f003 0302 	and.w	r3, r3, #2
 8014f14:	2b00      	cmp	r3, #0
 8014f16:	d151      	bne.n	8014fbc <CircularQueue_Remove+0x13e>
     {
       if (((eltSize == 0xFFFF) && q->elementSize == 0 ) ||
 8014f18:	897b      	ldrh	r3, [r7, #10]
 8014f1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8014f1e:	4293      	cmp	r3, r2
 8014f20:	d103      	bne.n	8014f2a <CircularQueue_Remove+0xac>
 8014f22:	687b      	ldr	r3, [r7, #4]
 8014f24:	891b      	ldrh	r3, [r3, #8]
 8014f26:	2b00      	cmp	r3, #0
 8014f28:	d012      	beq.n	8014f50 <CircularQueue_Remove+0xd2>
           ((q->first > q->last) && q->elementSize && ((q->queueMaxSize - q->first) < q->elementSize))) 
 8014f2a:	687b      	ldr	r3, [r7, #4]
 8014f2c:	68da      	ldr	r2, [r3, #12]
 8014f2e:	687b      	ldr	r3, [r7, #4]
 8014f30:	691b      	ldr	r3, [r3, #16]
       if (((eltSize == 0xFFFF) && q->elementSize == 0 ) ||
 8014f32:	429a      	cmp	r2, r3
 8014f34:	d942      	bls.n	8014fbc <CircularQueue_Remove+0x13e>
           ((q->first > q->last) && q->elementSize && ((q->queueMaxSize - q->first) < q->elementSize))) 
 8014f36:	687b      	ldr	r3, [r7, #4]
 8014f38:	891b      	ldrh	r3, [r3, #8]
 8014f3a:	2b00      	cmp	r3, #0
 8014f3c:	d03e      	beq.n	8014fbc <CircularQueue_Remove+0x13e>
 8014f3e:	687b      	ldr	r3, [r7, #4]
 8014f40:	685a      	ldr	r2, [r3, #4]
 8014f42:	687b      	ldr	r3, [r7, #4]
 8014f44:	68db      	ldr	r3, [r3, #12]
 8014f46:	1ad3      	subs	r3, r2, r3
 8014f48:	687a      	ldr	r2, [r7, #4]
 8014f4a:	8912      	ldrh	r2, [r2, #8]
 8014f4c:	4293      	cmp	r3, r2
 8014f4e:	d235      	bcs.n	8014fbc <CircularQueue_Remove+0x13e>
       {
          /* all data from current position up to the end of buffer are invalid */
          q->byteCount -= (q->queueMaxSize - q->first);
 8014f50:	687b      	ldr	r3, [r7, #4]
 8014f52:	695a      	ldr	r2, [r3, #20]
 8014f54:	687b      	ldr	r3, [r7, #4]
 8014f56:	68d9      	ldr	r1, [r3, #12]
 8014f58:	687b      	ldr	r3, [r7, #4]
 8014f5a:	685b      	ldr	r3, [r3, #4]
 8014f5c:	1acb      	subs	r3, r1, r3
 8014f5e:	441a      	add	r2, r3
 8014f60:	687b      	ldr	r3, [r7, #4]
 8014f62:	615a      	str	r2, [r3, #20]
          /* Adjust first element pos */
          q->first = 0;
 8014f64:	687b      	ldr	r3, [r7, #4]
 8014f66:	2200      	movs	r2, #0
 8014f68:	60da      	str	r2, [r3, #12]
          /* retrieve the right size after the wrap [if variable size element] */
          eltSize = (q->elementSize == 0) ? q->qBuff[q->first] + ((q->qBuff[MOD((q->first+1), q->queueMaxSize)])<<8) : q->elementSize;
 8014f6a:	687b      	ldr	r3, [r7, #4]
 8014f6c:	891b      	ldrh	r3, [r3, #8]
 8014f6e:	2b00      	cmp	r3, #0
 8014f70:	d121      	bne.n	8014fb6 <CircularQueue_Remove+0x138>
 8014f72:	687b      	ldr	r3, [r7, #4]
 8014f74:	681a      	ldr	r2, [r3, #0]
 8014f76:	687b      	ldr	r3, [r7, #4]
 8014f78:	68db      	ldr	r3, [r3, #12]
 8014f7a:	4413      	add	r3, r2
 8014f7c:	781b      	ldrb	r3, [r3, #0]
 8014f7e:	b29a      	uxth	r2, r3
 8014f80:	687b      	ldr	r3, [r7, #4]
 8014f82:	6819      	ldr	r1, [r3, #0]
 8014f84:	687b      	ldr	r3, [r7, #4]
 8014f86:	68db      	ldr	r3, [r3, #12]
 8014f88:	1c58      	adds	r0, r3, #1
 8014f8a:	687b      	ldr	r3, [r7, #4]
 8014f8c:	685b      	ldr	r3, [r3, #4]
 8014f8e:	4298      	cmp	r0, r3
 8014f90:	d306      	bcc.n	8014fa0 <CircularQueue_Remove+0x122>
 8014f92:	687b      	ldr	r3, [r7, #4]
 8014f94:	68d8      	ldr	r0, [r3, #12]
 8014f96:	687b      	ldr	r3, [r7, #4]
 8014f98:	685b      	ldr	r3, [r3, #4]
 8014f9a:	1ac3      	subs	r3, r0, r3
 8014f9c:	3301      	adds	r3, #1
 8014f9e:	e002      	b.n	8014fa6 <CircularQueue_Remove+0x128>
 8014fa0:	687b      	ldr	r3, [r7, #4]
 8014fa2:	68db      	ldr	r3, [r3, #12]
 8014fa4:	3301      	adds	r3, #1
 8014fa6:	440b      	add	r3, r1
 8014fa8:	781b      	ldrb	r3, [r3, #0]
 8014faa:	b29b      	uxth	r3, r3
 8014fac:	021b      	lsls	r3, r3, #8
 8014fae:	b29b      	uxth	r3, r3
 8014fb0:	4413      	add	r3, r2
 8014fb2:	b29b      	uxth	r3, r3
 8014fb4:	e001      	b.n	8014fba <CircularQueue_Remove+0x13c>
 8014fb6:	687b      	ldr	r3, [r7, #4]
 8014fb8:	891b      	ldrh	r3, [r3, #8]
 8014fba:	817b      	strh	r3, [r7, #10]
       }
     }

    /* retrieve element */
    ptr = q->qBuff + (MOD((q->first + elemSizeStorageRoom), q->queueMaxSize));
 8014fbc:	687b      	ldr	r3, [r7, #4]
 8014fbe:	681a      	ldr	r2, [r3, #0]
 8014fc0:	687b      	ldr	r3, [r7, #4]
 8014fc2:	68d9      	ldr	r1, [r3, #12]
 8014fc4:	7a7b      	ldrb	r3, [r7, #9]
 8014fc6:	4419      	add	r1, r3
 8014fc8:	687b      	ldr	r3, [r7, #4]
 8014fca:	685b      	ldr	r3, [r3, #4]
 8014fcc:	4299      	cmp	r1, r3
 8014fce:	d307      	bcc.n	8014fe0 <CircularQueue_Remove+0x162>
 8014fd0:	687b      	ldr	r3, [r7, #4]
 8014fd2:	68d9      	ldr	r1, [r3, #12]
 8014fd4:	7a7b      	ldrb	r3, [r7, #9]
 8014fd6:	4419      	add	r1, r3
 8014fd8:	687b      	ldr	r3, [r7, #4]
 8014fda:	685b      	ldr	r3, [r3, #4]
 8014fdc:	1acb      	subs	r3, r1, r3
 8014fde:	e003      	b.n	8014fe8 <CircularQueue_Remove+0x16a>
 8014fe0:	687b      	ldr	r3, [r7, #4]
 8014fe2:	68d9      	ldr	r1, [r3, #12]
 8014fe4:	7a7b      	ldrb	r3, [r7, #9]
 8014fe6:	440b      	add	r3, r1
 8014fe8:	4413      	add	r3, r2
 8014fea:	60fb      	str	r3, [r7, #12]

    /* adjust byte count */
    q->byteCount -= (eltSize + elemSizeStorageRoom) ;
 8014fec:	687b      	ldr	r3, [r7, #4]
 8014fee:	695b      	ldr	r3, [r3, #20]
 8014ff0:	8979      	ldrh	r1, [r7, #10]
 8014ff2:	7a7a      	ldrb	r2, [r7, #9]
 8014ff4:	440a      	add	r2, r1
 8014ff6:	1a9a      	subs	r2, r3, r2
 8014ff8:	687b      	ldr	r3, [r7, #4]
 8014ffa:	615a      	str	r2, [r3, #20]
    
    /* Adjust q->first */
    if (q->byteCount > 0)
 8014ffc:	687b      	ldr	r3, [r7, #4]
 8014ffe:	695b      	ldr	r3, [r3, #20]
 8015000:	2b00      	cmp	r3, #0
 8015002:	d01b      	beq.n	801503c <CircularQueue_Remove+0x1be>
    {
      q->first = MOD((q->first+ eltSize + elemSizeStorageRoom ), q->queueMaxSize);
 8015004:	687b      	ldr	r3, [r7, #4]
 8015006:	68da      	ldr	r2, [r3, #12]
 8015008:	897b      	ldrh	r3, [r7, #10]
 801500a:	441a      	add	r2, r3
 801500c:	7a7b      	ldrb	r3, [r7, #9]
 801500e:	441a      	add	r2, r3
 8015010:	687b      	ldr	r3, [r7, #4]
 8015012:	685b      	ldr	r3, [r3, #4]
 8015014:	429a      	cmp	r2, r3
 8015016:	d309      	bcc.n	801502c <CircularQueue_Remove+0x1ae>
 8015018:	687b      	ldr	r3, [r7, #4]
 801501a:	68da      	ldr	r2, [r3, #12]
 801501c:	897b      	ldrh	r3, [r7, #10]
 801501e:	441a      	add	r2, r3
 8015020:	7a7b      	ldrb	r3, [r7, #9]
 8015022:	441a      	add	r2, r3
 8015024:	687b      	ldr	r3, [r7, #4]
 8015026:	685b      	ldr	r3, [r3, #4]
 8015028:	1ad3      	subs	r3, r2, r3
 801502a:	e005      	b.n	8015038 <CircularQueue_Remove+0x1ba>
 801502c:	687b      	ldr	r3, [r7, #4]
 801502e:	68da      	ldr	r2, [r3, #12]
 8015030:	897b      	ldrh	r3, [r7, #10]
 8015032:	441a      	add	r2, r3
 8015034:	7a7b      	ldrb	r3, [r7, #9]
 8015036:	4413      	add	r3, r2
 8015038:	687a      	ldr	r2, [r7, #4]
 801503a:	60d3      	str	r3, [r2, #12]
    }    
    /* adjust element count */    
    --q->elementCount;    
 801503c:	687b      	ldr	r3, [r7, #4]
 801503e:	699b      	ldr	r3, [r3, #24]
 8015040:	1e5a      	subs	r2, r3, #1
 8015042:	687b      	ldr	r3, [r7, #4]
 8015044:	619a      	str	r2, [r3, #24]
  }
  if (elementSize != NULL)
 8015046:	683b      	ldr	r3, [r7, #0]
 8015048:	2b00      	cmp	r3, #0
 801504a:	d002      	beq.n	8015052 <CircularQueue_Remove+0x1d4>
  {
    *elementSize = eltSize;
 801504c:	683b      	ldr	r3, [r7, #0]
 801504e:	897a      	ldrh	r2, [r7, #10]
 8015050:	801a      	strh	r2, [r3, #0]
  }
  return ptr;
 8015052:	68fb      	ldr	r3, [r7, #12]
}
 8015054:	4618      	mov	r0, r3
 8015056:	3714      	adds	r7, #20
 8015058:	46bd      	mov	sp, r7
 801505a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801505e:	4770      	bx	lr

08015060 <CircularQueue_Sense>:
  * @param  q: pointer on queue structure  to be handled
  * @param  elementSize:  Pointer to return Size of element to be removed (ignored if NULL)
  * @retval Pointer on sensed element. NULL if queue was empty
  */
uint8_t* CircularQueue_Sense(queue_t *q, uint16_t* elementSize)
{
 8015060:	b480      	push	{r7}
 8015062:	b087      	sub	sp, #28
 8015064:	af00      	add	r7, sp, #0
 8015066:	6078      	str	r0, [r7, #4]
 8015068:	6039      	str	r1, [r7, #0]
  uint8_t  elemSizeStorageRoom = 0;
 801506a:	2300      	movs	r3, #0
 801506c:	72fb      	strb	r3, [r7, #11]
  uint8_t* x= NULL;
 801506e:	2300      	movs	r3, #0
 8015070:	617b      	str	r3, [r7, #20]
  elemSizeStorageRoom = (q->elementSize == 0) ? 2 : 0;
 8015072:	687b      	ldr	r3, [r7, #4]
 8015074:	891b      	ldrh	r3, [r3, #8]
 8015076:	2b00      	cmp	r3, #0
 8015078:	d101      	bne.n	801507e <CircularQueue_Sense+0x1e>
 801507a:	2302      	movs	r3, #2
 801507c:	e000      	b.n	8015080 <CircularQueue_Sense+0x20>
 801507e:	2300      	movs	r3, #0
 8015080:	72fb      	strb	r3, [r7, #11]
  uint16_t eltSize = 0;
 8015082:	2300      	movs	r3, #0
 8015084:	827b      	strh	r3, [r7, #18]
  uint32_t FirstElemetPos = 0;
 8015086:	2300      	movs	r3, #0
 8015088:	60fb      	str	r3, [r7, #12]
    
  if (q->byteCount > 0) 
 801508a:	687b      	ldr	r3, [r7, #4]
 801508c:	695b      	ldr	r3, [r3, #20]
 801508e:	2b00      	cmp	r3, #0
 8015090:	f000 8090 	beq.w	80151b4 <CircularQueue_Sense+0x154>
  {
    FirstElemetPos = q->first;
 8015094:	687b      	ldr	r3, [r7, #4]
 8015096:	68db      	ldr	r3, [r3, #12]
 8015098:	60fb      	str	r3, [r7, #12]
    eltSize = (q->elementSize == 0) ? q->qBuff[q->first] + ((q->qBuff[MOD((q->first+1), q->queueMaxSize)])<<8) : q->elementSize;
 801509a:	687b      	ldr	r3, [r7, #4]
 801509c:	891b      	ldrh	r3, [r3, #8]
 801509e:	2b00      	cmp	r3, #0
 80150a0:	d121      	bne.n	80150e6 <CircularQueue_Sense+0x86>
 80150a2:	687b      	ldr	r3, [r7, #4]
 80150a4:	681a      	ldr	r2, [r3, #0]
 80150a6:	687b      	ldr	r3, [r7, #4]
 80150a8:	68db      	ldr	r3, [r3, #12]
 80150aa:	4413      	add	r3, r2
 80150ac:	781b      	ldrb	r3, [r3, #0]
 80150ae:	b29a      	uxth	r2, r3
 80150b0:	687b      	ldr	r3, [r7, #4]
 80150b2:	6819      	ldr	r1, [r3, #0]
 80150b4:	687b      	ldr	r3, [r7, #4]
 80150b6:	68db      	ldr	r3, [r3, #12]
 80150b8:	1c58      	adds	r0, r3, #1
 80150ba:	687b      	ldr	r3, [r7, #4]
 80150bc:	685b      	ldr	r3, [r3, #4]
 80150be:	4298      	cmp	r0, r3
 80150c0:	d306      	bcc.n	80150d0 <CircularQueue_Sense+0x70>
 80150c2:	687b      	ldr	r3, [r7, #4]
 80150c4:	68d8      	ldr	r0, [r3, #12]
 80150c6:	687b      	ldr	r3, [r7, #4]
 80150c8:	685b      	ldr	r3, [r3, #4]
 80150ca:	1ac3      	subs	r3, r0, r3
 80150cc:	3301      	adds	r3, #1
 80150ce:	e002      	b.n	80150d6 <CircularQueue_Sense+0x76>
 80150d0:	687b      	ldr	r3, [r7, #4]
 80150d2:	68db      	ldr	r3, [r3, #12]
 80150d4:	3301      	adds	r3, #1
 80150d6:	440b      	add	r3, r1
 80150d8:	781b      	ldrb	r3, [r3, #0]
 80150da:	b29b      	uxth	r3, r3
 80150dc:	021b      	lsls	r3, r3, #8
 80150de:	b29b      	uxth	r3, r3
 80150e0:	4413      	add	r3, r2
 80150e2:	b29b      	uxth	r3, r3
 80150e4:	e001      	b.n	80150ea <CircularQueue_Sense+0x8a>
 80150e6:	687b      	ldr	r3, [r7, #4]
 80150e8:	891b      	ldrh	r3, [r3, #8]
 80150ea:	827b      	strh	r3, [r7, #18]
    
    if ((q->optionFlags & CIRCULAR_QUEUE_NO_WRAP_FLAG) && !(q->optionFlags & CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG))
 80150ec:	687b      	ldr	r3, [r7, #4]
 80150ee:	7f1b      	ldrb	r3, [r3, #28]
 80150f0:	f003 0301 	and.w	r3, r3, #1
 80150f4:	2b00      	cmp	r3, #0
 80150f6:	d048      	beq.n	801518a <CircularQueue_Sense+0x12a>
 80150f8:	687b      	ldr	r3, [r7, #4]
 80150fa:	7f1b      	ldrb	r3, [r3, #28]
 80150fc:	f003 0302 	and.w	r3, r3, #2
 8015100:	2b00      	cmp	r3, #0
 8015102:	d142      	bne.n	801518a <CircularQueue_Sense+0x12a>
    { 
      if (((eltSize == 0xFFFF) && q->elementSize == 0 ) ||
 8015104:	8a7b      	ldrh	r3, [r7, #18]
 8015106:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801510a:	4293      	cmp	r3, r2
 801510c:	d103      	bne.n	8015116 <CircularQueue_Sense+0xb6>
 801510e:	687b      	ldr	r3, [r7, #4]
 8015110:	891b      	ldrh	r3, [r3, #8]
 8015112:	2b00      	cmp	r3, #0
 8015114:	d012      	beq.n	801513c <CircularQueue_Sense+0xdc>
          ((q->first > q->last) && q->elementSize && ((q->queueMaxSize - q->first) < q->elementSize))) 
 8015116:	687b      	ldr	r3, [r7, #4]
 8015118:	68da      	ldr	r2, [r3, #12]
 801511a:	687b      	ldr	r3, [r7, #4]
 801511c:	691b      	ldr	r3, [r3, #16]
      if (((eltSize == 0xFFFF) && q->elementSize == 0 ) ||
 801511e:	429a      	cmp	r2, r3
 8015120:	d933      	bls.n	801518a <CircularQueue_Sense+0x12a>
          ((q->first > q->last) && q->elementSize && ((q->queueMaxSize - q->first) < q->elementSize))) 
 8015122:	687b      	ldr	r3, [r7, #4]
 8015124:	891b      	ldrh	r3, [r3, #8]
 8015126:	2b00      	cmp	r3, #0
 8015128:	d02f      	beq.n	801518a <CircularQueue_Sense+0x12a>
 801512a:	687b      	ldr	r3, [r7, #4]
 801512c:	685a      	ldr	r2, [r3, #4]
 801512e:	687b      	ldr	r3, [r7, #4]
 8015130:	68db      	ldr	r3, [r3, #12]
 8015132:	1ad3      	subs	r3, r2, r3
 8015134:	687a      	ldr	r2, [r7, #4]
 8015136:	8912      	ldrh	r2, [r2, #8]
 8015138:	4293      	cmp	r3, r2
 801513a:	d226      	bcs.n	801518a <CircularQueue_Sense+0x12a>

      {
        /* all data from current position up to the end of buffer are invalid */
        FirstElemetPos = 0; /* wrap to the begiining of buffer */
 801513c:	2300      	movs	r3, #0
 801513e:	60fb      	str	r3, [r7, #12]

        /* retrieve the right size after the wrap [if variable size element] */
        eltSize = (q->elementSize == 0) ? q->qBuff[FirstElemetPos]+ ((q->qBuff[MOD((FirstElemetPos+1), q->queueMaxSize)])<<8) : q->elementSize;
 8015140:	687b      	ldr	r3, [r7, #4]
 8015142:	891b      	ldrh	r3, [r3, #8]
 8015144:	2b00      	cmp	r3, #0
 8015146:	d11d      	bne.n	8015184 <CircularQueue_Sense+0x124>
 8015148:	687b      	ldr	r3, [r7, #4]
 801514a:	681a      	ldr	r2, [r3, #0]
 801514c:	68fb      	ldr	r3, [r7, #12]
 801514e:	4413      	add	r3, r2
 8015150:	781b      	ldrb	r3, [r3, #0]
 8015152:	b29a      	uxth	r2, r3
 8015154:	687b      	ldr	r3, [r7, #4]
 8015156:	6819      	ldr	r1, [r3, #0]
 8015158:	68fb      	ldr	r3, [r7, #12]
 801515a:	1c58      	adds	r0, r3, #1
 801515c:	687b      	ldr	r3, [r7, #4]
 801515e:	685b      	ldr	r3, [r3, #4]
 8015160:	4298      	cmp	r0, r3
 8015162:	d305      	bcc.n	8015170 <CircularQueue_Sense+0x110>
 8015164:	687b      	ldr	r3, [r7, #4]
 8015166:	685b      	ldr	r3, [r3, #4]
 8015168:	68f8      	ldr	r0, [r7, #12]
 801516a:	1ac3      	subs	r3, r0, r3
 801516c:	3301      	adds	r3, #1
 801516e:	e001      	b.n	8015174 <CircularQueue_Sense+0x114>
 8015170:	68fb      	ldr	r3, [r7, #12]
 8015172:	3301      	adds	r3, #1
 8015174:	440b      	add	r3, r1
 8015176:	781b      	ldrb	r3, [r3, #0]
 8015178:	b29b      	uxth	r3, r3
 801517a:	021b      	lsls	r3, r3, #8
 801517c:	b29b      	uxth	r3, r3
 801517e:	4413      	add	r3, r2
 8015180:	b29b      	uxth	r3, r3
 8015182:	e001      	b.n	8015188 <CircularQueue_Sense+0x128>
 8015184:	687b      	ldr	r3, [r7, #4]
 8015186:	891b      	ldrh	r3, [r3, #8]
 8015188:	827b      	strh	r3, [r7, #18]
      }
   }
   /* retrieve element */
    x = q->qBuff + (MOD((FirstElemetPos + elemSizeStorageRoom), q->queueMaxSize));
 801518a:	687b      	ldr	r3, [r7, #4]
 801518c:	681a      	ldr	r2, [r3, #0]
 801518e:	7af9      	ldrb	r1, [r7, #11]
 8015190:	68fb      	ldr	r3, [r7, #12]
 8015192:	4419      	add	r1, r3
 8015194:	687b      	ldr	r3, [r7, #4]
 8015196:	685b      	ldr	r3, [r3, #4]
 8015198:	4299      	cmp	r1, r3
 801519a:	d306      	bcc.n	80151aa <CircularQueue_Sense+0x14a>
 801519c:	7af9      	ldrb	r1, [r7, #11]
 801519e:	68fb      	ldr	r3, [r7, #12]
 80151a0:	4419      	add	r1, r3
 80151a2:	687b      	ldr	r3, [r7, #4]
 80151a4:	685b      	ldr	r3, [r3, #4]
 80151a6:	1acb      	subs	r3, r1, r3
 80151a8:	e002      	b.n	80151b0 <CircularQueue_Sense+0x150>
 80151aa:	7af9      	ldrb	r1, [r7, #11]
 80151ac:	68fb      	ldr	r3, [r7, #12]
 80151ae:	440b      	add	r3, r1
 80151b0:	4413      	add	r3, r2
 80151b2:	617b      	str	r3, [r7, #20]
  }
  if (elementSize != NULL)
 80151b4:	683b      	ldr	r3, [r7, #0]
 80151b6:	2b00      	cmp	r3, #0
 80151b8:	d002      	beq.n	80151c0 <CircularQueue_Sense+0x160>
  {
    *elementSize = eltSize;
 80151ba:	683b      	ldr	r3, [r7, #0]
 80151bc:	8a7a      	ldrh	r2, [r7, #18]
 80151be:	801a      	strh	r2, [r3, #0]
  }
  return x;
 80151c0:	697b      	ldr	r3, [r7, #20]
}
 80151c2:	4618      	mov	r0, r3
 80151c4:	371c      	adds	r7, #28
 80151c6:	46bd      	mov	sp, r7
 80151c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80151cc:	4770      	bx	lr

080151ce <zb_ipc_m4_memcpy2>:
/* ST: Don't use built-in memcpy. "Unfortunately when full size optimization is enabled on
 * M4 side, IAR maps memcpy to aeaby_memcpy4 instead of aeabi_memcpy which allows
 * unaligned memcpy." */
static void
zb_ipc_m4_memcpy2(void *dst, void *src, unsigned int len)
{
 80151ce:	b480      	push	{r7}
 80151d0:	b087      	sub	sp, #28
 80151d2:	af00      	add	r7, sp, #0
 80151d4:	60f8      	str	r0, [r7, #12]
 80151d6:	60b9      	str	r1, [r7, #8]
 80151d8:	607a      	str	r2, [r7, #4]
    unsigned int i;

    for (i = 0; i < len; i++) {
 80151da:	2300      	movs	r3, #0
 80151dc:	617b      	str	r3, [r7, #20]
 80151de:	e00a      	b.n	80151f6 <zb_ipc_m4_memcpy2+0x28>
        ((uint8_t *)dst)[i] = ((uint8_t *)src)[i];
 80151e0:	68ba      	ldr	r2, [r7, #8]
 80151e2:	697b      	ldr	r3, [r7, #20]
 80151e4:	441a      	add	r2, r3
 80151e6:	68f9      	ldr	r1, [r7, #12]
 80151e8:	697b      	ldr	r3, [r7, #20]
 80151ea:	440b      	add	r3, r1
 80151ec:	7812      	ldrb	r2, [r2, #0]
 80151ee:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < len; i++) {
 80151f0:	697b      	ldr	r3, [r7, #20]
 80151f2:	3301      	adds	r3, #1
 80151f4:	617b      	str	r3, [r7, #20]
 80151f6:	697a      	ldr	r2, [r7, #20]
 80151f8:	687b      	ldr	r3, [r7, #4]
 80151fa:	429a      	cmp	r2, r3
 80151fc:	d3f0      	bcc.n	80151e0 <zb_ipc_m4_memcpy2+0x12>
    }
}
 80151fe:	bf00      	nop
 8015200:	bf00      	nop
 8015202:	371c      	adds	r7, #28
 8015204:	46bd      	mov	sp, r7
 8015206:	f85d 7b04 	ldr.w	r7, [sp], #4
 801520a:	4770      	bx	lr

0801520c <zb_ipc_m4_cb_info_alloc>:
    ZbSetLogging(zb_ipc_globals.zb, mask, func);
}

static struct zb_ipc_m4_cb_info_t *
zb_ipc_m4_cb_info_alloc(void *callback, void *arg)
{
 801520c:	b580      	push	{r7, lr}
 801520e:	b084      	sub	sp, #16
 8015210:	af00      	add	r7, sp, #0
 8015212:	6078      	str	r0, [r7, #4]
 8015214:	6039      	str	r1, [r7, #0]
    struct zb_ipc_m4_cb_info_t *info;

    info = malloc(sizeof(struct zb_ipc_m4_cb_info_t));
 8015216:	200c      	movs	r0, #12
 8015218:	f002 feb0 	bl	8017f7c <malloc>
 801521c:	4603      	mov	r3, r0
 801521e:	60fb      	str	r3, [r7, #12]
    if (info != NULL) {
 8015220:	68fb      	ldr	r3, [r7, #12]
 8015222:	2b00      	cmp	r3, #0
 8015224:	d00a      	beq.n	801523c <zb_ipc_m4_cb_info_alloc+0x30>
        memset(info, 0, sizeof(struct zb_ipc_m4_cb_info_t));
 8015226:	220c      	movs	r2, #12
 8015228:	2100      	movs	r1, #0
 801522a:	68f8      	ldr	r0, [r7, #12]
 801522c:	f003 f918 	bl	8018460 <memset>
        info->callback = callback;
 8015230:	68fb      	ldr	r3, [r7, #12]
 8015232:	687a      	ldr	r2, [r7, #4]
 8015234:	601a      	str	r2, [r3, #0]
        info->arg = arg;
 8015236:	68fb      	ldr	r3, [r7, #12]
 8015238:	683a      	ldr	r2, [r7, #0]
 801523a:	605a      	str	r2, [r3, #4]
    }
    return info;
 801523c:	68fb      	ldr	r3, [r7, #12]
}
 801523e:	4618      	mov	r0, r3
 8015240:	3710      	adds	r7, #16
 8015242:	46bd      	mov	sp, r7
 8015244:	bd80      	pop	{r7, pc}

08015246 <zb_ipc_m4_cb_info_free>:

static void
zb_ipc_m4_cb_info_free(struct zb_ipc_m4_cb_info_t *info)
{
 8015246:	b580      	push	{r7, lr}
 8015248:	b082      	sub	sp, #8
 801524a:	af00      	add	r7, sp, #0
 801524c:	6078      	str	r0, [r7, #4]
    free(info);
 801524e:	6878      	ldr	r0, [r7, #4]
 8015250:	f002 fe9c 	bl	8017f8c <free>
}
 8015254:	bf00      	nop
 8015256:	3708      	adds	r7, #8
 8015258:	46bd      	mov	sp, r7
 801525a:	bd80      	pop	{r7, pc}

0801525c <zb_ipc_m4_get_retval>:

static uint32_t
zb_ipc_m4_get_retval(void)
{
 801525c:	b580      	push	{r7, lr}
 801525e:	b082      	sub	sp, #8
 8015260:	af00      	add	r7, sp, #0
    Zigbee_Cmd_Request_t *ipcc_req;
    uint32_t retval;

    ipcc_req = ZIGBEE_Get_OTCmdRspPayloadBuffer();
 8015262:	f7f3 fbcf 	bl	8008a04 <ZIGBEE_Get_OTCmdRspPayloadBuffer>
 8015266:	6078      	str	r0, [r7, #4]
    assert(ipcc_req->Size == 1);
 8015268:	687b      	ldr	r3, [r7, #4]
 801526a:	685b      	ldr	r3, [r3, #4]
 801526c:	2b01      	cmp	r3, #1
 801526e:	d006      	beq.n	801527e <zb_ipc_m4_get_retval+0x22>
 8015270:	4b09      	ldr	r3, [pc, #36]	; (8015298 <zb_ipc_m4_get_retval+0x3c>)
 8015272:	4a0a      	ldr	r2, [pc, #40]	; (801529c <zb_ipc_m4_get_retval+0x40>)
 8015274:	f240 1151 	movw	r1, #337	; 0x151
 8015278:	4809      	ldr	r0, [pc, #36]	; (80152a0 <zb_ipc_m4_get_retval+0x44>)
 801527a:	f002 fe61 	bl	8017f40 <__assert_func>
    zb_ipc_m4_memcpy2(&retval, (void *)&ipcc_req->Data[0], 4);
 801527e:	687b      	ldr	r3, [r7, #4]
 8015280:	f103 0108 	add.w	r1, r3, #8
 8015284:	463b      	mov	r3, r7
 8015286:	2204      	movs	r2, #4
 8015288:	4618      	mov	r0, r3
 801528a:	f7ff ffa0 	bl	80151ce <zb_ipc_m4_memcpy2>
    return retval;
 801528e:	683b      	ldr	r3, [r7, #0]
}
 8015290:	4618      	mov	r0, r3
 8015292:	3708      	adds	r7, #8
 8015294:	46bd      	mov	sp, r7
 8015296:	bd80      	pop	{r7, pc}
 8015298:	08019848 	.word	0x08019848
 801529c:	08019cc4 	.word	0x08019cc4
 80152a0:	0801985c 	.word	0x0801985c

080152a4 <ZbInit>:
    return ZB_HEAP_MAX_ALLOC;
}

struct ZigBeeT *
ZbInit(uint64_t extAddr, struct ZbInitTblSizesT *tblSizes, struct ZbInitSetLoggingT *setLogging)
{
 80152a4:	b580      	push	{r7, lr}
 80152a6:	b086      	sub	sp, #24
 80152a8:	af00      	add	r7, sp, #0
 80152aa:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80152ae:	607a      	str	r2, [r7, #4]
 80152b0:	603b      	str	r3, [r7, #0]
    Zigbee_Cmd_Request_t *ipcc_req;

    if (zb_ipc_globals.zb != NULL) {
 80152b2:	4b25      	ldr	r3, [pc, #148]	; (8015348 <ZbInit+0xa4>)
 80152b4:	681b      	ldr	r3, [r3, #0]
 80152b6:	2b00      	cmp	r3, #0
 80152b8:	d001      	beq.n	80152be <ZbInit+0x1a>
        return NULL;
 80152ba:	2300      	movs	r3, #0
 80152bc:	e03f      	b.n	801533e <ZbInit+0x9a>
    }
    Pre_ZigbeeCmdProcessing();
 80152be:	f7f3 fc03 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 80152c2:	f7f3 fb93 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 80152c6:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_ZB_INIT;
 80152c8:	697b      	ldr	r3, [r7, #20]
 80152ca:	2200      	movs	r2, #0
 80152cc:	f042 020a 	orr.w	r2, r2, #10
 80152d0:	701a      	strb	r2, [r3, #0]
 80152d2:	2200      	movs	r2, #0
 80152d4:	705a      	strb	r2, [r3, #1]
 80152d6:	2200      	movs	r2, #0
 80152d8:	709a      	strb	r2, [r3, #2]
 80152da:	2200      	movs	r2, #0
 80152dc:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 4;
 80152de:	697b      	ldr	r3, [r7, #20]
 80152e0:	2200      	movs	r2, #0
 80152e2:	f042 0204 	orr.w	r2, r2, #4
 80152e6:	711a      	strb	r2, [r3, #4]
 80152e8:	2200      	movs	r2, #0
 80152ea:	715a      	strb	r2, [r3, #5]
 80152ec:	2200      	movs	r2, #0
 80152ee:	719a      	strb	r2, [r3, #6]
 80152f0:	2200      	movs	r2, #0
 80152f2:	71da      	strb	r2, [r3, #7]
    zb_ipc_m4_memcpy2((void *)&ipcc_req->Data[0], &extAddr, 8);
 80152f4:	697b      	ldr	r3, [r7, #20]
 80152f6:	3308      	adds	r3, #8
 80152f8:	f107 0108 	add.w	r1, r7, #8
 80152fc:	2208      	movs	r2, #8
 80152fe:	4618      	mov	r0, r3
 8015300:	f7ff ff65 	bl	80151ce <zb_ipc_m4_memcpy2>
    ipcc_req->Data[2] = (uint32_t)tblSizes;
 8015304:	687a      	ldr	r2, [r7, #4]
 8015306:	697b      	ldr	r3, [r7, #20]
 8015308:	611a      	str	r2, [r3, #16]
    ipcc_req->Data[3] = (uint32_t)setLogging;
 801530a:	683a      	ldr	r2, [r7, #0]
 801530c:	697b      	ldr	r3, [r7, #20]
 801530e:	615a      	str	r2, [r3, #20]
    ZIGBEE_CmdTransfer();
 8015310:	f7f3 fb9c 	bl	8008a4c <ZIGBEE_CmdTransfer>
    zb_ipc_globals.zb = (struct ZigBeeT *)zb_ipc_m4_get_retval();
 8015314:	f7ff ffa2 	bl	801525c <zb_ipc_m4_get_retval>
 8015318:	4603      	mov	r3, r0
 801531a:	461a      	mov	r2, r3
 801531c:	4b0a      	ldr	r3, [pc, #40]	; (8015348 <ZbInit+0xa4>)
 801531e:	601a      	str	r2, [r3, #0]
    Post_ZigbeeCmdProcessing();
 8015320:	f7fe fd48 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    if (setLogging != NULL) {
 8015324:	683b      	ldr	r3, [r7, #0]
 8015326:	2b00      	cmp	r3, #0
 8015328:	d007      	beq.n	801533a <ZbInit+0x96>
        /* Save the log mask */
        zb_ipc_globals.log_cb = setLogging->func;
 801532a:	683b      	ldr	r3, [r7, #0]
 801532c:	685b      	ldr	r3, [r3, #4]
 801532e:	4a06      	ldr	r2, [pc, #24]	; (8015348 <ZbInit+0xa4>)
 8015330:	6053      	str	r3, [r2, #4]
        zb_ipc_globals.log_mask = setLogging->mask;
 8015332:	683b      	ldr	r3, [r7, #0]
 8015334:	681b      	ldr	r3, [r3, #0]
 8015336:	4a04      	ldr	r2, [pc, #16]	; (8015348 <ZbInit+0xa4>)
 8015338:	6093      	str	r3, [r2, #8]
    }
    return zb_ipc_globals.zb;
 801533a:	4b03      	ldr	r3, [pc, #12]	; (8015348 <ZbInit+0xa4>)
 801533c:	681b      	ldr	r3, [r3, #0]
}
 801533e:	4618      	mov	r0, r3
 8015340:	3718      	adds	r7, #24
 8015342:	46bd      	mov	sp, r7
 8015344:	bd80      	pop	{r7, pc}
 8015346:	bf00      	nop
 8015348:	20002510 	.word	0x20002510

0801534c <ZbSetLogging>:
}

void
ZbSetLogging(struct ZigBeeT *zb, uint32_t mask,
    void (*func)(struct ZigBeeT *zb, uint32_t mask, const char *hdr, const char *fmt, va_list argptr))
{
 801534c:	b580      	push	{r7, lr}
 801534e:	b086      	sub	sp, #24
 8015350:	af00      	add	r7, sp, #0
 8015352:	60f8      	str	r0, [r7, #12]
 8015354:	60b9      	str	r1, [r7, #8]
 8015356:	607a      	str	r2, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 8015358:	f7f3 fbb6 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 801535c:	f7f3 fb46 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015360:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_LOG_CONFIG;
 8015362:	697b      	ldr	r3, [r7, #20]
 8015364:	2200      	movs	r2, #0
 8015366:	f042 0213 	orr.w	r2, r2, #19
 801536a:	701a      	strb	r2, [r3, #0]
 801536c:	2200      	movs	r2, #0
 801536e:	705a      	strb	r2, [r3, #1]
 8015370:	2200      	movs	r2, #0
 8015372:	709a      	strb	r2, [r3, #2]
 8015374:	2200      	movs	r2, #0
 8015376:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 8015378:	697b      	ldr	r3, [r7, #20]
 801537a:	2200      	movs	r2, #0
 801537c:	f042 0202 	orr.w	r2, r2, #2
 8015380:	711a      	strb	r2, [r3, #4]
 8015382:	2200      	movs	r2, #0
 8015384:	715a      	strb	r2, [r3, #5]
 8015386:	2200      	movs	r2, #0
 8015388:	719a      	strb	r2, [r3, #6]
 801538a:	2200      	movs	r2, #0
 801538c:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = mask;
 801538e:	697b      	ldr	r3, [r7, #20]
 8015390:	68ba      	ldr	r2, [r7, #8]
 8015392:	609a      	str	r2, [r3, #8]
    /* Ignore the 'func' argument. Only use zb_ipc_globals.log_enable to determine if we want
     * log messages from the M4. If zb_ipc_globals.log_func != NULL, M0 sends log messages
     * over IPCC. */
    ipcc_req->Data[1] = (zb_ipc_globals.log_enable || (func != NULL)) ? 1U : 0U;
 8015394:	4b0c      	ldr	r3, [pc, #48]	; (80153c8 <ZbSetLogging+0x7c>)
 8015396:	7b1b      	ldrb	r3, [r3, #12]
 8015398:	2b00      	cmp	r3, #0
 801539a:	d102      	bne.n	80153a2 <ZbSetLogging+0x56>
 801539c:	687b      	ldr	r3, [r7, #4]
 801539e:	2b00      	cmp	r3, #0
 80153a0:	d001      	beq.n	80153a6 <ZbSetLogging+0x5a>
 80153a2:	2201      	movs	r2, #1
 80153a4:	e000      	b.n	80153a8 <ZbSetLogging+0x5c>
 80153a6:	2200      	movs	r2, #0
 80153a8:	697b      	ldr	r3, [r7, #20]
 80153aa:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 80153ac:	f7f3 fb4e 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 80153b0:	f7fe fd00 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    /* Save the log mask */
    zb_ipc_globals.log_cb = func;
 80153b4:	4a04      	ldr	r2, [pc, #16]	; (80153c8 <ZbSetLogging+0x7c>)
 80153b6:	687b      	ldr	r3, [r7, #4]
 80153b8:	6053      	str	r3, [r2, #4]
    zb_ipc_globals.log_mask = mask;
 80153ba:	4a03      	ldr	r2, [pc, #12]	; (80153c8 <ZbSetLogging+0x7c>)
 80153bc:	68bb      	ldr	r3, [r7, #8]
 80153be:	6093      	str	r3, [r2, #8]
}
 80153c0:	bf00      	nop
 80153c2:	3718      	adds	r7, #24
 80153c4:	46bd      	mov	sp, r7
 80153c6:	bd80      	pop	{r7, pc}
 80153c8:	20002510 	.word	0x20002510

080153cc <ZbExtendedAddress>:
    }
}

uint64_t
ZbExtendedAddress(struct ZigBeeT *zb)
{
 80153cc:	b580      	push	{r7, lr}
 80153ce:	b086      	sub	sp, #24
 80153d0:	af00      	add	r7, sp, #0
 80153d2:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;
    uint64_t ext_addr = 0U;
 80153d4:	f04f 0200 	mov.w	r2, #0
 80153d8:	f04f 0300 	mov.w	r3, #0
 80153dc:	e9c7 2302 	strd	r2, r3, [r7, #8]

    Pre_ZigbeeCmdProcessing();
 80153e0:	f7f3 fb72 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 80153e4:	f7f3 fb02 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 80153e8:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_EXTADDR_GET;
 80153ea:	697b      	ldr	r3, [r7, #20]
 80153ec:	2200      	movs	r2, #0
 80153ee:	f042 020e 	orr.w	r2, r2, #14
 80153f2:	701a      	strb	r2, [r3, #0]
 80153f4:	2200      	movs	r2, #0
 80153f6:	705a      	strb	r2, [r3, #1]
 80153f8:	2200      	movs	r2, #0
 80153fa:	709a      	strb	r2, [r3, #2]
 80153fc:	2200      	movs	r2, #0
 80153fe:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 0;
 8015400:	697b      	ldr	r3, [r7, #20]
 8015402:	2200      	movs	r2, #0
 8015404:	711a      	strb	r2, [r3, #4]
 8015406:	2200      	movs	r2, #0
 8015408:	715a      	strb	r2, [r3, #5]
 801540a:	2200      	movs	r2, #0
 801540c:	719a      	strb	r2, [r3, #6]
 801540e:	2200      	movs	r2, #0
 8015410:	71da      	strb	r2, [r3, #7]
    ZIGBEE_CmdTransfer();
 8015412:	f7f3 fb1b 	bl	8008a4c <ZIGBEE_CmdTransfer>
    ipcc_req = ZIGBEE_Get_OTCmdRspPayloadBuffer();
 8015416:	f7f3 faf5 	bl	8008a04 <ZIGBEE_Get_OTCmdRspPayloadBuffer>
 801541a:	6178      	str	r0, [r7, #20]
    assert(ipcc_req->Size == 2);
 801541c:	697b      	ldr	r3, [r7, #20]
 801541e:	685b      	ldr	r3, [r3, #4]
 8015420:	2b02      	cmp	r3, #2
 8015422:	d006      	beq.n	8015432 <ZbExtendedAddress+0x66>
 8015424:	4b0c      	ldr	r3, [pc, #48]	; (8015458 <ZbExtendedAddress+0x8c>)
 8015426:	4a0d      	ldr	r2, [pc, #52]	; (801545c <ZbExtendedAddress+0x90>)
 8015428:	f240 11cd 	movw	r1, #461	; 0x1cd
 801542c:	480c      	ldr	r0, [pc, #48]	; (8015460 <ZbExtendedAddress+0x94>)
 801542e:	f002 fd87 	bl	8017f40 <__assert_func>
    zb_ipc_m4_memcpy2(&ext_addr, &ipcc_req->Data, 8);
 8015432:	697b      	ldr	r3, [r7, #20]
 8015434:	f103 0108 	add.w	r1, r3, #8
 8015438:	f107 0308 	add.w	r3, r7, #8
 801543c:	2208      	movs	r2, #8
 801543e:	4618      	mov	r0, r3
 8015440:	f7ff fec5 	bl	80151ce <zb_ipc_m4_memcpy2>
    Post_ZigbeeCmdProcessing();
 8015444:	f7fe fcb6 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return ext_addr;
 8015448:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
}
 801544c:	4610      	mov	r0, r2
 801544e:	4619      	mov	r1, r3
 8015450:	3718      	adds	r7, #24
 8015452:	46bd      	mov	sp, r7
 8015454:	bd80      	pop	{r7, pc}
 8015456:	bf00      	nop
 8015458:	080198d4 	.word	0x080198d4
 801545c:	08019cdc 	.word	0x08019cdc
 8015460:	0801985c 	.word	0x0801985c

08015464 <ZbShortAddress>:

uint16_t
ZbShortAddress(struct ZigBeeT *zb)
{
 8015464:	b580      	push	{r7, lr}
 8015466:	b084      	sub	sp, #16
 8015468:	af00      	add	r7, sp, #0
 801546a:	6078      	str	r0, [r7, #4]
    uint16_t nwkAddr = 0U;
 801546c:	2300      	movs	r3, #0
 801546e:	81fb      	strh	r3, [r7, #14]

    (void)ZbNwkGet(zb, ZB_NWK_NIB_ID_NetworkAddress, &nwkAddr, sizeof(nwkAddr));
 8015470:	f107 020e 	add.w	r2, r7, #14
 8015474:	2302      	movs	r3, #2
 8015476:	2196      	movs	r1, #150	; 0x96
 8015478:	6878      	ldr	r0, [r7, #4]
 801547a:	f000 fc1b 	bl	8015cb4 <ZbNwkGet>
    return nwkAddr;
 801547e:	89fb      	ldrh	r3, [r7, #14]
}
 8015480:	4618      	mov	r0, r3
 8015482:	3710      	adds	r7, #16
 8015484:	46bd      	mov	sp, r7
 8015486:	bd80      	pop	{r7, pc}

08015488 <ZbStartupConfigGetProDefaults>:
    Post_ZigbeeCmdProcessing();
}

void
ZbStartupConfigGetProDefaults(struct ZbStartupT *configPtr)
{
 8015488:	b580      	push	{r7, lr}
 801548a:	b084      	sub	sp, #16
 801548c:	af00      	add	r7, sp, #0
 801548e:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 8015490:	f7f3 fb1a 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015494:	f7f3 faaa 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015498:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_STARTUP_GET_CFG;
 801549a:	68fb      	ldr	r3, [r7, #12]
 801549c:	2200      	movs	r2, #0
 801549e:	f042 021b 	orr.w	r2, r2, #27
 80154a2:	701a      	strb	r2, [r3, #0]
 80154a4:	2200      	movs	r2, #0
 80154a6:	705a      	strb	r2, [r3, #1]
 80154a8:	2200      	movs	r2, #0
 80154aa:	709a      	strb	r2, [r3, #2]
 80154ac:	2200      	movs	r2, #0
 80154ae:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 80154b0:	68fb      	ldr	r3, [r7, #12]
 80154b2:	2200      	movs	r2, #0
 80154b4:	f042 0201 	orr.w	r2, r2, #1
 80154b8:	711a      	strb	r2, [r3, #4]
 80154ba:	2200      	movs	r2, #0
 80154bc:	715a      	strb	r2, [r3, #5]
 80154be:	2200      	movs	r2, #0
 80154c0:	719a      	strb	r2, [r3, #6]
 80154c2:	2200      	movs	r2, #0
 80154c4:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)configPtr;
 80154c6:	687a      	ldr	r2, [r7, #4]
 80154c8:	68fb      	ldr	r3, [r7, #12]
 80154ca:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 80154cc:	f7f3 fabe 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 80154d0:	f7fe fc70 	bl	8013db4 <Post_ZigbeeCmdProcessing>
}
 80154d4:	bf00      	nop
 80154d6:	3710      	adds	r7, #16
 80154d8:	46bd      	mov	sp, r7
 80154da:	bd80      	pop	{r7, pc}

080154dc <ZbStartup>:
}

enum ZbStatusCodeT
ZbStartup(struct ZigBeeT *zb, struct ZbStartupT *configPtr,
    void (*callback)(enum ZbStatusCodeT status, void *cb_arg), void *arg)
{
 80154dc:	b580      	push	{r7, lr}
 80154de:	b088      	sub	sp, #32
 80154e0:	af00      	add	r7, sp, #0
 80154e2:	60f8      	str	r0, [r7, #12]
 80154e4:	60b9      	str	r1, [r7, #8]
 80154e6:	607a      	str	r2, [r7, #4]
 80154e8:	603b      	str	r3, [r7, #0]
    Zigbee_Cmd_Request_t *ipcc_req;
    struct zb_ipc_m4_cb_info_t *info;
    enum ZbStatusCodeT status;

    info = zb_ipc_m4_cb_info_alloc((void *)callback, arg);
 80154ea:	6839      	ldr	r1, [r7, #0]
 80154ec:	6878      	ldr	r0, [r7, #4]
 80154ee:	f7ff fe8d 	bl	801520c <zb_ipc_m4_cb_info_alloc>
 80154f2:	61f8      	str	r0, [r7, #28]
    if (info == NULL) {
 80154f4:	69fb      	ldr	r3, [r7, #28]
 80154f6:	2b00      	cmp	r3, #0
 80154f8:	d101      	bne.n	80154fe <ZbStartup+0x22>
        return ZB_STATUS_ALLOC_FAIL;
 80154fa:	2370      	movs	r3, #112	; 0x70
 80154fc:	e036      	b.n	801556c <ZbStartup+0x90>
    }

    /* Save the touchlink callbacks */
    /* I.e. MSG_M0TOM4_ZCL_TL_EP_INFO_CB */
    memcpy(&zigbee_m4_tl_callbacks, &configPtr->touchlink.callbacks, sizeof(struct ZbTouchlinkCallbacks));
 80154fe:	68bb      	ldr	r3, [r7, #8]
 8015500:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 8015504:	681b      	ldr	r3, [r3, #0]
 8015506:	461a      	mov	r2, r3
 8015508:	4b1a      	ldr	r3, [pc, #104]	; (8015574 <ZbStartup+0x98>)
 801550a:	601a      	str	r2, [r3, #0]

    Pre_ZigbeeCmdProcessing();
 801550c:	f7f3 fadc 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015510:	f7f3 fa6c 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015514:	61b8      	str	r0, [r7, #24]
    ipcc_req->ID = MSG_M4TOM0_STARTUP_REQ;
 8015516:	69bb      	ldr	r3, [r7, #24]
 8015518:	2200      	movs	r2, #0
 801551a:	f042 021c 	orr.w	r2, r2, #28
 801551e:	701a      	strb	r2, [r3, #0]
 8015520:	2200      	movs	r2, #0
 8015522:	705a      	strb	r2, [r3, #1]
 8015524:	2200      	movs	r2, #0
 8015526:	709a      	strb	r2, [r3, #2]
 8015528:	2200      	movs	r2, #0
 801552a:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 801552c:	69bb      	ldr	r3, [r7, #24]
 801552e:	2200      	movs	r2, #0
 8015530:	f042 0202 	orr.w	r2, r2, #2
 8015534:	711a      	strb	r2, [r3, #4]
 8015536:	2200      	movs	r2, #0
 8015538:	715a      	strb	r2, [r3, #5]
 801553a:	2200      	movs	r2, #0
 801553c:	719a      	strb	r2, [r3, #6]
 801553e:	2200      	movs	r2, #0
 8015540:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)configPtr;
 8015542:	68ba      	ldr	r2, [r7, #8]
 8015544:	69bb      	ldr	r3, [r7, #24]
 8015546:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)info;
 8015548:	69fa      	ldr	r2, [r7, #28]
 801554a:	69bb      	ldr	r3, [r7, #24]
 801554c:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 801554e:	f7f3 fa7d 	bl	8008a4c <ZIGBEE_CmdTransfer>
    status = (enum ZbStatusCodeT)zb_ipc_m4_get_retval();
 8015552:	f7ff fe83 	bl	801525c <zb_ipc_m4_get_retval>
 8015556:	4603      	mov	r3, r0
 8015558:	75fb      	strb	r3, [r7, #23]
    Post_ZigbeeCmdProcessing();
 801555a:	f7fe fc2b 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    if (status != ZB_STATUS_SUCCESS) {
 801555e:	7dfb      	ldrb	r3, [r7, #23]
 8015560:	2b00      	cmp	r3, #0
 8015562:	d002      	beq.n	801556a <ZbStartup+0x8e>
        zb_ipc_m4_cb_info_free(info);
 8015564:	69f8      	ldr	r0, [r7, #28]
 8015566:	f7ff fe6e 	bl	8015246 <zb_ipc_m4_cb_info_free>
    }
    return status;
 801556a:	7dfb      	ldrb	r3, [r7, #23]
    /* If success, followed up in MSG_M0TOM4_STARTUP_CB handler */
}
 801556c:	4618      	mov	r0, r3
 801556e:	3720      	adds	r7, #32
 8015570:	46bd      	mov	sp, r7
 8015572:	bd80      	pop	{r7, pc}
 8015574:	200024fc 	.word	0x200024fc

08015578 <ZbBdbGetIndex>:
 ******************************************************************************
 */
enum ZbStatusCodeT
ZbBdbGetIndex(struct ZigBeeT *zb, enum ZbBdbAttrIdT attrId, void *attrPtr,
    unsigned int attrSz, unsigned int attrIndex)
{
 8015578:	b580      	push	{r7, lr}
 801557a:	b08c      	sub	sp, #48	; 0x30
 801557c:	af00      	add	r7, sp, #0
 801557e:	60f8      	str	r0, [r7, #12]
 8015580:	607a      	str	r2, [r7, #4]
 8015582:	603b      	str	r3, [r7, #0]
 8015584:	460b      	mov	r3, r1
 8015586:	817b      	strh	r3, [r7, #10]
    struct ZbBdbGetReqT bdbGetReq;
    struct ZbBdbGetConfT bdbGetConf;
    enum ZbStatusCodeT status;

    /* Do the BDB-GET.request */
    bdbGetReq.attrId = attrId;
 8015588:	897b      	ldrh	r3, [r7, #10]
 801558a:	833b      	strh	r3, [r7, #24]
    bdbGetReq.attr = attrPtr;
 801558c:	687b      	ldr	r3, [r7, #4]
 801558e:	61fb      	str	r3, [r7, #28]
    bdbGetReq.attrLength = attrSz;
 8015590:	683b      	ldr	r3, [r7, #0]
 8015592:	623b      	str	r3, [r7, #32]
    bdbGetReq.attrIndex = attrIndex;
 8015594:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015596:	627b      	str	r3, [r7, #36]	; 0x24

    Pre_ZigbeeCmdProcessing();
 8015598:	f7f3 fa96 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 801559c:	f7f3 fa26 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 80155a0:	62f8      	str	r0, [r7, #44]	; 0x2c
    ipcc_req->ID = MSG_M4TOM0_BDB_GET_REQ;
 80155a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155a4:	2200      	movs	r2, #0
 80155a6:	701a      	strb	r2, [r3, #0]
 80155a8:	2200      	movs	r2, #0
 80155aa:	f042 0202 	orr.w	r2, r2, #2
 80155ae:	705a      	strb	r2, [r3, #1]
 80155b0:	2200      	movs	r2, #0
 80155b2:	709a      	strb	r2, [r3, #2]
 80155b4:	2200      	movs	r2, #0
 80155b6:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 80155b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155ba:	2200      	movs	r2, #0
 80155bc:	f042 0202 	orr.w	r2, r2, #2
 80155c0:	711a      	strb	r2, [r3, #4]
 80155c2:	2200      	movs	r2, #0
 80155c4:	715a      	strb	r2, [r3, #5]
 80155c6:	2200      	movs	r2, #0
 80155c8:	719a      	strb	r2, [r3, #6]
 80155ca:	2200      	movs	r2, #0
 80155cc:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)&bdbGetReq;
 80155ce:	f107 0218 	add.w	r2, r7, #24
 80155d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155d4:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)&bdbGetConf;
 80155d6:	f107 0214 	add.w	r2, r7, #20
 80155da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80155dc:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 80155de:	f7f3 fa35 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 80155e2:	f7fe fbe7 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    status = (enum ZbStatusCodeT)bdbGetConf.status;
 80155e6:	7d3b      	ldrb	r3, [r7, #20]
 80155e8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    return status;
 80155ec:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
}
 80155f0:	4618      	mov	r0, r3
 80155f2:	3730      	adds	r7, #48	; 0x30
 80155f4:	46bd      	mov	sp, r7
 80155f6:	bd80      	pop	{r7, pc}

080155f8 <ZbApsdeDataReqCallback>:
 ******************************************************************************
 */
enum ZbStatusCodeT
ZbApsdeDataReqCallback(struct ZigBeeT *zb, struct ZbApsdeDataReqT *req,
    void (*callback)(struct ZbApsdeDataConfT *conf, void *arg), void *arg)
{
 80155f8:	b580      	push	{r7, lr}
 80155fa:	b088      	sub	sp, #32
 80155fc:	af00      	add	r7, sp, #0
 80155fe:	60f8      	str	r0, [r7, #12]
 8015600:	60b9      	str	r1, [r7, #8]
 8015602:	607a      	str	r2, [r7, #4]
 8015604:	603b      	str	r3, [r7, #0]
    Zigbee_Cmd_Request_t *ipcc_req;
    enum ZbStatusCodeT status;
    struct zb_ipc_m4_cb_info_t *info;

    info = zb_ipc_m4_cb_info_alloc((void *)callback, arg);
 8015606:	6839      	ldr	r1, [r7, #0]
 8015608:	6878      	ldr	r0, [r7, #4]
 801560a:	f7ff fdff 	bl	801520c <zb_ipc_m4_cb_info_alloc>
 801560e:	61f8      	str	r0, [r7, #28]
    if (info == NULL) {
 8015610:	69fb      	ldr	r3, [r7, #28]
 8015612:	2b00      	cmp	r3, #0
 8015614:	d101      	bne.n	801561a <ZbApsdeDataReqCallback+0x22>
        return ZB_STATUS_ALLOC_FAIL;
 8015616:	2370      	movs	r3, #112	; 0x70
 8015618:	e031      	b.n	801567e <ZbApsdeDataReqCallback+0x86>
    }
    Pre_ZigbeeCmdProcessing();
 801561a:	f7f3 fa55 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 801561e:	f7f3 f9e5 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015622:	61b8      	str	r0, [r7, #24]
    ipcc_req->ID = MSG_M4TOM0_APSDE_DATA_REQ;
 8015624:	69bb      	ldr	r3, [r7, #24]
 8015626:	2200      	movs	r2, #0
 8015628:	f042 0204 	orr.w	r2, r2, #4
 801562c:	701a      	strb	r2, [r3, #0]
 801562e:	2200      	movs	r2, #0
 8015630:	f042 0202 	orr.w	r2, r2, #2
 8015634:	705a      	strb	r2, [r3, #1]
 8015636:	2200      	movs	r2, #0
 8015638:	709a      	strb	r2, [r3, #2]
 801563a:	2200      	movs	r2, #0
 801563c:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 801563e:	69bb      	ldr	r3, [r7, #24]
 8015640:	2200      	movs	r2, #0
 8015642:	f042 0202 	orr.w	r2, r2, #2
 8015646:	711a      	strb	r2, [r3, #4]
 8015648:	2200      	movs	r2, #0
 801564a:	715a      	strb	r2, [r3, #5]
 801564c:	2200      	movs	r2, #0
 801564e:	719a      	strb	r2, [r3, #6]
 8015650:	2200      	movs	r2, #0
 8015652:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)req;
 8015654:	68ba      	ldr	r2, [r7, #8]
 8015656:	69bb      	ldr	r3, [r7, #24]
 8015658:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)info;
 801565a:	69fa      	ldr	r2, [r7, #28]
 801565c:	69bb      	ldr	r3, [r7, #24]
 801565e:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 8015660:	f7f3 f9f4 	bl	8008a4c <ZIGBEE_CmdTransfer>
    /* Get the status code */
    status = (enum ZbStatusCodeT)zb_ipc_m4_get_retval();
 8015664:	f7ff fdfa 	bl	801525c <zb_ipc_m4_get_retval>
 8015668:	4603      	mov	r3, r0
 801566a:	75fb      	strb	r3, [r7, #23]
    Post_ZigbeeCmdProcessing();
 801566c:	f7fe fba2 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    if (status != ZB_STATUS_SUCCESS) {
 8015670:	7dfb      	ldrb	r3, [r7, #23]
 8015672:	2b00      	cmp	r3, #0
 8015674:	d002      	beq.n	801567c <ZbApsdeDataReqCallback+0x84>
        zb_ipc_m4_cb_info_free(info);
 8015676:	69f8      	ldr	r0, [r7, #28]
 8015678:	f7ff fde5 	bl	8015246 <zb_ipc_m4_cb_info_free>
    }
    return status;
 801567c:	7dfb      	ldrb	r3, [r7, #23]
    /* If success, followed up in MSG_M0TOM4_APSDE_DATA_REQ_CB handler */
}
 801567e:	4618      	mov	r0, r3
 8015680:	3720      	adds	r7, #32
 8015682:	46bd      	mov	sp, r7
 8015684:	bd80      	pop	{r7, pc}

08015686 <ZbApsEndpointProfile>:
    return rc;
}

uint16_t
ZbApsEndpointProfile(struct ZigBeeT *zb, uint8_t endpoint)
{
 8015686:	b580      	push	{r7, lr}
 8015688:	b084      	sub	sp, #16
 801568a:	af00      	add	r7, sp, #0
 801568c:	6078      	str	r0, [r7, #4]
 801568e:	460b      	mov	r3, r1
 8015690:	70fb      	strb	r3, [r7, #3]
    Zigbee_Cmd_Request_t *ipcc_req;
    uint16_t val_ret;

    Pre_ZigbeeCmdProcessing();
 8015692:	f7f3 fa19 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015696:	f7f3 f9a9 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 801569a:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_APS_EP_GET_PROFILE;
 801569c:	68fb      	ldr	r3, [r7, #12]
 801569e:	2200      	movs	r2, #0
 80156a0:	f042 020d 	orr.w	r2, r2, #13
 80156a4:	701a      	strb	r2, [r3, #0]
 80156a6:	2200      	movs	r2, #0
 80156a8:	f042 0202 	orr.w	r2, r2, #2
 80156ac:	705a      	strb	r2, [r3, #1]
 80156ae:	2200      	movs	r2, #0
 80156b0:	709a      	strb	r2, [r3, #2]
 80156b2:	2200      	movs	r2, #0
 80156b4:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 80156b6:	68fb      	ldr	r3, [r7, #12]
 80156b8:	2200      	movs	r2, #0
 80156ba:	f042 0201 	orr.w	r2, r2, #1
 80156be:	711a      	strb	r2, [r3, #4]
 80156c0:	2200      	movs	r2, #0
 80156c2:	715a      	strb	r2, [r3, #5]
 80156c4:	2200      	movs	r2, #0
 80156c6:	719a      	strb	r2, [r3, #6]
 80156c8:	2200      	movs	r2, #0
 80156ca:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)endpoint;
 80156cc:	78fa      	ldrb	r2, [r7, #3]
 80156ce:	68fb      	ldr	r3, [r7, #12]
 80156d0:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 80156d2:	f7f3 f9bb 	bl	8008a4c <ZIGBEE_CmdTransfer>
    val_ret = (uint16_t)zb_ipc_m4_get_retval();
 80156d6:	f7ff fdc1 	bl	801525c <zb_ipc_m4_get_retval>
 80156da:	4603      	mov	r3, r0
 80156dc:	817b      	strh	r3, [r7, #10]
    Post_ZigbeeCmdProcessing();
 80156de:	f7fe fb69 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return val_ret;
 80156e2:	897b      	ldrh	r3, [r7, #10]
}
 80156e4:	4618      	mov	r0, r3
 80156e6:	3710      	adds	r7, #16
 80156e8:	46bd      	mov	sp, r7
 80156ea:	bd80      	pop	{r7, pc}

080156ec <ZbApsAddrIsBcast>:

bool
ZbApsAddrIsBcast(const struct ZbApsAddrT *addr)
{
 80156ec:	b480      	push	{r7}
 80156ee:	b083      	sub	sp, #12
 80156f0:	af00      	add	r7, sp, #0
 80156f2:	6078      	str	r0, [r7, #4]
    /* Check the destination of the original request */
    if (addr->mode == ZB_APSDE_ADDRMODE_GROUP) {
 80156f4:	687b      	ldr	r3, [r7, #4]
 80156f6:	781b      	ldrb	r3, [r3, #0]
 80156f8:	2b01      	cmp	r3, #1
 80156fa:	d101      	bne.n	8015700 <ZbApsAddrIsBcast+0x14>
        return true;
 80156fc:	2301      	movs	r3, #1
 80156fe:	e012      	b.n	8015726 <ZbApsAddrIsBcast+0x3a>
    }
    if ((addr->mode == ZB_APSDE_ADDRMODE_SHORT) && (ZbNwkAddrIsBcast(addr->nwkAddr))) {
 8015700:	687b      	ldr	r3, [r7, #4]
 8015702:	781b      	ldrb	r3, [r3, #0]
 8015704:	2b02      	cmp	r3, #2
 8015706:	d10d      	bne.n	8015724 <ZbApsAddrIsBcast+0x38>
 8015708:	687b      	ldr	r3, [r7, #4]
 801570a:	88db      	ldrh	r3, [r3, #6]
 801570c:	f64f 72f7 	movw	r2, #65527	; 0xfff7
 8015710:	4293      	cmp	r3, r2
 8015712:	d907      	bls.n	8015724 <ZbApsAddrIsBcast+0x38>
 8015714:	687b      	ldr	r3, [r7, #4]
 8015716:	88db      	ldrh	r3, [r3, #6]
 8015718:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 801571c:	4293      	cmp	r3, r2
 801571e:	d001      	beq.n	8015724 <ZbApsAddrIsBcast+0x38>
        return true;
 8015720:	2301      	movs	r3, #1
 8015722:	e000      	b.n	8015726 <ZbApsAddrIsBcast+0x3a>
    }
    return false;
 8015724:	2300      	movs	r3, #0
}
 8015726:	4618      	mov	r0, r3
 8015728:	370c      	adds	r7, #12
 801572a:	46bd      	mov	sp, r7
 801572c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015730:	4770      	bx	lr

08015732 <ZbApsAddrIsLocal>:

bool
ZbApsAddrIsLocal(struct ZigBeeT *zb, const struct ZbApsAddrT *addr)
{
 8015732:	b5b0      	push	{r4, r5, r7, lr}
 8015734:	b082      	sub	sp, #8
 8015736:	af00      	add	r7, sp, #0
 8015738:	6078      	str	r0, [r7, #4]
 801573a:	6039      	str	r1, [r7, #0]
    if (addr->mode == ZB_APSDE_ADDRMODE_EXT) {
 801573c:	683b      	ldr	r3, [r7, #0]
 801573e:	781b      	ldrb	r3, [r3, #0]
 8015740:	2b03      	cmp	r3, #3
 8015742:	d10d      	bne.n	8015760 <ZbApsAddrIsLocal+0x2e>
        if (addr->extAddr == ZbExtendedAddress(zb)) {
 8015744:	683b      	ldr	r3, [r7, #0]
 8015746:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 801574a:	6878      	ldr	r0, [r7, #4]
 801574c:	f7ff fe3e 	bl	80153cc <ZbExtendedAddress>
 8015750:	4602      	mov	r2, r0
 8015752:	460b      	mov	r3, r1
 8015754:	429d      	cmp	r5, r3
 8015756:	bf08      	it	eq
 8015758:	4294      	cmpeq	r4, r2
 801575a:	d101      	bne.n	8015760 <ZbApsAddrIsLocal+0x2e>
            return true;
 801575c:	2301      	movs	r3, #1
 801575e:	e00e      	b.n	801577e <ZbApsAddrIsLocal+0x4c>
        }
    }
    if (addr->mode == ZB_APSDE_ADDRMODE_SHORT) {
 8015760:	683b      	ldr	r3, [r7, #0]
 8015762:	781b      	ldrb	r3, [r3, #0]
 8015764:	2b02      	cmp	r3, #2
 8015766:	d109      	bne.n	801577c <ZbApsAddrIsLocal+0x4a>
        if (addr->nwkAddr == ZbShortAddress(zb)) {
 8015768:	683b      	ldr	r3, [r7, #0]
 801576a:	88dc      	ldrh	r4, [r3, #6]
 801576c:	6878      	ldr	r0, [r7, #4]
 801576e:	f7ff fe79 	bl	8015464 <ZbShortAddress>
 8015772:	4603      	mov	r3, r0
 8015774:	429c      	cmp	r4, r3
 8015776:	d101      	bne.n	801577c <ZbApsAddrIsLocal+0x4a>
            /* Note, if our address is ZB_NWK_ADDR_UNDEFINED, then this message could only
             * have been generated locally. */
            return true;
 8015778:	2301      	movs	r3, #1
 801577a:	e000      	b.n	801577e <ZbApsAddrIsLocal+0x4c>
        }
    }
    return false;
 801577c:	2300      	movs	r3, #0
}
 801577e:	4618      	mov	r0, r3
 8015780:	3708      	adds	r7, #8
 8015782:	46bd      	mov	sp, r7
 8015784:	bdb0      	pop	{r4, r5, r7, pc}

08015786 <ZbApsGetIndex>:
};

enum ZbStatusCodeT
ZbApsGetIndex(struct ZigBeeT *zb, enum ZbApsmeIbAttrIdT attrId, void *attrPtr,
    unsigned int attrSz, unsigned int attrIndex)
{
 8015786:	b580      	push	{r7, lr}
 8015788:	b08a      	sub	sp, #40	; 0x28
 801578a:	af00      	add	r7, sp, #0
 801578c:	60f8      	str	r0, [r7, #12]
 801578e:	607a      	str	r2, [r7, #4]
 8015790:	603b      	str	r3, [r7, #0]
 8015792:	460b      	mov	r3, r1
 8015794:	817b      	strh	r3, [r7, #10]
    Zigbee_Cmd_Request_t *ipcc_req;
    struct ZbApsmeGetReqT apsmeGetReq;
    struct ZbApsmeGetConfT apsmeGetConf;

    /* Do the APSME-GET.request */
    apsmeGetReq.attrId = attrId;
 8015796:	897b      	ldrh	r3, [r7, #10]
 8015798:	82bb      	strh	r3, [r7, #20]
    apsmeGetReq.attr = attrPtr;
 801579a:	687b      	ldr	r3, [r7, #4]
 801579c:	61bb      	str	r3, [r7, #24]
    apsmeGetReq.attrLength = attrSz;
 801579e:	683b      	ldr	r3, [r7, #0]
 80157a0:	61fb      	str	r3, [r7, #28]
    apsmeGetReq.attrIndex = attrIndex;
 80157a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80157a4:	623b      	str	r3, [r7, #32]

    Pre_ZigbeeCmdProcessing();
 80157a6:	f7f3 f98f 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 80157aa:	f7f3 f91f 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 80157ae:	6278      	str	r0, [r7, #36]	; 0x24
    ipcc_req->ID = MSG_M4TOM0_APS_GET_REQ;
 80157b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157b2:	2200      	movs	r2, #0
 80157b4:	f042 0210 	orr.w	r2, r2, #16
 80157b8:	701a      	strb	r2, [r3, #0]
 80157ba:	2200      	movs	r2, #0
 80157bc:	f042 0202 	orr.w	r2, r2, #2
 80157c0:	705a      	strb	r2, [r3, #1]
 80157c2:	2200      	movs	r2, #0
 80157c4:	709a      	strb	r2, [r3, #2]
 80157c6:	2200      	movs	r2, #0
 80157c8:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 80157ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157cc:	2200      	movs	r2, #0
 80157ce:	f042 0202 	orr.w	r2, r2, #2
 80157d2:	711a      	strb	r2, [r3, #4]
 80157d4:	2200      	movs	r2, #0
 80157d6:	715a      	strb	r2, [r3, #5]
 80157d8:	2200      	movs	r2, #0
 80157da:	719a      	strb	r2, [r3, #6]
 80157dc:	2200      	movs	r2, #0
 80157de:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)&apsmeGetReq;
 80157e0:	f107 0214 	add.w	r2, r7, #20
 80157e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157e6:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)&apsmeGetConf;
 80157e8:	f107 0210 	add.w	r2, r7, #16
 80157ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80157ee:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 80157f0:	f7f3 f92c 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 80157f4:	f7fe fade 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return apsmeGetConf.status;
 80157f8:	7c3b      	ldrb	r3, [r7, #16]
}
 80157fa:	4618      	mov	r0, r3
 80157fc:	3728      	adds	r7, #40	; 0x28
 80157fe:	46bd      	mov	sp, r7
 8015800:	bd80      	pop	{r7, pc}

08015802 <ZbApsmeBindReq>:
    }
    ZbExitCritical(zb);
    return len;
}

IPC_REQ_CONF_FUNC(ZbApsmeBindReq, MSG_M4TOM0_APSME_BIND, struct ZbApsmeBindReqT, struct ZbApsmeBindConfT)
 8015802:	b580      	push	{r7, lr}
 8015804:	b086      	sub	sp, #24
 8015806:	af00      	add	r7, sp, #0
 8015808:	60f8      	str	r0, [r7, #12]
 801580a:	60b9      	str	r1, [r7, #8]
 801580c:	607a      	str	r2, [r7, #4]
 801580e:	f7f3 f95b 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
 8015812:	f7f3 f8eb 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015816:	6178      	str	r0, [r7, #20]
 8015818:	697b      	ldr	r3, [r7, #20]
 801581a:	2200      	movs	r2, #0
 801581c:	f042 0215 	orr.w	r2, r2, #21
 8015820:	701a      	strb	r2, [r3, #0]
 8015822:	2200      	movs	r2, #0
 8015824:	f042 0202 	orr.w	r2, r2, #2
 8015828:	705a      	strb	r2, [r3, #1]
 801582a:	2200      	movs	r2, #0
 801582c:	709a      	strb	r2, [r3, #2]
 801582e:	2200      	movs	r2, #0
 8015830:	70da      	strb	r2, [r3, #3]
 8015832:	697b      	ldr	r3, [r7, #20]
 8015834:	2200      	movs	r2, #0
 8015836:	f042 0202 	orr.w	r2, r2, #2
 801583a:	711a      	strb	r2, [r3, #4]
 801583c:	2200      	movs	r2, #0
 801583e:	715a      	strb	r2, [r3, #5]
 8015840:	2200      	movs	r2, #0
 8015842:	719a      	strb	r2, [r3, #6]
 8015844:	2200      	movs	r2, #0
 8015846:	71da      	strb	r2, [r3, #7]
 8015848:	68ba      	ldr	r2, [r7, #8]
 801584a:	697b      	ldr	r3, [r7, #20]
 801584c:	609a      	str	r2, [r3, #8]
 801584e:	687a      	ldr	r2, [r7, #4]
 8015850:	697b      	ldr	r3, [r7, #20]
 8015852:	60da      	str	r2, [r3, #12]
 8015854:	f7f3 f8fa 	bl	8008a4c <ZIGBEE_CmdTransfer>
 8015858:	f7fe faac 	bl	8013db4 <Post_ZigbeeCmdProcessing>
 801585c:	3718      	adds	r7, #24
 801585e:	46bd      	mov	sp, r7
 8015860:	bd80      	pop	{r7, pc}

08015862 <ZbApsBindSrcExists>:
    Post_ZigbeeCmdProcessing();
}

bool
ZbApsBindSrcExists(struct ZigBeeT *zb, uint8_t endpoint, uint16_t clusterId)
{
 8015862:	b580      	push	{r7, lr}
 8015864:	b092      	sub	sp, #72	; 0x48
 8015866:	af02      	add	r7, sp, #8
 8015868:	6078      	str	r0, [r7, #4]
 801586a:	460b      	mov	r3, r1
 801586c:	70fb      	strb	r3, [r7, #3]
 801586e:	4613      	mov	r3, r2
 8015870:	803b      	strh	r3, [r7, #0]
    struct ZbApsmeBindT entry;
    enum ZbStatusCodeT status;
    unsigned int i;
    uint64_t local_ext = ZbExtendedAddress(zb);
 8015872:	6878      	ldr	r0, [r7, #4]
 8015874:	f7ff fdaa 	bl	80153cc <ZbExtendedAddress>
 8015878:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

    ZbEnterCritical(zb);
    for (i = 0;; i++) {
 801587c:	2300      	movs	r3, #0
 801587e:	63fb      	str	r3, [r7, #60]	; 0x3c
        status = ZbApsGetIndex(zb, ZB_APS_IB_ID_BINDING_TABLE, &entry, sizeof(entry), i);
 8015880:	f107 0208 	add.w	r2, r7, #8
 8015884:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015886:	9300      	str	r3, [sp, #0]
 8015888:	2320      	movs	r3, #32
 801588a:	21c1      	movs	r1, #193	; 0xc1
 801588c:	6878      	ldr	r0, [r7, #4]
 801588e:	f7ff ff7a 	bl	8015786 <ZbApsGetIndex>
 8015892:	4603      	mov	r3, r0
 8015894:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        if (status != ZB_APS_STATUS_SUCCESS) {
 8015898:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801589c:	2b00      	cmp	r3, #0
 801589e:	d120      	bne.n	80158e2 <ZbApsBindSrcExists+0x80>
            break;
        }
        if (entry.srcExtAddr == 0ULL) {
 80158a0:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80158a4:	4313      	orrs	r3, r2
 80158a6:	d011      	beq.n	80158cc <ZbApsBindSrcExists+0x6a>
            continue;
        }
        if (entry.srcExtAddr != local_ext) {
 80158a8:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80158ac:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
 80158b0:	4299      	cmp	r1, r3
 80158b2:	bf08      	it	eq
 80158b4:	4290      	cmpeq	r0, r2
 80158b6:	d10b      	bne.n	80158d0 <ZbApsBindSrcExists+0x6e>
            continue;
        }
        if (entry.srcEndpt != endpoint) {
 80158b8:	7c3b      	ldrb	r3, [r7, #16]
 80158ba:	78fa      	ldrb	r2, [r7, #3]
 80158bc:	429a      	cmp	r2, r3
 80158be:	d109      	bne.n	80158d4 <ZbApsBindSrcExists+0x72>
            continue;
        }
        if (entry.clusterId != clusterId) {
 80158c0:	8a7b      	ldrh	r3, [r7, #18]
 80158c2:	883a      	ldrh	r2, [r7, #0]
 80158c4:	429a      	cmp	r2, r3
 80158c6:	d107      	bne.n	80158d8 <ZbApsBindSrcExists+0x76>
            continue;
        }
        ZbExitCritical(zb);
        return true;
 80158c8:	2301      	movs	r3, #1
 80158ca:	e00c      	b.n	80158e6 <ZbApsBindSrcExists+0x84>
            continue;
 80158cc:	bf00      	nop
 80158ce:	e004      	b.n	80158da <ZbApsBindSrcExists+0x78>
            continue;
 80158d0:	bf00      	nop
 80158d2:	e002      	b.n	80158da <ZbApsBindSrcExists+0x78>
            continue;
 80158d4:	bf00      	nop
 80158d6:	e000      	b.n	80158da <ZbApsBindSrcExists+0x78>
            continue;
 80158d8:	bf00      	nop
    for (i = 0;; i++) {
 80158da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80158dc:	3301      	adds	r3, #1
 80158de:	63fb      	str	r3, [r7, #60]	; 0x3c
        status = ZbApsGetIndex(zb, ZB_APS_IB_ID_BINDING_TABLE, &entry, sizeof(entry), i);
 80158e0:	e7ce      	b.n	8015880 <ZbApsBindSrcExists+0x1e>
            break;
 80158e2:	bf00      	nop
    }
    ZbExitCritical(zb);
    return false;
 80158e4:	2300      	movs	r3, #0
}
 80158e6:	4618      	mov	r0, r3
 80158e8:	3740      	adds	r7, #64	; 0x40
 80158ea:	46bd      	mov	sp, r7
 80158ec:	bd80      	pop	{r7, pc}
	...

080158f0 <ZbMsgFilterRegister>:
static struct zb_msg_filter_cb_info_t zb_msg_filter_cb_list[ZB_IPC_MSG_FILTER_CB_LIST_MAX];

struct ZbMsgFilterT *
ZbMsgFilterRegister(struct ZigBeeT *zb, uint32_t mask, uint8_t prio,
    enum zb_msg_filter_rc (*callback)(struct ZigBeeT *zb, uint32_t id, void *msg, void *cbarg), void *arg)
{
 80158f0:	b580      	push	{r7, lr}
 80158f2:	b088      	sub	sp, #32
 80158f4:	af00      	add	r7, sp, #0
 80158f6:	60f8      	str	r0, [r7, #12]
 80158f8:	60b9      	str	r1, [r7, #8]
 80158fa:	603b      	str	r3, [r7, #0]
 80158fc:	4613      	mov	r3, r2
 80158fe:	71fb      	strb	r3, [r7, #7]
    Zigbee_Cmd_Request_t *ipcc_req;
    struct ZbMsgFilterT *filter;
    struct zb_msg_filter_cb_info_t *cb_info;
    unsigned int i;

    for (i = 0; i < ZB_IPC_MSG_FILTER_CB_LIST_MAX; i++) {
 8015900:	2300      	movs	r3, #0
 8015902:	61bb      	str	r3, [r7, #24]
 8015904:	e00e      	b.n	8015924 <ZbMsgFilterRegister+0x34>
        cb_info = &zb_msg_filter_cb_list[i];
 8015906:	69ba      	ldr	r2, [r7, #24]
 8015908:	4613      	mov	r3, r2
 801590a:	005b      	lsls	r3, r3, #1
 801590c:	4413      	add	r3, r2
 801590e:	009b      	lsls	r3, r3, #2
 8015910:	4a28      	ldr	r2, [pc, #160]	; (80159b4 <ZbMsgFilterRegister+0xc4>)
 8015912:	4413      	add	r3, r2
 8015914:	61fb      	str	r3, [r7, #28]
        if (cb_info->filter == NULL) {
 8015916:	69fb      	ldr	r3, [r7, #28]
 8015918:	681b      	ldr	r3, [r3, #0]
 801591a:	2b00      	cmp	r3, #0
 801591c:	d006      	beq.n	801592c <ZbMsgFilterRegister+0x3c>
    for (i = 0; i < ZB_IPC_MSG_FILTER_CB_LIST_MAX; i++) {
 801591e:	69bb      	ldr	r3, [r7, #24]
 8015920:	3301      	adds	r3, #1
 8015922:	61bb      	str	r3, [r7, #24]
 8015924:	69bb      	ldr	r3, [r7, #24]
 8015926:	2b1f      	cmp	r3, #31
 8015928:	d9ed      	bls.n	8015906 <ZbMsgFilterRegister+0x16>
 801592a:	e000      	b.n	801592e <ZbMsgFilterRegister+0x3e>
            break;
 801592c:	bf00      	nop
        }
    }
    if (i == ZB_IPC_MSG_FILTER_CB_LIST_MAX) {
 801592e:	69bb      	ldr	r3, [r7, #24]
 8015930:	2b20      	cmp	r3, #32
 8015932:	d101      	bne.n	8015938 <ZbMsgFilterRegister+0x48>
        return NULL;
 8015934:	2300      	movs	r3, #0
 8015936:	e038      	b.n	80159aa <ZbMsgFilterRegister+0xba>
    }

    Pre_ZigbeeCmdProcessing();
 8015938:	f7f3 f8c6 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 801593c:	f7f3 f856 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015940:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_FILTER_ADD;
 8015942:	697b      	ldr	r3, [r7, #20]
 8015944:	2200      	movs	r2, #0
 8015946:	f042 0210 	orr.w	r2, r2, #16
 801594a:	701a      	strb	r2, [r3, #0]
 801594c:	2200      	movs	r2, #0
 801594e:	705a      	strb	r2, [r3, #1]
 8015950:	2200      	movs	r2, #0
 8015952:	709a      	strb	r2, [r3, #2]
 8015954:	2200      	movs	r2, #0
 8015956:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 3;
 8015958:	697b      	ldr	r3, [r7, #20]
 801595a:	2200      	movs	r2, #0
 801595c:	f042 0203 	orr.w	r2, r2, #3
 8015960:	711a      	strb	r2, [r3, #4]
 8015962:	2200      	movs	r2, #0
 8015964:	715a      	strb	r2, [r3, #5]
 8015966:	2200      	movs	r2, #0
 8015968:	719a      	strb	r2, [r3, #6]
 801596a:	2200      	movs	r2, #0
 801596c:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)mask;
 801596e:	697b      	ldr	r3, [r7, #20]
 8015970:	68ba      	ldr	r2, [r7, #8]
 8015972:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)prio;
 8015974:	79fa      	ldrb	r2, [r7, #7]
 8015976:	697b      	ldr	r3, [r7, #20]
 8015978:	60da      	str	r2, [r3, #12]
    ipcc_req->Data[2] = (uint32_t)cb_info;
 801597a:	69fa      	ldr	r2, [r7, #28]
 801597c:	697b      	ldr	r3, [r7, #20]
 801597e:	611a      	str	r2, [r3, #16]
    ZIGBEE_CmdTransfer();
 8015980:	f7f3 f864 	bl	8008a4c <ZIGBEE_CmdTransfer>
    filter = (struct ZbMsgFilterT *)zb_ipc_m4_get_retval();
 8015984:	f7ff fc6a 	bl	801525c <zb_ipc_m4_get_retval>
 8015988:	4603      	mov	r3, r0
 801598a:	613b      	str	r3, [r7, #16]
    Post_ZigbeeCmdProcessing();
 801598c:	f7fe fa12 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    if (filter != NULL) {
 8015990:	693b      	ldr	r3, [r7, #16]
 8015992:	2b00      	cmp	r3, #0
 8015994:	d008      	beq.n	80159a8 <ZbMsgFilterRegister+0xb8>
        cb_info->filter = filter;
 8015996:	69fb      	ldr	r3, [r7, #28]
 8015998:	693a      	ldr	r2, [r7, #16]
 801599a:	601a      	str	r2, [r3, #0]
        cb_info->callback = callback;
 801599c:	69fb      	ldr	r3, [r7, #28]
 801599e:	683a      	ldr	r2, [r7, #0]
 80159a0:	605a      	str	r2, [r3, #4]
        cb_info->arg = arg;
 80159a2:	69fb      	ldr	r3, [r7, #28]
 80159a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80159a6:	609a      	str	r2, [r3, #8]
    }
    return filter;
 80159a8:	693b      	ldr	r3, [r7, #16]
    /* Followed up by MSG_M0TOM4_FILTER_MSG_CB */
}
 80159aa:	4618      	mov	r0, r3
 80159ac:	3720      	adds	r7, #32
 80159ae:	46bd      	mov	sp, r7
 80159b0:	bd80      	pop	{r7, pc}
 80159b2:	bf00      	nop
 80159b4:	20002524 	.word	0x20002524

080159b8 <ZbMsgFilterRemove>:

void
ZbMsgFilterRemove(struct ZigBeeT *zb, struct ZbMsgFilterT *filter)
{
 80159b8:	b580      	push	{r7, lr}
 80159ba:	b086      	sub	sp, #24
 80159bc:	af00      	add	r7, sp, #0
 80159be:	6078      	str	r0, [r7, #4]
 80159c0:	6039      	str	r1, [r7, #0]
    Zigbee_Cmd_Request_t *ipcc_req;
    struct zb_msg_filter_cb_info_t *cb_info;
    unsigned int i;

    if (filter == NULL) {
 80159c2:	683b      	ldr	r3, [r7, #0]
 80159c4:	2b00      	cmp	r3, #0
 80159c6:	d046      	beq.n	8015a56 <ZbMsgFilterRemove+0x9e>
        return;
    }
    for (i = 0; i < ZB_IPC_MSG_FILTER_CB_LIST_MAX; i++) {
 80159c8:	2300      	movs	r3, #0
 80159ca:	613b      	str	r3, [r7, #16]
 80159cc:	e00f      	b.n	80159ee <ZbMsgFilterRemove+0x36>
        cb_info = &zb_msg_filter_cb_list[i];
 80159ce:	693a      	ldr	r2, [r7, #16]
 80159d0:	4613      	mov	r3, r2
 80159d2:	005b      	lsls	r3, r3, #1
 80159d4:	4413      	add	r3, r2
 80159d6:	009b      	lsls	r3, r3, #2
 80159d8:	4a22      	ldr	r2, [pc, #136]	; (8015a64 <ZbMsgFilterRemove+0xac>)
 80159da:	4413      	add	r3, r2
 80159dc:	617b      	str	r3, [r7, #20]
        if (cb_info->filter == filter) {
 80159de:	697b      	ldr	r3, [r7, #20]
 80159e0:	681b      	ldr	r3, [r3, #0]
 80159e2:	683a      	ldr	r2, [r7, #0]
 80159e4:	429a      	cmp	r2, r3
 80159e6:	d006      	beq.n	80159f6 <ZbMsgFilterRemove+0x3e>
    for (i = 0; i < ZB_IPC_MSG_FILTER_CB_LIST_MAX; i++) {
 80159e8:	693b      	ldr	r3, [r7, #16]
 80159ea:	3301      	adds	r3, #1
 80159ec:	613b      	str	r3, [r7, #16]
 80159ee:	693b      	ldr	r3, [r7, #16]
 80159f0:	2b1f      	cmp	r3, #31
 80159f2:	d9ec      	bls.n	80159ce <ZbMsgFilterRemove+0x16>
 80159f4:	e000      	b.n	80159f8 <ZbMsgFilterRemove+0x40>
            break;
 80159f6:	bf00      	nop
        }
    }
    if (i == ZB_IPC_MSG_FILTER_CB_LIST_MAX) {
 80159f8:	693b      	ldr	r3, [r7, #16]
 80159fa:	2b20      	cmp	r3, #32
 80159fc:	d02d      	beq.n	8015a5a <ZbMsgFilterRemove+0xa2>
        return;
    }

    Pre_ZigbeeCmdProcessing();
 80159fe:	f7f3 f863 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015a02:	f7f2 fff3 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015a06:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_FILTER_DEL;
 8015a08:	68fb      	ldr	r3, [r7, #12]
 8015a0a:	2200      	movs	r2, #0
 8015a0c:	f042 0211 	orr.w	r2, r2, #17
 8015a10:	701a      	strb	r2, [r3, #0]
 8015a12:	2200      	movs	r2, #0
 8015a14:	705a      	strb	r2, [r3, #1]
 8015a16:	2200      	movs	r2, #0
 8015a18:	709a      	strb	r2, [r3, #2]
 8015a1a:	2200      	movs	r2, #0
 8015a1c:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 8015a1e:	68fb      	ldr	r3, [r7, #12]
 8015a20:	2200      	movs	r2, #0
 8015a22:	f042 0201 	orr.w	r2, r2, #1
 8015a26:	711a      	strb	r2, [r3, #4]
 8015a28:	2200      	movs	r2, #0
 8015a2a:	715a      	strb	r2, [r3, #5]
 8015a2c:	2200      	movs	r2, #0
 8015a2e:	719a      	strb	r2, [r3, #6]
 8015a30:	2200      	movs	r2, #0
 8015a32:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)filter;
 8015a34:	683a      	ldr	r2, [r7, #0]
 8015a36:	68fb      	ldr	r3, [r7, #12]
 8015a38:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 8015a3a:	f7f3 f807 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8015a3e:	f7fe f9b9 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    cb_info->filter = NULL;
 8015a42:	697b      	ldr	r3, [r7, #20]
 8015a44:	2200      	movs	r2, #0
 8015a46:	701a      	strb	r2, [r3, #0]
 8015a48:	2200      	movs	r2, #0
 8015a4a:	705a      	strb	r2, [r3, #1]
 8015a4c:	2200      	movs	r2, #0
 8015a4e:	709a      	strb	r2, [r3, #2]
 8015a50:	2200      	movs	r2, #0
 8015a52:	70da      	strb	r2, [r3, #3]
 8015a54:	e002      	b.n	8015a5c <ZbMsgFilterRemove+0xa4>
        return;
 8015a56:	bf00      	nop
 8015a58:	e000      	b.n	8015a5c <ZbMsgFilterRemove+0xa4>
        return;
 8015a5a:	bf00      	nop
}
 8015a5c:	3718      	adds	r7, #24
 8015a5e:	46bd      	mov	sp, r7
 8015a60:	bd80      	pop	{r7, pc}
 8015a62:	bf00      	nop
 8015a64:	20002524 	.word	0x20002524

08015a68 <ZbTimerAlloc>:
    void *m0_timer; /* Handle */
};

struct ZbTimerT *
ZbTimerAlloc(struct ZigBeeT *zb, void (*callback)(struct ZigBeeT *zb, void *cn_arg), void *arg)
{
 8015a68:	b580      	push	{r7, lr}
 8015a6a:	b086      	sub	sp, #24
 8015a6c:	af00      	add	r7, sp, #0
 8015a6e:	60f8      	str	r0, [r7, #12]
 8015a70:	60b9      	str	r1, [r7, #8]
 8015a72:	607a      	str	r2, [r7, #4]
    struct ZbTimerT *timer;

    timer = ZbHeapAlloc(NULL, sizeof(struct ZbTimerT));
 8015a74:	2300      	movs	r3, #0
 8015a76:	4a24      	ldr	r2, [pc, #144]	; (8015b08 <ZbTimerAlloc+0xa0>)
 8015a78:	210c      	movs	r1, #12
 8015a7a:	2000      	movs	r0, #0
 8015a7c:	f000 fbb6 	bl	80161ec <zb_heap_alloc>
 8015a80:	6178      	str	r0, [r7, #20]
    if (timer != NULL) {
 8015a82:	697b      	ldr	r3, [r7, #20]
 8015a84:	2b00      	cmp	r3, #0
 8015a86:	d039      	beq.n	8015afc <ZbTimerAlloc+0x94>
        Zigbee_Cmd_Request_t *ipcc_req;

        /* Configure the callback struct */
        timer->callback = callback;
 8015a88:	697b      	ldr	r3, [r7, #20]
 8015a8a:	68ba      	ldr	r2, [r7, #8]
 8015a8c:	601a      	str	r2, [r3, #0]
        timer->arg = arg;
 8015a8e:	697b      	ldr	r3, [r7, #20]
 8015a90:	687a      	ldr	r2, [r7, #4]
 8015a92:	605a      	str	r2, [r3, #4]

        /* Pass this to the M0 (stack) */
        Pre_ZigbeeCmdProcessing();
 8015a94:	f7f3 f818 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
        ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015a98:	f7f2 ffa8 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015a9c:	6138      	str	r0, [r7, #16]
        ipcc_req->ID = MSG_M4TOM0_TIMER_ALLOC;
 8015a9e:	693b      	ldr	r3, [r7, #16]
 8015aa0:	2200      	movs	r2, #0
 8015aa2:	f042 0214 	orr.w	r2, r2, #20
 8015aa6:	701a      	strb	r2, [r3, #0]
 8015aa8:	2200      	movs	r2, #0
 8015aaa:	705a      	strb	r2, [r3, #1]
 8015aac:	2200      	movs	r2, #0
 8015aae:	709a      	strb	r2, [r3, #2]
 8015ab0:	2200      	movs	r2, #0
 8015ab2:	70da      	strb	r2, [r3, #3]
        ipcc_req->Size = 1;
 8015ab4:	693b      	ldr	r3, [r7, #16]
 8015ab6:	2200      	movs	r2, #0
 8015ab8:	f042 0201 	orr.w	r2, r2, #1
 8015abc:	711a      	strb	r2, [r3, #4]
 8015abe:	2200      	movs	r2, #0
 8015ac0:	715a      	strb	r2, [r3, #5]
 8015ac2:	2200      	movs	r2, #0
 8015ac4:	719a      	strb	r2, [r3, #6]
 8015ac6:	2200      	movs	r2, #0
 8015ac8:	71da      	strb	r2, [r3, #7]
        ipcc_req->Data[0] = (uint32_t)timer;
 8015aca:	697a      	ldr	r2, [r7, #20]
 8015acc:	693b      	ldr	r3, [r7, #16]
 8015ace:	609a      	str	r2, [r3, #8]
        ZIGBEE_CmdTransfer();
 8015ad0:	f7f2 ffbc 	bl	8008a4c <ZIGBEE_CmdTransfer>
        timer->m0_timer = (void *)zb_ipc_m4_get_retval();
 8015ad4:	f7ff fbc2 	bl	801525c <zb_ipc_m4_get_retval>
 8015ad8:	4603      	mov	r3, r0
 8015ada:	461a      	mov	r2, r3
 8015adc:	697b      	ldr	r3, [r7, #20]
 8015ade:	609a      	str	r2, [r3, #8]
        Post_ZigbeeCmdProcessing();
 8015ae0:	f7fe f968 	bl	8013db4 <Post_ZigbeeCmdProcessing>
        if (timer->m0_timer == NULL) {
 8015ae4:	697b      	ldr	r3, [r7, #20]
 8015ae6:	689b      	ldr	r3, [r3, #8]
 8015ae8:	2b00      	cmp	r3, #0
 8015aea:	d107      	bne.n	8015afc <ZbTimerAlloc+0x94>
            ZbHeapFree(NULL, timer);
 8015aec:	2300      	movs	r3, #0
 8015aee:	4a06      	ldr	r2, [pc, #24]	; (8015b08 <ZbTimerAlloc+0xa0>)
 8015af0:	6979      	ldr	r1, [r7, #20]
 8015af2:	2000      	movs	r0, #0
 8015af4:	f000 fb89 	bl	801620a <zb_heap_free>
            timer = NULL;
 8015af8:	2300      	movs	r3, #0
 8015afa:	617b      	str	r3, [r7, #20]
        }
    }
    return timer;
 8015afc:	697b      	ldr	r3, [r7, #20]
}
 8015afe:	4618      	mov	r0, r3
 8015b00:	3718      	adds	r7, #24
 8015b02:	46bd      	mov	sp, r7
 8015b04:	bd80      	pop	{r7, pc}
 8015b06:	bf00      	nop
 8015b08:	080198e8 	.word	0x080198e8

08015b0c <ZbTimerFree>:
    timer->arg = arg;
}

void
ZbTimerFree(struct ZbTimerT *timer)
{
 8015b0c:	b580      	push	{r7, lr}
 8015b0e:	b084      	sub	sp, #16
 8015b10:	af00      	add	r7, sp, #0
 8015b12:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;

    /* Stop and free the timer on the M0 */
    Pre_ZigbeeCmdProcessing();
 8015b14:	f7f2 ffd8 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015b18:	f7f2 ff68 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015b1c:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_TIMER_FREE;
 8015b1e:	68fb      	ldr	r3, [r7, #12]
 8015b20:	2200      	movs	r2, #0
 8015b22:	f042 0215 	orr.w	r2, r2, #21
 8015b26:	701a      	strb	r2, [r3, #0]
 8015b28:	2200      	movs	r2, #0
 8015b2a:	705a      	strb	r2, [r3, #1]
 8015b2c:	2200      	movs	r2, #0
 8015b2e:	709a      	strb	r2, [r3, #2]
 8015b30:	2200      	movs	r2, #0
 8015b32:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 8015b34:	68fb      	ldr	r3, [r7, #12]
 8015b36:	2200      	movs	r2, #0
 8015b38:	f042 0201 	orr.w	r2, r2, #1
 8015b3c:	711a      	strb	r2, [r3, #4]
 8015b3e:	2200      	movs	r2, #0
 8015b40:	715a      	strb	r2, [r3, #5]
 8015b42:	2200      	movs	r2, #0
 8015b44:	719a      	strb	r2, [r3, #6]
 8015b46:	2200      	movs	r2, #0
 8015b48:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)timer->m0_timer;
 8015b4a:	687b      	ldr	r3, [r7, #4]
 8015b4c:	689b      	ldr	r3, [r3, #8]
 8015b4e:	461a      	mov	r2, r3
 8015b50:	68fb      	ldr	r3, [r7, #12]
 8015b52:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 8015b54:	f7f2 ff7a 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8015b58:	f7fe f92c 	bl	8013db4 <Post_ZigbeeCmdProcessing>

    /* Free the timer struct on the M4 */
    ZbHeapFree(NULL, timer);
 8015b5c:	2300      	movs	r3, #0
 8015b5e:	4a04      	ldr	r2, [pc, #16]	; (8015b70 <ZbTimerFree+0x64>)
 8015b60:	6879      	ldr	r1, [r7, #4]
 8015b62:	2000      	movs	r0, #0
 8015b64:	f000 fb51 	bl	801620a <zb_heap_free>
}
 8015b68:	bf00      	nop
 8015b6a:	3710      	adds	r7, #16
 8015b6c:	46bd      	mov	sp, r7
 8015b6e:	bd80      	pop	{r7, pc}
 8015b70:	080198e8 	.word	0x080198e8

08015b74 <ZbTimerReset>:
    Post_ZigbeeCmdProcessing();
}

void
ZbTimerReset(struct ZbTimerT *timer, unsigned int timeout)
{
 8015b74:	b580      	push	{r7, lr}
 8015b76:	b084      	sub	sp, #16
 8015b78:	af00      	add	r7, sp, #0
 8015b7a:	6078      	str	r0, [r7, #4]
 8015b7c:	6039      	str	r1, [r7, #0]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 8015b7e:	f7f2 ffa3 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015b82:	f7f2 ff33 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015b86:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_TIMER_RESET;
 8015b88:	68fb      	ldr	r3, [r7, #12]
 8015b8a:	2200      	movs	r2, #0
 8015b8c:	f042 0217 	orr.w	r2, r2, #23
 8015b90:	701a      	strb	r2, [r3, #0]
 8015b92:	2200      	movs	r2, #0
 8015b94:	705a      	strb	r2, [r3, #1]
 8015b96:	2200      	movs	r2, #0
 8015b98:	709a      	strb	r2, [r3, #2]
 8015b9a:	2200      	movs	r2, #0
 8015b9c:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 8015b9e:	68fb      	ldr	r3, [r7, #12]
 8015ba0:	2200      	movs	r2, #0
 8015ba2:	f042 0202 	orr.w	r2, r2, #2
 8015ba6:	711a      	strb	r2, [r3, #4]
 8015ba8:	2200      	movs	r2, #0
 8015baa:	715a      	strb	r2, [r3, #5]
 8015bac:	2200      	movs	r2, #0
 8015bae:	719a      	strb	r2, [r3, #6]
 8015bb0:	2200      	movs	r2, #0
 8015bb2:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)timer->m0_timer;
 8015bb4:	687b      	ldr	r3, [r7, #4]
 8015bb6:	689b      	ldr	r3, [r3, #8]
 8015bb8:	461a      	mov	r2, r3
 8015bba:	68fb      	ldr	r3, [r7, #12]
 8015bbc:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)timeout;
 8015bbe:	68fb      	ldr	r3, [r7, #12]
 8015bc0:	683a      	ldr	r2, [r7, #0]
 8015bc2:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 8015bc4:	f7f2 ff42 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8015bc8:	f7fe f8f4 	bl	8013db4 <Post_ZigbeeCmdProcessing>
}
 8015bcc:	bf00      	nop
 8015bce:	3710      	adds	r7, #16
 8015bd0:	46bd      	mov	sp, r7
 8015bd2:	bd80      	pop	{r7, pc}

08015bd4 <ZbTimeoutRemaining>:

unsigned int
ZbTimeoutRemaining(ZbUptimeT now, ZbUptimeT expire_time)
{
 8015bd4:	b480      	push	{r7}
 8015bd6:	b085      	sub	sp, #20
 8015bd8:	af00      	add	r7, sp, #0
 8015bda:	6078      	str	r0, [r7, #4]
 8015bdc:	6039      	str	r1, [r7, #0]
    ZbUptimeT u_delta;

    /* Check for 'timeout' rollover condition */
    if ((now >= TIMER_ROLL_OVER_HIGH) && (expire_time <= TIMER_ROLL_OVER_LOW)) {
 8015bde:	687b      	ldr	r3, [r7, #4]
 8015be0:	4a13      	ldr	r2, [pc, #76]	; (8015c30 <ZbTimeoutRemaining+0x5c>)
 8015be2:	4293      	cmp	r3, r2
 8015be4:	d909      	bls.n	8015bfa <ZbTimeoutRemaining+0x26>
 8015be6:	683b      	ldr	r3, [r7, #0]
 8015be8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8015bec:	d805      	bhi.n	8015bfa <ZbTimeoutRemaining+0x26>
        /* Timeout has rolled over, we haven't expired.
         * Compute timeout remaining */
        u_delta = (ZB_UPTIME_MAX - now) + expire_time + 1U;
 8015bee:	683a      	ldr	r2, [r7, #0]
 8015bf0:	687b      	ldr	r3, [r7, #4]
 8015bf2:	1ad3      	subs	r3, r2, r3
 8015bf4:	60fb      	str	r3, [r7, #12]

        return (unsigned int)u_delta;
 8015bf6:	68fb      	ldr	r3, [r7, #12]
 8015bf8:	e014      	b.n	8015c24 <ZbTimeoutRemaining+0x50>
    }

    /* Check for 'now' rollover condition */
    if ((expire_time >= TIMER_ROLL_OVER_HIGH) && (now <= TIMER_ROLL_OVER_LOW)) {
 8015bfa:	683b      	ldr	r3, [r7, #0]
 8015bfc:	4a0c      	ldr	r2, [pc, #48]	; (8015c30 <ZbTimeoutRemaining+0x5c>)
 8015bfe:	4293      	cmp	r3, r2
 8015c00:	d905      	bls.n	8015c0e <ZbTimeoutRemaining+0x3a>
 8015c02:	687b      	ldr	r3, [r7, #4]
 8015c04:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8015c08:	d801      	bhi.n	8015c0e <ZbTimeoutRemaining+0x3a>
        /* 'now' has rolled over, so now is > timeout, meaning we expired. */
        return 0;
 8015c0a:	2300      	movs	r3, #0
 8015c0c:	e00a      	b.n	8015c24 <ZbTimeoutRemaining+0x50>
    }

    /* No rollover, check if timer has expired */
    if (now >= expire_time) {
 8015c0e:	687a      	ldr	r2, [r7, #4]
 8015c10:	683b      	ldr	r3, [r7, #0]
 8015c12:	429a      	cmp	r2, r3
 8015c14:	d301      	bcc.n	8015c1a <ZbTimeoutRemaining+0x46>
        /* Timer has expired */
        return 0;
 8015c16:	2300      	movs	r3, #0
 8015c18:	e004      	b.n	8015c24 <ZbTimeoutRemaining+0x50>
    }

    /* Compute time remaining */
    u_delta = expire_time - now;
 8015c1a:	683a      	ldr	r2, [r7, #0]
 8015c1c:	687b      	ldr	r3, [r7, #4]
 8015c1e:	1ad3      	subs	r3, r2, r3
 8015c20:	60fb      	str	r3, [r7, #12]

    return (unsigned int)u_delta;
 8015c22:	68fb      	ldr	r3, [r7, #12]
}
 8015c24:	4618      	mov	r0, r3
 8015c26:	3714      	adds	r7, #20
 8015c28:	46bd      	mov	sp, r7
 8015c2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c2e:	4770      	bx	lr
 8015c30:	bffffffd 	.word	0xbffffffd

08015c34 <ZbNwkGetIndex>:
 ******************************************************************************
 */
enum ZbStatusCodeT
ZbNwkGetIndex(struct ZigBeeT *zb, enum ZbNwkNibAttrIdT attrId, void *attrPtr,
    unsigned int attrSz, unsigned int attrIndex)
{
 8015c34:	b580      	push	{r7, lr}
 8015c36:	b08c      	sub	sp, #48	; 0x30
 8015c38:	af00      	add	r7, sp, #0
 8015c3a:	60f8      	str	r0, [r7, #12]
 8015c3c:	607a      	str	r2, [r7, #4]
 8015c3e:	603b      	str	r3, [r7, #0]
 8015c40:	460b      	mov	r3, r1
 8015c42:	817b      	strh	r3, [r7, #10]
    struct ZbNlmeGetReqT nlmeGetReq;
    struct ZbNlmeGetConfT nlmeGetConf;
    enum ZbStatusCodeT status;

    /* Form the NLME-GET.request */
    nlmeGetReq.attrId = attrId;
 8015c44:	897b      	ldrh	r3, [r7, #10]
 8015c46:	833b      	strh	r3, [r7, #24]
    nlmeGetReq.attr = attrPtr;
 8015c48:	687b      	ldr	r3, [r7, #4]
 8015c4a:	61fb      	str	r3, [r7, #28]
    nlmeGetReq.attrLength = attrSz;
 8015c4c:	683b      	ldr	r3, [r7, #0]
 8015c4e:	623b      	str	r3, [r7, #32]
    nlmeGetReq.attrIndex = attrIndex;
 8015c50:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015c52:	627b      	str	r3, [r7, #36]	; 0x24

    Pre_ZigbeeCmdProcessing();
 8015c54:	f7f2 ff38 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015c58:	f7f2 fec8 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015c5c:	62f8      	str	r0, [r7, #44]	; 0x2c
    ipcc_req->ID = MSG_M4TOM0_NWK_GET_INDEX;
 8015c5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c60:	2200      	movs	r2, #0
 8015c62:	701a      	strb	r2, [r3, #0]
 8015c64:	2200      	movs	r2, #0
 8015c66:	f042 0203 	orr.w	r2, r2, #3
 8015c6a:	705a      	strb	r2, [r3, #1]
 8015c6c:	2200      	movs	r2, #0
 8015c6e:	709a      	strb	r2, [r3, #2]
 8015c70:	2200      	movs	r2, #0
 8015c72:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 8015c74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c76:	2200      	movs	r2, #0
 8015c78:	f042 0202 	orr.w	r2, r2, #2
 8015c7c:	711a      	strb	r2, [r3, #4]
 8015c7e:	2200      	movs	r2, #0
 8015c80:	715a      	strb	r2, [r3, #5]
 8015c82:	2200      	movs	r2, #0
 8015c84:	719a      	strb	r2, [r3, #6]
 8015c86:	2200      	movs	r2, #0
 8015c88:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)&nlmeGetReq;
 8015c8a:	f107 0218 	add.w	r2, r7, #24
 8015c8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c90:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)&nlmeGetConf;
 8015c92:	f107 0214 	add.w	r2, r7, #20
 8015c96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015c98:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 8015c9a:	f7f2 fed7 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8015c9e:	f7fe f889 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    status = nlmeGetConf.status;
 8015ca2:	7d3b      	ldrb	r3, [r7, #20]
 8015ca4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    return status;
 8015ca8:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
}
 8015cac:	4618      	mov	r0, r3
 8015cae:	3730      	adds	r7, #48	; 0x30
 8015cb0:	46bd      	mov	sp, r7
 8015cb2:	bd80      	pop	{r7, pc}

08015cb4 <ZbNwkGet>:
    return status;
}

enum ZbStatusCodeT
ZbNwkGet(struct ZigBeeT *zb, enum ZbNwkNibAttrIdT attrId, void *attrPtr, unsigned int attrSz)
{
 8015cb4:	b580      	push	{r7, lr}
 8015cb6:	b086      	sub	sp, #24
 8015cb8:	af02      	add	r7, sp, #8
 8015cba:	60f8      	str	r0, [r7, #12]
 8015cbc:	607a      	str	r2, [r7, #4]
 8015cbe:	603b      	str	r3, [r7, #0]
 8015cc0:	460b      	mov	r3, r1
 8015cc2:	817b      	strh	r3, [r7, #10]
    return ZbNwkGetIndex(zb, attrId, attrPtr, attrSz, 0);
 8015cc4:	8979      	ldrh	r1, [r7, #10]
 8015cc6:	2300      	movs	r3, #0
 8015cc8:	9300      	str	r3, [sp, #0]
 8015cca:	683b      	ldr	r3, [r7, #0]
 8015ccc:	687a      	ldr	r2, [r7, #4]
 8015cce:	68f8      	ldr	r0, [r7, #12]
 8015cd0:	f7ff ffb0 	bl	8015c34 <ZbNwkGetIndex>
 8015cd4:	4603      	mov	r3, r0
}
 8015cd6:	4618      	mov	r0, r3
 8015cd8:	3710      	adds	r7, #16
 8015cda:	46bd      	mov	sp, r7
 8015cdc:	bd80      	pop	{r7, pc}

08015cde <ZbZclUptime>:
 ******************************************************************************
 */

ZbUptimeT
ZbZclUptime(struct ZigBeeT *zb)
{
 8015cde:	b580      	push	{r7, lr}
 8015ce0:	b086      	sub	sp, #24
 8015ce2:	af02      	add	r7, sp, #8
 8015ce4:	6078      	str	r0, [r7, #4]
    uint32_t uptime;

    ZbBdbGet(zb, ZB_BDB_Uptime, &uptime, sizeof(uptime));
 8015ce6:	f107 020c 	add.w	r2, r7, #12
 8015cea:	2300      	movs	r3, #0
 8015cec:	9300      	str	r3, [sp, #0]
 8015cee:	2304      	movs	r3, #4
 8015cf0:	f241 111d 	movw	r1, #4381	; 0x111d
 8015cf4:	6878      	ldr	r0, [r7, #4]
 8015cf6:	f7ff fc3f 	bl	8015578 <ZbBdbGetIndex>
    return (ZbUptimeT)uptime;
 8015cfa:	68fb      	ldr	r3, [r7, #12]
}
 8015cfc:	4618      	mov	r0, r3
 8015cfe:	3710      	adds	r7, #16
 8015d00:	46bd      	mov	sp, r7
 8015d02:	bd80      	pop	{r7, pc}

08015d04 <ZbZclDeviceLogCheckAllow>:

bool
ZbZclDeviceLogCheckAllow(struct ZigBeeT *zb, struct ZbApsdeDataIndT *dataIndPtr, struct ZbZclHeaderT *zclHdrPtr)
{
 8015d04:	b580      	push	{r7, lr}
 8015d06:	b086      	sub	sp, #24
 8015d08:	af00      	add	r7, sp, #0
 8015d0a:	60f8      	str	r0, [r7, #12]
 8015d0c:	60b9      	str	r1, [r7, #8]
 8015d0e:	607a      	str	r2, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;
    bool rc;

    Pre_ZigbeeCmdProcessing();
 8015d10:	f7f2 feda 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015d14:	f7f2 fe6a 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015d18:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_ZCL_DEVICE_LOG_CHECK;
 8015d1a:	697b      	ldr	r3, [r7, #20]
 8015d1c:	2200      	movs	r2, #0
 8015d1e:	f042 021d 	orr.w	r2, r2, #29
 8015d22:	701a      	strb	r2, [r3, #0]
 8015d24:	2200      	movs	r2, #0
 8015d26:	f042 0204 	orr.w	r2, r2, #4
 8015d2a:	705a      	strb	r2, [r3, #1]
 8015d2c:	2200      	movs	r2, #0
 8015d2e:	709a      	strb	r2, [r3, #2]
 8015d30:	2200      	movs	r2, #0
 8015d32:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 8015d34:	697b      	ldr	r3, [r7, #20]
 8015d36:	2200      	movs	r2, #0
 8015d38:	f042 0202 	orr.w	r2, r2, #2
 8015d3c:	711a      	strb	r2, [r3, #4]
 8015d3e:	2200      	movs	r2, #0
 8015d40:	715a      	strb	r2, [r3, #5]
 8015d42:	2200      	movs	r2, #0
 8015d44:	719a      	strb	r2, [r3, #6]
 8015d46:	2200      	movs	r2, #0
 8015d48:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)dataIndPtr;
 8015d4a:	68ba      	ldr	r2, [r7, #8]
 8015d4c:	697b      	ldr	r3, [r7, #20]
 8015d4e:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)zclHdrPtr;
 8015d50:	687a      	ldr	r2, [r7, #4]
 8015d52:	697b      	ldr	r3, [r7, #20]
 8015d54:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 8015d56:	f7f2 fe79 	bl	8008a4c <ZIGBEE_CmdTransfer>
    rc = zb_ipc_m4_get_retval() != 0U ? true : false;
 8015d5a:	f7ff fa7f 	bl	801525c <zb_ipc_m4_get_retval>
 8015d5e:	4603      	mov	r3, r0
 8015d60:	2b00      	cmp	r3, #0
 8015d62:	bf14      	ite	ne
 8015d64:	2301      	movne	r3, #1
 8015d66:	2300      	moveq	r3, #0
 8015d68:	74fb      	strb	r3, [r7, #19]
    Post_ZigbeeCmdProcessing();
 8015d6a:	f7fe f823 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return rc;
 8015d6e:	7cfb      	ldrb	r3, [r7, #19]
}
 8015d70:	4618      	mov	r0, r3
 8015d72:	3718      	adds	r7, #24
 8015d74:	46bd      	mov	sp, r7
 8015d76:	bd80      	pop	{r7, pc}

08015d78 <ZbZclAddEndpoint>:
    return rc;
}

void
ZbZclAddEndpoint(struct ZigBeeT *zb, struct ZbApsmeAddEndpointReqT *req, struct ZbApsmeAddEndpointConfT *conf)
{
 8015d78:	b580      	push	{r7, lr}
 8015d7a:	b086      	sub	sp, #24
 8015d7c:	af00      	add	r7, sp, #0
 8015d7e:	60f8      	str	r0, [r7, #12]
 8015d80:	60b9      	str	r1, [r7, #8]
 8015d82:	607a      	str	r2, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 8015d84:	f7f2 fea0 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015d88:	f7f2 fe30 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015d8c:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_ZCL_ENDPOINT_ADD;
 8015d8e:	697b      	ldr	r3, [r7, #20]
 8015d90:	2200      	movs	r2, #0
 8015d92:	701a      	strb	r2, [r3, #0]
 8015d94:	2200      	movs	r2, #0
 8015d96:	f042 0204 	orr.w	r2, r2, #4
 8015d9a:	705a      	strb	r2, [r3, #1]
 8015d9c:	2200      	movs	r2, #0
 8015d9e:	709a      	strb	r2, [r3, #2]
 8015da0:	2200      	movs	r2, #0
 8015da2:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 8015da4:	697b      	ldr	r3, [r7, #20]
 8015da6:	2200      	movs	r2, #0
 8015da8:	f042 0202 	orr.w	r2, r2, #2
 8015dac:	711a      	strb	r2, [r3, #4]
 8015dae:	2200      	movs	r2, #0
 8015db0:	715a      	strb	r2, [r3, #5]
 8015db2:	2200      	movs	r2, #0
 8015db4:	719a      	strb	r2, [r3, #6]
 8015db6:	2200      	movs	r2, #0
 8015db8:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)req;
 8015dba:	68ba      	ldr	r2, [r7, #8]
 8015dbc:	697b      	ldr	r3, [r7, #20]
 8015dbe:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)conf;
 8015dc0:	687a      	ldr	r2, [r7, #4]
 8015dc2:	697b      	ldr	r3, [r7, #20]
 8015dc4:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 8015dc6:	f7f2 fe41 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8015dca:	f7fd fff3 	bl	8013db4 <Post_ZigbeeCmdProcessing>
}
 8015dce:	bf00      	nop
 8015dd0:	3718      	adds	r7, #24
 8015dd2:	46bd      	mov	sp, r7
 8015dd4:	bd80      	pop	{r7, pc}

08015dd6 <ZbZclReadReq>:
    ipcc_req->Data[1] = (uint32_t)conf;
    ZIGBEE_CmdTransfer();
    Post_ZigbeeCmdProcessing();
}

IPC_CLUSTER_REQ_CALLBACK_FUNC(ZbZclReadReq, MSG_M4TOM0_ZCL_READ_REQ, ZbZclReadReqT, ZbZclReadRspT);
 8015dd6:	b580      	push	{r7, lr}
 8015dd8:	b088      	sub	sp, #32
 8015dda:	af00      	add	r7, sp, #0
 8015ddc:	60f8      	str	r0, [r7, #12]
 8015dde:	60b9      	str	r1, [r7, #8]
 8015de0:	607a      	str	r2, [r7, #4]
 8015de2:	603b      	str	r3, [r7, #0]
 8015de4:	6839      	ldr	r1, [r7, #0]
 8015de6:	6878      	ldr	r0, [r7, #4]
 8015de8:	f7ff fa10 	bl	801520c <zb_ipc_m4_cb_info_alloc>
 8015dec:	61f8      	str	r0, [r7, #28]
 8015dee:	69fb      	ldr	r3, [r7, #28]
 8015df0:	2b00      	cmp	r3, #0
 8015df2:	d101      	bne.n	8015df8 <ZbZclReadReq+0x22>
 8015df4:	2389      	movs	r3, #137	; 0x89
 8015df6:	e034      	b.n	8015e62 <ZbZclReadReq+0x8c>
 8015df8:	f7f2 fe66 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
 8015dfc:	f7f2 fdf6 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015e00:	61b8      	str	r0, [r7, #24]
 8015e02:	69bb      	ldr	r3, [r7, #24]
 8015e04:	2200      	movs	r2, #0
 8015e06:	f042 0215 	orr.w	r2, r2, #21
 8015e0a:	701a      	strb	r2, [r3, #0]
 8015e0c:	2200      	movs	r2, #0
 8015e0e:	f042 0204 	orr.w	r2, r2, #4
 8015e12:	705a      	strb	r2, [r3, #1]
 8015e14:	2200      	movs	r2, #0
 8015e16:	709a      	strb	r2, [r3, #2]
 8015e18:	2200      	movs	r2, #0
 8015e1a:	70da      	strb	r2, [r3, #3]
 8015e1c:	69bb      	ldr	r3, [r7, #24]
 8015e1e:	2200      	movs	r2, #0
 8015e20:	f042 0203 	orr.w	r2, r2, #3
 8015e24:	711a      	strb	r2, [r3, #4]
 8015e26:	2200      	movs	r2, #0
 8015e28:	715a      	strb	r2, [r3, #5]
 8015e2a:	2200      	movs	r2, #0
 8015e2c:	719a      	strb	r2, [r3, #6]
 8015e2e:	2200      	movs	r2, #0
 8015e30:	71da      	strb	r2, [r3, #7]
 8015e32:	68fa      	ldr	r2, [r7, #12]
 8015e34:	69bb      	ldr	r3, [r7, #24]
 8015e36:	609a      	str	r2, [r3, #8]
 8015e38:	68ba      	ldr	r2, [r7, #8]
 8015e3a:	69bb      	ldr	r3, [r7, #24]
 8015e3c:	60da      	str	r2, [r3, #12]
 8015e3e:	69fa      	ldr	r2, [r7, #28]
 8015e40:	69bb      	ldr	r3, [r7, #24]
 8015e42:	611a      	str	r2, [r3, #16]
 8015e44:	f7f2 fe02 	bl	8008a4c <ZIGBEE_CmdTransfer>
 8015e48:	f7ff fa08 	bl	801525c <zb_ipc_m4_get_retval>
 8015e4c:	4603      	mov	r3, r0
 8015e4e:	75fb      	strb	r3, [r7, #23]
 8015e50:	f7fd ffb0 	bl	8013db4 <Post_ZigbeeCmdProcessing>
 8015e54:	7dfb      	ldrb	r3, [r7, #23]
 8015e56:	2b00      	cmp	r3, #0
 8015e58:	d002      	beq.n	8015e60 <ZbZclReadReq+0x8a>
 8015e5a:	69f8      	ldr	r0, [r7, #28]
 8015e5c:	f7ff f9f3 	bl	8015246 <zb_ipc_m4_cb_info_free>
 8015e60:	7dfb      	ldrb	r3, [r7, #23]
 8015e62:	4618      	mov	r0, r3
 8015e64:	3720      	adds	r7, #32
 8015e66:	46bd      	mov	sp, r7
 8015e68:	bd80      	pop	{r7, pc}

08015e6a <ZbZclGetNextSeqnum>:
    ZbZclDiscoverAttrReqT, ZbZclDiscoverAttrRspT);
/* Followed up in MSG_M0TOM4_ZCL_DISCOVER_ATTR_CB handler */

uint8_t
ZbZclGetNextSeqnum(void)
{
 8015e6a:	b580      	push	{r7, lr}
 8015e6c:	b082      	sub	sp, #8
 8015e6e:	af00      	add	r7, sp, #0
    Zigbee_Cmd_Request_t *ipcc_req;
    uint8_t rc;

    Pre_ZigbeeCmdProcessing();
 8015e70:	f7f2 fe2a 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015e74:	f7f2 fdba 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015e78:	6078      	str	r0, [r7, #4]
    ipcc_req->ID = MSG_M4TOM0_ZCL_GET_SEQNUM;
 8015e7a:	687b      	ldr	r3, [r7, #4]
 8015e7c:	2200      	movs	r2, #0
 8015e7e:	f042 0211 	orr.w	r2, r2, #17
 8015e82:	701a      	strb	r2, [r3, #0]
 8015e84:	2200      	movs	r2, #0
 8015e86:	f042 0204 	orr.w	r2, r2, #4
 8015e8a:	705a      	strb	r2, [r3, #1]
 8015e8c:	2200      	movs	r2, #0
 8015e8e:	709a      	strb	r2, [r3, #2]
 8015e90:	2200      	movs	r2, #0
 8015e92:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 0;
 8015e94:	687b      	ldr	r3, [r7, #4]
 8015e96:	2200      	movs	r2, #0
 8015e98:	711a      	strb	r2, [r3, #4]
 8015e9a:	2200      	movs	r2, #0
 8015e9c:	715a      	strb	r2, [r3, #5]
 8015e9e:	2200      	movs	r2, #0
 8015ea0:	719a      	strb	r2, [r3, #6]
 8015ea2:	2200      	movs	r2, #0
 8015ea4:	71da      	strb	r2, [r3, #7]
    ZIGBEE_CmdTransfer();
 8015ea6:	f7f2 fdd1 	bl	8008a4c <ZIGBEE_CmdTransfer>
    rc = (uint8_t)zb_ipc_m4_get_retval();
 8015eaa:	f7ff f9d7 	bl	801525c <zb_ipc_m4_get_retval>
 8015eae:	4603      	mov	r3, r0
 8015eb0:	70fb      	strb	r3, [r7, #3]
    Post_ZigbeeCmdProcessing();
 8015eb2:	f7fd ff7f 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return rc;
 8015eb6:	78fb      	ldrb	r3, [r7, #3]
}
 8015eb8:	4618      	mov	r0, r3
 8015eba:	3708      	adds	r7, #8
 8015ebc:	46bd      	mov	sp, r7
 8015ebe:	bd80      	pop	{r7, pc}

08015ec0 <ZbZclCommandReq>:

enum ZclStatusCodeT
ZbZclCommandReq(struct ZigBeeT *zb, struct ZbZclCommandReqT *zclReq,
    void (*callback)(struct ZbZclCommandRspT *rsp, void *arg), void *arg)
{
 8015ec0:	b580      	push	{r7, lr}
 8015ec2:	b088      	sub	sp, #32
 8015ec4:	af00      	add	r7, sp, #0
 8015ec6:	60f8      	str	r0, [r7, #12]
 8015ec8:	60b9      	str	r1, [r7, #8]
 8015eca:	607a      	str	r2, [r7, #4]
 8015ecc:	603b      	str	r3, [r7, #0]
    Zigbee_Cmd_Request_t *ipcc_req;
    struct zb_ipc_m4_cb_info_t *info = NULL;
 8015ece:	2300      	movs	r3, #0
 8015ed0:	61fb      	str	r3, [r7, #28]
    enum ZclStatusCodeT status;

    if (callback != NULL) {
 8015ed2:	687b      	ldr	r3, [r7, #4]
 8015ed4:	2b00      	cmp	r3, #0
 8015ed6:	d013      	beq.n	8015f00 <ZbZclCommandReq+0x40>
        info = zb_ipc_m4_cb_info_alloc((void *)callback, arg);
 8015ed8:	6839      	ldr	r1, [r7, #0]
 8015eda:	6878      	ldr	r0, [r7, #4]
 8015edc:	f7ff f996 	bl	801520c <zb_ipc_m4_cb_info_alloc>
 8015ee0:	61f8      	str	r0, [r7, #28]
        if (info == NULL) {
 8015ee2:	69fb      	ldr	r3, [r7, #28]
 8015ee4:	2b00      	cmp	r3, #0
 8015ee6:	d101      	bne.n	8015eec <ZbZclCommandReq+0x2c>
            return ZCL_STATUS_INSUFFICIENT_SPACE;
 8015ee8:	2389      	movs	r3, #137	; 0x89
 8015eea:	e03e      	b.n	8015f6a <ZbZclCommandReq+0xaa>
        }
        if (ZbApsAddrIsBcast(&zclReq->dst)) {
 8015eec:	68bb      	ldr	r3, [r7, #8]
 8015eee:	4618      	mov	r0, r3
 8015ef0:	f7ff fbfc 	bl	80156ec <ZbApsAddrIsBcast>
 8015ef4:	4603      	mov	r3, r0
 8015ef6:	2b00      	cmp	r3, #0
 8015ef8:	d002      	beq.n	8015f00 <ZbZclCommandReq+0x40>
            info->zcl_recv_multi_rsp = true; /* callback only freed on ZCL_STATUS_TIMEOUT */
 8015efa:	69fb      	ldr	r3, [r7, #28]
 8015efc:	2201      	movs	r2, #1
 8015efe:	721a      	strb	r2, [r3, #8]
        }
    }
    Pre_ZigbeeCmdProcessing();
 8015f00:	f7f2 fde2 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015f04:	f7f2 fd72 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015f08:	61b8      	str	r0, [r7, #24]
    ipcc_req->ID = MSG_M4TOM0_ZCL_COMMAND_REQ;
 8015f0a:	69bb      	ldr	r3, [r7, #24]
 8015f0c:	2200      	movs	r2, #0
 8015f0e:	f042 0212 	orr.w	r2, r2, #18
 8015f12:	701a      	strb	r2, [r3, #0]
 8015f14:	2200      	movs	r2, #0
 8015f16:	f042 0204 	orr.w	r2, r2, #4
 8015f1a:	705a      	strb	r2, [r3, #1]
 8015f1c:	2200      	movs	r2, #0
 8015f1e:	709a      	strb	r2, [r3, #2]
 8015f20:	2200      	movs	r2, #0
 8015f22:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 2;
 8015f24:	69bb      	ldr	r3, [r7, #24]
 8015f26:	2200      	movs	r2, #0
 8015f28:	f042 0202 	orr.w	r2, r2, #2
 8015f2c:	711a      	strb	r2, [r3, #4]
 8015f2e:	2200      	movs	r2, #0
 8015f30:	715a      	strb	r2, [r3, #5]
 8015f32:	2200      	movs	r2, #0
 8015f34:	719a      	strb	r2, [r3, #6]
 8015f36:	2200      	movs	r2, #0
 8015f38:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)zclReq;
 8015f3a:	68ba      	ldr	r2, [r7, #8]
 8015f3c:	69bb      	ldr	r3, [r7, #24]
 8015f3e:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)info;
 8015f40:	69fa      	ldr	r2, [r7, #28]
 8015f42:	69bb      	ldr	r3, [r7, #24]
 8015f44:	60da      	str	r2, [r3, #12]
    ZIGBEE_CmdTransfer();
 8015f46:	f7f2 fd81 	bl	8008a4c <ZIGBEE_CmdTransfer>
    status = (enum ZclStatusCodeT)zb_ipc_m4_get_retval();
 8015f4a:	f7ff f987 	bl	801525c <zb_ipc_m4_get_retval>
 8015f4e:	4603      	mov	r3, r0
 8015f50:	75fb      	strb	r3, [r7, #23]
    Post_ZigbeeCmdProcessing();
 8015f52:	f7fd ff2f 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    if (status != ZCL_STATUS_SUCCESS) {
 8015f56:	7dfb      	ldrb	r3, [r7, #23]
 8015f58:	2b00      	cmp	r3, #0
 8015f5a:	d005      	beq.n	8015f68 <ZbZclCommandReq+0xa8>
        if (info != NULL) {
 8015f5c:	69fb      	ldr	r3, [r7, #28]
 8015f5e:	2b00      	cmp	r3, #0
 8015f60:	d002      	beq.n	8015f68 <ZbZclCommandReq+0xa8>
            zb_ipc_m4_cb_info_free(info);
 8015f62:	69f8      	ldr	r0, [r7, #28]
 8015f64:	f7ff f96f 	bl	8015246 <zb_ipc_m4_cb_info_free>
        }
    }
    return status;
 8015f68:	7dfb      	ldrb	r3, [r7, #23]
    /* Followed up in MSG_M0TOM4_ZCL_COMMAND_REQ_CB handler if callback != NULL */
}
 8015f6a:	4618      	mov	r0, r3
 8015f6c:	3720      	adds	r7, #32
 8015f6e:	46bd      	mov	sp, r7
 8015f70:	bd80      	pop	{r7, pc}

08015f72 <ZbZclSendDefaultResponse>:

void
ZbZclSendDefaultResponse(struct ZbZclClusterT *clusterPtr, struct ZbApsdeDataIndT *dataIndPtr,
    struct ZbZclHeaderT *zclHdrPtr, enum ZclStatusCodeT status)
{
 8015f72:	b580      	push	{r7, lr}
 8015f74:	b086      	sub	sp, #24
 8015f76:	af00      	add	r7, sp, #0
 8015f78:	60f8      	str	r0, [r7, #12]
 8015f7a:	60b9      	str	r1, [r7, #8]
 8015f7c:	607a      	str	r2, [r7, #4]
 8015f7e:	70fb      	strb	r3, [r7, #3]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 8015f80:	f7f2 fda2 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015f84:	f7f2 fd32 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015f88:	6178      	str	r0, [r7, #20]
    ipcc_req->ID = MSG_M4TOM0_ZCL_SEND_DEFAULT_RSP;
 8015f8a:	697b      	ldr	r3, [r7, #20]
 8015f8c:	2200      	movs	r2, #0
 8015f8e:	f042 0214 	orr.w	r2, r2, #20
 8015f92:	701a      	strb	r2, [r3, #0]
 8015f94:	2200      	movs	r2, #0
 8015f96:	f042 0204 	orr.w	r2, r2, #4
 8015f9a:	705a      	strb	r2, [r3, #1]
 8015f9c:	2200      	movs	r2, #0
 8015f9e:	709a      	strb	r2, [r3, #2]
 8015fa0:	2200      	movs	r2, #0
 8015fa2:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 4;
 8015fa4:	697b      	ldr	r3, [r7, #20]
 8015fa6:	2200      	movs	r2, #0
 8015fa8:	f042 0204 	orr.w	r2, r2, #4
 8015fac:	711a      	strb	r2, [r3, #4]
 8015fae:	2200      	movs	r2, #0
 8015fb0:	715a      	strb	r2, [r3, #5]
 8015fb2:	2200      	movs	r2, #0
 8015fb4:	719a      	strb	r2, [r3, #6]
 8015fb6:	2200      	movs	r2, #0
 8015fb8:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)clusterPtr;
 8015fba:	68fa      	ldr	r2, [r7, #12]
 8015fbc:	697b      	ldr	r3, [r7, #20]
 8015fbe:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)dataIndPtr;
 8015fc0:	68ba      	ldr	r2, [r7, #8]
 8015fc2:	697b      	ldr	r3, [r7, #20]
 8015fc4:	60da      	str	r2, [r3, #12]
    ipcc_req->Data[2] = (uint32_t)zclHdrPtr;
 8015fc6:	687a      	ldr	r2, [r7, #4]
 8015fc8:	697b      	ldr	r3, [r7, #20]
 8015fca:	611a      	str	r2, [r3, #16]
    ipcc_req->Data[3] = (uint32_t)status;
 8015fcc:	78fa      	ldrb	r2, [r7, #3]
 8015fce:	697b      	ldr	r3, [r7, #20]
 8015fd0:	615a      	str	r2, [r3, #20]
    ZIGBEE_CmdTransfer();
 8015fd2:	f7f2 fd3b 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8015fd6:	f7fd feed 	bl	8013db4 <Post_ZigbeeCmdProcessing>
}
 8015fda:	bf00      	nop
 8015fdc:	3718      	adds	r7, #24
 8015fde:	46bd      	mov	sp, r7
 8015fe0:	bd80      	pop	{r7, pc}

08015fe2 <ZbZclClusterEndpointRegister>:
    return status;
}

bool
ZbZclClusterEndpointRegister(struct ZbZclClusterT *clusterPtr)
{
 8015fe2:	b580      	push	{r7, lr}
 8015fe4:	b084      	sub	sp, #16
 8015fe6:	af00      	add	r7, sp, #0
 8015fe8:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;
    bool rc;

    Pre_ZigbeeCmdProcessing();
 8015fea:	f7f2 fd6d 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8015fee:	f7f2 fcfd 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 8015ff2:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_ZCL_CLUSTER_EP_REGISTER;
 8015ff4:	68fb      	ldr	r3, [r7, #12]
 8015ff6:	2200      	movs	r2, #0
 8015ff8:	f042 0202 	orr.w	r2, r2, #2
 8015ffc:	701a      	strb	r2, [r3, #0]
 8015ffe:	2200      	movs	r2, #0
 8016000:	f042 0204 	orr.w	r2, r2, #4
 8016004:	705a      	strb	r2, [r3, #1]
 8016006:	2200      	movs	r2, #0
 8016008:	709a      	strb	r2, [r3, #2]
 801600a:	2200      	movs	r2, #0
 801600c:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 801600e:	68fb      	ldr	r3, [r7, #12]
 8016010:	2200      	movs	r2, #0
 8016012:	f042 0201 	orr.w	r2, r2, #1
 8016016:	711a      	strb	r2, [r3, #4]
 8016018:	2200      	movs	r2, #0
 801601a:	715a      	strb	r2, [r3, #5]
 801601c:	2200      	movs	r2, #0
 801601e:	719a      	strb	r2, [r3, #6]
 8016020:	2200      	movs	r2, #0
 8016022:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)clusterPtr;
 8016024:	687a      	ldr	r2, [r7, #4]
 8016026:	68fb      	ldr	r3, [r7, #12]
 8016028:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 801602a:	f7f2 fd0f 	bl	8008a4c <ZIGBEE_CmdTransfer>
    rc = zb_ipc_m4_get_retval() != 0U ? true : false;
 801602e:	f7ff f915 	bl	801525c <zb_ipc_m4_get_retval>
 8016032:	4603      	mov	r3, r0
 8016034:	2b00      	cmp	r3, #0
 8016036:	bf14      	ite	ne
 8016038:	2301      	movne	r3, #1
 801603a:	2300      	moveq	r3, #0
 801603c:	72fb      	strb	r3, [r7, #11]
    Post_ZigbeeCmdProcessing();
 801603e:	f7fd feb9 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return rc;
 8016042:	7afb      	ldrb	r3, [r7, #11]
}
 8016044:	4618      	mov	r0, r3
 8016046:	3710      	adds	r7, #16
 8016048:	46bd      	mov	sp, r7
 801604a:	bd80      	pop	{r7, pc}

0801604c <ZbZclClusterEndpointRemove>:

bool
ZbZclClusterEndpointRemove(struct ZbZclClusterT *clusterPtr)
{
 801604c:	b580      	push	{r7, lr}
 801604e:	b084      	sub	sp, #16
 8016050:	af00      	add	r7, sp, #0
 8016052:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;
    bool rc;

    Pre_ZigbeeCmdProcessing();
 8016054:	f7f2 fd38 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8016058:	f7f2 fcc8 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 801605c:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_ZCL_CLUSTER_EP_REMOVE;
 801605e:	68fb      	ldr	r3, [r7, #12]
 8016060:	2200      	movs	r2, #0
 8016062:	f042 0203 	orr.w	r2, r2, #3
 8016066:	701a      	strb	r2, [r3, #0]
 8016068:	2200      	movs	r2, #0
 801606a:	f042 0204 	orr.w	r2, r2, #4
 801606e:	705a      	strb	r2, [r3, #1]
 8016070:	2200      	movs	r2, #0
 8016072:	709a      	strb	r2, [r3, #2]
 8016074:	2200      	movs	r2, #0
 8016076:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 8016078:	68fb      	ldr	r3, [r7, #12]
 801607a:	2200      	movs	r2, #0
 801607c:	f042 0201 	orr.w	r2, r2, #1
 8016080:	711a      	strb	r2, [r3, #4]
 8016082:	2200      	movs	r2, #0
 8016084:	715a      	strb	r2, [r3, #5]
 8016086:	2200      	movs	r2, #0
 8016088:	719a      	strb	r2, [r3, #6]
 801608a:	2200      	movs	r2, #0
 801608c:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)clusterPtr;
 801608e:	687a      	ldr	r2, [r7, #4]
 8016090:	68fb      	ldr	r3, [r7, #12]
 8016092:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 8016094:	f7f2 fcda 	bl	8008a4c <ZIGBEE_CmdTransfer>
    rc = zb_ipc_m4_get_retval() != 0U ? true : false;
 8016098:	f7ff f8e0 	bl	801525c <zb_ipc_m4_get_retval>
 801609c:	4603      	mov	r3, r0
 801609e:	2b00      	cmp	r3, #0
 80160a0:	bf14      	ite	ne
 80160a2:	2301      	movne	r3, #1
 80160a4:	2300      	moveq	r3, #0
 80160a6:	72fb      	strb	r3, [r7, #11]
    Post_ZigbeeCmdProcessing();
 80160a8:	f7fd fe84 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return rc;
 80160ac:	7afb      	ldrb	r3, [r7, #11]
}
 80160ae:	4618      	mov	r0, r3
 80160b0:	3710      	adds	r7, #16
 80160b2:	46bd      	mov	sp, r7
 80160b4:	bd80      	pop	{r7, pc}

080160b6 <ZbZclClusterBind>:

enum ZclStatusCodeT
ZbZclClusterBind(struct ZbZclClusterT *clusterPtr, uint8_t endpoint, uint16_t profileId, enum ZbZclDirectionT direction)
{
 80160b6:	b580      	push	{r7, lr}
 80160b8:	b084      	sub	sp, #16
 80160ba:	af00      	add	r7, sp, #0
 80160bc:	6078      	str	r0, [r7, #4]
 80160be:	4608      	mov	r0, r1
 80160c0:	4611      	mov	r1, r2
 80160c2:	461a      	mov	r2, r3
 80160c4:	4603      	mov	r3, r0
 80160c6:	70fb      	strb	r3, [r7, #3]
 80160c8:	460b      	mov	r3, r1
 80160ca:	803b      	strh	r3, [r7, #0]
 80160cc:	4613      	mov	r3, r2
 80160ce:	70bb      	strb	r3, [r7, #2]
    Zigbee_Cmd_Request_t *ipcc_req;
    enum ZclStatusCodeT status;

    Pre_ZigbeeCmdProcessing();
 80160d0:	f7f2 fcfa 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 80160d4:	f7f2 fc8a 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 80160d8:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_ZCL_CLUSTER_BIND;
 80160da:	68fb      	ldr	r3, [r7, #12]
 80160dc:	2200      	movs	r2, #0
 80160de:	f042 0204 	orr.w	r2, r2, #4
 80160e2:	701a      	strb	r2, [r3, #0]
 80160e4:	2200      	movs	r2, #0
 80160e6:	f042 0204 	orr.w	r2, r2, #4
 80160ea:	705a      	strb	r2, [r3, #1]
 80160ec:	2200      	movs	r2, #0
 80160ee:	709a      	strb	r2, [r3, #2]
 80160f0:	2200      	movs	r2, #0
 80160f2:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 4;
 80160f4:	68fb      	ldr	r3, [r7, #12]
 80160f6:	2200      	movs	r2, #0
 80160f8:	f042 0204 	orr.w	r2, r2, #4
 80160fc:	711a      	strb	r2, [r3, #4]
 80160fe:	2200      	movs	r2, #0
 8016100:	715a      	strb	r2, [r3, #5]
 8016102:	2200      	movs	r2, #0
 8016104:	719a      	strb	r2, [r3, #6]
 8016106:	2200      	movs	r2, #0
 8016108:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)clusterPtr;
 801610a:	687a      	ldr	r2, [r7, #4]
 801610c:	68fb      	ldr	r3, [r7, #12]
 801610e:	609a      	str	r2, [r3, #8]
    ipcc_req->Data[1] = (uint32_t)endpoint;
 8016110:	78fa      	ldrb	r2, [r7, #3]
 8016112:	68fb      	ldr	r3, [r7, #12]
 8016114:	60da      	str	r2, [r3, #12]
    ipcc_req->Data[2] = (uint32_t)profileId;
 8016116:	883a      	ldrh	r2, [r7, #0]
 8016118:	68fb      	ldr	r3, [r7, #12]
 801611a:	611a      	str	r2, [r3, #16]
    ipcc_req->Data[3] = (uint32_t)direction;
 801611c:	78ba      	ldrb	r2, [r7, #2]
 801611e:	68fb      	ldr	r3, [r7, #12]
 8016120:	615a      	str	r2, [r3, #20]
    ZIGBEE_CmdTransfer();
 8016122:	f7f2 fc93 	bl	8008a4c <ZIGBEE_CmdTransfer>
    status = (enum ZclStatusCodeT)zb_ipc_m4_get_retval();
 8016126:	f7ff f899 	bl	801525c <zb_ipc_m4_get_retval>
 801612a:	4603      	mov	r3, r0
 801612c:	72fb      	strb	r3, [r7, #11]
    Post_ZigbeeCmdProcessing();
 801612e:	f7fd fe41 	bl	8013db4 <Post_ZigbeeCmdProcessing>
    return status;
 8016132:	7afb      	ldrb	r3, [r7, #11]

    /* Data indication callbacks go to MSG_M0TOM4_ZCL_CLUSTER_DATA_IND */
}
 8016134:	4618      	mov	r0, r3
 8016136:	3710      	adds	r7, #16
 8016138:	46bd      	mov	sp, r7
 801613a:	bd80      	pop	{r7, pc}

0801613c <ZbZclClusterUnbind>:

void
ZbZclClusterUnbind(struct ZbZclClusterT *clusterPtr)
{
 801613c:	b580      	push	{r7, lr}
 801613e:	b084      	sub	sp, #16
 8016140:	af00      	add	r7, sp, #0
 8016142:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 8016144:	f7f2 fcc0 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 8016148:	f7f2 fc50 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 801614c:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_ZCL_CLUSTER_UNBIND;
 801614e:	68fb      	ldr	r3, [r7, #12]
 8016150:	2200      	movs	r2, #0
 8016152:	f042 0206 	orr.w	r2, r2, #6
 8016156:	701a      	strb	r2, [r3, #0]
 8016158:	2200      	movs	r2, #0
 801615a:	f042 0204 	orr.w	r2, r2, #4
 801615e:	705a      	strb	r2, [r3, #1]
 8016160:	2200      	movs	r2, #0
 8016162:	709a      	strb	r2, [r3, #2]
 8016164:	2200      	movs	r2, #0
 8016166:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 8016168:	68fb      	ldr	r3, [r7, #12]
 801616a:	2200      	movs	r2, #0
 801616c:	f042 0201 	orr.w	r2, r2, #1
 8016170:	711a      	strb	r2, [r3, #4]
 8016172:	2200      	movs	r2, #0
 8016174:	715a      	strb	r2, [r3, #5]
 8016176:	2200      	movs	r2, #0
 8016178:	719a      	strb	r2, [r3, #6]
 801617a:	2200      	movs	r2, #0
 801617c:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)clusterPtr;
 801617e:	687a      	ldr	r2, [r7, #4]
 8016180:	68fb      	ldr	r3, [r7, #12]
 8016182:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 8016184:	f7f2 fc62 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 8016188:	f7fd fe14 	bl	8013db4 <Post_ZigbeeCmdProcessing>
}
 801618c:	bf00      	nop
 801618e:	3710      	adds	r7, #16
 8016190:	46bd      	mov	sp, r7
 8016192:	bd80      	pop	{r7, pc}

08016194 <ZbZclClusterRemoveAlarmResetHandler>:
    /* Callbacks followed up in MSG_M0TOM4_ZCL_CLUSTER_ALARM_CB handler. */
}

void
ZbZclClusterRemoveAlarmResetHandler(struct ZbZclClusterT *clusterPtr)
{
 8016194:	b580      	push	{r7, lr}
 8016196:	b084      	sub	sp, #16
 8016198:	af00      	add	r7, sp, #0
 801619a:	6078      	str	r0, [r7, #4]
    Zigbee_Cmd_Request_t *ipcc_req;

    Pre_ZigbeeCmdProcessing();
 801619c:	f7f2 fc94 	bl	8008ac8 <Pre_ZigbeeCmdProcessing>
    ipcc_req = ZIGBEE_Get_OTCmdPayloadBuffer();
 80161a0:	f7f2 fc24 	bl	80089ec <ZIGBEE_Get_OTCmdPayloadBuffer>
 80161a4:	60f8      	str	r0, [r7, #12]
    ipcc_req->ID = MSG_M4TOM0_ZCL_CLUSTER_ALARM_REMOVE_FILTER;
 80161a6:	68fb      	ldr	r3, [r7, #12]
 80161a8:	2200      	movs	r2, #0
 80161aa:	f042 020b 	orr.w	r2, r2, #11
 80161ae:	701a      	strb	r2, [r3, #0]
 80161b0:	2200      	movs	r2, #0
 80161b2:	f042 0204 	orr.w	r2, r2, #4
 80161b6:	705a      	strb	r2, [r3, #1]
 80161b8:	2200      	movs	r2, #0
 80161ba:	709a      	strb	r2, [r3, #2]
 80161bc:	2200      	movs	r2, #0
 80161be:	70da      	strb	r2, [r3, #3]
    ipcc_req->Size = 1;
 80161c0:	68fb      	ldr	r3, [r7, #12]
 80161c2:	2200      	movs	r2, #0
 80161c4:	f042 0201 	orr.w	r2, r2, #1
 80161c8:	711a      	strb	r2, [r3, #4]
 80161ca:	2200      	movs	r2, #0
 80161cc:	715a      	strb	r2, [r3, #5]
 80161ce:	2200      	movs	r2, #0
 80161d0:	719a      	strb	r2, [r3, #6]
 80161d2:	2200      	movs	r2, #0
 80161d4:	71da      	strb	r2, [r3, #7]
    ipcc_req->Data[0] = (uint32_t)clusterPtr;
 80161d6:	687a      	ldr	r2, [r7, #4]
 80161d8:	68fb      	ldr	r3, [r7, #12]
 80161da:	609a      	str	r2, [r3, #8]
    ZIGBEE_CmdTransfer();
 80161dc:	f7f2 fc36 	bl	8008a4c <ZIGBEE_CmdTransfer>
    Post_ZigbeeCmdProcessing();
 80161e0:	f7fd fde8 	bl	8013db4 <Post_ZigbeeCmdProcessing>
}
 80161e4:	bf00      	nop
 80161e6:	3710      	adds	r7, #16
 80161e8:	46bd      	mov	sp, r7
 80161ea:	bd80      	pop	{r7, pc}

080161ec <zb_heap_alloc>:
 * Memory Helpers
 ******************************************************************************
 */
void *
zb_heap_alloc(struct ZigBeeT *zb, size_t sz, const char *filename, unsigned int line)
{
 80161ec:	b580      	push	{r7, lr}
 80161ee:	b084      	sub	sp, #16
 80161f0:	af00      	add	r7, sp, #0
 80161f2:	60f8      	str	r0, [r7, #12]
 80161f4:	60b9      	str	r1, [r7, #8]
 80161f6:	607a      	str	r2, [r7, #4]
 80161f8:	603b      	str	r3, [r7, #0]
    /* The M4 has access to malloc */
    return malloc(sz);
 80161fa:	68b8      	ldr	r0, [r7, #8]
 80161fc:	f001 febe 	bl	8017f7c <malloc>
 8016200:	4603      	mov	r3, r0
}
 8016202:	4618      	mov	r0, r3
 8016204:	3710      	adds	r7, #16
 8016206:	46bd      	mov	sp, r7
 8016208:	bd80      	pop	{r7, pc}

0801620a <zb_heap_free>:

void
zb_heap_free(struct ZigBeeT *zb, void *ptr, const char *filename, unsigned int line)
{
 801620a:	b580      	push	{r7, lr}
 801620c:	b084      	sub	sp, #16
 801620e:	af00      	add	r7, sp, #0
 8016210:	60f8      	str	r0, [r7, #12]
 8016212:	60b9      	str	r1, [r7, #8]
 8016214:	607a      	str	r2, [r7, #4]
 8016216:	603b      	str	r3, [r7, #0]
    free(ptr);
 8016218:	68b8      	ldr	r0, [r7, #8]
 801621a:	f001 feb7 	bl	8017f8c <free>
}
 801621e:	bf00      	nop
 8016220:	3710      	adds	r7, #16
 8016222:	46bd      	mov	sp, r7
 8016224:	bd80      	pop	{r7, pc}
	...

08016228 <WpanCrc>:
    0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
};

uint16_t
WpanCrc(uint16_t crc, const void *dataPtr, unsigned int dataLen)
{
 8016228:	b480      	push	{r7}
 801622a:	b087      	sub	sp, #28
 801622c:	af00      	add	r7, sp, #0
 801622e:	4603      	mov	r3, r0
 8016230:	60b9      	str	r1, [r7, #8]
 8016232:	607a      	str	r2, [r7, #4]
 8016234:	81fb      	strh	r3, [r7, #14]
    const uint8_t *p = dataPtr;
 8016236:	68bb      	ldr	r3, [r7, #8]
 8016238:	617b      	str	r3, [r7, #20]
     * Step 4: Repeat until out of data.
     *
     * Non-Reflected CRCs use the same algorithm, except that the crc register
     * is shifted left, and the table needs to be regenerated.
     */
    while (dataLen--) {
 801623a:	e00e      	b.n	801625a <WpanCrc+0x32>
        crc = (crc >> 8) ^ wpanCrcTable[(crc & 0xff) ^ *p++];
 801623c:	89fb      	ldrh	r3, [r7, #14]
 801623e:	0a1b      	lsrs	r3, r3, #8
 8016240:	b29a      	uxth	r2, r3
 8016242:	89fb      	ldrh	r3, [r7, #14]
 8016244:	b2d9      	uxtb	r1, r3
 8016246:	697b      	ldr	r3, [r7, #20]
 8016248:	1c58      	adds	r0, r3, #1
 801624a:	6178      	str	r0, [r7, #20]
 801624c:	781b      	ldrb	r3, [r3, #0]
 801624e:	404b      	eors	r3, r1
 8016250:	4908      	ldr	r1, [pc, #32]	; (8016274 <WpanCrc+0x4c>)
 8016252:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 8016256:	4053      	eors	r3, r2
 8016258:	81fb      	strh	r3, [r7, #14]
    while (dataLen--) {
 801625a:	687b      	ldr	r3, [r7, #4]
 801625c:	1e5a      	subs	r2, r3, #1
 801625e:	607a      	str	r2, [r7, #4]
 8016260:	2b00      	cmp	r3, #0
 8016262:	d1eb      	bne.n	801623c <WpanCrc+0x14>
    }
    return crc;
 8016264:	89fb      	ldrh	r3, [r7, #14]
}
 8016266:	4618      	mov	r0, r3
 8016268:	371c      	adds	r7, #28
 801626a:	46bd      	mov	sp, r7
 801626c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016270:	4770      	bx	lr
 8016272:	bf00      	nop
 8016274:	08019ac4 	.word	0x08019ac4

08016278 <Zigbee_CallBackProcessing>:
 * @param  None
 * @retval None
 */
HAL_StatusTypeDef
Zigbee_CallBackProcessing(void)
{
 8016278:	b5f0      	push	{r4, r5, r6, r7, lr}
 801627a:	b0cf      	sub	sp, #316	; 0x13c
 801627c:	af02      	add	r7, sp, #8
    HAL_StatusTypeDef status = HAL_OK;
 801627e:	2300      	movs	r3, #0
 8016280:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
    struct zb_ipc_m4_cb_info_t *info = NULL;
 8016284:	2300      	movs	r3, #0
 8016286:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    Zigbee_Cmd_Request_t *p_notification;
    uint32_t retval = 0;
 801628a:	2300      	movs	r3, #0
 801628c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124

    /* Get pointer on received event buffer from M0 */
    p_notification = ZIGBEE_Get_NotificationPayloadBuffer();
 8016290:	f7f2 fbc4 	bl	8008a1c <ZIGBEE_Get_NotificationPayloadBuffer>
 8016294:	f8c7 010c 	str.w	r0, [r7, #268]	; 0x10c

    switch (p_notification->ID) {
 8016298:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801629c:	681b      	ldr	r3, [r3, #0]
 801629e:	f240 421c 	movw	r2, #1052	; 0x41c
 80162a2:	4293      	cmp	r3, r2
 80162a4:	f201 82f0 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 80162a8:	f240 4205 	movw	r2, #1029	; 0x405
 80162ac:	4293      	cmp	r3, r2
 80162ae:	d22d      	bcs.n	801630c <Zigbee_CallBackProcessing+0x94>
 80162b0:	f240 321d 	movw	r2, #797	; 0x31d
 80162b4:	4293      	cmp	r3, r2
 80162b6:	f201 82e7 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 80162ba:	f240 3206 	movw	r2, #774	; 0x306
 80162be:	4293      	cmp	r3, r2
 80162c0:	d25c      	bcs.n	801637c <Zigbee_CallBackProcessing+0x104>
 80162c2:	f240 2209 	movw	r2, #521	; 0x209
 80162c6:	4293      	cmp	r3, r2
 80162c8:	f000 847e 	beq.w	8016bc8 <Zigbee_CallBackProcessing+0x950>
 80162cc:	f240 2209 	movw	r2, #521	; 0x209
 80162d0:	4293      	cmp	r3, r2
 80162d2:	f201 82d9 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 80162d6:	f240 2207 	movw	r2, #519	; 0x207
 80162da:	4293      	cmp	r3, r2
 80162dc:	f000 8443 	beq.w	8016b66 <Zigbee_CallBackProcessing+0x8ee>
 80162e0:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 80162e4:	f081 82d0 	bcs.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 80162e8:	f240 2205 	movw	r2, #517	; 0x205
 80162ec:	4293      	cmp	r3, r2
 80162ee:	f000 840c 	beq.w	8016b0a <Zigbee_CallBackProcessing+0x892>
 80162f2:	f240 2205 	movw	r2, #517	; 0x205
 80162f6:	4293      	cmp	r3, r2
 80162f8:	f201 82c6 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 80162fc:	2b3e      	cmp	r3, #62	; 0x3e
 80162fe:	f200 8133 	bhi.w	8016568 <Zigbee_CallBackProcessing+0x2f0>
 8016302:	2b0d      	cmp	r3, #13
 8016304:	f080 80c4 	bcs.w	8016490 <Zigbee_CallBackProcessing+0x218>
 8016308:	f001 babe 	b.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 801630c:	f2a3 4305 	subw	r3, r3, #1029	; 0x405
 8016310:	2b17      	cmp	r3, #23
 8016312:	f201 82b9 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 8016316:	a201      	add	r2, pc, #4	; (adr r2, 801631c <Zigbee_CallBackProcessing+0xa4>)
 8016318:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801631c:	0801751f 	.word	0x0801751f
 8016320:	08017889 	.word	0x08017889
 8016324:	08017889 	.word	0x08017889
 8016328:	08017889 	.word	0x08017889
 801632c:	08017889 	.word	0x08017889
 8016330:	08017567 	.word	0x08017567
 8016334:	08017889 	.word	0x08017889
 8016338:	08017889 	.word	0x08017889
 801633c:	08017889 	.word	0x08017889
 8016340:	08017889 	.word	0x08017889
 8016344:	080175af 	.word	0x080175af
 8016348:	08017889 	.word	0x08017889
 801634c:	08017889 	.word	0x08017889
 8016350:	08017889 	.word	0x08017889
 8016354:	08017623 	.word	0x08017623
 8016358:	08017889 	.word	0x08017889
 801635c:	08017889 	.word	0x08017889
 8016360:	080176ad 	.word	0x080176ad
 8016364:	08017889 	.word	0x08017889
 8016368:	08017707 	.word	0x08017707
 801636c:	08017889 	.word	0x08017889
 8016370:	08017761 	.word	0x08017761
 8016374:	08017889 	.word	0x08017889
 8016378:	080177bb 	.word	0x080177bb
 801637c:	f2a3 3306 	subw	r3, r3, #774	; 0x306
 8016380:	2b17      	cmp	r3, #23
 8016382:	f201 8281 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 8016386:	a201      	add	r2, pc, #4	; (adr r2, 801638c <Zigbee_CallBackProcessing+0x114>)
 8016388:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801638c:	08016c49 	.word	0x08016c49
 8016390:	08017889 	.word	0x08017889
 8016394:	08016d01 	.word	0x08016d01
 8016398:	08017889 	.word	0x08017889
 801639c:	08017889 	.word	0x08017889
 80163a0:	08017889 	.word	0x08017889
 80163a4:	08016d5d 	.word	0x08016d5d
 80163a8:	08017889 	.word	0x08017889
 80163ac:	08016db9 	.word	0x08016db9
 80163b0:	08017889 	.word	0x08017889
 80163b4:	08017889 	.word	0x08017889
 80163b8:	08017889 	.word	0x08017889
 80163bc:	08017889 	.word	0x08017889
 80163c0:	08017889 	.word	0x08017889
 80163c4:	08017889 	.word	0x08017889
 80163c8:	08017889 	.word	0x08017889
 80163cc:	08017889 	.word	0x08017889
 80163d0:	08017889 	.word	0x08017889
 80163d4:	08017889 	.word	0x08017889
 80163d8:	08017889 	.word	0x08017889
 80163dc:	08017889 	.word	0x08017889
 80163e0:	08017889 	.word	0x08017889
 80163e4:	08017889 	.word	0x08017889
 80163e8:	08016ca5 	.word	0x08016ca5
 80163ec:	f2a3 1301 	subw	r3, r3, #257	; 0x101
 80163f0:	2b24      	cmp	r3, #36	; 0x24
 80163f2:	f201 8249 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 80163f6:	a201      	add	r2, pc, #4	; (adr r2, 80163fc <Zigbee_CallBackProcessing+0x184>)
 80163f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80163fc:	08016eb7 	.word	0x08016eb7
 8016400:	08017889 	.word	0x08017889
 8016404:	08016f0f 	.word	0x08016f0f
 8016408:	08017889 	.word	0x08017889
 801640c:	08016f81 	.word	0x08016f81
 8016410:	08017889 	.word	0x08017889
 8016414:	08016fd9 	.word	0x08016fd9
 8016418:	08017889 	.word	0x08017889
 801641c:	08017031 	.word	0x08017031
 8016420:	08017889 	.word	0x08017889
 8016424:	08017089 	.word	0x08017089
 8016428:	08017889 	.word	0x08017889
 801642c:	080170e1 	.word	0x080170e1
 8016430:	08017889 	.word	0x08017889
 8016434:	08017137 	.word	0x08017137
 8016438:	08017889 	.word	0x08017889
 801643c:	08017889 	.word	0x08017889
 8016440:	08017889 	.word	0x08017889
 8016444:	08016e15 	.word	0x08016e15
 8016448:	08017889 	.word	0x08017889
 801644c:	08017181 	.word	0x08017181
 8016450:	08017889 	.word	0x08017889
 8016454:	080171db 	.word	0x080171db
 8016458:	08017889 	.word	0x08017889
 801645c:	08017235 	.word	0x08017235
 8016460:	08017889 	.word	0x08017889
 8016464:	080172a9 	.word	0x080172a9
 8016468:	08017889 	.word	0x08017889
 801646c:	08017303 	.word	0x08017303
 8016470:	08017889 	.word	0x08017889
 8016474:	0801735d 	.word	0x0801735d
 8016478:	08017889 	.word	0x08017889
 801647c:	080173b7 	.word	0x080173b7
 8016480:	08017889 	.word	0x08017889
 8016484:	08017411 	.word	0x08017411
 8016488:	08017889 	.word	0x08017889
 801648c:	0801746b 	.word	0x0801746b
 8016490:	3b0d      	subs	r3, #13
 8016492:	2b31      	cmp	r3, #49	; 0x31
 8016494:	f201 81f8 	bhi.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 8016498:	a201      	add	r2, pc, #4	; (adr r2, 80164a0 <Zigbee_CallBackProcessing+0x228>)
 801649a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801649e:	bf00      	nop
 80164a0:	0801657d 	.word	0x0801657d
 80164a4:	08017889 	.word	0x08017889
 80164a8:	08017889 	.word	0x08017889
 80164ac:	08017889 	.word	0x08017889
 80164b0:	08017889 	.word	0x08017889
 80164b4:	080165e3 	.word	0x080165e3
 80164b8:	08017889 	.word	0x08017889
 80164bc:	08017889 	.word	0x08017889
 80164c0:	08017889 	.word	0x08017889
 80164c4:	08017889 	.word	0x08017889
 80164c8:	08017889 	.word	0x08017889
 80164cc:	08017889 	.word	0x08017889
 80164d0:	08017889 	.word	0x08017889
 80164d4:	08016657 	.word	0x08016657
 80164d8:	08017889 	.word	0x08017889
 80164dc:	08017889 	.word	0x08017889
 80164e0:	080166b3 	.word	0x080166b3
 80164e4:	08017889 	.word	0x08017889
 80164e8:	0801671b 	.word	0x0801671b
 80164ec:	08017889 	.word	0x08017889
 80164f0:	08016783 	.word	0x08016783
 80164f4:	08017889 	.word	0x08017889
 80164f8:	080167eb 	.word	0x080167eb
 80164fc:	08017889 	.word	0x08017889
 8016500:	08017889 	.word	0x08017889
 8016504:	08016853 	.word	0x08016853
 8016508:	08017889 	.word	0x08017889
 801650c:	08017889 	.word	0x08017889
 8016510:	080168d5 	.word	0x080168d5
 8016514:	08017889 	.word	0x08017889
 8016518:	0801693d 	.word	0x0801693d
 801651c:	08017889 	.word	0x08017889
 8016520:	08017889 	.word	0x08017889
 8016524:	08017889 	.word	0x08017889
 8016528:	0801695b 	.word	0x0801695b
 801652c:	08017889 	.word	0x08017889
 8016530:	08017889 	.word	0x08017889
 8016534:	08017889 	.word	0x08017889
 8016538:	080169b3 	.word	0x080169b3
 801653c:	08017889 	.word	0x08017889
 8016540:	08017889 	.word	0x08017889
 8016544:	08017889 	.word	0x08017889
 8016548:	08017889 	.word	0x08017889
 801654c:	08017889 	.word	0x08017889
 8016550:	08016a03 	.word	0x08016a03
 8016554:	08017889 	.word	0x08017889
 8016558:	08016a5b 	.word	0x08016a5b
 801655c:	08017889 	.word	0x08017889
 8016560:	08016ab3 	.word	0x08016ab3
 8016564:	08017835 	.word	0x08017835
 8016568:	f5b3 7f93 	cmp.w	r3, #294	; 0x126
 801656c:	f081 818c 	bcs.w	8017888 <Zigbee_CallBackProcessing+0x1610>
 8016570:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8016574:	f63f af3a 	bhi.w	80163ec <Zigbee_CallBackProcessing+0x174>
 8016578:	f001 b986 	b.w	8017888 <Zigbee_CallBackProcessing+0x1610>
        case MSG_M0TOM4_ZB_DESTROY_CB:
            zb_ipc_globals.zb = NULL;
 801657c:	4bbb      	ldr	r3, [pc, #748]	; (801686c <Zigbee_CallBackProcessing+0x5f4>)
 801657e:	2200      	movs	r2, #0
 8016580:	601a      	str	r2, [r3, #0]
            assert(p_notification->Size == 1);
 8016582:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016586:	685b      	ldr	r3, [r3, #4]
 8016588:	2b01      	cmp	r3, #1
 801658a:	d006      	beq.n	801659a <Zigbee_CallBackProcessing+0x322>
 801658c:	4bb8      	ldr	r3, [pc, #736]	; (8016870 <Zigbee_CallBackProcessing+0x5f8>)
 801658e:	4ab9      	ldr	r2, [pc, #740]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 8016590:	f640 51ed 	movw	r1, #3565	; 0xded
 8016594:	48b8      	ldr	r0, [pc, #736]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 8016596:	f001 fcd3 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[0];
 801659a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801659e:	689b      	ldr	r3, [r3, #8]
 80165a0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80165a4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80165a8:	2b00      	cmp	r3, #0
 80165aa:	f001 8171 	beq.w	8017890 <Zigbee_CallBackProcessing+0x1618>
 80165ae:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80165b2:	681b      	ldr	r3, [r3, #0]
 80165b4:	2b00      	cmp	r3, #0
 80165b6:	f001 816b 	beq.w	8017890 <Zigbee_CallBackProcessing+0x1618>
                void (*callback)(void *arg);

                callback = (void (*)(void *arg))info->callback;
 80165ba:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80165be:	681a      	ldr	r2, [r3, #0]
 80165c0:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80165c4:	f5a3 7392 	sub.w	r3, r3, #292	; 0x124
 80165c8:	601a      	str	r2, [r3, #0]
                callback(info->arg);
 80165ca:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80165ce:	685a      	ldr	r2, [r3, #4]
 80165d0:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80165d4:	f5a3 7392 	sub.w	r3, r3, #292	; 0x124
 80165d8:	681b      	ldr	r3, [r3, #0]
 80165da:	4610      	mov	r0, r2
 80165dc:	4798      	blx	r3
            }
            break;
 80165de:	f001 b957 	b.w	8017890 <Zigbee_CallBackProcessing+0x1618>
        case MSG_M0TOM4_FILTER_MSG_CB:
        {
            struct zb_msg_filter_cb_info_t *cb_info;
            enum zb_msg_filter_rc filter_rc;

            assert(p_notification->Size == 3);
 80165e2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80165e6:	685b      	ldr	r3, [r3, #4]
 80165e8:	2b03      	cmp	r3, #3
 80165ea:	d006      	beq.n	80165fa <Zigbee_CallBackProcessing+0x382>
 80165ec:	4ba3      	ldr	r3, [pc, #652]	; (801687c <Zigbee_CallBackProcessing+0x604>)
 80165ee:	4aa1      	ldr	r2, [pc, #644]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 80165f0:	f640 51fc 	movw	r1, #3580	; 0xdfc
 80165f4:	48a0      	ldr	r0, [pc, #640]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 80165f6:	f001 fca3 	bl	8017f40 <__assert_func>
            cb_info = (struct zb_msg_filter_cb_info_t *)p_notification->Data[2];
 80165fa:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80165fe:	691a      	ldr	r2, [r3, #16]
 8016600:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016604:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 8016608:	601a      	str	r2, [r3, #0]
            filter_rc = cb_info->callback(zb_ipc_globals.zb, (uint32_t)p_notification->Data[0],
 801660a:	f507 7398 	add.w	r3, r7, #304	; 0x130
 801660e:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 8016612:	681b      	ldr	r3, [r3, #0]
 8016614:	685d      	ldr	r5, [r3, #4]
 8016616:	4b95      	ldr	r3, [pc, #596]	; (801686c <Zigbee_CallBackProcessing+0x5f4>)
 8016618:	6818      	ldr	r0, [r3, #0]
 801661a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801661e:	6899      	ldr	r1, [r3, #8]
                    (void *)p_notification->Data[1], cb_info->arg);
 8016620:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016624:	68db      	ldr	r3, [r3, #12]
            filter_rc = cb_info->callback(zb_ipc_globals.zb, (uint32_t)p_notification->Data[0],
 8016626:	461e      	mov	r6, r3
 8016628:	f507 7398 	add.w	r3, r7, #304	; 0x130
 801662c:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 8016630:	681b      	ldr	r3, [r3, #0]
 8016632:	689b      	ldr	r3, [r3, #8]
 8016634:	f507 7298 	add.w	r2, r7, #304	; 0x130
 8016638:	f2a2 141d 	subw	r4, r2, #285	; 0x11d
 801663c:	4632      	mov	r2, r6
 801663e:	47a8      	blx	r5
 8016640:	4603      	mov	r3, r0
 8016642:	7023      	strb	r3, [r4, #0]
            retval = (uint32_t)filter_rc;
 8016644:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016648:	f2a3 131d 	subw	r3, r3, #285	; 0x11d
 801664c:	781b      	ldrb	r3, [r3, #0]
 801664e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
            break;
 8016652:	f001 b980 	b.w	8017956 <Zigbee_CallBackProcessing+0x16de>

        case MSG_M0TOM4_TIMER_CB:
        {
            struct ZbTimerT *timer;

            assert(p_notification->Size == 1);
 8016656:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801665a:	685b      	ldr	r3, [r3, #4]
 801665c:	2b01      	cmp	r3, #1
 801665e:	d006      	beq.n	801666e <Zigbee_CallBackProcessing+0x3f6>
 8016660:	4b83      	ldr	r3, [pc, #524]	; (8016870 <Zigbee_CallBackProcessing+0x5f8>)
 8016662:	4a84      	ldr	r2, [pc, #528]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 8016664:	f640 6108 	movw	r1, #3592	; 0xe08
 8016668:	4883      	ldr	r0, [pc, #524]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 801666a:	f001 fc69 	bl	8017f40 <__assert_func>
            timer = (struct ZbTimerT *)p_notification->Data[0];
 801666e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016672:	689a      	ldr	r2, [r3, #8]
 8016674:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016678:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 801667c:	601a      	str	r2, [r3, #0]
            if (timer->callback != NULL) {
 801667e:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016682:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8016686:	681b      	ldr	r3, [r3, #0]
 8016688:	681b      	ldr	r3, [r3, #0]
 801668a:	2b00      	cmp	r3, #0
 801668c:	f001 8102 	beq.w	8017894 <Zigbee_CallBackProcessing+0x161c>
                timer->callback(NULL, timer->arg);
 8016690:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016694:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8016698:	681b      	ldr	r3, [r3, #0]
 801669a:	681b      	ldr	r3, [r3, #0]
 801669c:	f507 7298 	add.w	r2, r7, #304	; 0x130
 80166a0:	f5a2 728c 	sub.w	r2, r2, #280	; 0x118
 80166a4:	6812      	ldr	r2, [r2, #0]
 80166a6:	6852      	ldr	r2, [r2, #4]
 80166a8:	4611      	mov	r1, r2
 80166aa:	2000      	movs	r0, #0
 80166ac:	4798      	blx	r3
            }
            break;
 80166ae:	f001 b8f1 	b.w	8017894 <Zigbee_CallBackProcessing+0x161c>
        }

        case MSG_M0TOM4_STARTUP_CB:
            assert(p_notification->Size == 2);
 80166b2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80166b6:	685b      	ldr	r3, [r3, #4]
 80166b8:	2b02      	cmp	r3, #2
 80166ba:	d006      	beq.n	80166ca <Zigbee_CallBackProcessing+0x452>
 80166bc:	4b70      	ldr	r3, [pc, #448]	; (8016880 <Zigbee_CallBackProcessing+0x608>)
 80166be:	4a6d      	ldr	r2, [pc, #436]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 80166c0:	f640 6111 	movw	r1, #3601	; 0xe11
 80166c4:	486c      	ldr	r0, [pc, #432]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 80166c6:	f001 fc3b 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80166ca:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80166ce:	68db      	ldr	r3, [r3, #12]
 80166d0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80166d4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80166d8:	2b00      	cmp	r3, #0
 80166da:	f001 80dd 	beq.w	8017898 <Zigbee_CallBackProcessing+0x1620>
 80166de:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80166e2:	681b      	ldr	r3, [r3, #0]
 80166e4:	2b00      	cmp	r3, #0
 80166e6:	f001 80d7 	beq.w	8017898 <Zigbee_CallBackProcessing+0x1620>
                void (*callback)(enum ZbStatusCodeT status, void *arg);

                callback = (void (*)(enum ZbStatusCodeT status, void *arg))info->callback;
 80166ea:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80166ee:	681a      	ldr	r2, [r3, #0]
 80166f0:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80166f4:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80166f8:	601a      	str	r2, [r3, #0]
                callback((enum ZbStatusCodeT)p_notification->Data[0], info->arg);
 80166fa:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80166fe:	689b      	ldr	r3, [r3, #8]
 8016700:	b2da      	uxtb	r2, r3
 8016702:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016706:	6859      	ldr	r1, [r3, #4]
 8016708:	f507 7398 	add.w	r3, r7, #304	; 0x130
 801670c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8016710:	681b      	ldr	r3, [r3, #0]
 8016712:	4610      	mov	r0, r2
 8016714:	4798      	blx	r3
            }
            break;
 8016716:	f001 b8bf 	b.w	8017898 <Zigbee_CallBackProcessing+0x1620>

        case MSG_M0TOM4_STARTUP_REJOIN_CB:
            assert(p_notification->Size == 2);
 801671a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801671e:	685b      	ldr	r3, [r3, #4]
 8016720:	2b02      	cmp	r3, #2
 8016722:	d006      	beq.n	8016732 <Zigbee_CallBackProcessing+0x4ba>
 8016724:	4b56      	ldr	r3, [pc, #344]	; (8016880 <Zigbee_CallBackProcessing+0x608>)
 8016726:	4a53      	ldr	r2, [pc, #332]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 8016728:	f640 611c 	movw	r1, #3612	; 0xe1c
 801672c:	4852      	ldr	r0, [pc, #328]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 801672e:	f001 fc07 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016732:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016736:	68db      	ldr	r3, [r3, #12]
 8016738:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 801673c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016740:	2b00      	cmp	r3, #0
 8016742:	f001 80ab 	beq.w	801789c <Zigbee_CallBackProcessing+0x1624>
 8016746:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801674a:	681b      	ldr	r3, [r3, #0]
 801674c:	2b00      	cmp	r3, #0
 801674e:	f001 80a5 	beq.w	801789c <Zigbee_CallBackProcessing+0x1624>
                void (*callback)(struct ZbNlmeJoinConfT *conf, void *arg);

                callback = (void (*)(struct ZbNlmeJoinConfT *conf, void *arg))info->callback;
 8016752:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016756:	681a      	ldr	r2, [r3, #0]
 8016758:	f507 7398 	add.w	r3, r7, #304	; 0x130
 801675c:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8016760:	601a      	str	r2, [r3, #0]
                callback((struct ZbNlmeJoinConfT *)p_notification->Data[0], info->arg);
 8016762:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016766:	689b      	ldr	r3, [r3, #8]
 8016768:	4618      	mov	r0, r3
 801676a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801676e:	685a      	ldr	r2, [r3, #4]
 8016770:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016774:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8016778:	681b      	ldr	r3, [r3, #0]
 801677a:	4611      	mov	r1, r2
 801677c:	4798      	blx	r3
            }
            break;
 801677e:	f001 b88d 	b.w	801789c <Zigbee_CallBackProcessing+0x1624>

        case MSG_M0TOM4_STARTUP_PERSIST_CB:
            assert(p_notification->Size == 2);
 8016782:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016786:	685b      	ldr	r3, [r3, #4]
 8016788:	2b02      	cmp	r3, #2
 801678a:	d006      	beq.n	801679a <Zigbee_CallBackProcessing+0x522>
 801678c:	4b3c      	ldr	r3, [pc, #240]	; (8016880 <Zigbee_CallBackProcessing+0x608>)
 801678e:	4a39      	ldr	r2, [pc, #228]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 8016790:	f640 6127 	movw	r1, #3623	; 0xe27
 8016794:	4838      	ldr	r0, [pc, #224]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 8016796:	f001 fbd3 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 801679a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801679e:	68db      	ldr	r3, [r3, #12]
 80167a0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80167a4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80167a8:	2b00      	cmp	r3, #0
 80167aa:	f001 8079 	beq.w	80178a0 <Zigbee_CallBackProcessing+0x1628>
 80167ae:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80167b2:	681b      	ldr	r3, [r3, #0]
 80167b4:	2b00      	cmp	r3, #0
 80167b6:	f001 8073 	beq.w	80178a0 <Zigbee_CallBackProcessing+0x1628>
                void (*callback)(enum ZbStatusCodeT status, void *arg);

                callback = (void (*)(enum ZbStatusCodeT status, void *arg))info->callback;
 80167ba:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80167be:	681a      	ldr	r2, [r3, #0]
 80167c0:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80167c4:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80167c8:	601a      	str	r2, [r3, #0]
                callback((enum ZbStatusCodeT)p_notification->Data[0], info->arg);
 80167ca:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80167ce:	689b      	ldr	r3, [r3, #8]
 80167d0:	b2da      	uxtb	r2, r3
 80167d2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80167d6:	6859      	ldr	r1, [r3, #4]
 80167d8:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80167dc:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80167e0:	681b      	ldr	r3, [r3, #0]
 80167e2:	4610      	mov	r0, r2
 80167e4:	4798      	blx	r3
            }
            break;
 80167e6:	f001 b85b 	b.w	80178a0 <Zigbee_CallBackProcessing+0x1628>

        case MSG_M0TOM4_STARTUP_FINDBIND_CB:
            assert(p_notification->Size == 2);
 80167ea:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80167ee:	685b      	ldr	r3, [r3, #4]
 80167f0:	2b02      	cmp	r3, #2
 80167f2:	d006      	beq.n	8016802 <Zigbee_CallBackProcessing+0x58a>
 80167f4:	4b22      	ldr	r3, [pc, #136]	; (8016880 <Zigbee_CallBackProcessing+0x608>)
 80167f6:	4a1f      	ldr	r2, [pc, #124]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 80167f8:	f640 6132 	movw	r1, #3634	; 0xe32
 80167fc:	481e      	ldr	r0, [pc, #120]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 80167fe:	f001 fb9f 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016802:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016806:	68db      	ldr	r3, [r3, #12]
 8016808:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 801680c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016810:	2b00      	cmp	r3, #0
 8016812:	f001 8047 	beq.w	80178a4 <Zigbee_CallBackProcessing+0x162c>
 8016816:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801681a:	681b      	ldr	r3, [r3, #0]
 801681c:	2b00      	cmp	r3, #0
 801681e:	f001 8041 	beq.w	80178a4 <Zigbee_CallBackProcessing+0x162c>
                void (*callback)(enum ZbStatusCodeT status, void *arg);

                callback = (void (*)(enum ZbStatusCodeT status, void *arg))info->callback;
 8016822:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016826:	681a      	ldr	r2, [r3, #0]
 8016828:	f507 7398 	add.w	r3, r7, #304	; 0x130
 801682c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8016830:	601a      	str	r2, [r3, #0]
                callback((enum ZbStatusCodeT)p_notification->Data[0], info->arg);
 8016832:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016836:	689b      	ldr	r3, [r3, #8]
 8016838:	b2da      	uxtb	r2, r3
 801683a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801683e:	6859      	ldr	r1, [r3, #4]
 8016840:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016844:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8016848:	681b      	ldr	r3, [r3, #0]
 801684a:	4610      	mov	r0, r2
 801684c:	4798      	blx	r3
            }
            break;
 801684e:	f001 b829 	b.w	80178a4 <Zigbee_CallBackProcessing+0x162c>

        case MSG_M0TOM4_STARTUP_TCSO_CB:
            assert(p_notification->Size == 2);
 8016852:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016856:	685b      	ldr	r3, [r3, #4]
 8016858:	2b02      	cmp	r3, #2
 801685a:	d013      	beq.n	8016884 <Zigbee_CallBackProcessing+0x60c>
 801685c:	4b08      	ldr	r3, [pc, #32]	; (8016880 <Zigbee_CallBackProcessing+0x608>)
 801685e:	4a05      	ldr	r2, [pc, #20]	; (8016874 <Zigbee_CallBackProcessing+0x5fc>)
 8016860:	f640 613d 	movw	r1, #3645	; 0xe3d
 8016864:	4804      	ldr	r0, [pc, #16]	; (8016878 <Zigbee_CallBackProcessing+0x600>)
 8016866:	f001 fb6b 	bl	8017f40 <__assert_func>
 801686a:	bf00      	nop
 801686c:	20002510 	.word	0x20002510
 8016870:	080198ec 	.word	0x080198ec
 8016874:	08019cf0 	.word	0x08019cf0
 8016878:	0801985c 	.word	0x0801985c
 801687c:	08019908 	.word	0x08019908
 8016880:	08019924 	.word	0x08019924
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016884:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016888:	68db      	ldr	r3, [r3, #12]
 801688a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 801688e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016892:	2b00      	cmp	r3, #0
 8016894:	f001 8008 	beq.w	80178a8 <Zigbee_CallBackProcessing+0x1630>
 8016898:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801689c:	681b      	ldr	r3, [r3, #0]
 801689e:	2b00      	cmp	r3, #0
 80168a0:	f001 8002 	beq.w	80178a8 <Zigbee_CallBackProcessing+0x1630>
                void (*callback)(enum ZbTcsoStatusT status, void *arg);

                callback = (void (*)(enum ZbTcsoStatusT status, void *arg))info->callback;
 80168a4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80168a8:	681a      	ldr	r2, [r3, #0]
 80168aa:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80168ae:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80168b2:	601a      	str	r2, [r3, #0]
                callback((enum ZbTcsoStatusT)p_notification->Data[0], info->arg);
 80168b4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80168b8:	689b      	ldr	r3, [r3, #8]
 80168ba:	b2da      	uxtb	r2, r3
 80168bc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80168c0:	6859      	ldr	r1, [r3, #4]
 80168c2:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80168c6:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 80168ca:	681b      	ldr	r3, [r3, #0]
 80168cc:	4610      	mov	r0, r2
 80168ce:	4798      	blx	r3
            }
            break;
 80168d0:	f000 bfea 	b.w	80178a8 <Zigbee_CallBackProcessing+0x1630>

        case MSG_M0TOM4_STARTUP_TC_REJOIN_CB:
            assert(p_notification->Size == 2);
 80168d4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80168d8:	685b      	ldr	r3, [r3, #4]
 80168da:	2b02      	cmp	r3, #2
 80168dc:	d006      	beq.n	80168ec <Zigbee_CallBackProcessing+0x674>
 80168de:	4bc2      	ldr	r3, [pc, #776]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 80168e0:	4ac2      	ldr	r2, [pc, #776]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 80168e2:	f640 6148 	movw	r1, #3656	; 0xe48
 80168e6:	48c2      	ldr	r0, [pc, #776]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 80168e8:	f001 fb2a 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80168ec:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80168f0:	68db      	ldr	r3, [r3, #12]
 80168f2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80168f6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80168fa:	2b00      	cmp	r3, #0
 80168fc:	f000 87d6 	beq.w	80178ac <Zigbee_CallBackProcessing+0x1634>
 8016900:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016904:	681b      	ldr	r3, [r3, #0]
 8016906:	2b00      	cmp	r3, #0
 8016908:	f000 87d0 	beq.w	80178ac <Zigbee_CallBackProcessing+0x1634>
                void (*callback)(enum ZbStatusCodeT status, void *arg);

                callback = (void (*)(enum ZbStatusCodeT status, void *arg))info->callback;
 801690c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016910:	681a      	ldr	r2, [r3, #0]
 8016912:	f507 7398 	add.w	r3, r7, #304	; 0x130
 8016916:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 801691a:	601a      	str	r2, [r3, #0]
                callback((enum ZbStatusCodeT)p_notification->Data[0], info->arg);
 801691c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016920:	689b      	ldr	r3, [r3, #8]
 8016922:	b2da      	uxtb	r2, r3
 8016924:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016928:	6859      	ldr	r1, [r3, #4]
 801692a:	f507 7398 	add.w	r3, r7, #304	; 0x130
 801692e:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8016932:	681b      	ldr	r3, [r3, #0]
 8016934:	4610      	mov	r0, r2
 8016936:	4798      	blx	r3
            }
            break;
 8016938:	f000 bfb8 	b.w	80178ac <Zigbee_CallBackProcessing+0x1634>

        case MSG_M0TOM4_PERSIST_CB:
            if (zb_persist_cb != NULL) {
 801693c:	4bad      	ldr	r3, [pc, #692]	; (8016bf4 <Zigbee_CallBackProcessing+0x97c>)
 801693e:	681b      	ldr	r3, [r3, #0]
 8016940:	2b00      	cmp	r3, #0
 8016942:	f000 87b5 	beq.w	80178b0 <Zigbee_CallBackProcessing+0x1638>
                zb_persist_cb(zb_ipc_globals.zb, zb_persist_arg);
 8016946:	4bab      	ldr	r3, [pc, #684]	; (8016bf4 <Zigbee_CallBackProcessing+0x97c>)
 8016948:	681b      	ldr	r3, [r3, #0]
 801694a:	4aab      	ldr	r2, [pc, #684]	; (8016bf8 <Zigbee_CallBackProcessing+0x980>)
 801694c:	6812      	ldr	r2, [r2, #0]
 801694e:	49ab      	ldr	r1, [pc, #684]	; (8016bfc <Zigbee_CallBackProcessing+0x984>)
 8016950:	6809      	ldr	r1, [r1, #0]
 8016952:	4610      	mov	r0, r2
 8016954:	4798      	blx	r3
            }
            break;
 8016956:	f000 bfab 	b.w	80178b0 <Zigbee_CallBackProcessing+0x1638>

        case MSG_M0TOM4_ZB_LEAVE_CB:
            assert(p_notification->Size == 2);
 801695a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801695e:	685b      	ldr	r3, [r3, #4]
 8016960:	2b02      	cmp	r3, #2
 8016962:	d006      	beq.n	8016972 <Zigbee_CallBackProcessing+0x6fa>
 8016964:	4ba0      	ldr	r3, [pc, #640]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016966:	4aa1      	ldr	r2, [pc, #644]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016968:	f640 6159 	movw	r1, #3673	; 0xe59
 801696c:	48a0      	ldr	r0, [pc, #640]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 801696e:	f001 fae7 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016972:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016976:	68db      	ldr	r3, [r3, #12]
 8016978:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 801697c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016980:	2b00      	cmp	r3, #0
 8016982:	f000 8797 	beq.w	80178b4 <Zigbee_CallBackProcessing+0x163c>
 8016986:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801698a:	681b      	ldr	r3, [r3, #0]
 801698c:	2b00      	cmp	r3, #0
 801698e:	f000 8791 	beq.w	80178b4 <Zigbee_CallBackProcessing+0x163c>
                void (*callback)(struct ZbNlmeLeaveConfT *conf, void *arg);

                callback = (void (*)(struct ZbNlmeLeaveConfT *conf, void *arg))info->callback;
 8016992:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016996:	681b      	ldr	r3, [r3, #0]
 8016998:	637b      	str	r3, [r7, #52]	; 0x34
                callback((struct ZbNlmeLeaveConfT *)p_notification->Data[0], info->arg);
 801699a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801699e:	689b      	ldr	r3, [r3, #8]
 80169a0:	4618      	mov	r0, r3
 80169a2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80169a6:	685a      	ldr	r2, [r3, #4]
 80169a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169aa:	4611      	mov	r1, r2
 80169ac:	4798      	blx	r3
            }
            break;
 80169ae:	f000 bf81 	b.w	80178b4 <Zigbee_CallBackProcessing+0x163c>

        case MSG_M0TOM4_ZB_STATE_PAUSE_CB:
            assert(p_notification->Size == 1);
 80169b2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80169b6:	685b      	ldr	r3, [r3, #4]
 80169b8:	2b01      	cmp	r3, #1
 80169ba:	d006      	beq.n	80169ca <Zigbee_CallBackProcessing+0x752>
 80169bc:	4b90      	ldr	r3, [pc, #576]	; (8016c00 <Zigbee_CallBackProcessing+0x988>)
 80169be:	4a8b      	ldr	r2, [pc, #556]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 80169c0:	f640 6164 	movw	r1, #3684	; 0xe64
 80169c4:	488a      	ldr	r0, [pc, #552]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 80169c6:	f001 fabb 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[0];
 80169ca:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80169ce:	689b      	ldr	r3, [r3, #8]
 80169d0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80169d4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80169d8:	2b00      	cmp	r3, #0
 80169da:	f000 876d 	beq.w	80178b8 <Zigbee_CallBackProcessing+0x1640>
 80169de:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80169e2:	681b      	ldr	r3, [r3, #0]
 80169e4:	2b00      	cmp	r3, #0
 80169e6:	f000 8767 	beq.w	80178b8 <Zigbee_CallBackProcessing+0x1640>
                void (*callback)(void *arg);

                callback = (void (*)(void *arg))info->callback;
 80169ea:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80169ee:	681b      	ldr	r3, [r3, #0]
 80169f0:	63bb      	str	r3, [r7, #56]	; 0x38
                callback(info->arg);
 80169f2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80169f6:	685a      	ldr	r2, [r3, #4]
 80169f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80169fa:	4610      	mov	r0, r2
 80169fc:	4798      	blx	r3
            }
            break;
 80169fe:	f000 bf5b 	b.w	80178b8 <Zigbee_CallBackProcessing+0x1640>

        /* void (*callback)(struct ZbTlGetGroupIdsRspCmd *rsp, void *arg) */
        case MSG_M0TOM4_ZCL_TL_GET_GRP_CB:
            assert(p_notification->Size == 2);
 8016a02:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016a06:	685b      	ldr	r3, [r3, #4]
 8016a08:	2b02      	cmp	r3, #2
 8016a0a:	d006      	beq.n	8016a1a <Zigbee_CallBackProcessing+0x7a2>
 8016a0c:	4b76      	ldr	r3, [pc, #472]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016a0e:	4a77      	ldr	r2, [pc, #476]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016a10:	f44f 6167 	mov.w	r1, #3696	; 0xe70
 8016a14:	4876      	ldr	r0, [pc, #472]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 8016a16:	f001 fa93 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016a1a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016a1e:	68db      	ldr	r3, [r3, #12]
 8016a20:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016a24:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a28:	2b00      	cmp	r3, #0
 8016a2a:	f000 8747 	beq.w	80178bc <Zigbee_CallBackProcessing+0x1644>
 8016a2e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a32:	681b      	ldr	r3, [r3, #0]
 8016a34:	2b00      	cmp	r3, #0
 8016a36:	f000 8741 	beq.w	80178bc <Zigbee_CallBackProcessing+0x1644>
                void (*callback)(struct ZbTlGetGroupIdsRspCmd *rsp, void *arg);

                callback = (void (*)(struct ZbTlGetGroupIdsRspCmd *rsp, void *arg))info->callback;
 8016a3a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a3e:	681b      	ldr	r3, [r3, #0]
 8016a40:	63fb      	str	r3, [r7, #60]	; 0x3c
                callback((struct ZbTlGetGroupIdsRspCmd *)p_notification->Data[0], info->arg);
 8016a42:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016a46:	689b      	ldr	r3, [r3, #8]
 8016a48:	4618      	mov	r0, r3
 8016a4a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a4e:	685a      	ldr	r2, [r3, #4]
 8016a50:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a52:	4611      	mov	r1, r2
 8016a54:	4798      	blx	r3
            }
            break;
 8016a56:	f000 bf31 	b.w	80178bc <Zigbee_CallBackProcessing+0x1644>

        /* void (*callback)(struct ZbTlGetEpListRspCmd *rsp, void *arg) */
        case MSG_M0TOM4_ZCL_TL_GET_EPLIST_CB:
            assert(p_notification->Size == 2);
 8016a5a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016a5e:	685b      	ldr	r3, [r3, #4]
 8016a60:	2b02      	cmp	r3, #2
 8016a62:	d006      	beq.n	8016a72 <Zigbee_CallBackProcessing+0x7fa>
 8016a64:	4b60      	ldr	r3, [pc, #384]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016a66:	4a61      	ldr	r2, [pc, #388]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016a68:	f640 617c 	movw	r1, #3708	; 0xe7c
 8016a6c:	4860      	ldr	r0, [pc, #384]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 8016a6e:	f001 fa67 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016a72:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016a76:	68db      	ldr	r3, [r3, #12]
 8016a78:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016a7c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a80:	2b00      	cmp	r3, #0
 8016a82:	f000 871d 	beq.w	80178c0 <Zigbee_CallBackProcessing+0x1648>
 8016a86:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a8a:	681b      	ldr	r3, [r3, #0]
 8016a8c:	2b00      	cmp	r3, #0
 8016a8e:	f000 8717 	beq.w	80178c0 <Zigbee_CallBackProcessing+0x1648>
                void (*callback)(struct ZbTlGetEpListRspCmd *rsp, void *arg);

                callback = (void (*)(struct ZbTlGetEpListRspCmd *rsp, void *arg))info->callback;
 8016a92:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016a96:	681b      	ldr	r3, [r3, #0]
 8016a98:	643b      	str	r3, [r7, #64]	; 0x40
                callback((struct ZbTlGetEpListRspCmd *)p_notification->Data[0], info->arg);
 8016a9a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016a9e:	689b      	ldr	r3, [r3, #8]
 8016aa0:	4618      	mov	r0, r3
 8016aa2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016aa6:	685a      	ldr	r2, [r3, #4]
 8016aa8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016aaa:	4611      	mov	r1, r2
 8016aac:	4798      	blx	r3
            }
            break;
 8016aae:	f000 bf07 	b.w	80178c0 <Zigbee_CallBackProcessing+0x1648>

        /* void (*callback)(struct ZbZclCommandRspT *zcl_rsp, void *arg) */
        case MSG_M0TOM4_ZCL_TL_SEND_EPINFO_CB:
            assert(p_notification->Size == 2);
 8016ab2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016ab6:	685b      	ldr	r3, [r3, #4]
 8016ab8:	2b02      	cmp	r3, #2
 8016aba:	d006      	beq.n	8016aca <Zigbee_CallBackProcessing+0x852>
 8016abc:	4b4a      	ldr	r3, [pc, #296]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016abe:	4a4b      	ldr	r2, [pc, #300]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016ac0:	f640 6188 	movw	r1, #3720	; 0xe88
 8016ac4:	484a      	ldr	r0, [pc, #296]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 8016ac6:	f001 fa3b 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016aca:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016ace:	68db      	ldr	r3, [r3, #12]
 8016ad0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016ad4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016ad8:	2b00      	cmp	r3, #0
 8016ada:	f000 86f3 	beq.w	80178c4 <Zigbee_CallBackProcessing+0x164c>
 8016ade:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016ae2:	681b      	ldr	r3, [r3, #0]
 8016ae4:	2b00      	cmp	r3, #0
 8016ae6:	f000 86ed 	beq.w	80178c4 <Zigbee_CallBackProcessing+0x164c>
                void (*callback)(struct ZbZclCommandRspT *rsp, void *arg);

                callback = (void (*)(struct ZbZclCommandRspT *rsp, void *arg))info->callback;
 8016aea:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016aee:	681b      	ldr	r3, [r3, #0]
 8016af0:	647b      	str	r3, [r7, #68]	; 0x44
                callback((struct ZbZclCommandRspT *)p_notification->Data[0], info->arg);
 8016af2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016af6:	689b      	ldr	r3, [r3, #8]
 8016af8:	4618      	mov	r0, r3
 8016afa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016afe:	685a      	ldr	r2, [r3, #4]
 8016b00:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016b02:	4611      	mov	r1, r2
 8016b04:	4798      	blx	r3
            }
            break;
 8016b06:	f000 bedd 	b.w	80178c4 <Zigbee_CallBackProcessing+0x164c>

        case MSG_M0TOM4_APSDE_DATA_REQ_CB:
            assert(p_notification->Size == 2);
 8016b0a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016b0e:	685b      	ldr	r3, [r3, #4]
 8016b10:	2b02      	cmp	r3, #2
 8016b12:	d006      	beq.n	8016b22 <Zigbee_CallBackProcessing+0x8aa>
 8016b14:	4b34      	ldr	r3, [pc, #208]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016b16:	4a35      	ldr	r2, [pc, #212]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016b18:	f640 6193 	movw	r1, #3731	; 0xe93
 8016b1c:	4834      	ldr	r0, [pc, #208]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 8016b1e:	f001 fa0f 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016b22:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016b26:	68db      	ldr	r3, [r3, #12]
 8016b28:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016b2c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016b30:	2b00      	cmp	r3, #0
 8016b32:	f000 86c9 	beq.w	80178c8 <Zigbee_CallBackProcessing+0x1650>
 8016b36:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016b3a:	681b      	ldr	r3, [r3, #0]
 8016b3c:	2b00      	cmp	r3, #0
 8016b3e:	f000 86c3 	beq.w	80178c8 <Zigbee_CallBackProcessing+0x1650>
                void (*callback)(struct ZbApsdeDataConfT *conf, void *arg);

                callback = (void (*)(struct ZbApsdeDataConfT *conf, void *arg))info->callback;
 8016b42:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016b46:	681b      	ldr	r3, [r3, #0]
 8016b48:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
                callback((struct ZbApsdeDataConfT *)p_notification->Data[0], info->arg);
 8016b4c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016b50:	689b      	ldr	r3, [r3, #8]
 8016b52:	4618      	mov	r0, r3
 8016b54:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016b58:	685a      	ldr	r2, [r3, #4]
 8016b5a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8016b5e:	4611      	mov	r1, r2
 8016b60:	4798      	blx	r3
            }
            break;
 8016b62:	f000 beb1 	b.w	80178c8 <Zigbee_CallBackProcessing+0x1650>

        case MSG_M0TOM4_APS_FILTER_ENDPOINT_CB:
        {
            struct ZbApsdeDataIndT *data_ind;
            struct aps_filter_cb_t *aps_filter_cb;
            int err = ZB_APS_FILTER_CONTINUE;
 8016b66:	2300      	movs	r3, #0
 8016b68:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120

            assert(p_notification->Size == 2);
 8016b6c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016b70:	685b      	ldr	r3, [r3, #4]
 8016b72:	2b02      	cmp	r3, #2
 8016b74:	d006      	beq.n	8016b84 <Zigbee_CallBackProcessing+0x90c>
 8016b76:	4b1c      	ldr	r3, [pc, #112]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016b78:	4a1c      	ldr	r2, [pc, #112]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016b7a:	f640 61a3 	movw	r1, #3747	; 0xea3
 8016b7e:	481c      	ldr	r0, [pc, #112]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 8016b80:	f001 f9de 	bl	8017f40 <__assert_func>
            data_ind = (struct ZbApsdeDataIndT *)p_notification->Data[0];
 8016b84:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016b88:	689b      	ldr	r3, [r3, #8]
 8016b8a:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
            aps_filter_cb = (struct aps_filter_cb_t *)p_notification->Data[1];
 8016b8e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016b92:	68db      	ldr	r3, [r3, #12]
 8016b94:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
            if (aps_filter_cb->callback != NULL) {
 8016b98:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8016b9c:	685b      	ldr	r3, [r3, #4]
 8016b9e:	2b00      	cmp	r3, #0
 8016ba0:	d00b      	beq.n	8016bba <Zigbee_CallBackProcessing+0x942>
                err = aps_filter_cb->callback(data_ind, aps_filter_cb->cb_arg);
 8016ba2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8016ba6:	685b      	ldr	r3, [r3, #4]
 8016ba8:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8016bac:	6892      	ldr	r2, [r2, #8]
 8016bae:	4611      	mov	r1, r2
 8016bb0:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
 8016bb4:	4798      	blx	r3
 8016bb6:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120
            }
            /* Return err in second argument */
            p_notification->Data[1] = (uint32_t)err;
 8016bba:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
 8016bbe:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016bc2:	60da      	str	r2, [r3, #12]
            break;
 8016bc4:	f000 bec7 	b.w	8017956 <Zigbee_CallBackProcessing+0x16de>

        case MSG_M0TOM4_APS_FILTER_CLUSTER_CB:
        {
            struct ZbApsdeDataIndT *data_ind;
            struct aps_filter_cb_t *aps_filter_cb;
            int err = ZB_APS_FILTER_CONTINUE;
 8016bc8:	2300      	movs	r3, #0
 8016bca:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

            assert(p_notification->Size == 2);
 8016bce:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016bd2:	685b      	ldr	r3, [r3, #4]
 8016bd4:	2b02      	cmp	r3, #2
 8016bd6:	d015      	beq.n	8016c04 <Zigbee_CallBackProcessing+0x98c>
 8016bd8:	4b03      	ldr	r3, [pc, #12]	; (8016be8 <Zigbee_CallBackProcessing+0x970>)
 8016bda:	4a04      	ldr	r2, [pc, #16]	; (8016bec <Zigbee_CallBackProcessing+0x974>)
 8016bdc:	f640 61b4 	movw	r1, #3764	; 0xeb4
 8016be0:	4803      	ldr	r0, [pc, #12]	; (8016bf0 <Zigbee_CallBackProcessing+0x978>)
 8016be2:	f001 f9ad 	bl	8017f40 <__assert_func>
 8016be6:	bf00      	nop
 8016be8:	08019924 	.word	0x08019924
 8016bec:	08019cf0 	.word	0x08019cf0
 8016bf0:	0801985c 	.word	0x0801985c
 8016bf4:	20002500 	.word	0x20002500
 8016bf8:	20002510 	.word	0x20002510
 8016bfc:	20002504 	.word	0x20002504
 8016c00:	080198ec 	.word	0x080198ec
            data_ind = (struct ZbApsdeDataIndT *)p_notification->Data[0];
 8016c04:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016c08:	689b      	ldr	r3, [r3, #8]
 8016c0a:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
            aps_filter_cb = (struct aps_filter_cb_t *)p_notification->Data[1];
 8016c0e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016c12:	68db      	ldr	r3, [r3, #12]
 8016c14:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
            if (aps_filter_cb->callback != NULL) {
 8016c18:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8016c1c:	685b      	ldr	r3, [r3, #4]
 8016c1e:	2b00      	cmp	r3, #0
 8016c20:	d00b      	beq.n	8016c3a <Zigbee_CallBackProcessing+0x9c2>
                err = aps_filter_cb->callback(data_ind, aps_filter_cb->cb_arg);
 8016c22:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8016c26:	685b      	ldr	r3, [r3, #4]
 8016c28:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8016c2c:	6892      	ldr	r2, [r2, #8]
 8016c2e:	4611      	mov	r1, r2
 8016c30:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 8016c34:	4798      	blx	r3
 8016c36:	f8c7 011c 	str.w	r0, [r7, #284]	; 0x11c
            }
            /* Return err in second argument */
            p_notification->Data[1] = (uint32_t)err;
 8016c3a:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8016c3e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016c42:	60da      	str	r2, [r3, #12]
            break;
 8016c44:	f000 be87 	b.w	8017956 <Zigbee_CallBackProcessing+0x16de>
        }

        case MSG_M0TOM4_NLME_NET_DISC_CB:
            assert(p_notification->Size == 2);
 8016c48:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016c4c:	685b      	ldr	r3, [r3, #4]
 8016c4e:	2b02      	cmp	r3, #2
 8016c50:	d006      	beq.n	8016c60 <Zigbee_CallBackProcessing+0x9e8>
 8016c52:	4bc5      	ldr	r3, [pc, #788]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016c54:	4ac5      	ldr	r2, [pc, #788]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016c56:	f44f 616c 	mov.w	r1, #3776	; 0xec0
 8016c5a:	48c5      	ldr	r0, [pc, #788]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016c5c:	f001 f970 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016c60:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016c64:	68db      	ldr	r3, [r3, #12]
 8016c66:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016c6a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016c6e:	2b00      	cmp	r3, #0
 8016c70:	f000 862c 	beq.w	80178cc <Zigbee_CallBackProcessing+0x1654>
 8016c74:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016c78:	681b      	ldr	r3, [r3, #0]
 8016c7a:	2b00      	cmp	r3, #0
 8016c7c:	f000 8626 	beq.w	80178cc <Zigbee_CallBackProcessing+0x1654>
                void (*callback)(struct ZbNlmeNetDiscConfT *conf, void *arg);

                callback = (void (*)(struct ZbNlmeNetDiscConfT *conf, void *arg))info->callback;
 8016c80:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016c84:	681b      	ldr	r3, [r3, #0]
 8016c86:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
                callback((struct ZbNlmeNetDiscConfT *)p_notification->Data[0], info->arg);
 8016c8a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016c8e:	689b      	ldr	r3, [r3, #8]
 8016c90:	4618      	mov	r0, r3
 8016c92:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016c96:	685a      	ldr	r2, [r3, #4]
 8016c98:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8016c9c:	4611      	mov	r1, r2
 8016c9e:	4798      	blx	r3
            }
            break;
 8016ca0:	f000 be14 	b.w	80178cc <Zigbee_CallBackProcessing+0x1654>

#ifndef CONFIG_ZB_ENDNODE
        case MSG_M0TOM4_NLME_ED_SCAN_CB:
            assert(p_notification->Size == 2);
 8016ca4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016ca8:	685b      	ldr	r3, [r3, #4]
 8016caa:	2b02      	cmp	r3, #2
 8016cac:	d006      	beq.n	8016cbc <Zigbee_CallBackProcessing+0xa44>
 8016cae:	4bae      	ldr	r3, [pc, #696]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016cb0:	4aae      	ldr	r2, [pc, #696]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016cb2:	f640 61cc 	movw	r1, #3788	; 0xecc
 8016cb6:	48ae      	ldr	r0, [pc, #696]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016cb8:	f001 f942 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016cbc:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016cc0:	68db      	ldr	r3, [r3, #12]
 8016cc2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016cc6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016cca:	2b00      	cmp	r3, #0
 8016ccc:	f000 8600 	beq.w	80178d0 <Zigbee_CallBackProcessing+0x1658>
 8016cd0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016cd4:	681b      	ldr	r3, [r3, #0]
 8016cd6:	2b00      	cmp	r3, #0
 8016cd8:	f000 85fa 	beq.w	80178d0 <Zigbee_CallBackProcessing+0x1658>
                void (*callback)(struct ZbNlmeEdScanConfT *conf, void *arg);

                callback = (void (*)(struct ZbNlmeEdScanConfT *conf, void *arg))info->callback;
 8016cdc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016ce0:	681b      	ldr	r3, [r3, #0]
 8016ce2:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
                callback((struct ZbNlmeEdScanConfT *)p_notification->Data[0], info->arg);
 8016ce6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016cea:	689b      	ldr	r3, [r3, #8]
 8016cec:	4618      	mov	r0, r3
 8016cee:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016cf2:	685a      	ldr	r2, [r3, #4]
 8016cf4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8016cf8:	4611      	mov	r1, r2
 8016cfa:	4798      	blx	r3
            }
            break;
 8016cfc:	f000 bde8 	b.w	80178d0 <Zigbee_CallBackProcessing+0x1658>
#endif

        case MSG_M0TOM4_NLME_LEAVE_CB:
            assert(p_notification->Size == 2);
 8016d00:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016d04:	685b      	ldr	r3, [r3, #4]
 8016d06:	2b02      	cmp	r3, #2
 8016d08:	d006      	beq.n	8016d18 <Zigbee_CallBackProcessing+0xaa0>
 8016d0a:	4b97      	ldr	r3, [pc, #604]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016d0c:	4a97      	ldr	r2, [pc, #604]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016d0e:	f640 61d8 	movw	r1, #3800	; 0xed8
 8016d12:	4897      	ldr	r0, [pc, #604]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016d14:	f001 f914 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016d18:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016d1c:	68db      	ldr	r3, [r3, #12]
 8016d1e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016d22:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d26:	2b00      	cmp	r3, #0
 8016d28:	f000 85d4 	beq.w	80178d4 <Zigbee_CallBackProcessing+0x165c>
 8016d2c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d30:	681b      	ldr	r3, [r3, #0]
 8016d32:	2b00      	cmp	r3, #0
 8016d34:	f000 85ce 	beq.w	80178d4 <Zigbee_CallBackProcessing+0x165c>
                void (*callback)(struct ZbNlmeLeaveConfT *conf, void *arg);

                callback = (void (*)(struct ZbNlmeLeaveConfT *conf, void *arg))info->callback;
 8016d38:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d3c:	681b      	ldr	r3, [r3, #0]
 8016d3e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
                callback((struct ZbNlmeLeaveConfT *)p_notification->Data[0], info->arg);
 8016d42:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016d46:	689b      	ldr	r3, [r3, #8]
 8016d48:	4618      	mov	r0, r3
 8016d4a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d4e:	685a      	ldr	r2, [r3, #4]
 8016d50:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8016d54:	4611      	mov	r1, r2
 8016d56:	4798      	blx	r3
            }
            break;
 8016d58:	f000 bdbc 	b.w	80178d4 <Zigbee_CallBackProcessing+0x165c>

        case MSG_M0TOM4_NLME_SYNC_CB:
            assert(p_notification->Size == 2);
 8016d5c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016d60:	685b      	ldr	r3, [r3, #4]
 8016d62:	2b02      	cmp	r3, #2
 8016d64:	d006      	beq.n	8016d74 <Zigbee_CallBackProcessing+0xafc>
 8016d66:	4b80      	ldr	r3, [pc, #512]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016d68:	4a80      	ldr	r2, [pc, #512]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016d6a:	f640 61e3 	movw	r1, #3811	; 0xee3
 8016d6e:	4880      	ldr	r0, [pc, #512]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016d70:	f001 f8e6 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016d74:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016d78:	68db      	ldr	r3, [r3, #12]
 8016d7a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016d7e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d82:	2b00      	cmp	r3, #0
 8016d84:	f000 85a8 	beq.w	80178d8 <Zigbee_CallBackProcessing+0x1660>
 8016d88:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d8c:	681b      	ldr	r3, [r3, #0]
 8016d8e:	2b00      	cmp	r3, #0
 8016d90:	f000 85a2 	beq.w	80178d8 <Zigbee_CallBackProcessing+0x1660>
                void (*callback)(struct ZbNlmeSyncConfT *conf, void *arg);

                callback = (void (*)(struct ZbNlmeSyncConfT *discConf, void *arg))info->callback;
 8016d94:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016d98:	681b      	ldr	r3, [r3, #0]
 8016d9a:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
                callback((struct ZbNlmeSyncConfT *)p_notification->Data[0], info->arg);
 8016d9e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016da2:	689b      	ldr	r3, [r3, #8]
 8016da4:	4618      	mov	r0, r3
 8016da6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016daa:	685a      	ldr	r2, [r3, #4]
 8016dac:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8016db0:	4611      	mov	r1, r2
 8016db2:	4798      	blx	r3
            }
            break;
 8016db4:	f000 bd90 	b.w	80178d8 <Zigbee_CallBackProcessing+0x1660>

        case MSG_M0TOM4_NLME_ROUTE_DISC_CB:
            assert(p_notification->Size == 2);
 8016db8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016dbc:	685b      	ldr	r3, [r3, #4]
 8016dbe:	2b02      	cmp	r3, #2
 8016dc0:	d006      	beq.n	8016dd0 <Zigbee_CallBackProcessing+0xb58>
 8016dc2:	4b69      	ldr	r3, [pc, #420]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016dc4:	4a69      	ldr	r2, [pc, #420]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016dc6:	f640 61ee 	movw	r1, #3822	; 0xeee
 8016dca:	4869      	ldr	r0, [pc, #420]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016dcc:	f001 f8b8 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016dd0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016dd4:	68db      	ldr	r3, [r3, #12]
 8016dd6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016dda:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016dde:	2b00      	cmp	r3, #0
 8016de0:	f000 857c 	beq.w	80178dc <Zigbee_CallBackProcessing+0x1664>
 8016de4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016de8:	681b      	ldr	r3, [r3, #0]
 8016dea:	2b00      	cmp	r3, #0
 8016dec:	f000 8576 	beq.w	80178dc <Zigbee_CallBackProcessing+0x1664>
                void (*callback)(struct ZbNlmeRouteDiscConfT *discConf, void *cbarg);

                callback = (void (*)(struct ZbNlmeRouteDiscConfT *discConf, void *cbarg))info->callback;
 8016df0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016df4:	681b      	ldr	r3, [r3, #0]
 8016df6:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
                callback((struct ZbNlmeRouteDiscConfT *)p_notification->Data[0], info->arg);
 8016dfa:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016dfe:	689b      	ldr	r3, [r3, #8]
 8016e00:	4618      	mov	r0, r3
 8016e02:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016e06:	685a      	ldr	r2, [r3, #4]
 8016e08:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8016e0c:	4611      	mov	r1, r2
 8016e0e:	4798      	blx	r3
            }
            break;
 8016e10:	f000 bd64 	b.w	80178dc <Zigbee_CallBackProcessing+0x1664>

        case MSG_M0TOM4_ZDO_DEVICE_ANNCE_FILTER_CB:
        {
            struct zdo_filter_cb_info_t *cb_info;

            assert(p_notification->Size == 3);
 8016e14:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016e18:	685b      	ldr	r3, [r3, #4]
 8016e1a:	2b03      	cmp	r3, #3
 8016e1c:	d006      	beq.n	8016e2c <Zigbee_CallBackProcessing+0xbb4>
 8016e1e:	4b55      	ldr	r3, [pc, #340]	; (8016f74 <Zigbee_CallBackProcessing+0xcfc>)
 8016e20:	4a52      	ldr	r2, [pc, #328]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016e22:	f640 61fc 	movw	r1, #3836	; 0xefc
 8016e26:	4852      	ldr	r0, [pc, #328]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016e28:	f001 f88a 	bl	8017f40 <__assert_func>
            cb_info = (void *)p_notification->Data[2];
 8016e2c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016e30:	691b      	ldr	r3, [r3, #16]
 8016e32:	67fb      	str	r3, [r7, #124]	; 0x7c
            if ((cb_info != NULL) && (cb_info->callback != NULL)) {
 8016e34:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8016e36:	2b00      	cmp	r3, #0
 8016e38:	f000 8552 	beq.w	80178e0 <Zigbee_CallBackProcessing+0x1668>
 8016e3c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8016e3e:	685b      	ldr	r3, [r3, #4]
 8016e40:	2b00      	cmp	r3, #0
 8016e42:	f000 854d 	beq.w	80178e0 <Zigbee_CallBackProcessing+0x1668>
                struct ZbZdoDeviceAnnceT *msg;
                uint8_t seqno;
                unsigned int i;
                int (*callback)(struct ZigBeeT *zb, struct ZbZdoDeviceAnnceT *annce, uint8_t seqno, void *arg);

                for (i = 0; i < ZB_IPC_ZDO_FILTER_CB_LIST_MAX; i++) {
 8016e46:	2300      	movs	r3, #0
 8016e48:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 8016e4c:	e02a      	b.n	8016ea4 <Zigbee_CallBackProcessing+0xc2c>
                    /* Find the matching filter callback */
                    if (cb_info != &zdo_filter_cb_list[i]) {
 8016e4e:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8016e52:	4613      	mov	r3, r2
 8016e54:	005b      	lsls	r3, r3, #1
 8016e56:	4413      	add	r3, r2
 8016e58:	009b      	lsls	r3, r3, #2
 8016e5a:	4a47      	ldr	r2, [pc, #284]	; (8016f78 <Zigbee_CallBackProcessing+0xd00>)
 8016e5c:	4413      	add	r3, r2
 8016e5e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8016e60:	429a      	cmp	r2, r3
 8016e62:	d119      	bne.n	8016e98 <Zigbee_CallBackProcessing+0xc20>
                        continue;
                    }
                    if (cb_info->filter == NULL) {
 8016e64:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8016e66:	681b      	ldr	r3, [r3, #0]
 8016e68:	2b00      	cmp	r3, #0
 8016e6a:	d021      	beq.n	8016eb0 <Zigbee_CallBackProcessing+0xc38>
                        /* Shouldn't get here */
                        break;
                    }
                    /* Call the Device Annce callback */
                    msg = (struct ZbZdoDeviceAnnceT *)p_notification->Data[0];
 8016e6c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016e70:	689b      	ldr	r3, [r3, #8]
 8016e72:	67bb      	str	r3, [r7, #120]	; 0x78
                    seqno = (uint8_t)p_notification->Data[1];
 8016e74:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016e78:	68db      	ldr	r3, [r3, #12]
 8016e7a:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
                    callback = (int (*)(struct ZigBeeT *zb, struct ZbZdoDeviceAnnceT *annce, uint8_t seqno, void *arg))cb_info->callback;
 8016e7e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8016e80:	685b      	ldr	r3, [r3, #4]
 8016e82:	673b      	str	r3, [r7, #112]	; 0x70
                    callback(zb_ipc_globals.zb, msg, seqno, cb_info->arg);
 8016e84:	4b3d      	ldr	r3, [pc, #244]	; (8016f7c <Zigbee_CallBackProcessing+0xd04>)
 8016e86:	6818      	ldr	r0, [r3, #0]
 8016e88:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8016e8a:	689b      	ldr	r3, [r3, #8]
 8016e8c:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 8016e90:	6f3c      	ldr	r4, [r7, #112]	; 0x70
 8016e92:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8016e94:	47a0      	blx	r4
                    break;
 8016e96:	e00c      	b.n	8016eb2 <Zigbee_CallBackProcessing+0xc3a>
                        continue;
 8016e98:	bf00      	nop
                for (i = 0; i < ZB_IPC_ZDO_FILTER_CB_LIST_MAX; i++) {
 8016e9a:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8016e9e:	3301      	adds	r3, #1
 8016ea0:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 8016ea4:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8016ea8:	2b07      	cmp	r3, #7
 8016eaa:	d9d0      	bls.n	8016e4e <Zigbee_CallBackProcessing+0xbd6>
                }
            }
            break;
 8016eac:	f000 bd18 	b.w	80178e0 <Zigbee_CallBackProcessing+0x1668>
                        break;
 8016eb0:	bf00      	nop
            break;
 8016eb2:	f000 bd15 	b.w	80178e0 <Zigbee_CallBackProcessing+0x1668>
        }

        case MSG_M0TOM4_ZDO_NWK_ADDR_CB:
            assert(p_notification->Size == 2);
 8016eb6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016eba:	685b      	ldr	r3, [r3, #4]
 8016ebc:	2b02      	cmp	r3, #2
 8016ebe:	d006      	beq.n	8016ece <Zigbee_CallBackProcessing+0xc56>
 8016ec0:	4b29      	ldr	r3, [pc, #164]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016ec2:	4a2a      	ldr	r2, [pc, #168]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016ec4:	f640 7119 	movw	r1, #3865	; 0xf19
 8016ec8:	4829      	ldr	r0, [pc, #164]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016eca:	f001 f839 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016ece:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016ed2:	68db      	ldr	r3, [r3, #12]
 8016ed4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016ed8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016edc:	2b00      	cmp	r3, #0
 8016ede:	f000 8501 	beq.w	80178e4 <Zigbee_CallBackProcessing+0x166c>
 8016ee2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016ee6:	681b      	ldr	r3, [r3, #0]
 8016ee8:	2b00      	cmp	r3, #0
 8016eea:	f000 84fb 	beq.w	80178e4 <Zigbee_CallBackProcessing+0x166c>
                void (*callback)(struct ZbZdoNwkAddrRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoNwkAddrRspT *rsp, void *cbarg))info->callback;
 8016eee:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016ef2:	681b      	ldr	r3, [r3, #0]
 8016ef4:	653b      	str	r3, [r7, #80]	; 0x50
                callback((struct ZbZdoNwkAddrRspT *)p_notification->Data[0], info->arg);
 8016ef6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016efa:	689b      	ldr	r3, [r3, #8]
 8016efc:	4618      	mov	r0, r3
 8016efe:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016f02:	685a      	ldr	r2, [r3, #4]
 8016f04:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016f06:	4611      	mov	r1, r2
 8016f08:	4798      	blx	r3
            }
            break;
 8016f0a:	f000 bceb 	b.w	80178e4 <Zigbee_CallBackProcessing+0x166c>

        case MSG_M0TOM4_ZDO_IEEE_ADDR_CB:
            assert(p_notification->Size == 2);
 8016f0e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016f12:	685b      	ldr	r3, [r3, #4]
 8016f14:	2b02      	cmp	r3, #2
 8016f16:	d006      	beq.n	8016f26 <Zigbee_CallBackProcessing+0xcae>
 8016f18:	4b13      	ldr	r3, [pc, #76]	; (8016f68 <Zigbee_CallBackProcessing+0xcf0>)
 8016f1a:	4a14      	ldr	r2, [pc, #80]	; (8016f6c <Zigbee_CallBackProcessing+0xcf4>)
 8016f1c:	f640 7124 	movw	r1, #3876	; 0xf24
 8016f20:	4813      	ldr	r0, [pc, #76]	; (8016f70 <Zigbee_CallBackProcessing+0xcf8>)
 8016f22:	f001 f80d 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016f26:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016f2a:	68db      	ldr	r3, [r3, #12]
 8016f2c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016f30:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016f34:	2b00      	cmp	r3, #0
 8016f36:	f000 84d7 	beq.w	80178e8 <Zigbee_CallBackProcessing+0x1670>
 8016f3a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016f3e:	681b      	ldr	r3, [r3, #0]
 8016f40:	2b00      	cmp	r3, #0
 8016f42:	f000 84d1 	beq.w	80178e8 <Zigbee_CallBackProcessing+0x1670>
                void (*callback)(struct ZbZdoIeeeAddrRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoIeeeAddrRspT *rsp, void *cbarg))info->callback;
 8016f46:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016f4a:	681b      	ldr	r3, [r3, #0]
 8016f4c:	657b      	str	r3, [r7, #84]	; 0x54
                callback((struct ZbZdoIeeeAddrRspT *)p_notification->Data[0], info->arg);
 8016f4e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016f52:	689b      	ldr	r3, [r3, #8]
 8016f54:	4618      	mov	r0, r3
 8016f56:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016f5a:	685a      	ldr	r2, [r3, #4]
 8016f5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016f5e:	4611      	mov	r1, r2
 8016f60:	4798      	blx	r3
            }
            break;
 8016f62:	f000 bcc1 	b.w	80178e8 <Zigbee_CallBackProcessing+0x1670>
 8016f66:	bf00      	nop
 8016f68:	08019924 	.word	0x08019924
 8016f6c:	08019cf0 	.word	0x08019cf0
 8016f70:	0801985c 	.word	0x0801985c
 8016f74:	08019908 	.word	0x08019908
 8016f78:	200026a4 	.word	0x200026a4
 8016f7c:	20002510 	.word	0x20002510

        case MSG_M0TOM4_ZDO_NODE_DESC_CB:
            assert(p_notification->Size == 2);
 8016f80:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016f84:	685b      	ldr	r3, [r3, #4]
 8016f86:	2b02      	cmp	r3, #2
 8016f88:	d006      	beq.n	8016f98 <Zigbee_CallBackProcessing+0xd20>
 8016f8a:	4bc1      	ldr	r3, [pc, #772]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 8016f8c:	4ac1      	ldr	r2, [pc, #772]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 8016f8e:	f640 712f 	movw	r1, #3887	; 0xf2f
 8016f92:	48c1      	ldr	r0, [pc, #772]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 8016f94:	f000 ffd4 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016f98:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016f9c:	68db      	ldr	r3, [r3, #12]
 8016f9e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016fa2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016fa6:	2b00      	cmp	r3, #0
 8016fa8:	f000 84a0 	beq.w	80178ec <Zigbee_CallBackProcessing+0x1674>
 8016fac:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016fb0:	681b      	ldr	r3, [r3, #0]
 8016fb2:	2b00      	cmp	r3, #0
 8016fb4:	f000 849a 	beq.w	80178ec <Zigbee_CallBackProcessing+0x1674>
                void (*callback)(struct ZbZdoNodeDescRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoNodeDescRspT *rsp, void *cbarg))info->callback;
 8016fb8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016fbc:	681b      	ldr	r3, [r3, #0]
 8016fbe:	65bb      	str	r3, [r7, #88]	; 0x58
                callback((struct ZbZdoNodeDescRspT *)p_notification->Data[0], info->arg);
 8016fc0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016fc4:	689b      	ldr	r3, [r3, #8]
 8016fc6:	4618      	mov	r0, r3
 8016fc8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016fcc:	685a      	ldr	r2, [r3, #4]
 8016fce:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016fd0:	4611      	mov	r1, r2
 8016fd2:	4798      	blx	r3
            }
            break;
 8016fd4:	f000 bc8a 	b.w	80178ec <Zigbee_CallBackProcessing+0x1674>

        case MSG_M0TOM4_ZDO_POWER_DESC_CB:
            assert(p_notification->Size == 2);
 8016fd8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016fdc:	685b      	ldr	r3, [r3, #4]
 8016fde:	2b02      	cmp	r3, #2
 8016fe0:	d006      	beq.n	8016ff0 <Zigbee_CallBackProcessing+0xd78>
 8016fe2:	4bab      	ldr	r3, [pc, #684]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 8016fe4:	4aab      	ldr	r2, [pc, #684]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 8016fe6:	f640 713a 	movw	r1, #3898	; 0xf3a
 8016fea:	48ab      	ldr	r0, [pc, #684]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 8016fec:	f000 ffa8 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8016ff0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8016ff4:	68db      	ldr	r3, [r3, #12]
 8016ff6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8016ffa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8016ffe:	2b00      	cmp	r3, #0
 8017000:	f000 8476 	beq.w	80178f0 <Zigbee_CallBackProcessing+0x1678>
 8017004:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017008:	681b      	ldr	r3, [r3, #0]
 801700a:	2b00      	cmp	r3, #0
 801700c:	f000 8470 	beq.w	80178f0 <Zigbee_CallBackProcessing+0x1678>
                void (*callback)(struct ZbZdoPowerDescRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoPowerDescRspT *rsp, void *cbarg))info->callback;
 8017010:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017014:	681b      	ldr	r3, [r3, #0]
 8017016:	65fb      	str	r3, [r7, #92]	; 0x5c
                callback((struct ZbZdoPowerDescRspT *)p_notification->Data[0], info->arg);
 8017018:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801701c:	689b      	ldr	r3, [r3, #8]
 801701e:	4618      	mov	r0, r3
 8017020:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017024:	685a      	ldr	r2, [r3, #4]
 8017026:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017028:	4611      	mov	r1, r2
 801702a:	4798      	blx	r3
            }
            break;
 801702c:	f000 bc60 	b.w	80178f0 <Zigbee_CallBackProcessing+0x1678>

        case MSG_M0TOM4_ZDO_SIMPLE_DESC_CB:
            assert(p_notification->Size == 2);
 8017030:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017034:	685b      	ldr	r3, [r3, #4]
 8017036:	2b02      	cmp	r3, #2
 8017038:	d006      	beq.n	8017048 <Zigbee_CallBackProcessing+0xdd0>
 801703a:	4b95      	ldr	r3, [pc, #596]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 801703c:	4a95      	ldr	r2, [pc, #596]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 801703e:	f640 7145 	movw	r1, #3909	; 0xf45
 8017042:	4895      	ldr	r0, [pc, #596]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 8017044:	f000 ff7c 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8017048:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801704c:	68db      	ldr	r3, [r3, #12]
 801704e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017052:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017056:	2b00      	cmp	r3, #0
 8017058:	f000 844c 	beq.w	80178f4 <Zigbee_CallBackProcessing+0x167c>
 801705c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017060:	681b      	ldr	r3, [r3, #0]
 8017062:	2b00      	cmp	r3, #0
 8017064:	f000 8446 	beq.w	80178f4 <Zigbee_CallBackProcessing+0x167c>
                void (*callback)(struct ZbZdoSimpleDescRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoSimpleDescRspT *rsp, void *cbarg))info->callback;
 8017068:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801706c:	681b      	ldr	r3, [r3, #0]
 801706e:	663b      	str	r3, [r7, #96]	; 0x60
                callback((struct ZbZdoSimpleDescRspT *)p_notification->Data[0], info->arg);
 8017070:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017074:	689b      	ldr	r3, [r3, #8]
 8017076:	4618      	mov	r0, r3
 8017078:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801707c:	685a      	ldr	r2, [r3, #4]
 801707e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8017080:	4611      	mov	r1, r2
 8017082:	4798      	blx	r3
            }
            break;
 8017084:	f000 bc36 	b.w	80178f4 <Zigbee_CallBackProcessing+0x167c>

        case MSG_M0TOM4_ZDO_ACTIVE_EP_CB:
            assert(p_notification->Size == 2);
 8017088:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801708c:	685b      	ldr	r3, [r3, #4]
 801708e:	2b02      	cmp	r3, #2
 8017090:	d006      	beq.n	80170a0 <Zigbee_CallBackProcessing+0xe28>
 8017092:	4b7f      	ldr	r3, [pc, #508]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 8017094:	4a7f      	ldr	r2, [pc, #508]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 8017096:	f44f 6175 	mov.w	r1, #3920	; 0xf50
 801709a:	487f      	ldr	r0, [pc, #508]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 801709c:	f000 ff50 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80170a0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80170a4:	68db      	ldr	r3, [r3, #12]
 80170a6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80170aa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80170ae:	2b00      	cmp	r3, #0
 80170b0:	f000 8422 	beq.w	80178f8 <Zigbee_CallBackProcessing+0x1680>
 80170b4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80170b8:	681b      	ldr	r3, [r3, #0]
 80170ba:	2b00      	cmp	r3, #0
 80170bc:	f000 841c 	beq.w	80178f8 <Zigbee_CallBackProcessing+0x1680>
                void (*callback)(struct ZbZdoActiveEpRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoActiveEpRspT *rsp, void *cbarg))info->callback;
 80170c0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80170c4:	681b      	ldr	r3, [r3, #0]
 80170c6:	667b      	str	r3, [r7, #100]	; 0x64
                callback((struct ZbZdoActiveEpRspT *)p_notification->Data[0], info->arg);
 80170c8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80170cc:	689b      	ldr	r3, [r3, #8]
 80170ce:	4618      	mov	r0, r3
 80170d0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80170d4:	685a      	ldr	r2, [r3, #4]
 80170d6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80170d8:	4611      	mov	r1, r2
 80170da:	4798      	blx	r3
            }
            break;
 80170dc:	f000 bc0c 	b.w	80178f8 <Zigbee_CallBackProcessing+0x1680>

        case MSG_M0TOM4_ZDO_MATCH_DESC_CB:
            assert(p_notification->Size == 2);
 80170e0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80170e4:	685b      	ldr	r3, [r3, #4]
 80170e6:	2b02      	cmp	r3, #2
 80170e8:	d006      	beq.n	80170f8 <Zigbee_CallBackProcessing+0xe80>
 80170ea:	4b69      	ldr	r3, [pc, #420]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 80170ec:	4a69      	ldr	r2, [pc, #420]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 80170ee:	f640 715b 	movw	r1, #3931	; 0xf5b
 80170f2:	4869      	ldr	r0, [pc, #420]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 80170f4:	f000 ff24 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80170f8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80170fc:	68db      	ldr	r3, [r3, #12]
 80170fe:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017102:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017106:	2b00      	cmp	r3, #0
 8017108:	f000 83f8 	beq.w	80178fc <Zigbee_CallBackProcessing+0x1684>
 801710c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017110:	681b      	ldr	r3, [r3, #0]
 8017112:	2b00      	cmp	r3, #0
 8017114:	f000 83f2 	beq.w	80178fc <Zigbee_CallBackProcessing+0x1684>
                void (*callback)(struct ZbZdoMatchDescRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoMatchDescRspT *rsp, void *cbarg))info->callback;
 8017118:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801711c:	681b      	ldr	r3, [r3, #0]
 801711e:	66bb      	str	r3, [r7, #104]	; 0x68
                callback((struct ZbZdoMatchDescRspT *)p_notification->Data[0], info->arg);
 8017120:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017124:	689b      	ldr	r3, [r3, #8]
 8017126:	4618      	mov	r0, r3
 8017128:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801712c:	685a      	ldr	r2, [r3, #4]
 801712e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017130:	4611      	mov	r1, r2
 8017132:	4798      	blx	r3
            }
            break;
 8017134:	e3e2      	b.n	80178fc <Zigbee_CallBackProcessing+0x1684>

        case MSG_M0TOM4_ZDO_MATCH_DESC_MULTI_CB:
            /* Note, we're not using zb_ipc_m4_cb_info for this API, so we don't need
             * the callback argument. */
            assert(p_notification->Size == 1);
 8017136:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801713a:	685b      	ldr	r3, [r3, #4]
 801713c:	2b01      	cmp	r3, #1
 801713e:	d006      	beq.n	801714e <Zigbee_CallBackProcessing+0xed6>
 8017140:	4b56      	ldr	r3, [pc, #344]	; (801729c <Zigbee_CallBackProcessing+0x1024>)
 8017142:	4a54      	ldr	r2, [pc, #336]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 8017144:	f640 7168 	movw	r1, #3944	; 0xf68
 8017148:	4853      	ldr	r0, [pc, #332]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 801714a:	f000 fef9 	bl	8017f40 <__assert_func>
            if (zdo_match_multi_cb != NULL) {
 801714e:	4b54      	ldr	r3, [pc, #336]	; (80172a0 <Zigbee_CallBackProcessing+0x1028>)
 8017150:	681b      	ldr	r3, [r3, #0]
 8017152:	2b00      	cmp	r3, #0
 8017154:	f000 83d4 	beq.w	8017900 <Zigbee_CallBackProcessing+0x1688>
                struct ZbZdoMatchDescRspT *rsp;

                rsp = (struct ZbZdoMatchDescRspT *)p_notification->Data[0];
 8017158:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801715c:	689b      	ldr	r3, [r3, #8]
 801715e:	66fb      	str	r3, [r7, #108]	; 0x6c
                zdo_match_multi_cb(rsp, zdo_match_multi_arg);
 8017160:	4b4f      	ldr	r3, [pc, #316]	; (80172a0 <Zigbee_CallBackProcessing+0x1028>)
 8017162:	681b      	ldr	r3, [r3, #0]
 8017164:	4a4f      	ldr	r2, [pc, #316]	; (80172a4 <Zigbee_CallBackProcessing+0x102c>)
 8017166:	6812      	ldr	r2, [r2, #0]
 8017168:	4611      	mov	r1, r2
 801716a:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 801716c:	4798      	blx	r3
                if (rsp->status == ZB_ZDP_STATUS_TIMEOUT) {
 801716e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017170:	781b      	ldrb	r3, [r3, #0]
 8017172:	2b85      	cmp	r3, #133	; 0x85
 8017174:	f040 83c4 	bne.w	8017900 <Zigbee_CallBackProcessing+0x1688>
                    /* Release the callback */
                    zdo_match_multi_cb = NULL;
 8017178:	4b49      	ldr	r3, [pc, #292]	; (80172a0 <Zigbee_CallBackProcessing+0x1028>)
 801717a:	2200      	movs	r2, #0
 801717c:	601a      	str	r2, [r3, #0]
                }
            }
            break;
 801717e:	e3bf      	b.n	8017900 <Zigbee_CallBackProcessing+0x1688>

        case MSG_M0TOM4_ZDO_BIND_CB:
            assert(p_notification->Size == 2);
 8017180:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017184:	685b      	ldr	r3, [r3, #4]
 8017186:	2b02      	cmp	r3, #2
 8017188:	d006      	beq.n	8017198 <Zigbee_CallBackProcessing+0xf20>
 801718a:	4b41      	ldr	r3, [pc, #260]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 801718c:	4a41      	ldr	r2, [pc, #260]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 801718e:	f640 7176 	movw	r1, #3958	; 0xf76
 8017192:	4841      	ldr	r0, [pc, #260]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 8017194:	f000 fed4 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8017198:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801719c:	68db      	ldr	r3, [r3, #12]
 801719e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80171a2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80171a6:	2b00      	cmp	r3, #0
 80171a8:	f000 83ac 	beq.w	8017904 <Zigbee_CallBackProcessing+0x168c>
 80171ac:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80171b0:	681b      	ldr	r3, [r3, #0]
 80171b2:	2b00      	cmp	r3, #0
 80171b4:	f000 83a6 	beq.w	8017904 <Zigbee_CallBackProcessing+0x168c>
                void (*callback)(struct ZbZdoBindRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoBindRspT *rsp, void *cbarg))info->callback;
 80171b8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80171bc:	681b      	ldr	r3, [r3, #0]
 80171be:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                callback((struct ZbZdoBindRspT *)p_notification->Data[0], info->arg);
 80171c2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80171c6:	689b      	ldr	r3, [r3, #8]
 80171c8:	4618      	mov	r0, r3
 80171ca:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80171ce:	685a      	ldr	r2, [r3, #4]
 80171d0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80171d4:	4611      	mov	r1, r2
 80171d6:	4798      	blx	r3
            }
            break;
 80171d8:	e394      	b.n	8017904 <Zigbee_CallBackProcessing+0x168c>

        case MSG_M0TOM4_ZDO_UNBIND_CB:
            assert(p_notification->Size == 2);
 80171da:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80171de:	685b      	ldr	r3, [r3, #4]
 80171e0:	2b02      	cmp	r3, #2
 80171e2:	d006      	beq.n	80171f2 <Zigbee_CallBackProcessing+0xf7a>
 80171e4:	4b2a      	ldr	r3, [pc, #168]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 80171e6:	4a2b      	ldr	r2, [pc, #172]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 80171e8:	f640 7181 	movw	r1, #3969	; 0xf81
 80171ec:	482a      	ldr	r0, [pc, #168]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 80171ee:	f000 fea7 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80171f2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80171f6:	68db      	ldr	r3, [r3, #12]
 80171f8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80171fc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017200:	2b00      	cmp	r3, #0
 8017202:	f000 8381 	beq.w	8017908 <Zigbee_CallBackProcessing+0x1690>
 8017206:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801720a:	681b      	ldr	r3, [r3, #0]
 801720c:	2b00      	cmp	r3, #0
 801720e:	f000 837b 	beq.w	8017908 <Zigbee_CallBackProcessing+0x1690>
                void (*callback)(struct ZbZdoBindRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoBindRspT *rsp, void *cbarg))info->callback;
 8017212:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017216:	681b      	ldr	r3, [r3, #0]
 8017218:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                callback((struct ZbZdoBindRspT *)p_notification->Data[0], info->arg);
 801721c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017220:	689b      	ldr	r3, [r3, #8]
 8017222:	4618      	mov	r0, r3
 8017224:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017228:	685a      	ldr	r2, [r3, #4]
 801722a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801722e:	4611      	mov	r1, r2
 8017230:	4798      	blx	r3
            }
            break;
 8017232:	e369      	b.n	8017908 <Zigbee_CallBackProcessing+0x1690>

        case MSG_M0TOM4_ZDO_MGMT_LQI_CB:
            assert(p_notification->Size == 2);
 8017234:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017238:	685b      	ldr	r3, [r3, #4]
 801723a:	2b02      	cmp	r3, #2
 801723c:	d006      	beq.n	801724c <Zigbee_CallBackProcessing+0xfd4>
 801723e:	4b14      	ldr	r3, [pc, #80]	; (8017290 <Zigbee_CallBackProcessing+0x1018>)
 8017240:	4a14      	ldr	r2, [pc, #80]	; (8017294 <Zigbee_CallBackProcessing+0x101c>)
 8017242:	f640 718c 	movw	r1, #3980	; 0xf8c
 8017246:	4814      	ldr	r0, [pc, #80]	; (8017298 <Zigbee_CallBackProcessing+0x1020>)
 8017248:	f000 fe7a 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 801724c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017250:	68db      	ldr	r3, [r3, #12]
 8017252:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017256:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801725a:	2b00      	cmp	r3, #0
 801725c:	f000 8356 	beq.w	801790c <Zigbee_CallBackProcessing+0x1694>
 8017260:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017264:	681b      	ldr	r3, [r3, #0]
 8017266:	2b00      	cmp	r3, #0
 8017268:	f000 8350 	beq.w	801790c <Zigbee_CallBackProcessing+0x1694>
                void (*callback)(struct ZbZdoLqiRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoLqiRspT *rsp, void *cbarg))info->callback;
 801726c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017270:	681b      	ldr	r3, [r3, #0]
 8017272:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
                callback((struct ZbZdoLqiRspT *)p_notification->Data[0], info->arg);
 8017276:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801727a:	689b      	ldr	r3, [r3, #8]
 801727c:	4618      	mov	r0, r3
 801727e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017282:	685a      	ldr	r2, [r3, #4]
 8017284:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8017288:	4611      	mov	r1, r2
 801728a:	4798      	blx	r3
            }
            break;
 801728c:	e33e      	b.n	801790c <Zigbee_CallBackProcessing+0x1694>
 801728e:	bf00      	nop
 8017290:	08019924 	.word	0x08019924
 8017294:	08019cf0 	.word	0x08019cf0
 8017298:	0801985c 	.word	0x0801985c
 801729c:	080198ec 	.word	0x080198ec
 80172a0:	20002508 	.word	0x20002508
 80172a4:	2000250c 	.word	0x2000250c

        case MSG_M0TOM4_ZDO_MGMT_RTG_CB:
            assert(p_notification->Size == 2);
 80172a8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80172ac:	685b      	ldr	r3, [r3, #4]
 80172ae:	2b02      	cmp	r3, #2
 80172b0:	d006      	beq.n	80172c0 <Zigbee_CallBackProcessing+0x1048>
 80172b2:	4bc5      	ldr	r3, [pc, #788]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 80172b4:	4ac5      	ldr	r2, [pc, #788]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 80172b6:	f640 7197 	movw	r1, #3991	; 0xf97
 80172ba:	48c5      	ldr	r0, [pc, #788]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 80172bc:	f000 fe40 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80172c0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80172c4:	68db      	ldr	r3, [r3, #12]
 80172c6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80172ca:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80172ce:	2b00      	cmp	r3, #0
 80172d0:	f000 831e 	beq.w	8017910 <Zigbee_CallBackProcessing+0x1698>
 80172d4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80172d8:	681b      	ldr	r3, [r3, #0]
 80172da:	2b00      	cmp	r3, #0
 80172dc:	f000 8318 	beq.w	8017910 <Zigbee_CallBackProcessing+0x1698>
                void (*callback)(struct ZbZdoRtgRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoRtgRspT *rsp, void *cbarg))info->callback;
 80172e0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80172e4:	681b      	ldr	r3, [r3, #0]
 80172e6:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                callback((struct ZbZdoRtgRspT *)p_notification->Data[0], info->arg);
 80172ea:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80172ee:	689b      	ldr	r3, [r3, #8]
 80172f0:	4618      	mov	r0, r3
 80172f2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80172f6:	685a      	ldr	r2, [r3, #4]
 80172f8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80172fc:	4611      	mov	r1, r2
 80172fe:	4798      	blx	r3
            }
            break;
 8017300:	e306      	b.n	8017910 <Zigbee_CallBackProcessing+0x1698>

        case MSG_M0TOM4_ZDO_MGMT_BIND_CB:
            assert(p_notification->Size == 2);
 8017302:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017306:	685b      	ldr	r3, [r3, #4]
 8017308:	2b02      	cmp	r3, #2
 801730a:	d006      	beq.n	801731a <Zigbee_CallBackProcessing+0x10a2>
 801730c:	4bae      	ldr	r3, [pc, #696]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 801730e:	4aaf      	ldr	r2, [pc, #700]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 8017310:	f640 71a2 	movw	r1, #4002	; 0xfa2
 8017314:	48ae      	ldr	r0, [pc, #696]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 8017316:	f000 fe13 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 801731a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801731e:	68db      	ldr	r3, [r3, #12]
 8017320:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017324:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017328:	2b00      	cmp	r3, #0
 801732a:	f000 82f3 	beq.w	8017914 <Zigbee_CallBackProcessing+0x169c>
 801732e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017332:	681b      	ldr	r3, [r3, #0]
 8017334:	2b00      	cmp	r3, #0
 8017336:	f000 82ed 	beq.w	8017914 <Zigbee_CallBackProcessing+0x169c>
                void (*callback)(struct ZbZdoMgmtBindRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoMgmtBindRspT *rsp, void *cbarg))info->callback;
 801733a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801733e:	681b      	ldr	r3, [r3, #0]
 8017340:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                callback((struct ZbZdoMgmtBindRspT *)p_notification->Data[0], info->arg);
 8017344:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017348:	689b      	ldr	r3, [r3, #8]
 801734a:	4618      	mov	r0, r3
 801734c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017350:	685a      	ldr	r2, [r3, #4]
 8017352:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017356:	4611      	mov	r1, r2
 8017358:	4798      	blx	r3
            }
            break;
 801735a:	e2db      	b.n	8017914 <Zigbee_CallBackProcessing+0x169c>

        case MSG_M0TOM4_ZDO_MGMT_LEAVE_CB:
            assert(p_notification->Size == 2);
 801735c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017360:	685b      	ldr	r3, [r3, #4]
 8017362:	2b02      	cmp	r3, #2
 8017364:	d006      	beq.n	8017374 <Zigbee_CallBackProcessing+0x10fc>
 8017366:	4b98      	ldr	r3, [pc, #608]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 8017368:	4a98      	ldr	r2, [pc, #608]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 801736a:	f640 71ad 	movw	r1, #4013	; 0xfad
 801736e:	4898      	ldr	r0, [pc, #608]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 8017370:	f000 fde6 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8017374:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017378:	68db      	ldr	r3, [r3, #12]
 801737a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 801737e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017382:	2b00      	cmp	r3, #0
 8017384:	f000 82c8 	beq.w	8017918 <Zigbee_CallBackProcessing+0x16a0>
 8017388:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801738c:	681b      	ldr	r3, [r3, #0]
 801738e:	2b00      	cmp	r3, #0
 8017390:	f000 82c2 	beq.w	8017918 <Zigbee_CallBackProcessing+0x16a0>
                void (*callback)(struct ZbZdoLeaveRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoLeaveRspT *rsp, void *cbarg))info->callback;
 8017394:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017398:	681b      	ldr	r3, [r3, #0]
 801739a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
                callback((struct ZbZdoLeaveRspT *)p_notification->Data[0], info->arg);
 801739e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80173a2:	689b      	ldr	r3, [r3, #8]
 80173a4:	4618      	mov	r0, r3
 80173a6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80173aa:	685a      	ldr	r2, [r3, #4]
 80173ac:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80173b0:	4611      	mov	r1, r2
 80173b2:	4798      	blx	r3
            }
            break;
 80173b4:	e2b0      	b.n	8017918 <Zigbee_CallBackProcessing+0x16a0>

        case MSG_M0TOM4_ZDO_MGMT_PERMIT_JOIN_CB:
            assert(p_notification->Size == 2);
 80173b6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80173ba:	685b      	ldr	r3, [r3, #4]
 80173bc:	2b02      	cmp	r3, #2
 80173be:	d006      	beq.n	80173ce <Zigbee_CallBackProcessing+0x1156>
 80173c0:	4b81      	ldr	r3, [pc, #516]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 80173c2:	4a82      	ldr	r2, [pc, #520]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 80173c4:	f640 71b8 	movw	r1, #4024	; 0xfb8
 80173c8:	4881      	ldr	r0, [pc, #516]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 80173ca:	f000 fdb9 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80173ce:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80173d2:	68db      	ldr	r3, [r3, #12]
 80173d4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80173d8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80173dc:	2b00      	cmp	r3, #0
 80173de:	f000 829d 	beq.w	801791c <Zigbee_CallBackProcessing+0x16a4>
 80173e2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80173e6:	681b      	ldr	r3, [r3, #0]
 80173e8:	2b00      	cmp	r3, #0
 80173ea:	f000 8297 	beq.w	801791c <Zigbee_CallBackProcessing+0x16a4>
                void (*callback)(struct ZbZdoPermitJoinRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoPermitJoinRspT *rsp, void *cbarg))info->callback;
 80173ee:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80173f2:	681b      	ldr	r3, [r3, #0]
 80173f4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                callback((struct ZbZdoPermitJoinRspT *)p_notification->Data[0], info->arg);
 80173f8:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80173fc:	689b      	ldr	r3, [r3, #8]
 80173fe:	4618      	mov	r0, r3
 8017400:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017404:	685a      	ldr	r2, [r3, #4]
 8017406:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801740a:	4611      	mov	r1, r2
 801740c:	4798      	blx	r3
            }
            break;
 801740e:	e285      	b.n	801791c <Zigbee_CallBackProcessing+0x16a4>

        case MSG_M0TOM4_ZDO_MGMT_NWK_UPDATE_CB:
            assert(p_notification->Size == 2);
 8017410:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017414:	685b      	ldr	r3, [r3, #4]
 8017416:	2b02      	cmp	r3, #2
 8017418:	d006      	beq.n	8017428 <Zigbee_CallBackProcessing+0x11b0>
 801741a:	4b6b      	ldr	r3, [pc, #428]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 801741c:	4a6b      	ldr	r2, [pc, #428]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 801741e:	f640 71c3 	movw	r1, #4035	; 0xfc3
 8017422:	486b      	ldr	r0, [pc, #428]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 8017424:	f000 fd8c 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8017428:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801742c:	68db      	ldr	r3, [r3, #12]
 801742e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017432:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017436:	2b00      	cmp	r3, #0
 8017438:	f000 8272 	beq.w	8017920 <Zigbee_CallBackProcessing+0x16a8>
 801743c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017440:	681b      	ldr	r3, [r3, #0]
 8017442:	2b00      	cmp	r3, #0
 8017444:	f000 826c 	beq.w	8017920 <Zigbee_CallBackProcessing+0x16a8>
                void (*callback)(struct ZbZdoNwkUpdateNotifyT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZdoNwkUpdateNotifyT *rsp, void *cbarg))info->callback;
 8017448:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801744c:	681b      	ldr	r3, [r3, #0]
 801744e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
                callback((struct ZbZdoNwkUpdateNotifyT *)p_notification->Data[0], info->arg);
 8017452:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017456:	689b      	ldr	r3, [r3, #8]
 8017458:	4618      	mov	r0, r3
 801745a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801745e:	685a      	ldr	r2, [r3, #4]
 8017460:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8017464:	4611      	mov	r1, r2
 8017466:	4798      	blx	r3
            }
            break;
 8017468:	e25a      	b.n	8017920 <Zigbee_CallBackProcessing+0x16a8>

        case MSG_M0TOM4_ZDO_MGMT_NWK_UPDATE_FILTER_CB:
        {
            struct zdo_filter_cb_info_t *cb_info;

            assert(p_notification->Size == 3);
 801746a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801746e:	685b      	ldr	r3, [r3, #4]
 8017470:	2b03      	cmp	r3, #3
 8017472:	d006      	beq.n	8017482 <Zigbee_CallBackProcessing+0x120a>
 8017474:	4b57      	ldr	r3, [pc, #348]	; (80175d4 <Zigbee_CallBackProcessing+0x135c>)
 8017476:	4a55      	ldr	r2, [pc, #340]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 8017478:	f640 71d1 	movw	r1, #4049	; 0xfd1
 801747c:	4854      	ldr	r0, [pc, #336]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 801747e:	f000 fd5f 	bl	8017f40 <__assert_func>
            cb_info = (void *)p_notification->Data[2];
 8017482:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017486:	691b      	ldr	r3, [r3, #16]
 8017488:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
            if ((cb_info != NULL) && (cb_info->callback != NULL)) {
 801748c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8017490:	2b00      	cmp	r3, #0
 8017492:	f000 8247 	beq.w	8017924 <Zigbee_CallBackProcessing+0x16ac>
 8017496:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801749a:	685b      	ldr	r3, [r3, #4]
 801749c:	2b00      	cmp	r3, #0
 801749e:	f000 8241 	beq.w	8017924 <Zigbee_CallBackProcessing+0x16ac>
                struct ZbZdoNwkUpdateNotifyT *msg;
                uint8_t seqno;
                unsigned int i;
                int (*callback)(struct ZigBeeT *zb, struct ZbZdoNwkUpdateNotifyT *msg, uint8_t seqno, void *arg);

                for (i = 0; i < ZB_IPC_ZDO_FILTER_CB_LIST_MAX; i++) {
 80174a2:	2300      	movs	r3, #0
 80174a4:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 80174a8:	e032      	b.n	8017510 <Zigbee_CallBackProcessing+0x1298>
                    /* Find the matching filter callback */
                    if (cb_info != &zdo_filter_cb_list[i]) {
 80174aa:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 80174ae:	4613      	mov	r3, r2
 80174b0:	005b      	lsls	r3, r3, #1
 80174b2:	4413      	add	r3, r2
 80174b4:	009b      	lsls	r3, r3, #2
 80174b6:	4a48      	ldr	r2, [pc, #288]	; (80175d8 <Zigbee_CallBackProcessing+0x1360>)
 80174b8:	4413      	add	r3, r2
 80174ba:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80174be:	429a      	cmp	r2, r3
 80174c0:	d120      	bne.n	8017504 <Zigbee_CallBackProcessing+0x128c>
                        continue;
                    }
                    if (cb_info->filter == NULL) {
 80174c2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80174c6:	681b      	ldr	r3, [r3, #0]
 80174c8:	2b00      	cmp	r3, #0
 80174ca:	d026      	beq.n	801751a <Zigbee_CallBackProcessing+0x12a2>
                        /* Shouldn't get here */
                        break;
                    }
                    msg = (struct ZbZdoNwkUpdateNotifyT *)p_notification->Data[0];
 80174cc:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80174d0:	689b      	ldr	r3, [r3, #8]
 80174d2:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
                    seqno = (uint8_t)p_notification->Data[1];
 80174d6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80174da:	68db      	ldr	r3, [r3, #12]
 80174dc:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
                    callback = (int (*)(struct ZigBeeT *zb, struct ZbZdoNwkUpdateNotifyT *msg, uint8_t seqno, void *arg))cb_info->callback;
 80174e0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80174e4:	685b      	ldr	r3, [r3, #4]
 80174e6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
                    callback(zb_ipc_globals.zb, msg, seqno, cb_info->arg);
 80174ea:	4b3c      	ldr	r3, [pc, #240]	; (80175dc <Zigbee_CallBackProcessing+0x1364>)
 80174ec:	6818      	ldr	r0, [r3, #0]
 80174ee:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80174f2:	689b      	ldr	r3, [r3, #8]
 80174f4:	f897 20a7 	ldrb.w	r2, [r7, #167]	; 0xa7
 80174f8:	f8d7 40a0 	ldr.w	r4, [r7, #160]	; 0xa0
 80174fc:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 8017500:	47a0      	blx	r4
                    break;
 8017502:	e00b      	b.n	801751c <Zigbee_CallBackProcessing+0x12a4>
                        continue;
 8017504:	bf00      	nop
                for (i = 0; i < ZB_IPC_ZDO_FILTER_CB_LIST_MAX; i++) {
 8017506:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801750a:	3301      	adds	r3, #1
 801750c:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 8017510:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8017514:	2b07      	cmp	r3, #7
 8017516:	d9c8      	bls.n	80174aa <Zigbee_CallBackProcessing+0x1232>
                }
            }
            break;
 8017518:	e204      	b.n	8017924 <Zigbee_CallBackProcessing+0x16ac>
                        break;
 801751a:	bf00      	nop
            break;
 801751c:	e202      	b.n	8017924 <Zigbee_CallBackProcessing+0x16ac>
        {
            struct ZbApsdeDataIndT *dataIndPtr;
            void *cb_arg;
            int err;

            assert(p_notification->Size == 2);
 801751e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017522:	685b      	ldr	r3, [r3, #4]
 8017524:	2b02      	cmp	r3, #2
 8017526:	d006      	beq.n	8017536 <Zigbee_CallBackProcessing+0x12be>
 8017528:	4b27      	ldr	r3, [pc, #156]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 801752a:	4a28      	ldr	r2, [pc, #160]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 801752c:	f640 71f2 	movw	r1, #4082	; 0xff2
 8017530:	4827      	ldr	r0, [pc, #156]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 8017532:	f000 fd05 	bl	8017f40 <__assert_func>
            dataIndPtr = (struct ZbApsdeDataIndT *)p_notification->Data[0];
 8017536:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801753a:	689b      	ldr	r3, [r3, #8]
 801753c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
            cb_arg = (void *)p_notification->Data[1];
 8017540:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017544:	68db      	ldr	r3, [r3, #12]
 8017546:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
            err = zcl_cluster_data_ind(dataIndPtr, cb_arg);
 801754a:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
 801754e:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 8017552:	f7e9 fbf9 	bl	8000d48 <zcl_cluster_data_ind>
 8017556:	f8c7 00d8 	str.w	r0, [r7, #216]	; 0xd8
            /* Return err in second argument */
            p_notification->Data[1] = (uint32_t)err;
 801755a:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 801755e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017562:	60da      	str	r2, [r3, #12]
            break;
 8017564:	e1f7      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
        {
            struct ZbApsdeDataIndT *dataIndPtr;
            void *cb_arg;
            int err;

            assert(p_notification->Size == 2);
 8017566:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801756a:	685b      	ldr	r3, [r3, #4]
 801756c:	2b02      	cmp	r3, #2
 801756e:	d006      	beq.n	801757e <Zigbee_CallBackProcessing+0x1306>
 8017570:	4b15      	ldr	r3, [pc, #84]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 8017572:	4a16      	ldr	r2, [pc, #88]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 8017574:	f241 0101 	movw	r1, #4097	; 0x1001
 8017578:	4815      	ldr	r0, [pc, #84]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 801757a:	f000 fce1 	bl	8017f40 <__assert_func>
            dataIndPtr = (struct ZbApsdeDataIndT *)p_notification->Data[0];
 801757e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017582:	689b      	ldr	r3, [r3, #8]
 8017584:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
            cb_arg = (void *)p_notification->Data[1];
 8017588:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801758c:	68db      	ldr	r3, [r3, #12]
 801758e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
            err = zcl_cluster_alarm_data_ind(dataIndPtr, cb_arg);
 8017592:	f8d7 10e8 	ldr.w	r1, [r7, #232]	; 0xe8
 8017596:	f8d7 00ec 	ldr.w	r0, [r7, #236]	; 0xec
 801759a:	f7e9 fbef 	bl	8000d7c <zcl_cluster_alarm_data_ind>
 801759e:	f8c7 00e4 	str.w	r0, [r7, #228]	; 0xe4
            /* Return err in second argument */
            p_notification->Data[1] = (uint32_t)err;
 80175a2:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 80175a6:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80175aa:	60da      	str	r2, [r3, #12]
            break;
 80175ac:	e1d3      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
        }

        case MSG_M0TOM4_ZCL_CLUSTER_CMD_RSP_CONF_CB:
            assert(p_notification->Size == 2);
 80175ae:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80175b2:	685b      	ldr	r3, [r3, #4]
 80175b4:	2b02      	cmp	r3, #2
 80175b6:	d013      	beq.n	80175e0 <Zigbee_CallBackProcessing+0x1368>
 80175b8:	4b03      	ldr	r3, [pc, #12]	; (80175c8 <Zigbee_CallBackProcessing+0x1350>)
 80175ba:	4a04      	ldr	r2, [pc, #16]	; (80175cc <Zigbee_CallBackProcessing+0x1354>)
 80175bc:	f241 010b 	movw	r1, #4107	; 0x100b
 80175c0:	4803      	ldr	r0, [pc, #12]	; (80175d0 <Zigbee_CallBackProcessing+0x1358>)
 80175c2:	f000 fcbd 	bl	8017f40 <__assert_func>
 80175c6:	bf00      	nop
 80175c8:	08019924 	.word	0x08019924
 80175cc:	08019cf0 	.word	0x08019cf0
 80175d0:	0801985c 	.word	0x0801985c
 80175d4:	08019908 	.word	0x08019908
 80175d8:	200026a4 	.word	0x200026a4
 80175dc:	20002510 	.word	0x20002510
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80175e0:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80175e4:	68db      	ldr	r3, [r3, #12]
 80175e6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80175ea:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80175ee:	2b00      	cmp	r3, #0
 80175f0:	f000 81a8 	beq.w	8017944 <Zigbee_CallBackProcessing+0x16cc>
 80175f4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80175f8:	681b      	ldr	r3, [r3, #0]
 80175fa:	2b00      	cmp	r3, #0
 80175fc:	f000 81a2 	beq.w	8017944 <Zigbee_CallBackProcessing+0x16cc>
                void (*callback)(struct ZbApsdeDataConfT *conf, void *arg);

                callback = (void (*)(struct ZbApsdeDataConfT *conf, void *arg))info->callback;
 8017600:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017604:	681b      	ldr	r3, [r3, #0]
 8017606:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
                callback((struct ZbApsdeDataConfT *)p_notification->Data[0], info->arg);
 801760a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801760e:	689b      	ldr	r3, [r3, #8]
 8017610:	4618      	mov	r0, r3
 8017612:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017616:	685a      	ldr	r2, [r3, #4]
 8017618:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 801761c:	4611      	mov	r1, r2
 801761e:	4798      	blx	r3
            }
            break;
 8017620:	e190      	b.n	8017944 <Zigbee_CallBackProcessing+0x16cc>

        case MSG_M0TOM4_ZCL_COMMAND_REQ_CB:
        {
            int err = ZB_APS_FILTER_CONTINUE;
 8017622:	2300      	movs	r3, #0
 8017624:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

            assert(p_notification->Size == 2);
 8017628:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801762c:	685b      	ldr	r3, [r3, #4]
 801762e:	2b02      	cmp	r3, #2
 8017630:	d006      	beq.n	8017640 <Zigbee_CallBackProcessing+0x13c8>
 8017632:	4bbd      	ldr	r3, [pc, #756]	; (8017928 <Zigbee_CallBackProcessing+0x16b0>)
 8017634:	4abd      	ldr	r2, [pc, #756]	; (801792c <Zigbee_CallBackProcessing+0x16b4>)
 8017636:	f241 0119 	movw	r1, #4121	; 0x1019
 801763a:	48bd      	ldr	r0, [pc, #756]	; (8017930 <Zigbee_CallBackProcessing+0x16b8>)
 801763c:	f000 fc80 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8017640:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017644:	68db      	ldr	r3, [r3, #12]
 8017646:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            /* Note: shouldn't get here if callback was NULL in request, so info should
             * always be non-NULL. */
            if (info != NULL) {
 801764a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801764e:	2b00      	cmp	r3, #0
 8017650:	d026      	beq.n	80176a0 <Zigbee_CallBackProcessing+0x1428>
                struct ZbZclCommandRspT *zcl_rsp = (struct ZbZclCommandRspT *)p_notification->Data[0];
 8017652:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017656:	689b      	ldr	r3, [r3, #8]
 8017658:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8

                if (info->callback != NULL) {
 801765c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017660:	681b      	ldr	r3, [r3, #0]
 8017662:	2b00      	cmp	r3, #0
 8017664:	d00f      	beq.n	8017686 <Zigbee_CallBackProcessing+0x140e>
                    int (*callback)(struct ZbZclCommandRspT *conf, void *arg);

                    callback = (int (*)(struct ZbZclCommandRspT *rsp, void *arg))info->callback;
 8017666:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801766a:	681b      	ldr	r3, [r3, #0]
 801766c:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
                    err = callback(zcl_rsp, info->arg);
 8017670:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017674:	685a      	ldr	r2, [r3, #4]
 8017676:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 801767a:	4611      	mov	r1, r2
 801767c:	f8d7 00f8 	ldr.w	r0, [r7, #248]	; 0xf8
 8017680:	4798      	blx	r3
 8017682:	f8c7 0110 	str.w	r0, [r7, #272]	; 0x110
                }
                if (info->zcl_recv_multi_rsp && (zcl_rsp->status != ZCL_STATUS_TIMEOUT)) {
 8017686:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801768a:	7a1b      	ldrb	r3, [r3, #8]
 801768c:	2b00      	cmp	r3, #0
 801768e:	d007      	beq.n	80176a0 <Zigbee_CallBackProcessing+0x1428>
 8017690:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8017694:	785b      	ldrb	r3, [r3, #1]
 8017696:	2b94      	cmp	r3, #148	; 0x94
 8017698:	d002      	beq.n	80176a0 <Zigbee_CallBackProcessing+0x1428>
                    /* Don't free the callback yet */
                    info = NULL;
 801769a:	2300      	movs	r3, #0
 801769c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
                }
            }
            /* Return err in second argument */
            p_notification->Data[1] = (uint32_t)err;
 80176a0:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 80176a4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80176a8:	60da      	str	r2, [r3, #12]
            break;
 80176aa:	e154      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
        }

        case MSG_M0TOM4_ZCL_READ_CB:
            assert(p_notification->Size == 2);
 80176ac:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80176b0:	685b      	ldr	r3, [r3, #4]
 80176b2:	2b02      	cmp	r3, #2
 80176b4:	d006      	beq.n	80176c4 <Zigbee_CallBackProcessing+0x144c>
 80176b6:	4b9c      	ldr	r3, [pc, #624]	; (8017928 <Zigbee_CallBackProcessing+0x16b0>)
 80176b8:	4a9c      	ldr	r2, [pc, #624]	; (801792c <Zigbee_CallBackProcessing+0x16b4>)
 80176ba:	f241 0131 	movw	r1, #4145	; 0x1031
 80176be:	489c      	ldr	r0, [pc, #624]	; (8017930 <Zigbee_CallBackProcessing+0x16b8>)
 80176c0:	f000 fc3e 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 80176c4:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80176c8:	68db      	ldr	r3, [r3, #12]
 80176ca:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80176ce:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80176d2:	2b00      	cmp	r3, #0
 80176d4:	f000 8138 	beq.w	8017948 <Zigbee_CallBackProcessing+0x16d0>
 80176d8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80176dc:	681b      	ldr	r3, [r3, #0]
 80176de:	2b00      	cmp	r3, #0
 80176e0:	f000 8132 	beq.w	8017948 <Zigbee_CallBackProcessing+0x16d0>
                void (*callback)(struct ZbZclReadRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZclReadRspT *rsp, void *cbarg))info->callback;
 80176e4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80176e8:	681b      	ldr	r3, [r3, #0]
 80176ea:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
                callback((struct ZbZclReadRspT *)p_notification->Data[0], info->arg);
 80176ee:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80176f2:	689b      	ldr	r3, [r3, #8]
 80176f4:	4618      	mov	r0, r3
 80176f6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80176fa:	685a      	ldr	r2, [r3, #4]
 80176fc:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8017700:	4611      	mov	r1, r2
 8017702:	4798      	blx	r3
            }
            break;
 8017704:	e120      	b.n	8017948 <Zigbee_CallBackProcessing+0x16d0>

        case MSG_M0TOM4_ZCL_WRITE_CB:
            assert(p_notification->Size == 2);
 8017706:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801770a:	685b      	ldr	r3, [r3, #4]
 801770c:	2b02      	cmp	r3, #2
 801770e:	d006      	beq.n	801771e <Zigbee_CallBackProcessing+0x14a6>
 8017710:	4b85      	ldr	r3, [pc, #532]	; (8017928 <Zigbee_CallBackProcessing+0x16b0>)
 8017712:	4a86      	ldr	r2, [pc, #536]	; (801792c <Zigbee_CallBackProcessing+0x16b4>)
 8017714:	f241 013c 	movw	r1, #4156	; 0x103c
 8017718:	4885      	ldr	r0, [pc, #532]	; (8017930 <Zigbee_CallBackProcessing+0x16b8>)
 801771a:	f000 fc11 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 801771e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017722:	68db      	ldr	r3, [r3, #12]
 8017724:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017728:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801772c:	2b00      	cmp	r3, #0
 801772e:	f000 810d 	beq.w	801794c <Zigbee_CallBackProcessing+0x16d4>
 8017732:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017736:	681b      	ldr	r3, [r3, #0]
 8017738:	2b00      	cmp	r3, #0
 801773a:	f000 8107 	beq.w	801794c <Zigbee_CallBackProcessing+0x16d4>
                void (*callback)(struct ZbZclWriteRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZclWriteRspT *rsp, void *cbarg))info->callback;
 801773e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017742:	681b      	ldr	r3, [r3, #0]
 8017744:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
                callback((struct ZbZclWriteRspT *)p_notification->Data[0], info->arg);
 8017748:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801774c:	689b      	ldr	r3, [r3, #8]
 801774e:	4618      	mov	r0, r3
 8017750:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017754:	685a      	ldr	r2, [r3, #4]
 8017756:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801775a:	4611      	mov	r1, r2
 801775c:	4798      	blx	r3
            }
            break;
 801775e:	e0f5      	b.n	801794c <Zigbee_CallBackProcessing+0x16d4>

        case MSG_M0TOM4_ZCL_DISCOVER_ATTR_CB:
            assert(p_notification->Size == 2);
 8017760:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017764:	685b      	ldr	r3, [r3, #4]
 8017766:	2b02      	cmp	r3, #2
 8017768:	d006      	beq.n	8017778 <Zigbee_CallBackProcessing+0x1500>
 801776a:	4b6f      	ldr	r3, [pc, #444]	; (8017928 <Zigbee_CallBackProcessing+0x16b0>)
 801776c:	4a6f      	ldr	r2, [pc, #444]	; (801792c <Zigbee_CallBackProcessing+0x16b4>)
 801776e:	f241 0147 	movw	r1, #4167	; 0x1047
 8017772:	486f      	ldr	r0, [pc, #444]	; (8017930 <Zigbee_CallBackProcessing+0x16b8>)
 8017774:	f000 fbe4 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[1];
 8017778:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801777c:	68db      	ldr	r3, [r3, #12]
 801777e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 8017782:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017786:	2b00      	cmp	r3, #0
 8017788:	f000 80e2 	beq.w	8017950 <Zigbee_CallBackProcessing+0x16d8>
 801778c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017790:	681b      	ldr	r3, [r3, #0]
 8017792:	2b00      	cmp	r3, #0
 8017794:	f000 80dc 	beq.w	8017950 <Zigbee_CallBackProcessing+0x16d8>
                void (*callback)(struct ZbZclDiscoverAttrRspT *rsp, void *cbarg);

                callback = (void (*)(struct ZbZclDiscoverAttrRspT *rsp, void *cbarg))info->callback;
 8017798:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801779c:	681b      	ldr	r3, [r3, #0]
 801779e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                callback((struct ZbZclDiscoverAttrRspT *)p_notification->Data[0], info->arg);
 80177a2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80177a6:	689b      	ldr	r3, [r3, #8]
 80177a8:	4618      	mov	r0, r3
 80177aa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80177ae:	685a      	ldr	r2, [r3, #4]
 80177b0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80177b4:	4611      	mov	r1, r2
 80177b6:	4798      	blx	r3
            }
            break;
 80177b8:	e0ca      	b.n	8017950 <Zigbee_CallBackProcessing+0x16d8>

        case MSG_M0TOM4_ZCL_KE_WITH_DEVICE_CB:
            assert(p_notification->Size == 5);
 80177ba:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80177be:	685b      	ldr	r3, [r3, #4]
 80177c0:	2b05      	cmp	r3, #5
 80177c2:	d006      	beq.n	80177d2 <Zigbee_CallBackProcessing+0x155a>
 80177c4:	4b5b      	ldr	r3, [pc, #364]	; (8017934 <Zigbee_CallBackProcessing+0x16bc>)
 80177c6:	4a59      	ldr	r2, [pc, #356]	; (801792c <Zigbee_CallBackProcessing+0x16b4>)
 80177c8:	f241 0152 	movw	r1, #4178	; 0x1052
 80177cc:	4858      	ldr	r0, [pc, #352]	; (8017930 <Zigbee_CallBackProcessing+0x16b8>)
 80177ce:	f000 fbb7 	bl	8017f40 <__assert_func>
            info = (struct zb_ipc_m4_cb_info_t *)p_notification->Data[4];
 80177d2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80177d6:	699b      	ldr	r3, [r3, #24]
 80177d8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
            if ((info != NULL) && (info->callback != NULL)) {
 80177dc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80177e0:	2b00      	cmp	r3, #0
 80177e2:	f000 80b7 	beq.w	8017954 <Zigbee_CallBackProcessing+0x16dc>
 80177e6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80177ea:	681b      	ldr	r3, [r3, #0]
 80177ec:	2b00      	cmp	r3, #0
 80177ee:	f000 80b1 	beq.w	8017954 <Zigbee_CallBackProcessing+0x16dc>
                void (*callback)(uint64_t partnerAddr, uint16_t keSuite, enum ZbZclKeyStatusT key_status, void *arg);
                uint64_t partnerAddr;

                zb_ipc_m4_memcpy2(&partnerAddr, (void *)&p_notification->Data[0], 8);
 80177f2:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 80177f6:	f103 0108 	add.w	r1, r3, #8
 80177fa:	463b      	mov	r3, r7
 80177fc:	2208      	movs	r2, #8
 80177fe:	4618      	mov	r0, r3
 8017800:	f7fd fce5 	bl	80151ce <zb_ipc_m4_memcpy2>
                callback = (void (*)(uint64_t partnerAddr, uint16_t keSuite, enum ZbZclKeyStatusT key_status, void *arg))info->callback;
 8017804:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017808:	681b      	ldr	r3, [r3, #0]
 801780a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
                callback(partnerAddr, (uint16_t)p_notification->Data[2], (enum ZbZclKeyStatusT)p_notification->Data[3], info->arg);
 801780e:	e9d7 0100 	ldrd	r0, r1, [r7]
 8017812:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017816:	691b      	ldr	r3, [r3, #16]
 8017818:	b29a      	uxth	r2, r3
 801781a:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801781e:	695b      	ldr	r3, [r3, #20]
 8017820:	b2dd      	uxtb	r5, r3
 8017822:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8017826:	685b      	ldr	r3, [r3, #4]
 8017828:	9300      	str	r3, [sp, #0]
 801782a:	f8d7 4108 	ldr.w	r4, [r7, #264]	; 0x108
 801782e:	462b      	mov	r3, r5
 8017830:	47a0      	blx	r4
            }
            break;
 8017832:	e08f      	b.n	8017954 <Zigbee_CallBackProcessing+0x16dc>
        case MSG_M0TOM4_ZCL_TL_EP_INFO_CB:
        {
            struct ZbTlEpInfoCmd *cmd;
            struct ZbZclAddrInfoT *srcInfo;

            assert(p_notification->Size == 3);
 8017834:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017838:	685b      	ldr	r3, [r3, #4]
 801783a:	2b03      	cmp	r3, #3
 801783c:	d006      	beq.n	801784c <Zigbee_CallBackProcessing+0x15d4>
 801783e:	4b3e      	ldr	r3, [pc, #248]	; (8017938 <Zigbee_CallBackProcessing+0x16c0>)
 8017840:	4a3a      	ldr	r2, [pc, #232]	; (801792c <Zigbee_CallBackProcessing+0x16b4>)
 8017842:	f241 0163 	movw	r1, #4195	; 0x1063
 8017846:	483a      	ldr	r0, [pc, #232]	; (8017930 <Zigbee_CallBackProcessing+0x16b8>)
 8017848:	f000 fb7a 	bl	8017f40 <__assert_func>
            if (zigbee_m4_tl_callbacks.ep_info_cb == NULL) {
 801784c:	4b3b      	ldr	r3, [pc, #236]	; (801793c <Zigbee_CallBackProcessing+0x16c4>)
 801784e:	681b      	ldr	r3, [r3, #0]
 8017850:	2b00      	cmp	r3, #0
 8017852:	d103      	bne.n	801785c <Zigbee_CallBackProcessing+0x15e4>
                retval = (uint32_t)ZCL_STATUS_UNSUPP_COMMAND;
 8017854:	2381      	movs	r3, #129	; 0x81
 8017856:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
                break;
 801785a:	e07c      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            }
            cmd = (struct ZbTlEpInfoCmd *)p_notification->Data[0];
 801785c:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017860:	689b      	ldr	r3, [r3, #8]
 8017862:	64fb      	str	r3, [r7, #76]	; 0x4c
            srcInfo = (struct ZbZclAddrInfoT *)p_notification->Data[1];
 8017864:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017868:	68db      	ldr	r3, [r3, #12]
 801786a:	64bb      	str	r3, [r7, #72]	; 0x48
            retval = (uint32_t)zigbee_m4_tl_callbacks.ep_info_cb(zb_ipc_globals.zb, cmd,
 801786c:	4b33      	ldr	r3, [pc, #204]	; (801793c <Zigbee_CallBackProcessing+0x16c4>)
 801786e:	681c      	ldr	r4, [r3, #0]
 8017870:	4b33      	ldr	r3, [pc, #204]	; (8017940 <Zigbee_CallBackProcessing+0x16c8>)
 8017872:	6818      	ldr	r0, [r3, #0]
                    srcInfo, (void *)p_notification->Data[2]);
 8017874:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8017878:	691b      	ldr	r3, [r3, #16]
            retval = (uint32_t)zigbee_m4_tl_callbacks.ep_info_cb(zb_ipc_globals.zb, cmd,
 801787a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801787c:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801787e:	47a0      	blx	r4
 8017880:	4603      	mov	r3, r0
 8017882:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
            break;
 8017886:	e066      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
        }

        default:
            status = HAL_ERROR;
 8017888:	2301      	movs	r3, #1
 801788a:	f887 312f 	strb.w	r3, [r7, #303]	; 0x12f
            break;
 801788e:	e062      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017890:	bf00      	nop
 8017892:	e060      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017894:	bf00      	nop
 8017896:	e05e      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017898:	bf00      	nop
 801789a:	e05c      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 801789c:	bf00      	nop
 801789e:	e05a      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178a0:	bf00      	nop
 80178a2:	e058      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178a4:	bf00      	nop
 80178a6:	e056      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178a8:	bf00      	nop
 80178aa:	e054      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178ac:	bf00      	nop
 80178ae:	e052      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178b0:	bf00      	nop
 80178b2:	e050      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178b4:	bf00      	nop
 80178b6:	e04e      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178b8:	bf00      	nop
 80178ba:	e04c      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178bc:	bf00      	nop
 80178be:	e04a      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178c0:	bf00      	nop
 80178c2:	e048      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178c4:	bf00      	nop
 80178c6:	e046      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178c8:	bf00      	nop
 80178ca:	e044      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178cc:	bf00      	nop
 80178ce:	e042      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178d0:	bf00      	nop
 80178d2:	e040      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178d4:	bf00      	nop
 80178d6:	e03e      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178d8:	bf00      	nop
 80178da:	e03c      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178dc:	bf00      	nop
 80178de:	e03a      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178e0:	bf00      	nop
 80178e2:	e038      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178e4:	bf00      	nop
 80178e6:	e036      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178e8:	bf00      	nop
 80178ea:	e034      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178ec:	bf00      	nop
 80178ee:	e032      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178f0:	bf00      	nop
 80178f2:	e030      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178f4:	bf00      	nop
 80178f6:	e02e      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178f8:	bf00      	nop
 80178fa:	e02c      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 80178fc:	bf00      	nop
 80178fe:	e02a      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017900:	bf00      	nop
 8017902:	e028      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017904:	bf00      	nop
 8017906:	e026      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017908:	bf00      	nop
 801790a:	e024      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 801790c:	bf00      	nop
 801790e:	e022      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017910:	bf00      	nop
 8017912:	e020      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017914:	bf00      	nop
 8017916:	e01e      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017918:	bf00      	nop
 801791a:	e01c      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 801791c:	bf00      	nop
 801791e:	e01a      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017920:	bf00      	nop
 8017922:	e018      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017924:	bf00      	nop
 8017926:	e016      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
 8017928:	08019924 	.word	0x08019924
 801792c:	08019cf0 	.word	0x08019cf0
 8017930:	0801985c 	.word	0x0801985c
 8017934:	08019940 	.word	0x08019940
 8017938:	08019908 	.word	0x08019908
 801793c:	200024fc 	.word	0x200024fc
 8017940:	20002510 	.word	0x20002510
            break;
 8017944:	bf00      	nop
 8017946:	e006      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017948:	bf00      	nop
 801794a:	e004      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 801794c:	bf00      	nop
 801794e:	e002      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017950:	bf00      	nop
 8017952:	e000      	b.n	8017956 <Zigbee_CallBackProcessing+0x16de>
            break;
 8017954:	bf00      	nop
    }

    if (info != NULL) {
 8017956:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801795a:	2b00      	cmp	r3, #0
 801795c:	d003      	beq.n	8017966 <Zigbee_CallBackProcessing+0x16ee>
        zb_ipc_m4_cb_info_free(info);
 801795e:	f8d7 0128 	ldr.w	r0, [r7, #296]	; 0x128
 8017962:	f7fd fc70 	bl	8015246 <zb_ipc_m4_cb_info_free>
    }

    /* Return the retval, if any. */
    p_notification->Data[0] = retval;
 8017966:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801796a:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 801796e:	609a      	str	r2, [r3, #8]

    TL_ZIGBEE_SendM4AckToM0Notify();
 8017970:	f7fc f902 	bl	8013b78 <TL_ZIGBEE_SendM4AckToM0Notify>
    return status;
 8017974:	f897 312f 	ldrb.w	r3, [r7, #303]	; 0x12f
}
 8017978:	4618      	mov	r0, r3
 801797a:	f507 779a 	add.w	r7, r7, #308	; 0x134
 801797e:	46bd      	mov	sp, r7
 8017980:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017982:	bf00      	nop

08017984 <Zigbee_M0RequestProcessing>:

HAL_StatusTypeDef
Zigbee_M0RequestProcessing(void)
{
 8017984:	b590      	push	{r4, r7, lr}
 8017986:	b089      	sub	sp, #36	; 0x24
 8017988:	af02      	add	r7, sp, #8
    HAL_StatusTypeDef status = HAL_OK;
 801798a:	2300      	movs	r3, #0
 801798c:	75fb      	strb	r3, [r7, #23]
    Zigbee_Cmd_Request_t *p_logging = ZIGBEE_Get_M0RequestPayloadBuffer();
 801798e:	f7f1 f851 	bl	8008a34 <ZIGBEE_Get_M0RequestPayloadBuffer>
 8017992:	60f8      	str	r0, [r7, #12]

    switch (p_logging->ID) {
 8017994:	68fb      	ldr	r3, [r7, #12]
 8017996:	681b      	ldr	r3, [r3, #0]
 8017998:	2b09      	cmp	r3, #9
 801799a:	d046      	beq.n	8017a2a <Zigbee_M0RequestProcessing+0xa6>
 801799c:	2b09      	cmp	r3, #9
 801799e:	d864      	bhi.n	8017a6a <Zigbee_M0RequestProcessing+0xe6>
 80179a0:	2b07      	cmp	r3, #7
 80179a2:	d002      	beq.n	80179aa <Zigbee_M0RequestProcessing+0x26>
 80179a4:	2b08      	cmp	r3, #8
 80179a6:	d01e      	beq.n	80179e6 <Zigbee_M0RequestProcessing+0x62>
 80179a8:	e05f      	b.n	8017a6a <Zigbee_M0RequestProcessing+0xe6>
        case MSG_M0TOM4_ZB_LOGGING:
        {
            const char *log_str;

            assert(p_logging->Size == 1);
 80179aa:	68fb      	ldr	r3, [r7, #12]
 80179ac:	685b      	ldr	r3, [r3, #4]
 80179ae:	2b01      	cmp	r3, #1
 80179b0:	d006      	beq.n	80179c0 <Zigbee_M0RequestProcessing+0x3c>
 80179b2:	4b33      	ldr	r3, [pc, #204]	; (8017a80 <Zigbee_M0RequestProcessing+0xfc>)
 80179b4:	4a33      	ldr	r2, [pc, #204]	; (8017a84 <Zigbee_M0RequestProcessing+0x100>)
 80179b6:	f241 018a 	movw	r1, #4234	; 0x108a
 80179ba:	4833      	ldr	r0, [pc, #204]	; (8017a88 <Zigbee_M0RequestProcessing+0x104>)
 80179bc:	f000 fac0 	bl	8017f40 <__assert_func>
            log_str = (const char *)p_logging->Data[0];
 80179c0:	68fb      	ldr	r3, [r7, #12]
 80179c2:	689b      	ldr	r3, [r3, #8]
 80179c4:	603b      	str	r3, [r7, #0]
            if (zb_ipc_globals.log_cb != NULL) {
 80179c6:	4b31      	ldr	r3, [pc, #196]	; (8017a8c <Zigbee_M0RequestProcessing+0x108>)
 80179c8:	685b      	ldr	r3, [r3, #4]
 80179ca:	2b00      	cmp	r3, #0
 80179cc:	d050      	beq.n	8017a70 <Zigbee_M0RequestProcessing+0xec>
                /* We just need to print the raw string. The formatting has already been done. */
                zb_ipc_globals.log_cb(zb_ipc_globals.zb, 0 /* mask is unknown */, NULL,
 80179ce:	4b2f      	ldr	r3, [pc, #188]	; (8017a8c <Zigbee_M0RequestProcessing+0x108>)
 80179d0:	685c      	ldr	r4, [r3, #4]
 80179d2:	4b2e      	ldr	r3, [pc, #184]	; (8017a8c <Zigbee_M0RequestProcessing+0x108>)
 80179d4:	6818      	ldr	r0, [r3, #0]
 80179d6:	4b2e      	ldr	r3, [pc, #184]	; (8017a90 <Zigbee_M0RequestProcessing+0x10c>)
 80179d8:	681b      	ldr	r3, [r3, #0]
 80179da:	9300      	str	r3, [sp, #0]
 80179dc:	683b      	ldr	r3, [r7, #0]
 80179de:	2200      	movs	r2, #0
 80179e0:	2100      	movs	r1, #0
 80179e2:	47a0      	blx	r4
                    log_str /* fmt */, va_null);
            }
            break;
 80179e4:	e044      	b.n	8017a70 <Zigbee_M0RequestProcessing+0xec>
        case MSG_M0TOM4_ZB_MALLOC:
        {
            void *ptr;
            uint32_t alloc_sz;

            assert(p_logging->Size == 1);
 80179e6:	68fb      	ldr	r3, [r7, #12]
 80179e8:	685b      	ldr	r3, [r3, #4]
 80179ea:	2b01      	cmp	r3, #1
 80179ec:	d006      	beq.n	80179fc <Zigbee_M0RequestProcessing+0x78>
 80179ee:	4b24      	ldr	r3, [pc, #144]	; (8017a80 <Zigbee_M0RequestProcessing+0xfc>)
 80179f0:	4a24      	ldr	r2, [pc, #144]	; (8017a84 <Zigbee_M0RequestProcessing+0x100>)
 80179f2:	f241 019a 	movw	r1, #4250	; 0x109a
 80179f6:	4824      	ldr	r0, [pc, #144]	; (8017a88 <Zigbee_M0RequestProcessing+0x104>)
 80179f8:	f000 faa2 	bl	8017f40 <__assert_func>
            alloc_sz = (uint32_t)p_logging->Data[0];
 80179fc:	68fb      	ldr	r3, [r7, #12]
 80179fe:	689b      	ldr	r3, [r3, #8]
 8017a00:	607b      	str	r3, [r7, #4]
#ifndef CONFIG_ZB_M4_MALLOC_DEBUG_SZ
            /* Make room for tracking size at start of memory block */
            alloc_sz += 4U;
 8017a02:	687b      	ldr	r3, [r7, #4]
 8017a04:	3304      	adds	r3, #4
 8017a06:	607b      	str	r3, [r7, #4]
#endif
            ptr = malloc(alloc_sz);
 8017a08:	6878      	ldr	r0, [r7, #4]
 8017a0a:	f000 fab7 	bl	8017f7c <malloc>
 8017a0e:	4603      	mov	r3, r0
 8017a10:	613b      	str	r3, [r7, #16]
            if (ptr != NULL) {
 8017a12:	693b      	ldr	r3, [r7, #16]
 8017a14:	2b00      	cmp	r3, #0
 8017a16:	d004      	beq.n	8017a22 <Zigbee_M0RequestProcessing+0x9e>
                ptr = zb_malloc_track(ptr, alloc_sz);
 8017a18:	6879      	ldr	r1, [r7, #4]
 8017a1a:	6938      	ldr	r0, [r7, #16]
 8017a1c:	f000 f83c 	bl	8017a98 <zb_malloc_track>
 8017a20:	6138      	str	r0, [r7, #16]
            }
            /* Return ptr in second argument */
            p_logging->Data[1] = (uint32_t)ptr;
 8017a22:	693a      	ldr	r2, [r7, #16]
 8017a24:	68fb      	ldr	r3, [r7, #12]
 8017a26:	60da      	str	r2, [r3, #12]
            break;
 8017a28:	e023      	b.n	8017a72 <Zigbee_M0RequestProcessing+0xee>
        /* ZbFree */
        case MSG_M0TOM4_ZB_FREE:
        {
            void *ptr;

            assert(p_logging->Size == 1);
 8017a2a:	68fb      	ldr	r3, [r7, #12]
 8017a2c:	685b      	ldr	r3, [r3, #4]
 8017a2e:	2b01      	cmp	r3, #1
 8017a30:	d006      	beq.n	8017a40 <Zigbee_M0RequestProcessing+0xbc>
 8017a32:	4b13      	ldr	r3, [pc, #76]	; (8017a80 <Zigbee_M0RequestProcessing+0xfc>)
 8017a34:	4a13      	ldr	r2, [pc, #76]	; (8017a84 <Zigbee_M0RequestProcessing+0x100>)
 8017a36:	f241 01ae 	movw	r1, #4270	; 0x10ae
 8017a3a:	4813      	ldr	r0, [pc, #76]	; (8017a88 <Zigbee_M0RequestProcessing+0x104>)
 8017a3c:	f000 fa80 	bl	8017f40 <__assert_func>
            ptr = (void *)p_logging->Data[0];
 8017a40:	68fb      	ldr	r3, [r7, #12]
 8017a42:	689b      	ldr	r3, [r3, #8]
 8017a44:	60bb      	str	r3, [r7, #8]
            assert(ptr != NULL);
 8017a46:	68bb      	ldr	r3, [r7, #8]
 8017a48:	2b00      	cmp	r3, #0
 8017a4a:	d106      	bne.n	8017a5a <Zigbee_M0RequestProcessing+0xd6>
 8017a4c:	4b11      	ldr	r3, [pc, #68]	; (8017a94 <Zigbee_M0RequestProcessing+0x110>)
 8017a4e:	4a0d      	ldr	r2, [pc, #52]	; (8017a84 <Zigbee_M0RequestProcessing+0x100>)
 8017a50:	f241 01b0 	movw	r1, #4272	; 0x10b0
 8017a54:	480c      	ldr	r0, [pc, #48]	; (8017a88 <Zigbee_M0RequestProcessing+0x104>)
 8017a56:	f000 fa73 	bl	8017f40 <__assert_func>
            ptr = zb_malloc_untrack(ptr);
 8017a5a:	68b8      	ldr	r0, [r7, #8]
 8017a5c:	f000 f838 	bl	8017ad0 <zb_malloc_untrack>
 8017a60:	60b8      	str	r0, [r7, #8]
            free(ptr);
 8017a62:	68b8      	ldr	r0, [r7, #8]
 8017a64:	f000 fa92 	bl	8017f8c <free>
            break;
 8017a68:	e003      	b.n	8017a72 <Zigbee_M0RequestProcessing+0xee>
        }

        default:
            status = HAL_ERROR;
 8017a6a:	2301      	movs	r3, #1
 8017a6c:	75fb      	strb	r3, [r7, #23]
            break;
 8017a6e:	e000      	b.n	8017a72 <Zigbee_M0RequestProcessing+0xee>
            break;
 8017a70:	bf00      	nop
    }

    TL_ZIGBEE_SendM4AckToM0Request();
 8017a72:	f7fc f89b 	bl	8013bac <TL_ZIGBEE_SendM4AckToM0Request>
    return status;
 8017a76:	7dfb      	ldrb	r3, [r7, #23]
}
 8017a78:	4618      	mov	r0, r3
 8017a7a:	371c      	adds	r7, #28
 8017a7c:	46bd      	mov	sp, r7
 8017a7e:	bd90      	pop	{r4, r7, pc}
 8017a80:	0801995c 	.word	0x0801995c
 8017a84:	08019d0c 	.word	0x08019d0c
 8017a88:	0801985c 	.word	0x0801985c
 8017a8c:	20002510 	.word	0x20002510
 8017a90:	08019ac0 	.word	0x08019ac0
 8017a94:	08019974 	.word	0x08019974

08017a98 <zb_malloc_track>:

/* ZbMalloc (MSG_M0TOM4_ZB_MALLOC) Debugging */
static void *
zb_malloc_track(void *ptr, unsigned int sz)
{
 8017a98:	b480      	push	{r7}
 8017a9a:	b085      	sub	sp, #20
 8017a9c:	af00      	add	r7, sp, #0
 8017a9e:	6078      	str	r0, [r7, #4]
 8017aa0:	6039      	str	r1, [r7, #0]
    return ptr;

#else
    void *ret;

    *(uint32_t *)ptr = sz;
 8017aa2:	687b      	ldr	r3, [r7, #4]
 8017aa4:	683a      	ldr	r2, [r7, #0]
 8017aa6:	601a      	str	r2, [r3, #0]
    ret = ((uint8_t *)ptr) + 4U;
 8017aa8:	687b      	ldr	r3, [r7, #4]
 8017aaa:	3304      	adds	r3, #4
 8017aac:	60fb      	str	r3, [r7, #12]
    zb_ipc_globals.zb_alloc_sz += sz;
 8017aae:	4b07      	ldr	r3, [pc, #28]	; (8017acc <zb_malloc_track+0x34>)
 8017ab0:	f8d3 200d 	ldr.w	r2, [r3, #13]
 8017ab4:	683b      	ldr	r3, [r7, #0]
 8017ab6:	4413      	add	r3, r2
 8017ab8:	4a04      	ldr	r2, [pc, #16]	; (8017acc <zb_malloc_track+0x34>)
 8017aba:	f8c2 300d 	str.w	r3, [r2, #13]
    return ret;
 8017abe:	68fb      	ldr	r3, [r7, #12]
#endif
}
 8017ac0:	4618      	mov	r0, r3
 8017ac2:	3714      	adds	r7, #20
 8017ac4:	46bd      	mov	sp, r7
 8017ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017aca:	4770      	bx	lr
 8017acc:	20002510 	.word	0x20002510

08017ad0 <zb_malloc_untrack>:

static void *
zb_malloc_untrack(void *ptr)
{
 8017ad0:	b480      	push	{r7}
 8017ad2:	b085      	sub	sp, #20
 8017ad4:	af00      	add	r7, sp, #0
 8017ad6:	6078      	str	r0, [r7, #4]

#else
    uint32_t sz;
    void *ret;

    ret = ((uint8_t *)ptr) - 4U;
 8017ad8:	687b      	ldr	r3, [r7, #4]
 8017ada:	3b04      	subs	r3, #4
 8017adc:	60fb      	str	r3, [r7, #12]
    sz = *(uint32_t *)ret;
 8017ade:	68fb      	ldr	r3, [r7, #12]
 8017ae0:	681b      	ldr	r3, [r3, #0]
 8017ae2:	60bb      	str	r3, [r7, #8]
    zb_ipc_globals.zb_alloc_sz -= sz;
 8017ae4:	4b07      	ldr	r3, [pc, #28]	; (8017b04 <zb_malloc_untrack+0x34>)
 8017ae6:	f8d3 200d 	ldr.w	r2, [r3, #13]
 8017aea:	68bb      	ldr	r3, [r7, #8]
 8017aec:	1ad3      	subs	r3, r2, r3
 8017aee:	4a05      	ldr	r2, [pc, #20]	; (8017b04 <zb_malloc_untrack+0x34>)
 8017af0:	f8c2 300d 	str.w	r3, [r2, #13]
    return ret;
 8017af4:	68fb      	ldr	r3, [r7, #12]
#endif
}
 8017af6:	4618      	mov	r0, r3
 8017af8:	3714      	adds	r7, #20
 8017afa:	46bd      	mov	sp, r7
 8017afc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b00:	4770      	bx	lr
 8017b02:	bf00      	nop
 8017b04:	20002510 	.word	0x20002510

08017b08 <UTIL_LPM_Init>:

/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
 8017b08:	b480      	push	{r7}
 8017b0a:	af00      	add	r7, sp, #0
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 8017b0c:	4b05      	ldr	r3, [pc, #20]	; (8017b24 <UTIL_LPM_Init+0x1c>)
 8017b0e:	2200      	movs	r2, #0
 8017b10:	601a      	str	r2, [r3, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8017b12:	4b05      	ldr	r3, [pc, #20]	; (8017b28 <UTIL_LPM_Init+0x20>)
 8017b14:	2200      	movs	r2, #0
 8017b16:	601a      	str	r2, [r3, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 8017b18:	bf00      	nop
 8017b1a:	46bd      	mov	sp, r7
 8017b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b20:	4770      	bx	lr
 8017b22:	bf00      	nop
 8017b24:	20002704 	.word	0x20002704
 8017b28:	20002708 	.word	0x20002708

08017b2c <UTIL_LPM_SetOffMode>:
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 8017b2c:	b480      	push	{r7}
 8017b2e:	b087      	sub	sp, #28
 8017b30:	af00      	add	r7, sp, #0
 8017b32:	6078      	str	r0, [r7, #4]
 8017b34:	460b      	mov	r3, r1
 8017b36:	70fb      	strb	r3, [r7, #3]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017b38:	f3ef 8310 	mrs	r3, PRIMASK
 8017b3c:	613b      	str	r3, [r7, #16]
  return(result);
 8017b3e:	693b      	ldr	r3, [r7, #16]
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
 8017b40:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8017b42:	b672      	cpsid	i
}
 8017b44:	bf00      	nop
  
  switch(state)
 8017b46:	78fb      	ldrb	r3, [r7, #3]
 8017b48:	2b00      	cmp	r3, #0
 8017b4a:	d008      	beq.n	8017b5e <UTIL_LPM_SetOffMode+0x32>
 8017b4c:	2b01      	cmp	r3, #1
 8017b4e:	d10e      	bne.n	8017b6e <UTIL_LPM_SetOffMode+0x42>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 8017b50:	4b0d      	ldr	r3, [pc, #52]	; (8017b88 <UTIL_LPM_SetOffMode+0x5c>)
 8017b52:	681a      	ldr	r2, [r3, #0]
 8017b54:	687b      	ldr	r3, [r7, #4]
 8017b56:	4313      	orrs	r3, r2
 8017b58:	4a0b      	ldr	r2, [pc, #44]	; (8017b88 <UTIL_LPM_SetOffMode+0x5c>)
 8017b5a:	6013      	str	r3, [r2, #0]
      break;
 8017b5c:	e008      	b.n	8017b70 <UTIL_LPM_SetOffMode+0x44>
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 8017b5e:	687b      	ldr	r3, [r7, #4]
 8017b60:	43da      	mvns	r2, r3
 8017b62:	4b09      	ldr	r3, [pc, #36]	; (8017b88 <UTIL_LPM_SetOffMode+0x5c>)
 8017b64:	681b      	ldr	r3, [r3, #0]
 8017b66:	4013      	ands	r3, r2
 8017b68:	4a07      	ldr	r2, [pc, #28]	; (8017b88 <UTIL_LPM_SetOffMode+0x5c>)
 8017b6a:	6013      	str	r3, [r2, #0]
      break;
 8017b6c:	e000      	b.n	8017b70 <UTIL_LPM_SetOffMode+0x44>
    }
  default :
    {
      break;
 8017b6e:	bf00      	nop
 8017b70:	697b      	ldr	r3, [r7, #20]
 8017b72:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017b74:	68fb      	ldr	r3, [r7, #12]
 8017b76:	f383 8810 	msr	PRIMASK, r3
}
 8017b7a:	bf00      	nop
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8017b7c:	bf00      	nop
 8017b7e:	371c      	adds	r7, #28
 8017b80:	46bd      	mov	sp, r7
 8017b82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b86:	4770      	bx	lr
 8017b88:	20002708 	.word	0x20002708

08017b8c <UTIL_SEQ_Run>:
 * That is the reason why many variables that are used only in that function are declared static.
 * Note: These variables could have been declared static in the function.
 *
 */
void UTIL_SEQ_Run( UTIL_SEQ_bm_t Mask_bm )
{
 8017b8c:	b580      	push	{r7, lr}
 8017b8e:	b090      	sub	sp, #64	; 0x40
 8017b90:	af00      	add	r7, sp, #0
 8017b92:	6078      	str	r0, [r7, #4]
  /*
   * When this function is nested, the mask to be applied cannot be larger than the first call
   * The mask is always getting smaller and smaller
   * A copy is made of the mask set by UTIL_SEQ_Run() in case it is called again in the task
   */
  super_mask_backup = SuperMask;
 8017b94:	4b73      	ldr	r3, [pc, #460]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017b96:	681b      	ldr	r3, [r3, #0]
 8017b98:	62bb      	str	r3, [r7, #40]	; 0x28
  SuperMask &= Mask_bm;
 8017b9a:	4b72      	ldr	r3, [pc, #456]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017b9c:	681a      	ldr	r2, [r3, #0]
 8017b9e:	687b      	ldr	r3, [r7, #4]
 8017ba0:	4013      	ands	r3, r2
 8017ba2:	4a70      	ldr	r2, [pc, #448]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017ba4:	6013      	str	r3, [r2, #0]
   * TaskMask that comes from UTIL_SEQ_PauseTask() / UTIL_SEQ_ResumeTask
   * SuperMask that comes from UTIL_SEQ_Run
   * If the waited event is there, exit from  UTIL_SEQ_Run() to return to the
   * waiting task
   */
  local_taskset = TaskSet;
 8017ba6:	4b70      	ldr	r3, [pc, #448]	; (8017d68 <UTIL_SEQ_Run+0x1dc>)
 8017ba8:	681b      	ldr	r3, [r3, #0]
 8017baa:	63bb      	str	r3, [r7, #56]	; 0x38
  local_evtset = EvtSet;
 8017bac:	4b6f      	ldr	r3, [pc, #444]	; (8017d6c <UTIL_SEQ_Run+0x1e0>)
 8017bae:	681b      	ldr	r3, [r3, #0]
 8017bb0:	637b      	str	r3, [r7, #52]	; 0x34
  local_taskmask = TaskMask;
 8017bb2:	4b6f      	ldr	r3, [pc, #444]	; (8017d70 <UTIL_SEQ_Run+0x1e4>)
 8017bb4:	681b      	ldr	r3, [r3, #0]
 8017bb6:	633b      	str	r3, [r7, #48]	; 0x30
  local_evtwaited =  EvtWaited;
 8017bb8:	4b6e      	ldr	r3, [pc, #440]	; (8017d74 <UTIL_SEQ_Run+0x1e8>)
 8017bba:	681b      	ldr	r3, [r3, #0]
 8017bbc:	62fb      	str	r3, [r7, #44]	; 0x2c
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8017bbe:	e08d      	b.n	8017cdc <UTIL_SEQ_Run+0x150>
  {
    counter = 0U;
 8017bc0:	2300      	movs	r3, #0
 8017bc2:	63fb      	str	r3, [r7, #60]	; 0x3c
    /*
     * When a flag is set, the associated bit is set in TaskPrio[counter].priority mask depending
     * on the priority parameter given from UTIL_SEQ_SetTask()
     * The while loop is looking for a flag set from the highest priority maskr to the lower
     */
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 8017bc4:	e002      	b.n	8017bcc <UTIL_SEQ_Run+0x40>
    {
      counter++;
 8017bc6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017bc8:	3301      	adds	r3, #1
 8017bca:	63fb      	str	r3, [r7, #60]	; 0x3c
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 8017bcc:	4a6a      	ldr	r2, [pc, #424]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017bce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017bd0:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8017bd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017bd6:	401a      	ands	r2, r3
 8017bd8:	4b62      	ldr	r3, [pc, #392]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017bda:	681b      	ldr	r3, [r3, #0]
 8017bdc:	4013      	ands	r3, r2
 8017bde:	2b00      	cmp	r3, #0
 8017be0:	d0f1      	beq.n	8017bc6 <UTIL_SEQ_Run+0x3a>
    }

    current_task_set = TaskPrio[counter].priority & local_taskmask & SuperMask;
 8017be2:	4a65      	ldr	r2, [pc, #404]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017be4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017be6:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8017bea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017bec:	401a      	ands	r2, r3
 8017bee:	4b5d      	ldr	r3, [pc, #372]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017bf0:	681b      	ldr	r3, [r3, #0]
 8017bf2:	4013      	ands	r3, r2
 8017bf4:	627b      	str	r3, [r7, #36]	; 0x24
     * so that the second one can be executed.
     * Note that the first flag is not removed from the list of pending task but just masked by the round_robin mask
     *
     * In the check below, the round_robin mask is reinitialize in case all pending tasks haven been executed at least once
     */
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 8017bf6:	4a60      	ldr	r2, [pc, #384]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017bf8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017bfa:	00db      	lsls	r3, r3, #3
 8017bfc:	4413      	add	r3, r2
 8017bfe:	685a      	ldr	r2, [r3, #4]
 8017c00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c02:	4013      	ands	r3, r2
 8017c04:	2b00      	cmp	r3, #0
 8017c06:	d106      	bne.n	8017c16 <UTIL_SEQ_Run+0x8a>
    {
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 8017c08:	4a5b      	ldr	r2, [pc, #364]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017c0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c0c:	00db      	lsls	r3, r3, #3
 8017c0e:	4413      	add	r3, r2
 8017c10:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8017c14:	605a      	str	r2, [r3, #4]
  /*
   * Read the flag index of the task to be executed
	 * Once the index is read, the associated task will be executed even though a higher priority stack is requested
	 * before task execution.
	 */
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8017c16:	4a58      	ldr	r2, [pc, #352]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017c18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c1a:	00db      	lsls	r3, r3, #3
 8017c1c:	4413      	add	r3, r2
 8017c1e:	685a      	ldr	r2, [r3, #4]
 8017c20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c22:	4013      	ands	r3, r2
 8017c24:	4618      	mov	r0, r3
 8017c26:	f000 f973 	bl	8017f10 <SEQ_BitPosition>
 8017c2a:	4603      	mov	r3, r0
 8017c2c:	461a      	mov	r2, r3
 8017c2e:	4b53      	ldr	r3, [pc, #332]	; (8017d7c <UTIL_SEQ_Run+0x1f0>)
 8017c30:	601a      	str	r2, [r3, #0]

    /*
     * remove from the roun_robin mask the task that has been selected to be executed
     */
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 8017c32:	4a51      	ldr	r2, [pc, #324]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017c34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c36:	00db      	lsls	r3, r3, #3
 8017c38:	4413      	add	r3, r2
 8017c3a:	685a      	ldr	r2, [r3, #4]
 8017c3c:	4b4f      	ldr	r3, [pc, #316]	; (8017d7c <UTIL_SEQ_Run+0x1f0>)
 8017c3e:	681b      	ldr	r3, [r3, #0]
 8017c40:	2101      	movs	r1, #1
 8017c42:	fa01 f303 	lsl.w	r3, r1, r3
 8017c46:	43db      	mvns	r3, r3
 8017c48:	401a      	ands	r2, r3
 8017c4a:	494b      	ldr	r1, [pc, #300]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017c4c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c4e:	00db      	lsls	r3, r3, #3
 8017c50:	440b      	add	r3, r1
 8017c52:	605a      	str	r2, [r3, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017c54:	f3ef 8310 	mrs	r3, PRIMASK
 8017c58:	61bb      	str	r3, [r7, #24]
  return(result);
 8017c5a:	69bb      	ldr	r3, [r7, #24]

    UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 8017c5c:	623b      	str	r3, [r7, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 8017c5e:	b672      	cpsid	i
}
 8017c60:	bf00      	nop
    /* remove from the list or pending task the one that has been selected to be executed */
    TaskSet &= ~(1U << CurrentTaskIdx);
 8017c62:	4b46      	ldr	r3, [pc, #280]	; (8017d7c <UTIL_SEQ_Run+0x1f0>)
 8017c64:	681b      	ldr	r3, [r3, #0]
 8017c66:	2201      	movs	r2, #1
 8017c68:	fa02 f303 	lsl.w	r3, r2, r3
 8017c6c:	43da      	mvns	r2, r3
 8017c6e:	4b3e      	ldr	r3, [pc, #248]	; (8017d68 <UTIL_SEQ_Run+0x1dc>)
 8017c70:	681b      	ldr	r3, [r3, #0]
 8017c72:	4013      	ands	r3, r2
 8017c74:	4a3c      	ldr	r2, [pc, #240]	; (8017d68 <UTIL_SEQ_Run+0x1dc>)
 8017c76:	6013      	str	r3, [r2, #0]
    /* remove from all priority mask the task that has been selected to be executed */
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8017c78:	2302      	movs	r3, #2
 8017c7a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8017c7c:	e013      	b.n	8017ca6 <UTIL_SEQ_Run+0x11a>
    {
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 8017c7e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c80:	3b01      	subs	r3, #1
 8017c82:	4a3d      	ldr	r2, [pc, #244]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017c84:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 8017c88:	4b3c      	ldr	r3, [pc, #240]	; (8017d7c <UTIL_SEQ_Run+0x1f0>)
 8017c8a:	681b      	ldr	r3, [r3, #0]
 8017c8c:	2201      	movs	r2, #1
 8017c8e:	fa02 f303 	lsl.w	r3, r2, r3
 8017c92:	43da      	mvns	r2, r3
 8017c94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017c96:	3b01      	subs	r3, #1
 8017c98:	400a      	ands	r2, r1
 8017c9a:	4937      	ldr	r1, [pc, #220]	; (8017d78 <UTIL_SEQ_Run+0x1ec>)
 8017c9c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8017ca0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017ca2:	3b01      	subs	r3, #1
 8017ca4:	63fb      	str	r3, [r7, #60]	; 0x3c
 8017ca6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8017ca8:	2b00      	cmp	r3, #0
 8017caa:	d1e8      	bne.n	8017c7e <UTIL_SEQ_Run+0xf2>
 8017cac:	6a3b      	ldr	r3, [r7, #32]
 8017cae:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017cb0:	697b      	ldr	r3, [r7, #20]
 8017cb2:	f383 8810 	msr	PRIMASK, r3
}
 8017cb6:	bf00      	nop
    }
    UTIL_SEQ_EXIT_CRITICAL_SECTION( );

    /* Execute the task */
    TaskCb[CurrentTaskIdx]( );
 8017cb8:	4b30      	ldr	r3, [pc, #192]	; (8017d7c <UTIL_SEQ_Run+0x1f0>)
 8017cba:	681b      	ldr	r3, [r3, #0]
 8017cbc:	4a30      	ldr	r2, [pc, #192]	; (8017d80 <UTIL_SEQ_Run+0x1f4>)
 8017cbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8017cc2:	4798      	blx	r3

    local_taskset = TaskSet;
 8017cc4:	4b28      	ldr	r3, [pc, #160]	; (8017d68 <UTIL_SEQ_Run+0x1dc>)
 8017cc6:	681b      	ldr	r3, [r3, #0]
 8017cc8:	63bb      	str	r3, [r7, #56]	; 0x38
    local_evtset = EvtSet;
 8017cca:	4b28      	ldr	r3, [pc, #160]	; (8017d6c <UTIL_SEQ_Run+0x1e0>)
 8017ccc:	681b      	ldr	r3, [r3, #0]
 8017cce:	637b      	str	r3, [r7, #52]	; 0x34
    local_taskmask = TaskMask;
 8017cd0:	4b27      	ldr	r3, [pc, #156]	; (8017d70 <UTIL_SEQ_Run+0x1e4>)
 8017cd2:	681b      	ldr	r3, [r3, #0]
 8017cd4:	633b      	str	r3, [r7, #48]	; 0x30
    local_evtwaited = EvtWaited;
 8017cd6:	4b27      	ldr	r3, [pc, #156]	; (8017d74 <UTIL_SEQ_Run+0x1e8>)
 8017cd8:	681b      	ldr	r3, [r3, #0]
 8017cda:	62fb      	str	r3, [r7, #44]	; 0x2c
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8017cdc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8017cde:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017ce0:	401a      	ands	r2, r3
 8017ce2:	4b20      	ldr	r3, [pc, #128]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017ce4:	681b      	ldr	r3, [r3, #0]
 8017ce6:	4013      	ands	r3, r2
 8017ce8:	2b00      	cmp	r3, #0
 8017cea:	d005      	beq.n	8017cf8 <UTIL_SEQ_Run+0x16c>
 8017cec:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8017cee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017cf0:	4013      	ands	r3, r2
 8017cf2:	2b00      	cmp	r3, #0
 8017cf4:	f43f af64 	beq.w	8017bc0 <UTIL_SEQ_Run+0x34>
  }

  /* the set of CurrentTaskIdx to no task running allows to call WaitEvt in the Pre/Post ilde context */
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 8017cf8:	4b20      	ldr	r3, [pc, #128]	; (8017d7c <UTIL_SEQ_Run+0x1f0>)
 8017cfa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8017cfe:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8017d00:	f000 f8f8 	bl	8017ef4 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017d04:	f3ef 8310 	mrs	r3, PRIMASK
 8017d08:	613b      	str	r3, [r7, #16]
  return(result);
 8017d0a:	693b      	ldr	r3, [r7, #16]

  UTIL_SEQ_ENTER_CRITICAL_SECTION_IDLE( );
 8017d0c:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
 8017d0e:	b672      	cpsid	i
}
 8017d10:	bf00      	nop
  local_taskset = TaskSet;
 8017d12:	4b15      	ldr	r3, [pc, #84]	; (8017d68 <UTIL_SEQ_Run+0x1dc>)
 8017d14:	681b      	ldr	r3, [r3, #0]
 8017d16:	63bb      	str	r3, [r7, #56]	; 0x38
  local_evtset = EvtSet;
 8017d18:	4b14      	ldr	r3, [pc, #80]	; (8017d6c <UTIL_SEQ_Run+0x1e0>)
 8017d1a:	681b      	ldr	r3, [r3, #0]
 8017d1c:	637b      	str	r3, [r7, #52]	; 0x34
  local_taskmask = TaskMask;
 8017d1e:	4b14      	ldr	r3, [pc, #80]	; (8017d70 <UTIL_SEQ_Run+0x1e4>)
 8017d20:	681b      	ldr	r3, [r3, #0]
 8017d22:	633b      	str	r3, [r7, #48]	; 0x30
  if ((local_taskset & local_taskmask & SuperMask) == 0U)
 8017d24:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8017d26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017d28:	401a      	ands	r2, r3
 8017d2a:	4b0e      	ldr	r3, [pc, #56]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017d2c:	681b      	ldr	r3, [r3, #0]
 8017d2e:	4013      	ands	r3, r2
 8017d30:	2b00      	cmp	r3, #0
 8017d32:	d107      	bne.n	8017d44 <UTIL_SEQ_Run+0x1b8>
  {
    if ((local_evtset & EvtWaited)== 0U)
 8017d34:	4b0f      	ldr	r3, [pc, #60]	; (8017d74 <UTIL_SEQ_Run+0x1e8>)
 8017d36:	681a      	ldr	r2, [r3, #0]
 8017d38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017d3a:	4013      	ands	r3, r2
 8017d3c:	2b00      	cmp	r3, #0
 8017d3e:	d101      	bne.n	8017d44 <UTIL_SEQ_Run+0x1b8>
    {
      UTIL_SEQ_Idle( );
 8017d40:	f7ee fd3f 	bl	80067c2 <UTIL_SEQ_Idle>
 8017d44:	69fb      	ldr	r3, [r7, #28]
 8017d46:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017d48:	68fb      	ldr	r3, [r7, #12]
 8017d4a:	f383 8810 	msr	PRIMASK, r3
}
 8017d4e:	bf00      	nop
    }
  }
  UTIL_SEQ_EXIT_CRITICAL_SECTION_IDLE( );

  UTIL_SEQ_PostIdle( );
 8017d50:	f000 f8d7 	bl	8017f02 <UTIL_SEQ_PostIdle>

  /* restore the mask from UTIL_SEQ_Run() */
  SuperMask = super_mask_backup;
 8017d54:	4a03      	ldr	r2, [pc, #12]	; (8017d64 <UTIL_SEQ_Run+0x1d8>)
 8017d56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017d58:	6013      	str	r3, [r2, #0]

  return;
 8017d5a:	bf00      	nop
}
 8017d5c:	3740      	adds	r7, #64	; 0x40
 8017d5e:	46bd      	mov	sp, r7
 8017d60:	bd80      	pop	{r7, pc}
 8017d62:	bf00      	nop
 8017d64:	20000110 	.word	0x20000110
 8017d68:	2000270c 	.word	0x2000270c
 8017d6c:	20002710 	.word	0x20002710
 8017d70:	2000010c 	.word	0x2000010c
 8017d74:	20002714 	.word	0x20002714
 8017d78:	2000279c 	.word	0x2000279c
 8017d7c:	20002718 	.word	0x20002718
 8017d80:	2000271c 	.word	0x2000271c

08017d84 <UTIL_SEQ_RegTask>:

void UTIL_SEQ_RegTask(UTIL_SEQ_bm_t TaskId_bm, uint32_t Flags, void (*Task)( void ))
{
 8017d84:	b580      	push	{r7, lr}
 8017d86:	b088      	sub	sp, #32
 8017d88:	af00      	add	r7, sp, #0
 8017d8a:	60f8      	str	r0, [r7, #12]
 8017d8c:	60b9      	str	r1, [r7, #8]
 8017d8e:	607a      	str	r2, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017d90:	f3ef 8310 	mrs	r3, PRIMASK
 8017d94:	617b      	str	r3, [r7, #20]
  return(result);
 8017d96:	697b      	ldr	r3, [r7, #20]
  (void)Flags;
  UTIL_SEQ_ENTER_CRITICAL_SECTION();
 8017d98:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
 8017d9a:	b672      	cpsid	i
}
 8017d9c:	bf00      	nop

  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 8017d9e:	68f8      	ldr	r0, [r7, #12]
 8017da0:	f000 f8b6 	bl	8017f10 <SEQ_BitPosition>
 8017da4:	4603      	mov	r3, r0
 8017da6:	4619      	mov	r1, r3
 8017da8:	4a06      	ldr	r2, [pc, #24]	; (8017dc4 <UTIL_SEQ_RegTask+0x40>)
 8017daa:	687b      	ldr	r3, [r7, #4]
 8017dac:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8017db0:	69fb      	ldr	r3, [r7, #28]
 8017db2:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017db4:	69bb      	ldr	r3, [r7, #24]
 8017db6:	f383 8810 	msr	PRIMASK, r3
}
 8017dba:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION();

  return;
 8017dbc:	bf00      	nop
}
 8017dbe:	3720      	adds	r7, #32
 8017dc0:	46bd      	mov	sp, r7
 8017dc2:	bd80      	pop	{r7, pc}
 8017dc4:	2000271c 	.word	0x2000271c

08017dc8 <UTIL_SEQ_SetTask>:

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 8017dc8:	b480      	push	{r7}
 8017dca:	b087      	sub	sp, #28
 8017dcc:	af00      	add	r7, sp, #0
 8017dce:	6078      	str	r0, [r7, #4]
 8017dd0:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017dd2:	f3ef 8310 	mrs	r3, PRIMASK
 8017dd6:	60fb      	str	r3, [r7, #12]
  return(result);
 8017dd8:	68fb      	ldr	r3, [r7, #12]
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 8017dda:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8017ddc:	b672      	cpsid	i
}
 8017dde:	bf00      	nop

  TaskSet |= TaskId_bm;
 8017de0:	4b0d      	ldr	r3, [pc, #52]	; (8017e18 <UTIL_SEQ_SetTask+0x50>)
 8017de2:	681a      	ldr	r2, [r3, #0]
 8017de4:	687b      	ldr	r3, [r7, #4]
 8017de6:	4313      	orrs	r3, r2
 8017de8:	4a0b      	ldr	r2, [pc, #44]	; (8017e18 <UTIL_SEQ_SetTask+0x50>)
 8017dea:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 8017dec:	4a0b      	ldr	r2, [pc, #44]	; (8017e1c <UTIL_SEQ_SetTask+0x54>)
 8017dee:	683b      	ldr	r3, [r7, #0]
 8017df0:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8017df4:	687b      	ldr	r3, [r7, #4]
 8017df6:	431a      	orrs	r2, r3
 8017df8:	4908      	ldr	r1, [pc, #32]	; (8017e1c <UTIL_SEQ_SetTask+0x54>)
 8017dfa:	683b      	ldr	r3, [r7, #0]
 8017dfc:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
 8017e00:	697b      	ldr	r3, [r7, #20]
 8017e02:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017e04:	693b      	ldr	r3, [r7, #16]
 8017e06:	f383 8810 	msr	PRIMASK, r3
}
 8017e0a:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
 8017e0c:	bf00      	nop
}
 8017e0e:	371c      	adds	r7, #28
 8017e10:	46bd      	mov	sp, r7
 8017e12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017e16:	4770      	bx	lr
 8017e18:	2000270c 	.word	0x2000270c
 8017e1c:	2000279c 	.word	0x2000279c

08017e20 <UTIL_SEQ_SetEvt>:

  return;
}

void UTIL_SEQ_SetEvt( UTIL_SEQ_bm_t EvtId_bm )
{
 8017e20:	b480      	push	{r7}
 8017e22:	b087      	sub	sp, #28
 8017e24:	af00      	add	r7, sp, #0
 8017e26:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017e28:	f3ef 8310 	mrs	r3, PRIMASK
 8017e2c:	60fb      	str	r3, [r7, #12]
  return(result);
 8017e2e:	68fb      	ldr	r3, [r7, #12]
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 8017e30:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8017e32:	b672      	cpsid	i
}
 8017e34:	bf00      	nop

  EvtSet |= EvtId_bm;
 8017e36:	4b09      	ldr	r3, [pc, #36]	; (8017e5c <UTIL_SEQ_SetEvt+0x3c>)
 8017e38:	681a      	ldr	r2, [r3, #0]
 8017e3a:	687b      	ldr	r3, [r7, #4]
 8017e3c:	4313      	orrs	r3, r2
 8017e3e:	4a07      	ldr	r2, [pc, #28]	; (8017e5c <UTIL_SEQ_SetEvt+0x3c>)
 8017e40:	6013      	str	r3, [r2, #0]
 8017e42:	697b      	ldr	r3, [r7, #20]
 8017e44:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017e46:	693b      	ldr	r3, [r7, #16]
 8017e48:	f383 8810 	msr	PRIMASK, r3
}
 8017e4c:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
 8017e4e:	bf00      	nop
}
 8017e50:	371c      	adds	r7, #28
 8017e52:	46bd      	mov	sp, r7
 8017e54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017e58:	4770      	bx	lr
 8017e5a:	bf00      	nop
 8017e5c:	20002710 	.word	0x20002710

08017e60 <UTIL_SEQ_WaitEvt>:

  return;
}

void UTIL_SEQ_WaitEvt(UTIL_SEQ_bm_t EvtId_bm)
{
 8017e60:	b580      	push	{r7, lr}
 8017e62:	b088      	sub	sp, #32
 8017e64:	af00      	add	r7, sp, #0
 8017e66:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_bm_t wait_task_idx;
  /*
   * store in local the current_task_id_bm as the global variable CurrentTaskIdx
   * may be overwritten in case there are nested call of UTIL_SEQ_Run()
   */
  current_task_idx = CurrentTaskIdx;
 8017e68:	4b1f      	ldr	r3, [pc, #124]	; (8017ee8 <UTIL_SEQ_WaitEvt+0x88>)
 8017e6a:	681b      	ldr	r3, [r3, #0]
 8017e6c:	61bb      	str	r3, [r7, #24]
  if(UTIL_SEQ_NOTASKRUNNING == CurrentTaskIdx)
 8017e6e:	4b1e      	ldr	r3, [pc, #120]	; (8017ee8 <UTIL_SEQ_WaitEvt+0x88>)
 8017e70:	681b      	ldr	r3, [r3, #0]
 8017e72:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8017e76:	d102      	bne.n	8017e7e <UTIL_SEQ_WaitEvt+0x1e>
  {
    wait_task_idx = 0u;
 8017e78:	2300      	movs	r3, #0
 8017e7a:	61fb      	str	r3, [r7, #28]
 8017e7c:	e005      	b.n	8017e8a <UTIL_SEQ_WaitEvt+0x2a>
  }
  else
  {
    wait_task_idx = (uint32_t)1u << CurrentTaskIdx;
 8017e7e:	4b1a      	ldr	r3, [pc, #104]	; (8017ee8 <UTIL_SEQ_WaitEvt+0x88>)
 8017e80:	681b      	ldr	r3, [r3, #0]
 8017e82:	2201      	movs	r2, #1
 8017e84:	fa02 f303 	lsl.w	r3, r2, r3
 8017e88:	61fb      	str	r3, [r7, #28]
  }

  /* backup the event id that was currently waited */
  event_waited_id_backup = EvtWaited;
 8017e8a:	4b18      	ldr	r3, [pc, #96]	; (8017eec <UTIL_SEQ_WaitEvt+0x8c>)
 8017e8c:	681b      	ldr	r3, [r3, #0]
 8017e8e:	617b      	str	r3, [r7, #20]
  EvtWaited = EvtId_bm;
 8017e90:	4a16      	ldr	r2, [pc, #88]	; (8017eec <UTIL_SEQ_WaitEvt+0x8c>)
 8017e92:	687b      	ldr	r3, [r7, #4]
 8017e94:	6013      	str	r3, [r2, #0]
   * The system is waiting only for the last waited event.
   * When it will go out, it will wait again from the previous one.
   * It case it occurs while waiting for the second one, the while loop will exit immediately
   */

  while ((EvtSet & EvtId_bm) == 0U)
 8017e96:	e003      	b.n	8017ea0 <UTIL_SEQ_WaitEvt+0x40>
  {
    UTIL_SEQ_EvtIdle(wait_task_idx, EvtId_bm);
 8017e98:	6879      	ldr	r1, [r7, #4]
 8017e9a:	69f8      	ldr	r0, [r7, #28]
 8017e9c:	f7ee fc98 	bl	80067d0 <UTIL_SEQ_EvtIdle>
  while ((EvtSet & EvtId_bm) == 0U)
 8017ea0:	4b13      	ldr	r3, [pc, #76]	; (8017ef0 <UTIL_SEQ_WaitEvt+0x90>)
 8017ea2:	681a      	ldr	r2, [r3, #0]
 8017ea4:	687b      	ldr	r3, [r7, #4]
 8017ea6:	4013      	ands	r3, r2
 8017ea8:	2b00      	cmp	r3, #0
 8017eaa:	d0f5      	beq.n	8017e98 <UTIL_SEQ_WaitEvt+0x38>
  /*
   * Restore the CurrentTaskIdx that may have been modified by call of UTIL_SEQ_Run() from UTIL_SEQ_EvtIdle()
   * This is required so that a second call of UTIL_SEQ_WaitEvt() in the same process pass the correct current_task_id_bm
   * in the call of UTIL_SEQ_EvtIdle()
   */
  CurrentTaskIdx = current_task_idx;
 8017eac:	4a0e      	ldr	r2, [pc, #56]	; (8017ee8 <UTIL_SEQ_WaitEvt+0x88>)
 8017eae:	69bb      	ldr	r3, [r7, #24]
 8017eb0:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8017eb2:	f3ef 8310 	mrs	r3, PRIMASK
 8017eb6:	60bb      	str	r3, [r7, #8]
  return(result);
 8017eb8:	68bb      	ldr	r3, [r7, #8]

  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 8017eba:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 8017ebc:	b672      	cpsid	i
}
 8017ebe:	bf00      	nop

  EvtSet &= (~EvtId_bm);
 8017ec0:	687b      	ldr	r3, [r7, #4]
 8017ec2:	43da      	mvns	r2, r3
 8017ec4:	4b0a      	ldr	r3, [pc, #40]	; (8017ef0 <UTIL_SEQ_WaitEvt+0x90>)
 8017ec6:	681b      	ldr	r3, [r3, #0]
 8017ec8:	4013      	ands	r3, r2
 8017eca:	4a09      	ldr	r2, [pc, #36]	; (8017ef0 <UTIL_SEQ_WaitEvt+0x90>)
 8017ecc:	6013      	str	r3, [r2, #0]
 8017ece:	693b      	ldr	r3, [r7, #16]
 8017ed0:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8017ed2:	68fb      	ldr	r3, [r7, #12]
 8017ed4:	f383 8810 	msr	PRIMASK, r3
}
 8017ed8:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  EvtWaited = event_waited_id_backup;
 8017eda:	4a04      	ldr	r2, [pc, #16]	; (8017eec <UTIL_SEQ_WaitEvt+0x8c>)
 8017edc:	697b      	ldr	r3, [r7, #20]
 8017ede:	6013      	str	r3, [r2, #0]
  return;
 8017ee0:	bf00      	nop
}
 8017ee2:	3720      	adds	r7, #32
 8017ee4:	46bd      	mov	sp, r7
 8017ee6:	bd80      	pop	{r7, pc}
 8017ee8:	20002718 	.word	0x20002718
 8017eec:	20002714 	.word	0x20002714
 8017ef0:	20002710 	.word	0x20002710

08017ef4 <UTIL_SEQ_PreIdle>:
{
  return;
}

__WEAK void UTIL_SEQ_PreIdle( void )
{
 8017ef4:	b480      	push	{r7}
 8017ef6:	af00      	add	r7, sp, #0
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
 8017ef8:	bf00      	nop
}
 8017efa:	46bd      	mov	sp, r7
 8017efc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017f00:	4770      	bx	lr

08017f02 <UTIL_SEQ_PostIdle>:

__WEAK void UTIL_SEQ_PostIdle( void )
{
 8017f02:	b480      	push	{r7}
 8017f04:	af00      	add	r7, sp, #0
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
 8017f06:	bf00      	nop
}
 8017f08:	46bd      	mov	sp, r7
 8017f0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017f0e:	4770      	bx	lr

08017f10 <SEQ_BitPosition>:
 * @brief return the position of the first bit set to 1
 * @param Value 32 bit value
 * @retval bit position
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
 8017f10:	b480      	push	{r7}
 8017f12:	b085      	sub	sp, #20
 8017f14:	af00      	add	r7, sp, #0
 8017f16:	6078      	str	r0, [r7, #4]
 8017f18:	687b      	ldr	r3, [r7, #4]
 8017f1a:	60fb      	str	r3, [r7, #12]
  if (value == 0U)
 8017f1c:	68fb      	ldr	r3, [r7, #12]
 8017f1e:	2b00      	cmp	r3, #0
 8017f20:	d101      	bne.n	8017f26 <SEQ_BitPosition+0x16>
    return 32U;
 8017f22:	2320      	movs	r3, #32
 8017f24:	e003      	b.n	8017f2e <SEQ_BitPosition+0x1e>
  return __builtin_clz(value);
 8017f26:	68fb      	ldr	r3, [r7, #12]
 8017f28:	fab3 f383 	clz	r3, r3
 8017f2c:	b2db      	uxtb	r3, r3
  return (uint8_t)(31 -__CLZ( Value ));
 8017f2e:	f1c3 031f 	rsb	r3, r3, #31
 8017f32:	b2db      	uxtb	r3, r3
}
 8017f34:	4618      	mov	r0, r3
 8017f36:	3714      	adds	r7, #20
 8017f38:	46bd      	mov	sp, r7
 8017f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017f3e:	4770      	bx	lr

08017f40 <__assert_func>:
 8017f40:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8017f42:	4614      	mov	r4, r2
 8017f44:	461a      	mov	r2, r3
 8017f46:	4b09      	ldr	r3, [pc, #36]	; (8017f6c <__assert_func+0x2c>)
 8017f48:	681b      	ldr	r3, [r3, #0]
 8017f4a:	4605      	mov	r5, r0
 8017f4c:	68d8      	ldr	r0, [r3, #12]
 8017f4e:	b14c      	cbz	r4, 8017f64 <__assert_func+0x24>
 8017f50:	4b07      	ldr	r3, [pc, #28]	; (8017f70 <__assert_func+0x30>)
 8017f52:	9100      	str	r1, [sp, #0]
 8017f54:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8017f58:	4906      	ldr	r1, [pc, #24]	; (8017f74 <__assert_func+0x34>)
 8017f5a:	462b      	mov	r3, r5
 8017f5c:	f000 f96e 	bl	801823c <fiprintf>
 8017f60:	f000 fb27 	bl	80185b2 <abort>
 8017f64:	4b04      	ldr	r3, [pc, #16]	; (8017f78 <__assert_func+0x38>)
 8017f66:	461c      	mov	r4, r3
 8017f68:	e7f3      	b.n	8017f52 <__assert_func+0x12>
 8017f6a:	bf00      	nop
 8017f6c:	2000016c 	.word	0x2000016c
 8017f70:	08019d27 	.word	0x08019d27
 8017f74:	08019d34 	.word	0x08019d34
 8017f78:	08019d62 	.word	0x08019d62

08017f7c <malloc>:
 8017f7c:	4b02      	ldr	r3, [pc, #8]	; (8017f88 <malloc+0xc>)
 8017f7e:	4601      	mov	r1, r0
 8017f80:	6818      	ldr	r0, [r3, #0]
 8017f82:	f000 b82b 	b.w	8017fdc <_malloc_r>
 8017f86:	bf00      	nop
 8017f88:	2000016c 	.word	0x2000016c

08017f8c <free>:
 8017f8c:	4b02      	ldr	r3, [pc, #8]	; (8017f98 <free+0xc>)
 8017f8e:	4601      	mov	r1, r0
 8017f90:	6818      	ldr	r0, [r3, #0]
 8017f92:	f000 bb15 	b.w	80185c0 <_free_r>
 8017f96:	bf00      	nop
 8017f98:	2000016c 	.word	0x2000016c

08017f9c <sbrk_aligned>:
 8017f9c:	b570      	push	{r4, r5, r6, lr}
 8017f9e:	4e0e      	ldr	r6, [pc, #56]	; (8017fd8 <sbrk_aligned+0x3c>)
 8017fa0:	460c      	mov	r4, r1
 8017fa2:	6831      	ldr	r1, [r6, #0]
 8017fa4:	4605      	mov	r5, r0
 8017fa6:	b911      	cbnz	r1, 8017fae <sbrk_aligned+0x12>
 8017fa8:	f000 faa4 	bl	80184f4 <_sbrk_r>
 8017fac:	6030      	str	r0, [r6, #0]
 8017fae:	4621      	mov	r1, r4
 8017fb0:	4628      	mov	r0, r5
 8017fb2:	f000 fa9f 	bl	80184f4 <_sbrk_r>
 8017fb6:	1c43      	adds	r3, r0, #1
 8017fb8:	d00a      	beq.n	8017fd0 <sbrk_aligned+0x34>
 8017fba:	1cc4      	adds	r4, r0, #3
 8017fbc:	f024 0403 	bic.w	r4, r4, #3
 8017fc0:	42a0      	cmp	r0, r4
 8017fc2:	d007      	beq.n	8017fd4 <sbrk_aligned+0x38>
 8017fc4:	1a21      	subs	r1, r4, r0
 8017fc6:	4628      	mov	r0, r5
 8017fc8:	f000 fa94 	bl	80184f4 <_sbrk_r>
 8017fcc:	3001      	adds	r0, #1
 8017fce:	d101      	bne.n	8017fd4 <sbrk_aligned+0x38>
 8017fd0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8017fd4:	4620      	mov	r0, r4
 8017fd6:	bd70      	pop	{r4, r5, r6, pc}
 8017fd8:	200027b0 	.word	0x200027b0

08017fdc <_malloc_r>:
 8017fdc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8017fe0:	1ccd      	adds	r5, r1, #3
 8017fe2:	f025 0503 	bic.w	r5, r5, #3
 8017fe6:	3508      	adds	r5, #8
 8017fe8:	2d0c      	cmp	r5, #12
 8017fea:	bf38      	it	cc
 8017fec:	250c      	movcc	r5, #12
 8017fee:	2d00      	cmp	r5, #0
 8017ff0:	4607      	mov	r7, r0
 8017ff2:	db01      	blt.n	8017ff8 <_malloc_r+0x1c>
 8017ff4:	42a9      	cmp	r1, r5
 8017ff6:	d905      	bls.n	8018004 <_malloc_r+0x28>
 8017ff8:	230c      	movs	r3, #12
 8017ffa:	603b      	str	r3, [r7, #0]
 8017ffc:	2600      	movs	r6, #0
 8017ffe:	4630      	mov	r0, r6
 8018000:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8018004:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 80180d8 <_malloc_r+0xfc>
 8018008:	f000 f868 	bl	80180dc <__malloc_lock>
 801800c:	f8d8 3000 	ldr.w	r3, [r8]
 8018010:	461c      	mov	r4, r3
 8018012:	bb5c      	cbnz	r4, 801806c <_malloc_r+0x90>
 8018014:	4629      	mov	r1, r5
 8018016:	4638      	mov	r0, r7
 8018018:	f7ff ffc0 	bl	8017f9c <sbrk_aligned>
 801801c:	1c43      	adds	r3, r0, #1
 801801e:	4604      	mov	r4, r0
 8018020:	d155      	bne.n	80180ce <_malloc_r+0xf2>
 8018022:	f8d8 4000 	ldr.w	r4, [r8]
 8018026:	4626      	mov	r6, r4
 8018028:	2e00      	cmp	r6, #0
 801802a:	d145      	bne.n	80180b8 <_malloc_r+0xdc>
 801802c:	2c00      	cmp	r4, #0
 801802e:	d048      	beq.n	80180c2 <_malloc_r+0xe6>
 8018030:	6823      	ldr	r3, [r4, #0]
 8018032:	4631      	mov	r1, r6
 8018034:	4638      	mov	r0, r7
 8018036:	eb04 0903 	add.w	r9, r4, r3
 801803a:	f000 fa5b 	bl	80184f4 <_sbrk_r>
 801803e:	4581      	cmp	r9, r0
 8018040:	d13f      	bne.n	80180c2 <_malloc_r+0xe6>
 8018042:	6821      	ldr	r1, [r4, #0]
 8018044:	1a6d      	subs	r5, r5, r1
 8018046:	4629      	mov	r1, r5
 8018048:	4638      	mov	r0, r7
 801804a:	f7ff ffa7 	bl	8017f9c <sbrk_aligned>
 801804e:	3001      	adds	r0, #1
 8018050:	d037      	beq.n	80180c2 <_malloc_r+0xe6>
 8018052:	6823      	ldr	r3, [r4, #0]
 8018054:	442b      	add	r3, r5
 8018056:	6023      	str	r3, [r4, #0]
 8018058:	f8d8 3000 	ldr.w	r3, [r8]
 801805c:	2b00      	cmp	r3, #0
 801805e:	d038      	beq.n	80180d2 <_malloc_r+0xf6>
 8018060:	685a      	ldr	r2, [r3, #4]
 8018062:	42a2      	cmp	r2, r4
 8018064:	d12b      	bne.n	80180be <_malloc_r+0xe2>
 8018066:	2200      	movs	r2, #0
 8018068:	605a      	str	r2, [r3, #4]
 801806a:	e00f      	b.n	801808c <_malloc_r+0xb0>
 801806c:	6822      	ldr	r2, [r4, #0]
 801806e:	1b52      	subs	r2, r2, r5
 8018070:	d41f      	bmi.n	80180b2 <_malloc_r+0xd6>
 8018072:	2a0b      	cmp	r2, #11
 8018074:	d917      	bls.n	80180a6 <_malloc_r+0xca>
 8018076:	1961      	adds	r1, r4, r5
 8018078:	42a3      	cmp	r3, r4
 801807a:	6025      	str	r5, [r4, #0]
 801807c:	bf18      	it	ne
 801807e:	6059      	strne	r1, [r3, #4]
 8018080:	6863      	ldr	r3, [r4, #4]
 8018082:	bf08      	it	eq
 8018084:	f8c8 1000 	streq.w	r1, [r8]
 8018088:	5162      	str	r2, [r4, r5]
 801808a:	604b      	str	r3, [r1, #4]
 801808c:	4638      	mov	r0, r7
 801808e:	f104 060b 	add.w	r6, r4, #11
 8018092:	f000 f829 	bl	80180e8 <__malloc_unlock>
 8018096:	f026 0607 	bic.w	r6, r6, #7
 801809a:	1d23      	adds	r3, r4, #4
 801809c:	1af2      	subs	r2, r6, r3
 801809e:	d0ae      	beq.n	8017ffe <_malloc_r+0x22>
 80180a0:	1b9b      	subs	r3, r3, r6
 80180a2:	50a3      	str	r3, [r4, r2]
 80180a4:	e7ab      	b.n	8017ffe <_malloc_r+0x22>
 80180a6:	42a3      	cmp	r3, r4
 80180a8:	6862      	ldr	r2, [r4, #4]
 80180aa:	d1dd      	bne.n	8018068 <_malloc_r+0x8c>
 80180ac:	f8c8 2000 	str.w	r2, [r8]
 80180b0:	e7ec      	b.n	801808c <_malloc_r+0xb0>
 80180b2:	4623      	mov	r3, r4
 80180b4:	6864      	ldr	r4, [r4, #4]
 80180b6:	e7ac      	b.n	8018012 <_malloc_r+0x36>
 80180b8:	4634      	mov	r4, r6
 80180ba:	6876      	ldr	r6, [r6, #4]
 80180bc:	e7b4      	b.n	8018028 <_malloc_r+0x4c>
 80180be:	4613      	mov	r3, r2
 80180c0:	e7cc      	b.n	801805c <_malloc_r+0x80>
 80180c2:	230c      	movs	r3, #12
 80180c4:	603b      	str	r3, [r7, #0]
 80180c6:	4638      	mov	r0, r7
 80180c8:	f000 f80e 	bl	80180e8 <__malloc_unlock>
 80180cc:	e797      	b.n	8017ffe <_malloc_r+0x22>
 80180ce:	6025      	str	r5, [r4, #0]
 80180d0:	e7dc      	b.n	801808c <_malloc_r+0xb0>
 80180d2:	605b      	str	r3, [r3, #4]
 80180d4:	deff      	udf	#255	; 0xff
 80180d6:	bf00      	nop
 80180d8:	200027ac 	.word	0x200027ac

080180dc <__malloc_lock>:
 80180dc:	4801      	ldr	r0, [pc, #4]	; (80180e4 <__malloc_lock+0x8>)
 80180de:	f000 ba56 	b.w	801858e <__retarget_lock_acquire_recursive>
 80180e2:	bf00      	nop
 80180e4:	200028f4 	.word	0x200028f4

080180e8 <__malloc_unlock>:
 80180e8:	4801      	ldr	r0, [pc, #4]	; (80180f0 <__malloc_unlock+0x8>)
 80180ea:	f000 ba51 	b.w	8018590 <__retarget_lock_release_recursive>
 80180ee:	bf00      	nop
 80180f0:	200028f4 	.word	0x200028f4

080180f4 <std>:
 80180f4:	2300      	movs	r3, #0
 80180f6:	b510      	push	{r4, lr}
 80180f8:	4604      	mov	r4, r0
 80180fa:	e9c0 3300 	strd	r3, r3, [r0]
 80180fe:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8018102:	6083      	str	r3, [r0, #8]
 8018104:	8181      	strh	r1, [r0, #12]
 8018106:	6643      	str	r3, [r0, #100]	; 0x64
 8018108:	81c2      	strh	r2, [r0, #14]
 801810a:	6183      	str	r3, [r0, #24]
 801810c:	4619      	mov	r1, r3
 801810e:	2208      	movs	r2, #8
 8018110:	305c      	adds	r0, #92	; 0x5c
 8018112:	f000 f9a5 	bl	8018460 <memset>
 8018116:	4b0d      	ldr	r3, [pc, #52]	; (801814c <std+0x58>)
 8018118:	6263      	str	r3, [r4, #36]	; 0x24
 801811a:	4b0d      	ldr	r3, [pc, #52]	; (8018150 <std+0x5c>)
 801811c:	62a3      	str	r3, [r4, #40]	; 0x28
 801811e:	4b0d      	ldr	r3, [pc, #52]	; (8018154 <std+0x60>)
 8018120:	62e3      	str	r3, [r4, #44]	; 0x2c
 8018122:	4b0d      	ldr	r3, [pc, #52]	; (8018158 <std+0x64>)
 8018124:	6323      	str	r3, [r4, #48]	; 0x30
 8018126:	4b0d      	ldr	r3, [pc, #52]	; (801815c <std+0x68>)
 8018128:	6224      	str	r4, [r4, #32]
 801812a:	429c      	cmp	r4, r3
 801812c:	d006      	beq.n	801813c <std+0x48>
 801812e:	f103 0268 	add.w	r2, r3, #104	; 0x68
 8018132:	4294      	cmp	r4, r2
 8018134:	d002      	beq.n	801813c <std+0x48>
 8018136:	33d0      	adds	r3, #208	; 0xd0
 8018138:	429c      	cmp	r4, r3
 801813a:	d105      	bne.n	8018148 <std+0x54>
 801813c:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8018140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8018144:	f000 ba22 	b.w	801858c <__retarget_lock_init_recursive>
 8018148:	bd10      	pop	{r4, pc}
 801814a:	bf00      	nop
 801814c:	08018369 	.word	0x08018369
 8018150:	0801838b 	.word	0x0801838b
 8018154:	080183c3 	.word	0x080183c3
 8018158:	080183e7 	.word	0x080183e7
 801815c:	200027b4 	.word	0x200027b4

08018160 <stdio_exit_handler>:
 8018160:	4a02      	ldr	r2, [pc, #8]	; (801816c <stdio_exit_handler+0xc>)
 8018162:	4903      	ldr	r1, [pc, #12]	; (8018170 <stdio_exit_handler+0x10>)
 8018164:	4803      	ldr	r0, [pc, #12]	; (8018174 <stdio_exit_handler+0x14>)
 8018166:	f000 b87b 	b.w	8018260 <_fwalk_sglue>
 801816a:	bf00      	nop
 801816c:	20000114 	.word	0x20000114
 8018170:	08018fbd 	.word	0x08018fbd
 8018174:	20000120 	.word	0x20000120

08018178 <cleanup_stdio>:
 8018178:	6841      	ldr	r1, [r0, #4]
 801817a:	4b0c      	ldr	r3, [pc, #48]	; (80181ac <cleanup_stdio+0x34>)
 801817c:	4299      	cmp	r1, r3
 801817e:	b510      	push	{r4, lr}
 8018180:	4604      	mov	r4, r0
 8018182:	d001      	beq.n	8018188 <cleanup_stdio+0x10>
 8018184:	f000 ff1a 	bl	8018fbc <_fflush_r>
 8018188:	68a1      	ldr	r1, [r4, #8]
 801818a:	4b09      	ldr	r3, [pc, #36]	; (80181b0 <cleanup_stdio+0x38>)
 801818c:	4299      	cmp	r1, r3
 801818e:	d002      	beq.n	8018196 <cleanup_stdio+0x1e>
 8018190:	4620      	mov	r0, r4
 8018192:	f000 ff13 	bl	8018fbc <_fflush_r>
 8018196:	68e1      	ldr	r1, [r4, #12]
 8018198:	4b06      	ldr	r3, [pc, #24]	; (80181b4 <cleanup_stdio+0x3c>)
 801819a:	4299      	cmp	r1, r3
 801819c:	d004      	beq.n	80181a8 <cleanup_stdio+0x30>
 801819e:	4620      	mov	r0, r4
 80181a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80181a4:	f000 bf0a 	b.w	8018fbc <_fflush_r>
 80181a8:	bd10      	pop	{r4, pc}
 80181aa:	bf00      	nop
 80181ac:	200027b4 	.word	0x200027b4
 80181b0:	2000281c 	.word	0x2000281c
 80181b4:	20002884 	.word	0x20002884

080181b8 <global_stdio_init.part.0>:
 80181b8:	b510      	push	{r4, lr}
 80181ba:	4b0b      	ldr	r3, [pc, #44]	; (80181e8 <global_stdio_init.part.0+0x30>)
 80181bc:	4c0b      	ldr	r4, [pc, #44]	; (80181ec <global_stdio_init.part.0+0x34>)
 80181be:	4a0c      	ldr	r2, [pc, #48]	; (80181f0 <global_stdio_init.part.0+0x38>)
 80181c0:	601a      	str	r2, [r3, #0]
 80181c2:	4620      	mov	r0, r4
 80181c4:	2200      	movs	r2, #0
 80181c6:	2104      	movs	r1, #4
 80181c8:	f7ff ff94 	bl	80180f4 <std>
 80181cc:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80181d0:	2201      	movs	r2, #1
 80181d2:	2109      	movs	r1, #9
 80181d4:	f7ff ff8e 	bl	80180f4 <std>
 80181d8:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 80181dc:	2202      	movs	r2, #2
 80181de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80181e2:	2112      	movs	r1, #18
 80181e4:	f7ff bf86 	b.w	80180f4 <std>
 80181e8:	200028ec 	.word	0x200028ec
 80181ec:	200027b4 	.word	0x200027b4
 80181f0:	08018161 	.word	0x08018161

080181f4 <__sfp_lock_acquire>:
 80181f4:	4801      	ldr	r0, [pc, #4]	; (80181fc <__sfp_lock_acquire+0x8>)
 80181f6:	f000 b9ca 	b.w	801858e <__retarget_lock_acquire_recursive>
 80181fa:	bf00      	nop
 80181fc:	200028f5 	.word	0x200028f5

08018200 <__sfp_lock_release>:
 8018200:	4801      	ldr	r0, [pc, #4]	; (8018208 <__sfp_lock_release+0x8>)
 8018202:	f000 b9c5 	b.w	8018590 <__retarget_lock_release_recursive>
 8018206:	bf00      	nop
 8018208:	200028f5 	.word	0x200028f5

0801820c <__sinit>:
 801820c:	b510      	push	{r4, lr}
 801820e:	4604      	mov	r4, r0
 8018210:	f7ff fff0 	bl	80181f4 <__sfp_lock_acquire>
 8018214:	6a23      	ldr	r3, [r4, #32]
 8018216:	b11b      	cbz	r3, 8018220 <__sinit+0x14>
 8018218:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801821c:	f7ff bff0 	b.w	8018200 <__sfp_lock_release>
 8018220:	4b04      	ldr	r3, [pc, #16]	; (8018234 <__sinit+0x28>)
 8018222:	6223      	str	r3, [r4, #32]
 8018224:	4b04      	ldr	r3, [pc, #16]	; (8018238 <__sinit+0x2c>)
 8018226:	681b      	ldr	r3, [r3, #0]
 8018228:	2b00      	cmp	r3, #0
 801822a:	d1f5      	bne.n	8018218 <__sinit+0xc>
 801822c:	f7ff ffc4 	bl	80181b8 <global_stdio_init.part.0>
 8018230:	e7f2      	b.n	8018218 <__sinit+0xc>
 8018232:	bf00      	nop
 8018234:	08018179 	.word	0x08018179
 8018238:	200028ec 	.word	0x200028ec

0801823c <fiprintf>:
 801823c:	b40e      	push	{r1, r2, r3}
 801823e:	b503      	push	{r0, r1, lr}
 8018240:	4601      	mov	r1, r0
 8018242:	ab03      	add	r3, sp, #12
 8018244:	4805      	ldr	r0, [pc, #20]	; (801825c <fiprintf+0x20>)
 8018246:	f853 2b04 	ldr.w	r2, [r3], #4
 801824a:	6800      	ldr	r0, [r0, #0]
 801824c:	9301      	str	r3, [sp, #4]
 801824e:	f000 fb85 	bl	801895c <_vfiprintf_r>
 8018252:	b002      	add	sp, #8
 8018254:	f85d eb04 	ldr.w	lr, [sp], #4
 8018258:	b003      	add	sp, #12
 801825a:	4770      	bx	lr
 801825c:	2000016c 	.word	0x2000016c

08018260 <_fwalk_sglue>:
 8018260:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8018264:	4607      	mov	r7, r0
 8018266:	4688      	mov	r8, r1
 8018268:	4614      	mov	r4, r2
 801826a:	2600      	movs	r6, #0
 801826c:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8018270:	f1b9 0901 	subs.w	r9, r9, #1
 8018274:	d505      	bpl.n	8018282 <_fwalk_sglue+0x22>
 8018276:	6824      	ldr	r4, [r4, #0]
 8018278:	2c00      	cmp	r4, #0
 801827a:	d1f7      	bne.n	801826c <_fwalk_sglue+0xc>
 801827c:	4630      	mov	r0, r6
 801827e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8018282:	89ab      	ldrh	r3, [r5, #12]
 8018284:	2b01      	cmp	r3, #1
 8018286:	d907      	bls.n	8018298 <_fwalk_sglue+0x38>
 8018288:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 801828c:	3301      	adds	r3, #1
 801828e:	d003      	beq.n	8018298 <_fwalk_sglue+0x38>
 8018290:	4629      	mov	r1, r5
 8018292:	4638      	mov	r0, r7
 8018294:	47c0      	blx	r8
 8018296:	4306      	orrs	r6, r0
 8018298:	3568      	adds	r5, #104	; 0x68
 801829a:	e7e9      	b.n	8018270 <_fwalk_sglue+0x10>

0801829c <iprintf>:
 801829c:	b40f      	push	{r0, r1, r2, r3}
 801829e:	b507      	push	{r0, r1, r2, lr}
 80182a0:	4906      	ldr	r1, [pc, #24]	; (80182bc <iprintf+0x20>)
 80182a2:	ab04      	add	r3, sp, #16
 80182a4:	6808      	ldr	r0, [r1, #0]
 80182a6:	f853 2b04 	ldr.w	r2, [r3], #4
 80182aa:	6881      	ldr	r1, [r0, #8]
 80182ac:	9301      	str	r3, [sp, #4]
 80182ae:	f000 fb55 	bl	801895c <_vfiprintf_r>
 80182b2:	b003      	add	sp, #12
 80182b4:	f85d eb04 	ldr.w	lr, [sp], #4
 80182b8:	b004      	add	sp, #16
 80182ba:	4770      	bx	lr
 80182bc:	2000016c 	.word	0x2000016c

080182c0 <sniprintf>:
 80182c0:	b40c      	push	{r2, r3}
 80182c2:	b530      	push	{r4, r5, lr}
 80182c4:	4b17      	ldr	r3, [pc, #92]	; (8018324 <sniprintf+0x64>)
 80182c6:	1e0c      	subs	r4, r1, #0
 80182c8:	681d      	ldr	r5, [r3, #0]
 80182ca:	b09d      	sub	sp, #116	; 0x74
 80182cc:	da08      	bge.n	80182e0 <sniprintf+0x20>
 80182ce:	238b      	movs	r3, #139	; 0x8b
 80182d0:	602b      	str	r3, [r5, #0]
 80182d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80182d6:	b01d      	add	sp, #116	; 0x74
 80182d8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80182dc:	b002      	add	sp, #8
 80182de:	4770      	bx	lr
 80182e0:	f44f 7302 	mov.w	r3, #520	; 0x208
 80182e4:	f8ad 3014 	strh.w	r3, [sp, #20]
 80182e8:	bf14      	ite	ne
 80182ea:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
 80182ee:	4623      	moveq	r3, r4
 80182f0:	9304      	str	r3, [sp, #16]
 80182f2:	9307      	str	r3, [sp, #28]
 80182f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80182f8:	9002      	str	r0, [sp, #8]
 80182fa:	9006      	str	r0, [sp, #24]
 80182fc:	f8ad 3016 	strh.w	r3, [sp, #22]
 8018300:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8018302:	ab21      	add	r3, sp, #132	; 0x84
 8018304:	a902      	add	r1, sp, #8
 8018306:	4628      	mov	r0, r5
 8018308:	9301      	str	r3, [sp, #4]
 801830a:	f000 f9ff 	bl	801870c <_svfiprintf_r>
 801830e:	1c43      	adds	r3, r0, #1
 8018310:	bfbc      	itt	lt
 8018312:	238b      	movlt	r3, #139	; 0x8b
 8018314:	602b      	strlt	r3, [r5, #0]
 8018316:	2c00      	cmp	r4, #0
 8018318:	d0dd      	beq.n	80182d6 <sniprintf+0x16>
 801831a:	9b02      	ldr	r3, [sp, #8]
 801831c:	2200      	movs	r2, #0
 801831e:	701a      	strb	r2, [r3, #0]
 8018320:	e7d9      	b.n	80182d6 <sniprintf+0x16>
 8018322:	bf00      	nop
 8018324:	2000016c 	.word	0x2000016c

08018328 <siprintf>:
 8018328:	b40e      	push	{r1, r2, r3}
 801832a:	b500      	push	{lr}
 801832c:	b09c      	sub	sp, #112	; 0x70
 801832e:	ab1d      	add	r3, sp, #116	; 0x74
 8018330:	9002      	str	r0, [sp, #8]
 8018332:	9006      	str	r0, [sp, #24]
 8018334:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8018338:	4809      	ldr	r0, [pc, #36]	; (8018360 <siprintf+0x38>)
 801833a:	9107      	str	r1, [sp, #28]
 801833c:	9104      	str	r1, [sp, #16]
 801833e:	4909      	ldr	r1, [pc, #36]	; (8018364 <siprintf+0x3c>)
 8018340:	f853 2b04 	ldr.w	r2, [r3], #4
 8018344:	9105      	str	r1, [sp, #20]
 8018346:	6800      	ldr	r0, [r0, #0]
 8018348:	9301      	str	r3, [sp, #4]
 801834a:	a902      	add	r1, sp, #8
 801834c:	f000 f9de 	bl	801870c <_svfiprintf_r>
 8018350:	9b02      	ldr	r3, [sp, #8]
 8018352:	2200      	movs	r2, #0
 8018354:	701a      	strb	r2, [r3, #0]
 8018356:	b01c      	add	sp, #112	; 0x70
 8018358:	f85d eb04 	ldr.w	lr, [sp], #4
 801835c:	b003      	add	sp, #12
 801835e:	4770      	bx	lr
 8018360:	2000016c 	.word	0x2000016c
 8018364:	ffff0208 	.word	0xffff0208

08018368 <__sread>:
 8018368:	b510      	push	{r4, lr}
 801836a:	460c      	mov	r4, r1
 801836c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8018370:	f000 f8ae 	bl	80184d0 <_read_r>
 8018374:	2800      	cmp	r0, #0
 8018376:	bfab      	itete	ge
 8018378:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 801837a:	89a3      	ldrhlt	r3, [r4, #12]
 801837c:	181b      	addge	r3, r3, r0
 801837e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8018382:	bfac      	ite	ge
 8018384:	6563      	strge	r3, [r4, #84]	; 0x54
 8018386:	81a3      	strhlt	r3, [r4, #12]
 8018388:	bd10      	pop	{r4, pc}

0801838a <__swrite>:
 801838a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801838e:	461f      	mov	r7, r3
 8018390:	898b      	ldrh	r3, [r1, #12]
 8018392:	05db      	lsls	r3, r3, #23
 8018394:	4605      	mov	r5, r0
 8018396:	460c      	mov	r4, r1
 8018398:	4616      	mov	r6, r2
 801839a:	d505      	bpl.n	80183a8 <__swrite+0x1e>
 801839c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80183a0:	2302      	movs	r3, #2
 80183a2:	2200      	movs	r2, #0
 80183a4:	f000 f882 	bl	80184ac <_lseek_r>
 80183a8:	89a3      	ldrh	r3, [r4, #12]
 80183aa:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80183ae:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80183b2:	81a3      	strh	r3, [r4, #12]
 80183b4:	4632      	mov	r2, r6
 80183b6:	463b      	mov	r3, r7
 80183b8:	4628      	mov	r0, r5
 80183ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80183be:	f000 b8a9 	b.w	8018514 <_write_r>

080183c2 <__sseek>:
 80183c2:	b510      	push	{r4, lr}
 80183c4:	460c      	mov	r4, r1
 80183c6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80183ca:	f000 f86f 	bl	80184ac <_lseek_r>
 80183ce:	1c43      	adds	r3, r0, #1
 80183d0:	89a3      	ldrh	r3, [r4, #12]
 80183d2:	bf15      	itete	ne
 80183d4:	6560      	strne	r0, [r4, #84]	; 0x54
 80183d6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80183da:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80183de:	81a3      	strheq	r3, [r4, #12]
 80183e0:	bf18      	it	ne
 80183e2:	81a3      	strhne	r3, [r4, #12]
 80183e4:	bd10      	pop	{r4, pc}

080183e6 <__sclose>:
 80183e6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80183ea:	f000 b84f 	b.w	801848c <_close_r>

080183ee <_vsniprintf_r>:
 80183ee:	b530      	push	{r4, r5, lr}
 80183f0:	4614      	mov	r4, r2
 80183f2:	2c00      	cmp	r4, #0
 80183f4:	b09b      	sub	sp, #108	; 0x6c
 80183f6:	4605      	mov	r5, r0
 80183f8:	461a      	mov	r2, r3
 80183fa:	da05      	bge.n	8018408 <_vsniprintf_r+0x1a>
 80183fc:	238b      	movs	r3, #139	; 0x8b
 80183fe:	6003      	str	r3, [r0, #0]
 8018400:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8018404:	b01b      	add	sp, #108	; 0x6c
 8018406:	bd30      	pop	{r4, r5, pc}
 8018408:	f44f 7302 	mov.w	r3, #520	; 0x208
 801840c:	f8ad 300c 	strh.w	r3, [sp, #12]
 8018410:	bf14      	ite	ne
 8018412:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
 8018416:	4623      	moveq	r3, r4
 8018418:	9302      	str	r3, [sp, #8]
 801841a:	9305      	str	r3, [sp, #20]
 801841c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8018420:	9100      	str	r1, [sp, #0]
 8018422:	9104      	str	r1, [sp, #16]
 8018424:	f8ad 300e 	strh.w	r3, [sp, #14]
 8018428:	4669      	mov	r1, sp
 801842a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801842c:	f000 f96e 	bl	801870c <_svfiprintf_r>
 8018430:	1c43      	adds	r3, r0, #1
 8018432:	bfbc      	itt	lt
 8018434:	238b      	movlt	r3, #139	; 0x8b
 8018436:	602b      	strlt	r3, [r5, #0]
 8018438:	2c00      	cmp	r4, #0
 801843a:	d0e3      	beq.n	8018404 <_vsniprintf_r+0x16>
 801843c:	9b00      	ldr	r3, [sp, #0]
 801843e:	2200      	movs	r2, #0
 8018440:	701a      	strb	r2, [r3, #0]
 8018442:	e7df      	b.n	8018404 <_vsniprintf_r+0x16>

08018444 <vsniprintf>:
 8018444:	b507      	push	{r0, r1, r2, lr}
 8018446:	9300      	str	r3, [sp, #0]
 8018448:	4613      	mov	r3, r2
 801844a:	460a      	mov	r2, r1
 801844c:	4601      	mov	r1, r0
 801844e:	4803      	ldr	r0, [pc, #12]	; (801845c <vsniprintf+0x18>)
 8018450:	6800      	ldr	r0, [r0, #0]
 8018452:	f7ff ffcc 	bl	80183ee <_vsniprintf_r>
 8018456:	b003      	add	sp, #12
 8018458:	f85d fb04 	ldr.w	pc, [sp], #4
 801845c:	2000016c 	.word	0x2000016c

08018460 <memset>:
 8018460:	4402      	add	r2, r0
 8018462:	4603      	mov	r3, r0
 8018464:	4293      	cmp	r3, r2
 8018466:	d100      	bne.n	801846a <memset+0xa>
 8018468:	4770      	bx	lr
 801846a:	f803 1b01 	strb.w	r1, [r3], #1
 801846e:	e7f9      	b.n	8018464 <memset+0x4>

08018470 <strchr>:
 8018470:	b2c9      	uxtb	r1, r1
 8018472:	4603      	mov	r3, r0
 8018474:	f810 2b01 	ldrb.w	r2, [r0], #1
 8018478:	b11a      	cbz	r2, 8018482 <strchr+0x12>
 801847a:	428a      	cmp	r2, r1
 801847c:	d1f9      	bne.n	8018472 <strchr+0x2>
 801847e:	4618      	mov	r0, r3
 8018480:	4770      	bx	lr
 8018482:	2900      	cmp	r1, #0
 8018484:	bf18      	it	ne
 8018486:	2300      	movne	r3, #0
 8018488:	e7f9      	b.n	801847e <strchr+0xe>
	...

0801848c <_close_r>:
 801848c:	b538      	push	{r3, r4, r5, lr}
 801848e:	4d06      	ldr	r5, [pc, #24]	; (80184a8 <_close_r+0x1c>)
 8018490:	2300      	movs	r3, #0
 8018492:	4604      	mov	r4, r0
 8018494:	4608      	mov	r0, r1
 8018496:	602b      	str	r3, [r5, #0]
 8018498:	f7ef ff1b 	bl	80082d2 <_close>
 801849c:	1c43      	adds	r3, r0, #1
 801849e:	d102      	bne.n	80184a6 <_close_r+0x1a>
 80184a0:	682b      	ldr	r3, [r5, #0]
 80184a2:	b103      	cbz	r3, 80184a6 <_close_r+0x1a>
 80184a4:	6023      	str	r3, [r4, #0]
 80184a6:	bd38      	pop	{r3, r4, r5, pc}
 80184a8:	200028f0 	.word	0x200028f0

080184ac <_lseek_r>:
 80184ac:	b538      	push	{r3, r4, r5, lr}
 80184ae:	4d07      	ldr	r5, [pc, #28]	; (80184cc <_lseek_r+0x20>)
 80184b0:	4604      	mov	r4, r0
 80184b2:	4608      	mov	r0, r1
 80184b4:	4611      	mov	r1, r2
 80184b6:	2200      	movs	r2, #0
 80184b8:	602a      	str	r2, [r5, #0]
 80184ba:	461a      	mov	r2, r3
 80184bc:	f7ef ff30 	bl	8008320 <_lseek>
 80184c0:	1c43      	adds	r3, r0, #1
 80184c2:	d102      	bne.n	80184ca <_lseek_r+0x1e>
 80184c4:	682b      	ldr	r3, [r5, #0]
 80184c6:	b103      	cbz	r3, 80184ca <_lseek_r+0x1e>
 80184c8:	6023      	str	r3, [r4, #0]
 80184ca:	bd38      	pop	{r3, r4, r5, pc}
 80184cc:	200028f0 	.word	0x200028f0

080184d0 <_read_r>:
 80184d0:	b538      	push	{r3, r4, r5, lr}
 80184d2:	4d07      	ldr	r5, [pc, #28]	; (80184f0 <_read_r+0x20>)
 80184d4:	4604      	mov	r4, r0
 80184d6:	4608      	mov	r0, r1
 80184d8:	4611      	mov	r1, r2
 80184da:	2200      	movs	r2, #0
 80184dc:	602a      	str	r2, [r5, #0]
 80184de:	461a      	mov	r2, r3
 80184e0:	f7ef feda 	bl	8008298 <_read>
 80184e4:	1c43      	adds	r3, r0, #1
 80184e6:	d102      	bne.n	80184ee <_read_r+0x1e>
 80184e8:	682b      	ldr	r3, [r5, #0]
 80184ea:	b103      	cbz	r3, 80184ee <_read_r+0x1e>
 80184ec:	6023      	str	r3, [r4, #0]
 80184ee:	bd38      	pop	{r3, r4, r5, pc}
 80184f0:	200028f0 	.word	0x200028f0

080184f4 <_sbrk_r>:
 80184f4:	b538      	push	{r3, r4, r5, lr}
 80184f6:	4d06      	ldr	r5, [pc, #24]	; (8018510 <_sbrk_r+0x1c>)
 80184f8:	2300      	movs	r3, #0
 80184fa:	4604      	mov	r4, r0
 80184fc:	4608      	mov	r0, r1
 80184fe:	602b      	str	r3, [r5, #0]
 8018500:	f7ef ff1c 	bl	800833c <_sbrk>
 8018504:	1c43      	adds	r3, r0, #1
 8018506:	d102      	bne.n	801850e <_sbrk_r+0x1a>
 8018508:	682b      	ldr	r3, [r5, #0]
 801850a:	b103      	cbz	r3, 801850e <_sbrk_r+0x1a>
 801850c:	6023      	str	r3, [r4, #0]
 801850e:	bd38      	pop	{r3, r4, r5, pc}
 8018510:	200028f0 	.word	0x200028f0

08018514 <_write_r>:
 8018514:	b538      	push	{r3, r4, r5, lr}
 8018516:	4d07      	ldr	r5, [pc, #28]	; (8018534 <_write_r+0x20>)
 8018518:	4604      	mov	r4, r0
 801851a:	4608      	mov	r0, r1
 801851c:	4611      	mov	r1, r2
 801851e:	2200      	movs	r2, #0
 8018520:	602a      	str	r2, [r5, #0]
 8018522:	461a      	mov	r2, r3
 8018524:	f7fc f904 	bl	8014730 <_write>
 8018528:	1c43      	adds	r3, r0, #1
 801852a:	d102      	bne.n	8018532 <_write_r+0x1e>
 801852c:	682b      	ldr	r3, [r5, #0]
 801852e:	b103      	cbz	r3, 8018532 <_write_r+0x1e>
 8018530:	6023      	str	r3, [r4, #0]
 8018532:	bd38      	pop	{r3, r4, r5, pc}
 8018534:	200028f0 	.word	0x200028f0

08018538 <__errno>:
 8018538:	4b01      	ldr	r3, [pc, #4]	; (8018540 <__errno+0x8>)
 801853a:	6818      	ldr	r0, [r3, #0]
 801853c:	4770      	bx	lr
 801853e:	bf00      	nop
 8018540:	2000016c 	.word	0x2000016c

08018544 <__libc_init_array>:
 8018544:	b570      	push	{r4, r5, r6, lr}
 8018546:	4d0d      	ldr	r5, [pc, #52]	; (801857c <__libc_init_array+0x38>)
 8018548:	4c0d      	ldr	r4, [pc, #52]	; (8018580 <__libc_init_array+0x3c>)
 801854a:	1b64      	subs	r4, r4, r5
 801854c:	10a4      	asrs	r4, r4, #2
 801854e:	2600      	movs	r6, #0
 8018550:	42a6      	cmp	r6, r4
 8018552:	d109      	bne.n	8018568 <__libc_init_array+0x24>
 8018554:	4d0b      	ldr	r5, [pc, #44]	; (8018584 <__libc_init_array+0x40>)
 8018556:	4c0c      	ldr	r4, [pc, #48]	; (8018588 <__libc_init_array+0x44>)
 8018558:	f000 ff08 	bl	801936c <_init>
 801855c:	1b64      	subs	r4, r4, r5
 801855e:	10a4      	asrs	r4, r4, #2
 8018560:	2600      	movs	r6, #0
 8018562:	42a6      	cmp	r6, r4
 8018564:	d105      	bne.n	8018572 <__libc_init_array+0x2e>
 8018566:	bd70      	pop	{r4, r5, r6, pc}
 8018568:	f855 3b04 	ldr.w	r3, [r5], #4
 801856c:	4798      	blx	r3
 801856e:	3601      	adds	r6, #1
 8018570:	e7ee      	b.n	8018550 <__libc_init_array+0xc>
 8018572:	f855 3b04 	ldr.w	r3, [r5], #4
 8018576:	4798      	blx	r3
 8018578:	3601      	adds	r6, #1
 801857a:	e7f2      	b.n	8018562 <__libc_init_array+0x1e>
 801857c:	08019d98 	.word	0x08019d98
 8018580:	08019d98 	.word	0x08019d98
 8018584:	08019d98 	.word	0x08019d98
 8018588:	08019d9c 	.word	0x08019d9c

0801858c <__retarget_lock_init_recursive>:
 801858c:	4770      	bx	lr

0801858e <__retarget_lock_acquire_recursive>:
 801858e:	4770      	bx	lr

08018590 <__retarget_lock_release_recursive>:
 8018590:	4770      	bx	lr

08018592 <__aeabi_memcpy>:
 8018592:	f000 b800 	b.w	8018596 <memcpy>

08018596 <memcpy>:
 8018596:	440a      	add	r2, r1
 8018598:	4291      	cmp	r1, r2
 801859a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 801859e:	d100      	bne.n	80185a2 <memcpy+0xc>
 80185a0:	4770      	bx	lr
 80185a2:	b510      	push	{r4, lr}
 80185a4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80185a8:	f803 4f01 	strb.w	r4, [r3, #1]!
 80185ac:	4291      	cmp	r1, r2
 80185ae:	d1f9      	bne.n	80185a4 <memcpy+0xe>
 80185b0:	bd10      	pop	{r4, pc}

080185b2 <abort>:
 80185b2:	b508      	push	{r3, lr}
 80185b4:	2006      	movs	r0, #6
 80185b6:	f000 fe01 	bl	80191bc <raise>
 80185ba:	2001      	movs	r0, #1
 80185bc:	f7ef fe62 	bl	8008284 <_exit>

080185c0 <_free_r>:
 80185c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80185c2:	2900      	cmp	r1, #0
 80185c4:	d044      	beq.n	8018650 <_free_r+0x90>
 80185c6:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80185ca:	9001      	str	r0, [sp, #4]
 80185cc:	2b00      	cmp	r3, #0
 80185ce:	f1a1 0404 	sub.w	r4, r1, #4
 80185d2:	bfb8      	it	lt
 80185d4:	18e4      	addlt	r4, r4, r3
 80185d6:	f7ff fd81 	bl	80180dc <__malloc_lock>
 80185da:	4a1e      	ldr	r2, [pc, #120]	; (8018654 <_free_r+0x94>)
 80185dc:	9801      	ldr	r0, [sp, #4]
 80185de:	6813      	ldr	r3, [r2, #0]
 80185e0:	b933      	cbnz	r3, 80185f0 <_free_r+0x30>
 80185e2:	6063      	str	r3, [r4, #4]
 80185e4:	6014      	str	r4, [r2, #0]
 80185e6:	b003      	add	sp, #12
 80185e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80185ec:	f7ff bd7c 	b.w	80180e8 <__malloc_unlock>
 80185f0:	42a3      	cmp	r3, r4
 80185f2:	d908      	bls.n	8018606 <_free_r+0x46>
 80185f4:	6825      	ldr	r5, [r4, #0]
 80185f6:	1961      	adds	r1, r4, r5
 80185f8:	428b      	cmp	r3, r1
 80185fa:	bf01      	itttt	eq
 80185fc:	6819      	ldreq	r1, [r3, #0]
 80185fe:	685b      	ldreq	r3, [r3, #4]
 8018600:	1949      	addeq	r1, r1, r5
 8018602:	6021      	streq	r1, [r4, #0]
 8018604:	e7ed      	b.n	80185e2 <_free_r+0x22>
 8018606:	461a      	mov	r2, r3
 8018608:	685b      	ldr	r3, [r3, #4]
 801860a:	b10b      	cbz	r3, 8018610 <_free_r+0x50>
 801860c:	42a3      	cmp	r3, r4
 801860e:	d9fa      	bls.n	8018606 <_free_r+0x46>
 8018610:	6811      	ldr	r1, [r2, #0]
 8018612:	1855      	adds	r5, r2, r1
 8018614:	42a5      	cmp	r5, r4
 8018616:	d10b      	bne.n	8018630 <_free_r+0x70>
 8018618:	6824      	ldr	r4, [r4, #0]
 801861a:	4421      	add	r1, r4
 801861c:	1854      	adds	r4, r2, r1
 801861e:	42a3      	cmp	r3, r4
 8018620:	6011      	str	r1, [r2, #0]
 8018622:	d1e0      	bne.n	80185e6 <_free_r+0x26>
 8018624:	681c      	ldr	r4, [r3, #0]
 8018626:	685b      	ldr	r3, [r3, #4]
 8018628:	6053      	str	r3, [r2, #4]
 801862a:	440c      	add	r4, r1
 801862c:	6014      	str	r4, [r2, #0]
 801862e:	e7da      	b.n	80185e6 <_free_r+0x26>
 8018630:	d902      	bls.n	8018638 <_free_r+0x78>
 8018632:	230c      	movs	r3, #12
 8018634:	6003      	str	r3, [r0, #0]
 8018636:	e7d6      	b.n	80185e6 <_free_r+0x26>
 8018638:	6825      	ldr	r5, [r4, #0]
 801863a:	1961      	adds	r1, r4, r5
 801863c:	428b      	cmp	r3, r1
 801863e:	bf04      	itt	eq
 8018640:	6819      	ldreq	r1, [r3, #0]
 8018642:	685b      	ldreq	r3, [r3, #4]
 8018644:	6063      	str	r3, [r4, #4]
 8018646:	bf04      	itt	eq
 8018648:	1949      	addeq	r1, r1, r5
 801864a:	6021      	streq	r1, [r4, #0]
 801864c:	6054      	str	r4, [r2, #4]
 801864e:	e7ca      	b.n	80185e6 <_free_r+0x26>
 8018650:	b003      	add	sp, #12
 8018652:	bd30      	pop	{r4, r5, pc}
 8018654:	200027ac 	.word	0x200027ac

08018658 <__ssputs_r>:
 8018658:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801865c:	688e      	ldr	r6, [r1, #8]
 801865e:	461f      	mov	r7, r3
 8018660:	42be      	cmp	r6, r7
 8018662:	680b      	ldr	r3, [r1, #0]
 8018664:	4682      	mov	sl, r0
 8018666:	460c      	mov	r4, r1
 8018668:	4690      	mov	r8, r2
 801866a:	d82c      	bhi.n	80186c6 <__ssputs_r+0x6e>
 801866c:	898a      	ldrh	r2, [r1, #12]
 801866e:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8018672:	d026      	beq.n	80186c2 <__ssputs_r+0x6a>
 8018674:	6965      	ldr	r5, [r4, #20]
 8018676:	6909      	ldr	r1, [r1, #16]
 8018678:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 801867c:	eba3 0901 	sub.w	r9, r3, r1
 8018680:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8018684:	1c7b      	adds	r3, r7, #1
 8018686:	444b      	add	r3, r9
 8018688:	106d      	asrs	r5, r5, #1
 801868a:	429d      	cmp	r5, r3
 801868c:	bf38      	it	cc
 801868e:	461d      	movcc	r5, r3
 8018690:	0553      	lsls	r3, r2, #21
 8018692:	d527      	bpl.n	80186e4 <__ssputs_r+0x8c>
 8018694:	4629      	mov	r1, r5
 8018696:	f7ff fca1 	bl	8017fdc <_malloc_r>
 801869a:	4606      	mov	r6, r0
 801869c:	b360      	cbz	r0, 80186f8 <__ssputs_r+0xa0>
 801869e:	6921      	ldr	r1, [r4, #16]
 80186a0:	464a      	mov	r2, r9
 80186a2:	f7ff ff78 	bl	8018596 <memcpy>
 80186a6:	89a3      	ldrh	r3, [r4, #12]
 80186a8:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80186ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80186b0:	81a3      	strh	r3, [r4, #12]
 80186b2:	6126      	str	r6, [r4, #16]
 80186b4:	6165      	str	r5, [r4, #20]
 80186b6:	444e      	add	r6, r9
 80186b8:	eba5 0509 	sub.w	r5, r5, r9
 80186bc:	6026      	str	r6, [r4, #0]
 80186be:	60a5      	str	r5, [r4, #8]
 80186c0:	463e      	mov	r6, r7
 80186c2:	42be      	cmp	r6, r7
 80186c4:	d900      	bls.n	80186c8 <__ssputs_r+0x70>
 80186c6:	463e      	mov	r6, r7
 80186c8:	6820      	ldr	r0, [r4, #0]
 80186ca:	4632      	mov	r2, r6
 80186cc:	4641      	mov	r1, r8
 80186ce:	f000 fd33 	bl	8019138 <memmove>
 80186d2:	68a3      	ldr	r3, [r4, #8]
 80186d4:	1b9b      	subs	r3, r3, r6
 80186d6:	60a3      	str	r3, [r4, #8]
 80186d8:	6823      	ldr	r3, [r4, #0]
 80186da:	4433      	add	r3, r6
 80186dc:	6023      	str	r3, [r4, #0]
 80186de:	2000      	movs	r0, #0
 80186e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80186e4:	462a      	mov	r2, r5
 80186e6:	f000 fd85 	bl	80191f4 <_realloc_r>
 80186ea:	4606      	mov	r6, r0
 80186ec:	2800      	cmp	r0, #0
 80186ee:	d1e0      	bne.n	80186b2 <__ssputs_r+0x5a>
 80186f0:	6921      	ldr	r1, [r4, #16]
 80186f2:	4650      	mov	r0, sl
 80186f4:	f7ff ff64 	bl	80185c0 <_free_r>
 80186f8:	230c      	movs	r3, #12
 80186fa:	f8ca 3000 	str.w	r3, [sl]
 80186fe:	89a3      	ldrh	r3, [r4, #12]
 8018700:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8018704:	81a3      	strh	r3, [r4, #12]
 8018706:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801870a:	e7e9      	b.n	80186e0 <__ssputs_r+0x88>

0801870c <_svfiprintf_r>:
 801870c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018710:	4698      	mov	r8, r3
 8018712:	898b      	ldrh	r3, [r1, #12]
 8018714:	061b      	lsls	r3, r3, #24
 8018716:	b09d      	sub	sp, #116	; 0x74
 8018718:	4607      	mov	r7, r0
 801871a:	460d      	mov	r5, r1
 801871c:	4614      	mov	r4, r2
 801871e:	d50e      	bpl.n	801873e <_svfiprintf_r+0x32>
 8018720:	690b      	ldr	r3, [r1, #16]
 8018722:	b963      	cbnz	r3, 801873e <_svfiprintf_r+0x32>
 8018724:	2140      	movs	r1, #64	; 0x40
 8018726:	f7ff fc59 	bl	8017fdc <_malloc_r>
 801872a:	6028      	str	r0, [r5, #0]
 801872c:	6128      	str	r0, [r5, #16]
 801872e:	b920      	cbnz	r0, 801873a <_svfiprintf_r+0x2e>
 8018730:	230c      	movs	r3, #12
 8018732:	603b      	str	r3, [r7, #0]
 8018734:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8018738:	e0d0      	b.n	80188dc <_svfiprintf_r+0x1d0>
 801873a:	2340      	movs	r3, #64	; 0x40
 801873c:	616b      	str	r3, [r5, #20]
 801873e:	2300      	movs	r3, #0
 8018740:	9309      	str	r3, [sp, #36]	; 0x24
 8018742:	2320      	movs	r3, #32
 8018744:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8018748:	f8cd 800c 	str.w	r8, [sp, #12]
 801874c:	2330      	movs	r3, #48	; 0x30
 801874e:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 80188f4 <_svfiprintf_r+0x1e8>
 8018752:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8018756:	f04f 0901 	mov.w	r9, #1
 801875a:	4623      	mov	r3, r4
 801875c:	469a      	mov	sl, r3
 801875e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8018762:	b10a      	cbz	r2, 8018768 <_svfiprintf_r+0x5c>
 8018764:	2a25      	cmp	r2, #37	; 0x25
 8018766:	d1f9      	bne.n	801875c <_svfiprintf_r+0x50>
 8018768:	ebba 0b04 	subs.w	fp, sl, r4
 801876c:	d00b      	beq.n	8018786 <_svfiprintf_r+0x7a>
 801876e:	465b      	mov	r3, fp
 8018770:	4622      	mov	r2, r4
 8018772:	4629      	mov	r1, r5
 8018774:	4638      	mov	r0, r7
 8018776:	f7ff ff6f 	bl	8018658 <__ssputs_r>
 801877a:	3001      	adds	r0, #1
 801877c:	f000 80a9 	beq.w	80188d2 <_svfiprintf_r+0x1c6>
 8018780:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8018782:	445a      	add	r2, fp
 8018784:	9209      	str	r2, [sp, #36]	; 0x24
 8018786:	f89a 3000 	ldrb.w	r3, [sl]
 801878a:	2b00      	cmp	r3, #0
 801878c:	f000 80a1 	beq.w	80188d2 <_svfiprintf_r+0x1c6>
 8018790:	2300      	movs	r3, #0
 8018792:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8018796:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801879a:	f10a 0a01 	add.w	sl, sl, #1
 801879e:	9304      	str	r3, [sp, #16]
 80187a0:	9307      	str	r3, [sp, #28]
 80187a2:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80187a6:	931a      	str	r3, [sp, #104]	; 0x68
 80187a8:	4654      	mov	r4, sl
 80187aa:	2205      	movs	r2, #5
 80187ac:	f814 1b01 	ldrb.w	r1, [r4], #1
 80187b0:	4850      	ldr	r0, [pc, #320]	; (80188f4 <_svfiprintf_r+0x1e8>)
 80187b2:	f7ed f9a5 	bl	8005b00 <memchr>
 80187b6:	9a04      	ldr	r2, [sp, #16]
 80187b8:	b9d8      	cbnz	r0, 80187f2 <_svfiprintf_r+0xe6>
 80187ba:	06d0      	lsls	r0, r2, #27
 80187bc:	bf44      	itt	mi
 80187be:	2320      	movmi	r3, #32
 80187c0:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80187c4:	0711      	lsls	r1, r2, #28
 80187c6:	bf44      	itt	mi
 80187c8:	232b      	movmi	r3, #43	; 0x2b
 80187ca:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80187ce:	f89a 3000 	ldrb.w	r3, [sl]
 80187d2:	2b2a      	cmp	r3, #42	; 0x2a
 80187d4:	d015      	beq.n	8018802 <_svfiprintf_r+0xf6>
 80187d6:	9a07      	ldr	r2, [sp, #28]
 80187d8:	4654      	mov	r4, sl
 80187da:	2000      	movs	r0, #0
 80187dc:	f04f 0c0a 	mov.w	ip, #10
 80187e0:	4621      	mov	r1, r4
 80187e2:	f811 3b01 	ldrb.w	r3, [r1], #1
 80187e6:	3b30      	subs	r3, #48	; 0x30
 80187e8:	2b09      	cmp	r3, #9
 80187ea:	d94d      	bls.n	8018888 <_svfiprintf_r+0x17c>
 80187ec:	b1b0      	cbz	r0, 801881c <_svfiprintf_r+0x110>
 80187ee:	9207      	str	r2, [sp, #28]
 80187f0:	e014      	b.n	801881c <_svfiprintf_r+0x110>
 80187f2:	eba0 0308 	sub.w	r3, r0, r8
 80187f6:	fa09 f303 	lsl.w	r3, r9, r3
 80187fa:	4313      	orrs	r3, r2
 80187fc:	9304      	str	r3, [sp, #16]
 80187fe:	46a2      	mov	sl, r4
 8018800:	e7d2      	b.n	80187a8 <_svfiprintf_r+0x9c>
 8018802:	9b03      	ldr	r3, [sp, #12]
 8018804:	1d19      	adds	r1, r3, #4
 8018806:	681b      	ldr	r3, [r3, #0]
 8018808:	9103      	str	r1, [sp, #12]
 801880a:	2b00      	cmp	r3, #0
 801880c:	bfbb      	ittet	lt
 801880e:	425b      	neglt	r3, r3
 8018810:	f042 0202 	orrlt.w	r2, r2, #2
 8018814:	9307      	strge	r3, [sp, #28]
 8018816:	9307      	strlt	r3, [sp, #28]
 8018818:	bfb8      	it	lt
 801881a:	9204      	strlt	r2, [sp, #16]
 801881c:	7823      	ldrb	r3, [r4, #0]
 801881e:	2b2e      	cmp	r3, #46	; 0x2e
 8018820:	d10c      	bne.n	801883c <_svfiprintf_r+0x130>
 8018822:	7863      	ldrb	r3, [r4, #1]
 8018824:	2b2a      	cmp	r3, #42	; 0x2a
 8018826:	d134      	bne.n	8018892 <_svfiprintf_r+0x186>
 8018828:	9b03      	ldr	r3, [sp, #12]
 801882a:	1d1a      	adds	r2, r3, #4
 801882c:	681b      	ldr	r3, [r3, #0]
 801882e:	9203      	str	r2, [sp, #12]
 8018830:	2b00      	cmp	r3, #0
 8018832:	bfb8      	it	lt
 8018834:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8018838:	3402      	adds	r4, #2
 801883a:	9305      	str	r3, [sp, #20]
 801883c:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 8018904 <_svfiprintf_r+0x1f8>
 8018840:	7821      	ldrb	r1, [r4, #0]
 8018842:	2203      	movs	r2, #3
 8018844:	4650      	mov	r0, sl
 8018846:	f7ed f95b 	bl	8005b00 <memchr>
 801884a:	b138      	cbz	r0, 801885c <_svfiprintf_r+0x150>
 801884c:	9b04      	ldr	r3, [sp, #16]
 801884e:	eba0 000a 	sub.w	r0, r0, sl
 8018852:	2240      	movs	r2, #64	; 0x40
 8018854:	4082      	lsls	r2, r0
 8018856:	4313      	orrs	r3, r2
 8018858:	3401      	adds	r4, #1
 801885a:	9304      	str	r3, [sp, #16]
 801885c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8018860:	4825      	ldr	r0, [pc, #148]	; (80188f8 <_svfiprintf_r+0x1ec>)
 8018862:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8018866:	2206      	movs	r2, #6
 8018868:	f7ed f94a 	bl	8005b00 <memchr>
 801886c:	2800      	cmp	r0, #0
 801886e:	d038      	beq.n	80188e2 <_svfiprintf_r+0x1d6>
 8018870:	4b22      	ldr	r3, [pc, #136]	; (80188fc <_svfiprintf_r+0x1f0>)
 8018872:	bb1b      	cbnz	r3, 80188bc <_svfiprintf_r+0x1b0>
 8018874:	9b03      	ldr	r3, [sp, #12]
 8018876:	3307      	adds	r3, #7
 8018878:	f023 0307 	bic.w	r3, r3, #7
 801887c:	3308      	adds	r3, #8
 801887e:	9303      	str	r3, [sp, #12]
 8018880:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018882:	4433      	add	r3, r6
 8018884:	9309      	str	r3, [sp, #36]	; 0x24
 8018886:	e768      	b.n	801875a <_svfiprintf_r+0x4e>
 8018888:	fb0c 3202 	mla	r2, ip, r2, r3
 801888c:	460c      	mov	r4, r1
 801888e:	2001      	movs	r0, #1
 8018890:	e7a6      	b.n	80187e0 <_svfiprintf_r+0xd4>
 8018892:	2300      	movs	r3, #0
 8018894:	3401      	adds	r4, #1
 8018896:	9305      	str	r3, [sp, #20]
 8018898:	4619      	mov	r1, r3
 801889a:	f04f 0c0a 	mov.w	ip, #10
 801889e:	4620      	mov	r0, r4
 80188a0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80188a4:	3a30      	subs	r2, #48	; 0x30
 80188a6:	2a09      	cmp	r2, #9
 80188a8:	d903      	bls.n	80188b2 <_svfiprintf_r+0x1a6>
 80188aa:	2b00      	cmp	r3, #0
 80188ac:	d0c6      	beq.n	801883c <_svfiprintf_r+0x130>
 80188ae:	9105      	str	r1, [sp, #20]
 80188b0:	e7c4      	b.n	801883c <_svfiprintf_r+0x130>
 80188b2:	fb0c 2101 	mla	r1, ip, r1, r2
 80188b6:	4604      	mov	r4, r0
 80188b8:	2301      	movs	r3, #1
 80188ba:	e7f0      	b.n	801889e <_svfiprintf_r+0x192>
 80188bc:	ab03      	add	r3, sp, #12
 80188be:	9300      	str	r3, [sp, #0]
 80188c0:	462a      	mov	r2, r5
 80188c2:	4b0f      	ldr	r3, [pc, #60]	; (8018900 <_svfiprintf_r+0x1f4>)
 80188c4:	a904      	add	r1, sp, #16
 80188c6:	4638      	mov	r0, r7
 80188c8:	f3af 8000 	nop.w
 80188cc:	1c42      	adds	r2, r0, #1
 80188ce:	4606      	mov	r6, r0
 80188d0:	d1d6      	bne.n	8018880 <_svfiprintf_r+0x174>
 80188d2:	89ab      	ldrh	r3, [r5, #12]
 80188d4:	065b      	lsls	r3, r3, #25
 80188d6:	f53f af2d 	bmi.w	8018734 <_svfiprintf_r+0x28>
 80188da:	9809      	ldr	r0, [sp, #36]	; 0x24
 80188dc:	b01d      	add	sp, #116	; 0x74
 80188de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80188e2:	ab03      	add	r3, sp, #12
 80188e4:	9300      	str	r3, [sp, #0]
 80188e6:	462a      	mov	r2, r5
 80188e8:	4b05      	ldr	r3, [pc, #20]	; (8018900 <_svfiprintf_r+0x1f4>)
 80188ea:	a904      	add	r1, sp, #16
 80188ec:	4638      	mov	r0, r7
 80188ee:	f000 f9bd 	bl	8018c6c <_printf_i>
 80188f2:	e7eb      	b.n	80188cc <_svfiprintf_r+0x1c0>
 80188f4:	08019d63 	.word	0x08019d63
 80188f8:	08019d6d 	.word	0x08019d6d
 80188fc:	00000000 	.word	0x00000000
 8018900:	08018659 	.word	0x08018659
 8018904:	08019d69 	.word	0x08019d69

08018908 <__sfputc_r>:
 8018908:	6893      	ldr	r3, [r2, #8]
 801890a:	3b01      	subs	r3, #1
 801890c:	2b00      	cmp	r3, #0
 801890e:	b410      	push	{r4}
 8018910:	6093      	str	r3, [r2, #8]
 8018912:	da08      	bge.n	8018926 <__sfputc_r+0x1e>
 8018914:	6994      	ldr	r4, [r2, #24]
 8018916:	42a3      	cmp	r3, r4
 8018918:	db01      	blt.n	801891e <__sfputc_r+0x16>
 801891a:	290a      	cmp	r1, #10
 801891c:	d103      	bne.n	8018926 <__sfputc_r+0x1e>
 801891e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8018922:	f000 bb73 	b.w	801900c <__swbuf_r>
 8018926:	6813      	ldr	r3, [r2, #0]
 8018928:	1c58      	adds	r0, r3, #1
 801892a:	6010      	str	r0, [r2, #0]
 801892c:	7019      	strb	r1, [r3, #0]
 801892e:	4608      	mov	r0, r1
 8018930:	f85d 4b04 	ldr.w	r4, [sp], #4
 8018934:	4770      	bx	lr

08018936 <__sfputs_r>:
 8018936:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018938:	4606      	mov	r6, r0
 801893a:	460f      	mov	r7, r1
 801893c:	4614      	mov	r4, r2
 801893e:	18d5      	adds	r5, r2, r3
 8018940:	42ac      	cmp	r4, r5
 8018942:	d101      	bne.n	8018948 <__sfputs_r+0x12>
 8018944:	2000      	movs	r0, #0
 8018946:	e007      	b.n	8018958 <__sfputs_r+0x22>
 8018948:	f814 1b01 	ldrb.w	r1, [r4], #1
 801894c:	463a      	mov	r2, r7
 801894e:	4630      	mov	r0, r6
 8018950:	f7ff ffda 	bl	8018908 <__sfputc_r>
 8018954:	1c43      	adds	r3, r0, #1
 8018956:	d1f3      	bne.n	8018940 <__sfputs_r+0xa>
 8018958:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0801895c <_vfiprintf_r>:
 801895c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018960:	460d      	mov	r5, r1
 8018962:	b09d      	sub	sp, #116	; 0x74
 8018964:	4614      	mov	r4, r2
 8018966:	4698      	mov	r8, r3
 8018968:	4606      	mov	r6, r0
 801896a:	b118      	cbz	r0, 8018974 <_vfiprintf_r+0x18>
 801896c:	6a03      	ldr	r3, [r0, #32]
 801896e:	b90b      	cbnz	r3, 8018974 <_vfiprintf_r+0x18>
 8018970:	f7ff fc4c 	bl	801820c <__sinit>
 8018974:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8018976:	07d9      	lsls	r1, r3, #31
 8018978:	d405      	bmi.n	8018986 <_vfiprintf_r+0x2a>
 801897a:	89ab      	ldrh	r3, [r5, #12]
 801897c:	059a      	lsls	r2, r3, #22
 801897e:	d402      	bmi.n	8018986 <_vfiprintf_r+0x2a>
 8018980:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8018982:	f7ff fe04 	bl	801858e <__retarget_lock_acquire_recursive>
 8018986:	89ab      	ldrh	r3, [r5, #12]
 8018988:	071b      	lsls	r3, r3, #28
 801898a:	d501      	bpl.n	8018990 <_vfiprintf_r+0x34>
 801898c:	692b      	ldr	r3, [r5, #16]
 801898e:	b99b      	cbnz	r3, 80189b8 <_vfiprintf_r+0x5c>
 8018990:	4629      	mov	r1, r5
 8018992:	4630      	mov	r0, r6
 8018994:	f000 fb78 	bl	8019088 <__swsetup_r>
 8018998:	b170      	cbz	r0, 80189b8 <_vfiprintf_r+0x5c>
 801899a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801899c:	07dc      	lsls	r4, r3, #31
 801899e:	d504      	bpl.n	80189aa <_vfiprintf_r+0x4e>
 80189a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80189a4:	b01d      	add	sp, #116	; 0x74
 80189a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80189aa:	89ab      	ldrh	r3, [r5, #12]
 80189ac:	0598      	lsls	r0, r3, #22
 80189ae:	d4f7      	bmi.n	80189a0 <_vfiprintf_r+0x44>
 80189b0:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80189b2:	f7ff fded 	bl	8018590 <__retarget_lock_release_recursive>
 80189b6:	e7f3      	b.n	80189a0 <_vfiprintf_r+0x44>
 80189b8:	2300      	movs	r3, #0
 80189ba:	9309      	str	r3, [sp, #36]	; 0x24
 80189bc:	2320      	movs	r3, #32
 80189be:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80189c2:	f8cd 800c 	str.w	r8, [sp, #12]
 80189c6:	2330      	movs	r3, #48	; 0x30
 80189c8:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 8018b7c <_vfiprintf_r+0x220>
 80189cc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80189d0:	f04f 0901 	mov.w	r9, #1
 80189d4:	4623      	mov	r3, r4
 80189d6:	469a      	mov	sl, r3
 80189d8:	f813 2b01 	ldrb.w	r2, [r3], #1
 80189dc:	b10a      	cbz	r2, 80189e2 <_vfiprintf_r+0x86>
 80189de:	2a25      	cmp	r2, #37	; 0x25
 80189e0:	d1f9      	bne.n	80189d6 <_vfiprintf_r+0x7a>
 80189e2:	ebba 0b04 	subs.w	fp, sl, r4
 80189e6:	d00b      	beq.n	8018a00 <_vfiprintf_r+0xa4>
 80189e8:	465b      	mov	r3, fp
 80189ea:	4622      	mov	r2, r4
 80189ec:	4629      	mov	r1, r5
 80189ee:	4630      	mov	r0, r6
 80189f0:	f7ff ffa1 	bl	8018936 <__sfputs_r>
 80189f4:	3001      	adds	r0, #1
 80189f6:	f000 80a9 	beq.w	8018b4c <_vfiprintf_r+0x1f0>
 80189fa:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80189fc:	445a      	add	r2, fp
 80189fe:	9209      	str	r2, [sp, #36]	; 0x24
 8018a00:	f89a 3000 	ldrb.w	r3, [sl]
 8018a04:	2b00      	cmp	r3, #0
 8018a06:	f000 80a1 	beq.w	8018b4c <_vfiprintf_r+0x1f0>
 8018a0a:	2300      	movs	r3, #0
 8018a0c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8018a10:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8018a14:	f10a 0a01 	add.w	sl, sl, #1
 8018a18:	9304      	str	r3, [sp, #16]
 8018a1a:	9307      	str	r3, [sp, #28]
 8018a1c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8018a20:	931a      	str	r3, [sp, #104]	; 0x68
 8018a22:	4654      	mov	r4, sl
 8018a24:	2205      	movs	r2, #5
 8018a26:	f814 1b01 	ldrb.w	r1, [r4], #1
 8018a2a:	4854      	ldr	r0, [pc, #336]	; (8018b7c <_vfiprintf_r+0x220>)
 8018a2c:	f7ed f868 	bl	8005b00 <memchr>
 8018a30:	9a04      	ldr	r2, [sp, #16]
 8018a32:	b9d8      	cbnz	r0, 8018a6c <_vfiprintf_r+0x110>
 8018a34:	06d1      	lsls	r1, r2, #27
 8018a36:	bf44      	itt	mi
 8018a38:	2320      	movmi	r3, #32
 8018a3a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8018a3e:	0713      	lsls	r3, r2, #28
 8018a40:	bf44      	itt	mi
 8018a42:	232b      	movmi	r3, #43	; 0x2b
 8018a44:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8018a48:	f89a 3000 	ldrb.w	r3, [sl]
 8018a4c:	2b2a      	cmp	r3, #42	; 0x2a
 8018a4e:	d015      	beq.n	8018a7c <_vfiprintf_r+0x120>
 8018a50:	9a07      	ldr	r2, [sp, #28]
 8018a52:	4654      	mov	r4, sl
 8018a54:	2000      	movs	r0, #0
 8018a56:	f04f 0c0a 	mov.w	ip, #10
 8018a5a:	4621      	mov	r1, r4
 8018a5c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8018a60:	3b30      	subs	r3, #48	; 0x30
 8018a62:	2b09      	cmp	r3, #9
 8018a64:	d94d      	bls.n	8018b02 <_vfiprintf_r+0x1a6>
 8018a66:	b1b0      	cbz	r0, 8018a96 <_vfiprintf_r+0x13a>
 8018a68:	9207      	str	r2, [sp, #28]
 8018a6a:	e014      	b.n	8018a96 <_vfiprintf_r+0x13a>
 8018a6c:	eba0 0308 	sub.w	r3, r0, r8
 8018a70:	fa09 f303 	lsl.w	r3, r9, r3
 8018a74:	4313      	orrs	r3, r2
 8018a76:	9304      	str	r3, [sp, #16]
 8018a78:	46a2      	mov	sl, r4
 8018a7a:	e7d2      	b.n	8018a22 <_vfiprintf_r+0xc6>
 8018a7c:	9b03      	ldr	r3, [sp, #12]
 8018a7e:	1d19      	adds	r1, r3, #4
 8018a80:	681b      	ldr	r3, [r3, #0]
 8018a82:	9103      	str	r1, [sp, #12]
 8018a84:	2b00      	cmp	r3, #0
 8018a86:	bfbb      	ittet	lt
 8018a88:	425b      	neglt	r3, r3
 8018a8a:	f042 0202 	orrlt.w	r2, r2, #2
 8018a8e:	9307      	strge	r3, [sp, #28]
 8018a90:	9307      	strlt	r3, [sp, #28]
 8018a92:	bfb8      	it	lt
 8018a94:	9204      	strlt	r2, [sp, #16]
 8018a96:	7823      	ldrb	r3, [r4, #0]
 8018a98:	2b2e      	cmp	r3, #46	; 0x2e
 8018a9a:	d10c      	bne.n	8018ab6 <_vfiprintf_r+0x15a>
 8018a9c:	7863      	ldrb	r3, [r4, #1]
 8018a9e:	2b2a      	cmp	r3, #42	; 0x2a
 8018aa0:	d134      	bne.n	8018b0c <_vfiprintf_r+0x1b0>
 8018aa2:	9b03      	ldr	r3, [sp, #12]
 8018aa4:	1d1a      	adds	r2, r3, #4
 8018aa6:	681b      	ldr	r3, [r3, #0]
 8018aa8:	9203      	str	r2, [sp, #12]
 8018aaa:	2b00      	cmp	r3, #0
 8018aac:	bfb8      	it	lt
 8018aae:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8018ab2:	3402      	adds	r4, #2
 8018ab4:	9305      	str	r3, [sp, #20]
 8018ab6:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 8018b8c <_vfiprintf_r+0x230>
 8018aba:	7821      	ldrb	r1, [r4, #0]
 8018abc:	2203      	movs	r2, #3
 8018abe:	4650      	mov	r0, sl
 8018ac0:	f7ed f81e 	bl	8005b00 <memchr>
 8018ac4:	b138      	cbz	r0, 8018ad6 <_vfiprintf_r+0x17a>
 8018ac6:	9b04      	ldr	r3, [sp, #16]
 8018ac8:	eba0 000a 	sub.w	r0, r0, sl
 8018acc:	2240      	movs	r2, #64	; 0x40
 8018ace:	4082      	lsls	r2, r0
 8018ad0:	4313      	orrs	r3, r2
 8018ad2:	3401      	adds	r4, #1
 8018ad4:	9304      	str	r3, [sp, #16]
 8018ad6:	f814 1b01 	ldrb.w	r1, [r4], #1
 8018ada:	4829      	ldr	r0, [pc, #164]	; (8018b80 <_vfiprintf_r+0x224>)
 8018adc:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8018ae0:	2206      	movs	r2, #6
 8018ae2:	f7ed f80d 	bl	8005b00 <memchr>
 8018ae6:	2800      	cmp	r0, #0
 8018ae8:	d03f      	beq.n	8018b6a <_vfiprintf_r+0x20e>
 8018aea:	4b26      	ldr	r3, [pc, #152]	; (8018b84 <_vfiprintf_r+0x228>)
 8018aec:	bb1b      	cbnz	r3, 8018b36 <_vfiprintf_r+0x1da>
 8018aee:	9b03      	ldr	r3, [sp, #12]
 8018af0:	3307      	adds	r3, #7
 8018af2:	f023 0307 	bic.w	r3, r3, #7
 8018af6:	3308      	adds	r3, #8
 8018af8:	9303      	str	r3, [sp, #12]
 8018afa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8018afc:	443b      	add	r3, r7
 8018afe:	9309      	str	r3, [sp, #36]	; 0x24
 8018b00:	e768      	b.n	80189d4 <_vfiprintf_r+0x78>
 8018b02:	fb0c 3202 	mla	r2, ip, r2, r3
 8018b06:	460c      	mov	r4, r1
 8018b08:	2001      	movs	r0, #1
 8018b0a:	e7a6      	b.n	8018a5a <_vfiprintf_r+0xfe>
 8018b0c:	2300      	movs	r3, #0
 8018b0e:	3401      	adds	r4, #1
 8018b10:	9305      	str	r3, [sp, #20]
 8018b12:	4619      	mov	r1, r3
 8018b14:	f04f 0c0a 	mov.w	ip, #10
 8018b18:	4620      	mov	r0, r4
 8018b1a:	f810 2b01 	ldrb.w	r2, [r0], #1
 8018b1e:	3a30      	subs	r2, #48	; 0x30
 8018b20:	2a09      	cmp	r2, #9
 8018b22:	d903      	bls.n	8018b2c <_vfiprintf_r+0x1d0>
 8018b24:	2b00      	cmp	r3, #0
 8018b26:	d0c6      	beq.n	8018ab6 <_vfiprintf_r+0x15a>
 8018b28:	9105      	str	r1, [sp, #20]
 8018b2a:	e7c4      	b.n	8018ab6 <_vfiprintf_r+0x15a>
 8018b2c:	fb0c 2101 	mla	r1, ip, r1, r2
 8018b30:	4604      	mov	r4, r0
 8018b32:	2301      	movs	r3, #1
 8018b34:	e7f0      	b.n	8018b18 <_vfiprintf_r+0x1bc>
 8018b36:	ab03      	add	r3, sp, #12
 8018b38:	9300      	str	r3, [sp, #0]
 8018b3a:	462a      	mov	r2, r5
 8018b3c:	4b12      	ldr	r3, [pc, #72]	; (8018b88 <_vfiprintf_r+0x22c>)
 8018b3e:	a904      	add	r1, sp, #16
 8018b40:	4630      	mov	r0, r6
 8018b42:	f3af 8000 	nop.w
 8018b46:	4607      	mov	r7, r0
 8018b48:	1c78      	adds	r0, r7, #1
 8018b4a:	d1d6      	bne.n	8018afa <_vfiprintf_r+0x19e>
 8018b4c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8018b4e:	07d9      	lsls	r1, r3, #31
 8018b50:	d405      	bmi.n	8018b5e <_vfiprintf_r+0x202>
 8018b52:	89ab      	ldrh	r3, [r5, #12]
 8018b54:	059a      	lsls	r2, r3, #22
 8018b56:	d402      	bmi.n	8018b5e <_vfiprintf_r+0x202>
 8018b58:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8018b5a:	f7ff fd19 	bl	8018590 <__retarget_lock_release_recursive>
 8018b5e:	89ab      	ldrh	r3, [r5, #12]
 8018b60:	065b      	lsls	r3, r3, #25
 8018b62:	f53f af1d 	bmi.w	80189a0 <_vfiprintf_r+0x44>
 8018b66:	9809      	ldr	r0, [sp, #36]	; 0x24
 8018b68:	e71c      	b.n	80189a4 <_vfiprintf_r+0x48>
 8018b6a:	ab03      	add	r3, sp, #12
 8018b6c:	9300      	str	r3, [sp, #0]
 8018b6e:	462a      	mov	r2, r5
 8018b70:	4b05      	ldr	r3, [pc, #20]	; (8018b88 <_vfiprintf_r+0x22c>)
 8018b72:	a904      	add	r1, sp, #16
 8018b74:	4630      	mov	r0, r6
 8018b76:	f000 f879 	bl	8018c6c <_printf_i>
 8018b7a:	e7e4      	b.n	8018b46 <_vfiprintf_r+0x1ea>
 8018b7c:	08019d63 	.word	0x08019d63
 8018b80:	08019d6d 	.word	0x08019d6d
 8018b84:	00000000 	.word	0x00000000
 8018b88:	08018937 	.word	0x08018937
 8018b8c:	08019d69 	.word	0x08019d69

08018b90 <_printf_common>:
 8018b90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8018b94:	4616      	mov	r6, r2
 8018b96:	4699      	mov	r9, r3
 8018b98:	688a      	ldr	r2, [r1, #8]
 8018b9a:	690b      	ldr	r3, [r1, #16]
 8018b9c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8018ba0:	4293      	cmp	r3, r2
 8018ba2:	bfb8      	it	lt
 8018ba4:	4613      	movlt	r3, r2
 8018ba6:	6033      	str	r3, [r6, #0]
 8018ba8:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8018bac:	4607      	mov	r7, r0
 8018bae:	460c      	mov	r4, r1
 8018bb0:	b10a      	cbz	r2, 8018bb6 <_printf_common+0x26>
 8018bb2:	3301      	adds	r3, #1
 8018bb4:	6033      	str	r3, [r6, #0]
 8018bb6:	6823      	ldr	r3, [r4, #0]
 8018bb8:	0699      	lsls	r1, r3, #26
 8018bba:	bf42      	ittt	mi
 8018bbc:	6833      	ldrmi	r3, [r6, #0]
 8018bbe:	3302      	addmi	r3, #2
 8018bc0:	6033      	strmi	r3, [r6, #0]
 8018bc2:	6825      	ldr	r5, [r4, #0]
 8018bc4:	f015 0506 	ands.w	r5, r5, #6
 8018bc8:	d106      	bne.n	8018bd8 <_printf_common+0x48>
 8018bca:	f104 0a19 	add.w	sl, r4, #25
 8018bce:	68e3      	ldr	r3, [r4, #12]
 8018bd0:	6832      	ldr	r2, [r6, #0]
 8018bd2:	1a9b      	subs	r3, r3, r2
 8018bd4:	42ab      	cmp	r3, r5
 8018bd6:	dc26      	bgt.n	8018c26 <_printf_common+0x96>
 8018bd8:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8018bdc:	1e13      	subs	r3, r2, #0
 8018bde:	6822      	ldr	r2, [r4, #0]
 8018be0:	bf18      	it	ne
 8018be2:	2301      	movne	r3, #1
 8018be4:	0692      	lsls	r2, r2, #26
 8018be6:	d42b      	bmi.n	8018c40 <_printf_common+0xb0>
 8018be8:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8018bec:	4649      	mov	r1, r9
 8018bee:	4638      	mov	r0, r7
 8018bf0:	47c0      	blx	r8
 8018bf2:	3001      	adds	r0, #1
 8018bf4:	d01e      	beq.n	8018c34 <_printf_common+0xa4>
 8018bf6:	6823      	ldr	r3, [r4, #0]
 8018bf8:	6922      	ldr	r2, [r4, #16]
 8018bfa:	f003 0306 	and.w	r3, r3, #6
 8018bfe:	2b04      	cmp	r3, #4
 8018c00:	bf02      	ittt	eq
 8018c02:	68e5      	ldreq	r5, [r4, #12]
 8018c04:	6833      	ldreq	r3, [r6, #0]
 8018c06:	1aed      	subeq	r5, r5, r3
 8018c08:	68a3      	ldr	r3, [r4, #8]
 8018c0a:	bf0c      	ite	eq
 8018c0c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8018c10:	2500      	movne	r5, #0
 8018c12:	4293      	cmp	r3, r2
 8018c14:	bfc4      	itt	gt
 8018c16:	1a9b      	subgt	r3, r3, r2
 8018c18:	18ed      	addgt	r5, r5, r3
 8018c1a:	2600      	movs	r6, #0
 8018c1c:	341a      	adds	r4, #26
 8018c1e:	42b5      	cmp	r5, r6
 8018c20:	d11a      	bne.n	8018c58 <_printf_common+0xc8>
 8018c22:	2000      	movs	r0, #0
 8018c24:	e008      	b.n	8018c38 <_printf_common+0xa8>
 8018c26:	2301      	movs	r3, #1
 8018c28:	4652      	mov	r2, sl
 8018c2a:	4649      	mov	r1, r9
 8018c2c:	4638      	mov	r0, r7
 8018c2e:	47c0      	blx	r8
 8018c30:	3001      	adds	r0, #1
 8018c32:	d103      	bne.n	8018c3c <_printf_common+0xac>
 8018c34:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8018c38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8018c3c:	3501      	adds	r5, #1
 8018c3e:	e7c6      	b.n	8018bce <_printf_common+0x3e>
 8018c40:	18e1      	adds	r1, r4, r3
 8018c42:	1c5a      	adds	r2, r3, #1
 8018c44:	2030      	movs	r0, #48	; 0x30
 8018c46:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8018c4a:	4422      	add	r2, r4
 8018c4c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8018c50:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8018c54:	3302      	adds	r3, #2
 8018c56:	e7c7      	b.n	8018be8 <_printf_common+0x58>
 8018c58:	2301      	movs	r3, #1
 8018c5a:	4622      	mov	r2, r4
 8018c5c:	4649      	mov	r1, r9
 8018c5e:	4638      	mov	r0, r7
 8018c60:	47c0      	blx	r8
 8018c62:	3001      	adds	r0, #1
 8018c64:	d0e6      	beq.n	8018c34 <_printf_common+0xa4>
 8018c66:	3601      	adds	r6, #1
 8018c68:	e7d9      	b.n	8018c1e <_printf_common+0x8e>
	...

08018c6c <_printf_i>:
 8018c6c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8018c70:	7e0f      	ldrb	r7, [r1, #24]
 8018c72:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8018c74:	2f78      	cmp	r7, #120	; 0x78
 8018c76:	4691      	mov	r9, r2
 8018c78:	4680      	mov	r8, r0
 8018c7a:	460c      	mov	r4, r1
 8018c7c:	469a      	mov	sl, r3
 8018c7e:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8018c82:	d807      	bhi.n	8018c94 <_printf_i+0x28>
 8018c84:	2f62      	cmp	r7, #98	; 0x62
 8018c86:	d80a      	bhi.n	8018c9e <_printf_i+0x32>
 8018c88:	2f00      	cmp	r7, #0
 8018c8a:	f000 80d4 	beq.w	8018e36 <_printf_i+0x1ca>
 8018c8e:	2f58      	cmp	r7, #88	; 0x58
 8018c90:	f000 80c0 	beq.w	8018e14 <_printf_i+0x1a8>
 8018c94:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8018c98:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8018c9c:	e03a      	b.n	8018d14 <_printf_i+0xa8>
 8018c9e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8018ca2:	2b15      	cmp	r3, #21
 8018ca4:	d8f6      	bhi.n	8018c94 <_printf_i+0x28>
 8018ca6:	a101      	add	r1, pc, #4	; (adr r1, 8018cac <_printf_i+0x40>)
 8018ca8:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8018cac:	08018d05 	.word	0x08018d05
 8018cb0:	08018d19 	.word	0x08018d19
 8018cb4:	08018c95 	.word	0x08018c95
 8018cb8:	08018c95 	.word	0x08018c95
 8018cbc:	08018c95 	.word	0x08018c95
 8018cc0:	08018c95 	.word	0x08018c95
 8018cc4:	08018d19 	.word	0x08018d19
 8018cc8:	08018c95 	.word	0x08018c95
 8018ccc:	08018c95 	.word	0x08018c95
 8018cd0:	08018c95 	.word	0x08018c95
 8018cd4:	08018c95 	.word	0x08018c95
 8018cd8:	08018e1d 	.word	0x08018e1d
 8018cdc:	08018d45 	.word	0x08018d45
 8018ce0:	08018dd7 	.word	0x08018dd7
 8018ce4:	08018c95 	.word	0x08018c95
 8018ce8:	08018c95 	.word	0x08018c95
 8018cec:	08018e3f 	.word	0x08018e3f
 8018cf0:	08018c95 	.word	0x08018c95
 8018cf4:	08018d45 	.word	0x08018d45
 8018cf8:	08018c95 	.word	0x08018c95
 8018cfc:	08018c95 	.word	0x08018c95
 8018d00:	08018ddf 	.word	0x08018ddf
 8018d04:	682b      	ldr	r3, [r5, #0]
 8018d06:	1d1a      	adds	r2, r3, #4
 8018d08:	681b      	ldr	r3, [r3, #0]
 8018d0a:	602a      	str	r2, [r5, #0]
 8018d0c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8018d10:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8018d14:	2301      	movs	r3, #1
 8018d16:	e09f      	b.n	8018e58 <_printf_i+0x1ec>
 8018d18:	6820      	ldr	r0, [r4, #0]
 8018d1a:	682b      	ldr	r3, [r5, #0]
 8018d1c:	0607      	lsls	r7, r0, #24
 8018d1e:	f103 0104 	add.w	r1, r3, #4
 8018d22:	6029      	str	r1, [r5, #0]
 8018d24:	d501      	bpl.n	8018d2a <_printf_i+0xbe>
 8018d26:	681e      	ldr	r6, [r3, #0]
 8018d28:	e003      	b.n	8018d32 <_printf_i+0xc6>
 8018d2a:	0646      	lsls	r6, r0, #25
 8018d2c:	d5fb      	bpl.n	8018d26 <_printf_i+0xba>
 8018d2e:	f9b3 6000 	ldrsh.w	r6, [r3]
 8018d32:	2e00      	cmp	r6, #0
 8018d34:	da03      	bge.n	8018d3e <_printf_i+0xd2>
 8018d36:	232d      	movs	r3, #45	; 0x2d
 8018d38:	4276      	negs	r6, r6
 8018d3a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8018d3e:	485a      	ldr	r0, [pc, #360]	; (8018ea8 <_printf_i+0x23c>)
 8018d40:	230a      	movs	r3, #10
 8018d42:	e012      	b.n	8018d6a <_printf_i+0xfe>
 8018d44:	682b      	ldr	r3, [r5, #0]
 8018d46:	6820      	ldr	r0, [r4, #0]
 8018d48:	1d19      	adds	r1, r3, #4
 8018d4a:	6029      	str	r1, [r5, #0]
 8018d4c:	0605      	lsls	r5, r0, #24
 8018d4e:	d501      	bpl.n	8018d54 <_printf_i+0xe8>
 8018d50:	681e      	ldr	r6, [r3, #0]
 8018d52:	e002      	b.n	8018d5a <_printf_i+0xee>
 8018d54:	0641      	lsls	r1, r0, #25
 8018d56:	d5fb      	bpl.n	8018d50 <_printf_i+0xe4>
 8018d58:	881e      	ldrh	r6, [r3, #0]
 8018d5a:	4853      	ldr	r0, [pc, #332]	; (8018ea8 <_printf_i+0x23c>)
 8018d5c:	2f6f      	cmp	r7, #111	; 0x6f
 8018d5e:	bf0c      	ite	eq
 8018d60:	2308      	moveq	r3, #8
 8018d62:	230a      	movne	r3, #10
 8018d64:	2100      	movs	r1, #0
 8018d66:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8018d6a:	6865      	ldr	r5, [r4, #4]
 8018d6c:	60a5      	str	r5, [r4, #8]
 8018d6e:	2d00      	cmp	r5, #0
 8018d70:	bfa2      	ittt	ge
 8018d72:	6821      	ldrge	r1, [r4, #0]
 8018d74:	f021 0104 	bicge.w	r1, r1, #4
 8018d78:	6021      	strge	r1, [r4, #0]
 8018d7a:	b90e      	cbnz	r6, 8018d80 <_printf_i+0x114>
 8018d7c:	2d00      	cmp	r5, #0
 8018d7e:	d04b      	beq.n	8018e18 <_printf_i+0x1ac>
 8018d80:	4615      	mov	r5, r2
 8018d82:	fbb6 f1f3 	udiv	r1, r6, r3
 8018d86:	fb03 6711 	mls	r7, r3, r1, r6
 8018d8a:	5dc7      	ldrb	r7, [r0, r7]
 8018d8c:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8018d90:	4637      	mov	r7, r6
 8018d92:	42bb      	cmp	r3, r7
 8018d94:	460e      	mov	r6, r1
 8018d96:	d9f4      	bls.n	8018d82 <_printf_i+0x116>
 8018d98:	2b08      	cmp	r3, #8
 8018d9a:	d10b      	bne.n	8018db4 <_printf_i+0x148>
 8018d9c:	6823      	ldr	r3, [r4, #0]
 8018d9e:	07de      	lsls	r6, r3, #31
 8018da0:	d508      	bpl.n	8018db4 <_printf_i+0x148>
 8018da2:	6923      	ldr	r3, [r4, #16]
 8018da4:	6861      	ldr	r1, [r4, #4]
 8018da6:	4299      	cmp	r1, r3
 8018da8:	bfde      	ittt	le
 8018daa:	2330      	movle	r3, #48	; 0x30
 8018dac:	f805 3c01 	strble.w	r3, [r5, #-1]
 8018db0:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 8018db4:	1b52      	subs	r2, r2, r5
 8018db6:	6122      	str	r2, [r4, #16]
 8018db8:	f8cd a000 	str.w	sl, [sp]
 8018dbc:	464b      	mov	r3, r9
 8018dbe:	aa03      	add	r2, sp, #12
 8018dc0:	4621      	mov	r1, r4
 8018dc2:	4640      	mov	r0, r8
 8018dc4:	f7ff fee4 	bl	8018b90 <_printf_common>
 8018dc8:	3001      	adds	r0, #1
 8018dca:	d14a      	bne.n	8018e62 <_printf_i+0x1f6>
 8018dcc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8018dd0:	b004      	add	sp, #16
 8018dd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8018dd6:	6823      	ldr	r3, [r4, #0]
 8018dd8:	f043 0320 	orr.w	r3, r3, #32
 8018ddc:	6023      	str	r3, [r4, #0]
 8018dde:	4833      	ldr	r0, [pc, #204]	; (8018eac <_printf_i+0x240>)
 8018de0:	2778      	movs	r7, #120	; 0x78
 8018de2:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 8018de6:	6823      	ldr	r3, [r4, #0]
 8018de8:	6829      	ldr	r1, [r5, #0]
 8018dea:	061f      	lsls	r7, r3, #24
 8018dec:	f851 6b04 	ldr.w	r6, [r1], #4
 8018df0:	d402      	bmi.n	8018df8 <_printf_i+0x18c>
 8018df2:	065f      	lsls	r7, r3, #25
 8018df4:	bf48      	it	mi
 8018df6:	b2b6      	uxthmi	r6, r6
 8018df8:	07df      	lsls	r7, r3, #31
 8018dfa:	bf48      	it	mi
 8018dfc:	f043 0320 	orrmi.w	r3, r3, #32
 8018e00:	6029      	str	r1, [r5, #0]
 8018e02:	bf48      	it	mi
 8018e04:	6023      	strmi	r3, [r4, #0]
 8018e06:	b91e      	cbnz	r6, 8018e10 <_printf_i+0x1a4>
 8018e08:	6823      	ldr	r3, [r4, #0]
 8018e0a:	f023 0320 	bic.w	r3, r3, #32
 8018e0e:	6023      	str	r3, [r4, #0]
 8018e10:	2310      	movs	r3, #16
 8018e12:	e7a7      	b.n	8018d64 <_printf_i+0xf8>
 8018e14:	4824      	ldr	r0, [pc, #144]	; (8018ea8 <_printf_i+0x23c>)
 8018e16:	e7e4      	b.n	8018de2 <_printf_i+0x176>
 8018e18:	4615      	mov	r5, r2
 8018e1a:	e7bd      	b.n	8018d98 <_printf_i+0x12c>
 8018e1c:	682b      	ldr	r3, [r5, #0]
 8018e1e:	6826      	ldr	r6, [r4, #0]
 8018e20:	6961      	ldr	r1, [r4, #20]
 8018e22:	1d18      	adds	r0, r3, #4
 8018e24:	6028      	str	r0, [r5, #0]
 8018e26:	0635      	lsls	r5, r6, #24
 8018e28:	681b      	ldr	r3, [r3, #0]
 8018e2a:	d501      	bpl.n	8018e30 <_printf_i+0x1c4>
 8018e2c:	6019      	str	r1, [r3, #0]
 8018e2e:	e002      	b.n	8018e36 <_printf_i+0x1ca>
 8018e30:	0670      	lsls	r0, r6, #25
 8018e32:	d5fb      	bpl.n	8018e2c <_printf_i+0x1c0>
 8018e34:	8019      	strh	r1, [r3, #0]
 8018e36:	2300      	movs	r3, #0
 8018e38:	6123      	str	r3, [r4, #16]
 8018e3a:	4615      	mov	r5, r2
 8018e3c:	e7bc      	b.n	8018db8 <_printf_i+0x14c>
 8018e3e:	682b      	ldr	r3, [r5, #0]
 8018e40:	1d1a      	adds	r2, r3, #4
 8018e42:	602a      	str	r2, [r5, #0]
 8018e44:	681d      	ldr	r5, [r3, #0]
 8018e46:	6862      	ldr	r2, [r4, #4]
 8018e48:	2100      	movs	r1, #0
 8018e4a:	4628      	mov	r0, r5
 8018e4c:	f7ec fe58 	bl	8005b00 <memchr>
 8018e50:	b108      	cbz	r0, 8018e56 <_printf_i+0x1ea>
 8018e52:	1b40      	subs	r0, r0, r5
 8018e54:	6060      	str	r0, [r4, #4]
 8018e56:	6863      	ldr	r3, [r4, #4]
 8018e58:	6123      	str	r3, [r4, #16]
 8018e5a:	2300      	movs	r3, #0
 8018e5c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8018e60:	e7aa      	b.n	8018db8 <_printf_i+0x14c>
 8018e62:	6923      	ldr	r3, [r4, #16]
 8018e64:	462a      	mov	r2, r5
 8018e66:	4649      	mov	r1, r9
 8018e68:	4640      	mov	r0, r8
 8018e6a:	47d0      	blx	sl
 8018e6c:	3001      	adds	r0, #1
 8018e6e:	d0ad      	beq.n	8018dcc <_printf_i+0x160>
 8018e70:	6823      	ldr	r3, [r4, #0]
 8018e72:	079b      	lsls	r3, r3, #30
 8018e74:	d413      	bmi.n	8018e9e <_printf_i+0x232>
 8018e76:	68e0      	ldr	r0, [r4, #12]
 8018e78:	9b03      	ldr	r3, [sp, #12]
 8018e7a:	4298      	cmp	r0, r3
 8018e7c:	bfb8      	it	lt
 8018e7e:	4618      	movlt	r0, r3
 8018e80:	e7a6      	b.n	8018dd0 <_printf_i+0x164>
 8018e82:	2301      	movs	r3, #1
 8018e84:	4632      	mov	r2, r6
 8018e86:	4649      	mov	r1, r9
 8018e88:	4640      	mov	r0, r8
 8018e8a:	47d0      	blx	sl
 8018e8c:	3001      	adds	r0, #1
 8018e8e:	d09d      	beq.n	8018dcc <_printf_i+0x160>
 8018e90:	3501      	adds	r5, #1
 8018e92:	68e3      	ldr	r3, [r4, #12]
 8018e94:	9903      	ldr	r1, [sp, #12]
 8018e96:	1a5b      	subs	r3, r3, r1
 8018e98:	42ab      	cmp	r3, r5
 8018e9a:	dcf2      	bgt.n	8018e82 <_printf_i+0x216>
 8018e9c:	e7eb      	b.n	8018e76 <_printf_i+0x20a>
 8018e9e:	2500      	movs	r5, #0
 8018ea0:	f104 0619 	add.w	r6, r4, #25
 8018ea4:	e7f5      	b.n	8018e92 <_printf_i+0x226>
 8018ea6:	bf00      	nop
 8018ea8:	08019d74 	.word	0x08019d74
 8018eac:	08019d85 	.word	0x08019d85

08018eb0 <__sflush_r>:
 8018eb0:	898a      	ldrh	r2, [r1, #12]
 8018eb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018eb6:	4605      	mov	r5, r0
 8018eb8:	0710      	lsls	r0, r2, #28
 8018eba:	460c      	mov	r4, r1
 8018ebc:	d458      	bmi.n	8018f70 <__sflush_r+0xc0>
 8018ebe:	684b      	ldr	r3, [r1, #4]
 8018ec0:	2b00      	cmp	r3, #0
 8018ec2:	dc05      	bgt.n	8018ed0 <__sflush_r+0x20>
 8018ec4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8018ec6:	2b00      	cmp	r3, #0
 8018ec8:	dc02      	bgt.n	8018ed0 <__sflush_r+0x20>
 8018eca:	2000      	movs	r0, #0
 8018ecc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8018ed0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8018ed2:	2e00      	cmp	r6, #0
 8018ed4:	d0f9      	beq.n	8018eca <__sflush_r+0x1a>
 8018ed6:	2300      	movs	r3, #0
 8018ed8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8018edc:	682f      	ldr	r7, [r5, #0]
 8018ede:	6a21      	ldr	r1, [r4, #32]
 8018ee0:	602b      	str	r3, [r5, #0]
 8018ee2:	d032      	beq.n	8018f4a <__sflush_r+0x9a>
 8018ee4:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8018ee6:	89a3      	ldrh	r3, [r4, #12]
 8018ee8:	075a      	lsls	r2, r3, #29
 8018eea:	d505      	bpl.n	8018ef8 <__sflush_r+0x48>
 8018eec:	6863      	ldr	r3, [r4, #4]
 8018eee:	1ac0      	subs	r0, r0, r3
 8018ef0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8018ef2:	b10b      	cbz	r3, 8018ef8 <__sflush_r+0x48>
 8018ef4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8018ef6:	1ac0      	subs	r0, r0, r3
 8018ef8:	2300      	movs	r3, #0
 8018efa:	4602      	mov	r2, r0
 8018efc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8018efe:	6a21      	ldr	r1, [r4, #32]
 8018f00:	4628      	mov	r0, r5
 8018f02:	47b0      	blx	r6
 8018f04:	1c43      	adds	r3, r0, #1
 8018f06:	89a3      	ldrh	r3, [r4, #12]
 8018f08:	d106      	bne.n	8018f18 <__sflush_r+0x68>
 8018f0a:	6829      	ldr	r1, [r5, #0]
 8018f0c:	291d      	cmp	r1, #29
 8018f0e:	d82b      	bhi.n	8018f68 <__sflush_r+0xb8>
 8018f10:	4a29      	ldr	r2, [pc, #164]	; (8018fb8 <__sflush_r+0x108>)
 8018f12:	410a      	asrs	r2, r1
 8018f14:	07d6      	lsls	r6, r2, #31
 8018f16:	d427      	bmi.n	8018f68 <__sflush_r+0xb8>
 8018f18:	2200      	movs	r2, #0
 8018f1a:	6062      	str	r2, [r4, #4]
 8018f1c:	04d9      	lsls	r1, r3, #19
 8018f1e:	6922      	ldr	r2, [r4, #16]
 8018f20:	6022      	str	r2, [r4, #0]
 8018f22:	d504      	bpl.n	8018f2e <__sflush_r+0x7e>
 8018f24:	1c42      	adds	r2, r0, #1
 8018f26:	d101      	bne.n	8018f2c <__sflush_r+0x7c>
 8018f28:	682b      	ldr	r3, [r5, #0]
 8018f2a:	b903      	cbnz	r3, 8018f2e <__sflush_r+0x7e>
 8018f2c:	6560      	str	r0, [r4, #84]	; 0x54
 8018f2e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8018f30:	602f      	str	r7, [r5, #0]
 8018f32:	2900      	cmp	r1, #0
 8018f34:	d0c9      	beq.n	8018eca <__sflush_r+0x1a>
 8018f36:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8018f3a:	4299      	cmp	r1, r3
 8018f3c:	d002      	beq.n	8018f44 <__sflush_r+0x94>
 8018f3e:	4628      	mov	r0, r5
 8018f40:	f7ff fb3e 	bl	80185c0 <_free_r>
 8018f44:	2000      	movs	r0, #0
 8018f46:	6360      	str	r0, [r4, #52]	; 0x34
 8018f48:	e7c0      	b.n	8018ecc <__sflush_r+0x1c>
 8018f4a:	2301      	movs	r3, #1
 8018f4c:	4628      	mov	r0, r5
 8018f4e:	47b0      	blx	r6
 8018f50:	1c41      	adds	r1, r0, #1
 8018f52:	d1c8      	bne.n	8018ee6 <__sflush_r+0x36>
 8018f54:	682b      	ldr	r3, [r5, #0]
 8018f56:	2b00      	cmp	r3, #0
 8018f58:	d0c5      	beq.n	8018ee6 <__sflush_r+0x36>
 8018f5a:	2b1d      	cmp	r3, #29
 8018f5c:	d001      	beq.n	8018f62 <__sflush_r+0xb2>
 8018f5e:	2b16      	cmp	r3, #22
 8018f60:	d101      	bne.n	8018f66 <__sflush_r+0xb6>
 8018f62:	602f      	str	r7, [r5, #0]
 8018f64:	e7b1      	b.n	8018eca <__sflush_r+0x1a>
 8018f66:	89a3      	ldrh	r3, [r4, #12]
 8018f68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8018f6c:	81a3      	strh	r3, [r4, #12]
 8018f6e:	e7ad      	b.n	8018ecc <__sflush_r+0x1c>
 8018f70:	690f      	ldr	r7, [r1, #16]
 8018f72:	2f00      	cmp	r7, #0
 8018f74:	d0a9      	beq.n	8018eca <__sflush_r+0x1a>
 8018f76:	0793      	lsls	r3, r2, #30
 8018f78:	680e      	ldr	r6, [r1, #0]
 8018f7a:	bf08      	it	eq
 8018f7c:	694b      	ldreq	r3, [r1, #20]
 8018f7e:	600f      	str	r7, [r1, #0]
 8018f80:	bf18      	it	ne
 8018f82:	2300      	movne	r3, #0
 8018f84:	eba6 0807 	sub.w	r8, r6, r7
 8018f88:	608b      	str	r3, [r1, #8]
 8018f8a:	f1b8 0f00 	cmp.w	r8, #0
 8018f8e:	dd9c      	ble.n	8018eca <__sflush_r+0x1a>
 8018f90:	6a21      	ldr	r1, [r4, #32]
 8018f92:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8018f94:	4643      	mov	r3, r8
 8018f96:	463a      	mov	r2, r7
 8018f98:	4628      	mov	r0, r5
 8018f9a:	47b0      	blx	r6
 8018f9c:	2800      	cmp	r0, #0
 8018f9e:	dc06      	bgt.n	8018fae <__sflush_r+0xfe>
 8018fa0:	89a3      	ldrh	r3, [r4, #12]
 8018fa2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8018fa6:	81a3      	strh	r3, [r4, #12]
 8018fa8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8018fac:	e78e      	b.n	8018ecc <__sflush_r+0x1c>
 8018fae:	4407      	add	r7, r0
 8018fb0:	eba8 0800 	sub.w	r8, r8, r0
 8018fb4:	e7e9      	b.n	8018f8a <__sflush_r+0xda>
 8018fb6:	bf00      	nop
 8018fb8:	dfbffffe 	.word	0xdfbffffe

08018fbc <_fflush_r>:
 8018fbc:	b538      	push	{r3, r4, r5, lr}
 8018fbe:	690b      	ldr	r3, [r1, #16]
 8018fc0:	4605      	mov	r5, r0
 8018fc2:	460c      	mov	r4, r1
 8018fc4:	b913      	cbnz	r3, 8018fcc <_fflush_r+0x10>
 8018fc6:	2500      	movs	r5, #0
 8018fc8:	4628      	mov	r0, r5
 8018fca:	bd38      	pop	{r3, r4, r5, pc}
 8018fcc:	b118      	cbz	r0, 8018fd6 <_fflush_r+0x1a>
 8018fce:	6a03      	ldr	r3, [r0, #32]
 8018fd0:	b90b      	cbnz	r3, 8018fd6 <_fflush_r+0x1a>
 8018fd2:	f7ff f91b 	bl	801820c <__sinit>
 8018fd6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8018fda:	2b00      	cmp	r3, #0
 8018fdc:	d0f3      	beq.n	8018fc6 <_fflush_r+0xa>
 8018fde:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8018fe0:	07d0      	lsls	r0, r2, #31
 8018fe2:	d404      	bmi.n	8018fee <_fflush_r+0x32>
 8018fe4:	0599      	lsls	r1, r3, #22
 8018fe6:	d402      	bmi.n	8018fee <_fflush_r+0x32>
 8018fe8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8018fea:	f7ff fad0 	bl	801858e <__retarget_lock_acquire_recursive>
 8018fee:	4628      	mov	r0, r5
 8018ff0:	4621      	mov	r1, r4
 8018ff2:	f7ff ff5d 	bl	8018eb0 <__sflush_r>
 8018ff6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8018ff8:	07da      	lsls	r2, r3, #31
 8018ffa:	4605      	mov	r5, r0
 8018ffc:	d4e4      	bmi.n	8018fc8 <_fflush_r+0xc>
 8018ffe:	89a3      	ldrh	r3, [r4, #12]
 8019000:	059b      	lsls	r3, r3, #22
 8019002:	d4e1      	bmi.n	8018fc8 <_fflush_r+0xc>
 8019004:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8019006:	f7ff fac3 	bl	8018590 <__retarget_lock_release_recursive>
 801900a:	e7dd      	b.n	8018fc8 <_fflush_r+0xc>

0801900c <__swbuf_r>:
 801900c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801900e:	460e      	mov	r6, r1
 8019010:	4614      	mov	r4, r2
 8019012:	4605      	mov	r5, r0
 8019014:	b118      	cbz	r0, 801901e <__swbuf_r+0x12>
 8019016:	6a03      	ldr	r3, [r0, #32]
 8019018:	b90b      	cbnz	r3, 801901e <__swbuf_r+0x12>
 801901a:	f7ff f8f7 	bl	801820c <__sinit>
 801901e:	69a3      	ldr	r3, [r4, #24]
 8019020:	60a3      	str	r3, [r4, #8]
 8019022:	89a3      	ldrh	r3, [r4, #12]
 8019024:	071a      	lsls	r2, r3, #28
 8019026:	d525      	bpl.n	8019074 <__swbuf_r+0x68>
 8019028:	6923      	ldr	r3, [r4, #16]
 801902a:	b31b      	cbz	r3, 8019074 <__swbuf_r+0x68>
 801902c:	6823      	ldr	r3, [r4, #0]
 801902e:	6922      	ldr	r2, [r4, #16]
 8019030:	1a98      	subs	r0, r3, r2
 8019032:	6963      	ldr	r3, [r4, #20]
 8019034:	b2f6      	uxtb	r6, r6
 8019036:	4283      	cmp	r3, r0
 8019038:	4637      	mov	r7, r6
 801903a:	dc04      	bgt.n	8019046 <__swbuf_r+0x3a>
 801903c:	4621      	mov	r1, r4
 801903e:	4628      	mov	r0, r5
 8019040:	f7ff ffbc 	bl	8018fbc <_fflush_r>
 8019044:	b9e0      	cbnz	r0, 8019080 <__swbuf_r+0x74>
 8019046:	68a3      	ldr	r3, [r4, #8]
 8019048:	3b01      	subs	r3, #1
 801904a:	60a3      	str	r3, [r4, #8]
 801904c:	6823      	ldr	r3, [r4, #0]
 801904e:	1c5a      	adds	r2, r3, #1
 8019050:	6022      	str	r2, [r4, #0]
 8019052:	701e      	strb	r6, [r3, #0]
 8019054:	6962      	ldr	r2, [r4, #20]
 8019056:	1c43      	adds	r3, r0, #1
 8019058:	429a      	cmp	r2, r3
 801905a:	d004      	beq.n	8019066 <__swbuf_r+0x5a>
 801905c:	89a3      	ldrh	r3, [r4, #12]
 801905e:	07db      	lsls	r3, r3, #31
 8019060:	d506      	bpl.n	8019070 <__swbuf_r+0x64>
 8019062:	2e0a      	cmp	r6, #10
 8019064:	d104      	bne.n	8019070 <__swbuf_r+0x64>
 8019066:	4621      	mov	r1, r4
 8019068:	4628      	mov	r0, r5
 801906a:	f7ff ffa7 	bl	8018fbc <_fflush_r>
 801906e:	b938      	cbnz	r0, 8019080 <__swbuf_r+0x74>
 8019070:	4638      	mov	r0, r7
 8019072:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8019074:	4621      	mov	r1, r4
 8019076:	4628      	mov	r0, r5
 8019078:	f000 f806 	bl	8019088 <__swsetup_r>
 801907c:	2800      	cmp	r0, #0
 801907e:	d0d5      	beq.n	801902c <__swbuf_r+0x20>
 8019080:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8019084:	e7f4      	b.n	8019070 <__swbuf_r+0x64>
	...

08019088 <__swsetup_r>:
 8019088:	b538      	push	{r3, r4, r5, lr}
 801908a:	4b2a      	ldr	r3, [pc, #168]	; (8019134 <__swsetup_r+0xac>)
 801908c:	4605      	mov	r5, r0
 801908e:	6818      	ldr	r0, [r3, #0]
 8019090:	460c      	mov	r4, r1
 8019092:	b118      	cbz	r0, 801909c <__swsetup_r+0x14>
 8019094:	6a03      	ldr	r3, [r0, #32]
 8019096:	b90b      	cbnz	r3, 801909c <__swsetup_r+0x14>
 8019098:	f7ff f8b8 	bl	801820c <__sinit>
 801909c:	89a3      	ldrh	r3, [r4, #12]
 801909e:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80190a2:	0718      	lsls	r0, r3, #28
 80190a4:	d422      	bmi.n	80190ec <__swsetup_r+0x64>
 80190a6:	06d9      	lsls	r1, r3, #27
 80190a8:	d407      	bmi.n	80190ba <__swsetup_r+0x32>
 80190aa:	2309      	movs	r3, #9
 80190ac:	602b      	str	r3, [r5, #0]
 80190ae:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80190b2:	81a3      	strh	r3, [r4, #12]
 80190b4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80190b8:	e034      	b.n	8019124 <__swsetup_r+0x9c>
 80190ba:	0758      	lsls	r0, r3, #29
 80190bc:	d512      	bpl.n	80190e4 <__swsetup_r+0x5c>
 80190be:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80190c0:	b141      	cbz	r1, 80190d4 <__swsetup_r+0x4c>
 80190c2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80190c6:	4299      	cmp	r1, r3
 80190c8:	d002      	beq.n	80190d0 <__swsetup_r+0x48>
 80190ca:	4628      	mov	r0, r5
 80190cc:	f7ff fa78 	bl	80185c0 <_free_r>
 80190d0:	2300      	movs	r3, #0
 80190d2:	6363      	str	r3, [r4, #52]	; 0x34
 80190d4:	89a3      	ldrh	r3, [r4, #12]
 80190d6:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80190da:	81a3      	strh	r3, [r4, #12]
 80190dc:	2300      	movs	r3, #0
 80190de:	6063      	str	r3, [r4, #4]
 80190e0:	6923      	ldr	r3, [r4, #16]
 80190e2:	6023      	str	r3, [r4, #0]
 80190e4:	89a3      	ldrh	r3, [r4, #12]
 80190e6:	f043 0308 	orr.w	r3, r3, #8
 80190ea:	81a3      	strh	r3, [r4, #12]
 80190ec:	6923      	ldr	r3, [r4, #16]
 80190ee:	b94b      	cbnz	r3, 8019104 <__swsetup_r+0x7c>
 80190f0:	89a3      	ldrh	r3, [r4, #12]
 80190f2:	f403 7320 	and.w	r3, r3, #640	; 0x280
 80190f6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80190fa:	d003      	beq.n	8019104 <__swsetup_r+0x7c>
 80190fc:	4621      	mov	r1, r4
 80190fe:	4628      	mov	r0, r5
 8019100:	f000 f8cd 	bl	801929e <__smakebuf_r>
 8019104:	89a0      	ldrh	r0, [r4, #12]
 8019106:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 801910a:	f010 0301 	ands.w	r3, r0, #1
 801910e:	d00a      	beq.n	8019126 <__swsetup_r+0x9e>
 8019110:	2300      	movs	r3, #0
 8019112:	60a3      	str	r3, [r4, #8]
 8019114:	6963      	ldr	r3, [r4, #20]
 8019116:	425b      	negs	r3, r3
 8019118:	61a3      	str	r3, [r4, #24]
 801911a:	6923      	ldr	r3, [r4, #16]
 801911c:	b943      	cbnz	r3, 8019130 <__swsetup_r+0xa8>
 801911e:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8019122:	d1c4      	bne.n	80190ae <__swsetup_r+0x26>
 8019124:	bd38      	pop	{r3, r4, r5, pc}
 8019126:	0781      	lsls	r1, r0, #30
 8019128:	bf58      	it	pl
 801912a:	6963      	ldrpl	r3, [r4, #20]
 801912c:	60a3      	str	r3, [r4, #8]
 801912e:	e7f4      	b.n	801911a <__swsetup_r+0x92>
 8019130:	2000      	movs	r0, #0
 8019132:	e7f7      	b.n	8019124 <__swsetup_r+0x9c>
 8019134:	2000016c 	.word	0x2000016c

08019138 <memmove>:
 8019138:	4288      	cmp	r0, r1
 801913a:	b510      	push	{r4, lr}
 801913c:	eb01 0402 	add.w	r4, r1, r2
 8019140:	d902      	bls.n	8019148 <memmove+0x10>
 8019142:	4284      	cmp	r4, r0
 8019144:	4623      	mov	r3, r4
 8019146:	d807      	bhi.n	8019158 <memmove+0x20>
 8019148:	1e43      	subs	r3, r0, #1
 801914a:	42a1      	cmp	r1, r4
 801914c:	d008      	beq.n	8019160 <memmove+0x28>
 801914e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8019152:	f803 2f01 	strb.w	r2, [r3, #1]!
 8019156:	e7f8      	b.n	801914a <memmove+0x12>
 8019158:	4402      	add	r2, r0
 801915a:	4601      	mov	r1, r0
 801915c:	428a      	cmp	r2, r1
 801915e:	d100      	bne.n	8019162 <memmove+0x2a>
 8019160:	bd10      	pop	{r4, pc}
 8019162:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8019166:	f802 4d01 	strb.w	r4, [r2, #-1]!
 801916a:	e7f7      	b.n	801915c <memmove+0x24>

0801916c <_raise_r>:
 801916c:	291f      	cmp	r1, #31
 801916e:	b538      	push	{r3, r4, r5, lr}
 8019170:	4604      	mov	r4, r0
 8019172:	460d      	mov	r5, r1
 8019174:	d904      	bls.n	8019180 <_raise_r+0x14>
 8019176:	2316      	movs	r3, #22
 8019178:	6003      	str	r3, [r0, #0]
 801917a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801917e:	bd38      	pop	{r3, r4, r5, pc}
 8019180:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8019182:	b112      	cbz	r2, 801918a <_raise_r+0x1e>
 8019184:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8019188:	b94b      	cbnz	r3, 801919e <_raise_r+0x32>
 801918a:	4620      	mov	r0, r4
 801918c:	f000 f830 	bl	80191f0 <_getpid_r>
 8019190:	462a      	mov	r2, r5
 8019192:	4601      	mov	r1, r0
 8019194:	4620      	mov	r0, r4
 8019196:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801919a:	f000 b817 	b.w	80191cc <_kill_r>
 801919e:	2b01      	cmp	r3, #1
 80191a0:	d00a      	beq.n	80191b8 <_raise_r+0x4c>
 80191a2:	1c59      	adds	r1, r3, #1
 80191a4:	d103      	bne.n	80191ae <_raise_r+0x42>
 80191a6:	2316      	movs	r3, #22
 80191a8:	6003      	str	r3, [r0, #0]
 80191aa:	2001      	movs	r0, #1
 80191ac:	e7e7      	b.n	801917e <_raise_r+0x12>
 80191ae:	2400      	movs	r4, #0
 80191b0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 80191b4:	4628      	mov	r0, r5
 80191b6:	4798      	blx	r3
 80191b8:	2000      	movs	r0, #0
 80191ba:	e7e0      	b.n	801917e <_raise_r+0x12>

080191bc <raise>:
 80191bc:	4b02      	ldr	r3, [pc, #8]	; (80191c8 <raise+0xc>)
 80191be:	4601      	mov	r1, r0
 80191c0:	6818      	ldr	r0, [r3, #0]
 80191c2:	f7ff bfd3 	b.w	801916c <_raise_r>
 80191c6:	bf00      	nop
 80191c8:	2000016c 	.word	0x2000016c

080191cc <_kill_r>:
 80191cc:	b538      	push	{r3, r4, r5, lr}
 80191ce:	4d07      	ldr	r5, [pc, #28]	; (80191ec <_kill_r+0x20>)
 80191d0:	2300      	movs	r3, #0
 80191d2:	4604      	mov	r4, r0
 80191d4:	4608      	mov	r0, r1
 80191d6:	4611      	mov	r1, r2
 80191d8:	602b      	str	r3, [r5, #0]
 80191da:	f7ef f843 	bl	8008264 <_kill>
 80191de:	1c43      	adds	r3, r0, #1
 80191e0:	d102      	bne.n	80191e8 <_kill_r+0x1c>
 80191e2:	682b      	ldr	r3, [r5, #0]
 80191e4:	b103      	cbz	r3, 80191e8 <_kill_r+0x1c>
 80191e6:	6023      	str	r3, [r4, #0]
 80191e8:	bd38      	pop	{r3, r4, r5, pc}
 80191ea:	bf00      	nop
 80191ec:	200028f0 	.word	0x200028f0

080191f0 <_getpid_r>:
 80191f0:	f7ef b830 	b.w	8008254 <_getpid>

080191f4 <_realloc_r>:
 80191f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80191f8:	4680      	mov	r8, r0
 80191fa:	4614      	mov	r4, r2
 80191fc:	460e      	mov	r6, r1
 80191fe:	b921      	cbnz	r1, 801920a <_realloc_r+0x16>
 8019200:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8019204:	4611      	mov	r1, r2
 8019206:	f7fe bee9 	b.w	8017fdc <_malloc_r>
 801920a:	b92a      	cbnz	r2, 8019218 <_realloc_r+0x24>
 801920c:	f7ff f9d8 	bl	80185c0 <_free_r>
 8019210:	4625      	mov	r5, r4
 8019212:	4628      	mov	r0, r5
 8019214:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8019218:	f000 f8a0 	bl	801935c <_malloc_usable_size_r>
 801921c:	4284      	cmp	r4, r0
 801921e:	4607      	mov	r7, r0
 8019220:	d802      	bhi.n	8019228 <_realloc_r+0x34>
 8019222:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 8019226:	d812      	bhi.n	801924e <_realloc_r+0x5a>
 8019228:	4621      	mov	r1, r4
 801922a:	4640      	mov	r0, r8
 801922c:	f7fe fed6 	bl	8017fdc <_malloc_r>
 8019230:	4605      	mov	r5, r0
 8019232:	2800      	cmp	r0, #0
 8019234:	d0ed      	beq.n	8019212 <_realloc_r+0x1e>
 8019236:	42bc      	cmp	r4, r7
 8019238:	4622      	mov	r2, r4
 801923a:	4631      	mov	r1, r6
 801923c:	bf28      	it	cs
 801923e:	463a      	movcs	r2, r7
 8019240:	f7ff f9a9 	bl	8018596 <memcpy>
 8019244:	4631      	mov	r1, r6
 8019246:	4640      	mov	r0, r8
 8019248:	f7ff f9ba 	bl	80185c0 <_free_r>
 801924c:	e7e1      	b.n	8019212 <_realloc_r+0x1e>
 801924e:	4635      	mov	r5, r6
 8019250:	e7df      	b.n	8019212 <_realloc_r+0x1e>

08019252 <__swhatbuf_r>:
 8019252:	b570      	push	{r4, r5, r6, lr}
 8019254:	460c      	mov	r4, r1
 8019256:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801925a:	2900      	cmp	r1, #0
 801925c:	b096      	sub	sp, #88	; 0x58
 801925e:	4615      	mov	r5, r2
 8019260:	461e      	mov	r6, r3
 8019262:	da0d      	bge.n	8019280 <__swhatbuf_r+0x2e>
 8019264:	89a3      	ldrh	r3, [r4, #12]
 8019266:	f013 0f80 	tst.w	r3, #128	; 0x80
 801926a:	f04f 0100 	mov.w	r1, #0
 801926e:	bf0c      	ite	eq
 8019270:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 8019274:	2340      	movne	r3, #64	; 0x40
 8019276:	2000      	movs	r0, #0
 8019278:	6031      	str	r1, [r6, #0]
 801927a:	602b      	str	r3, [r5, #0]
 801927c:	b016      	add	sp, #88	; 0x58
 801927e:	bd70      	pop	{r4, r5, r6, pc}
 8019280:	466a      	mov	r2, sp
 8019282:	f000 f849 	bl	8019318 <_fstat_r>
 8019286:	2800      	cmp	r0, #0
 8019288:	dbec      	blt.n	8019264 <__swhatbuf_r+0x12>
 801928a:	9901      	ldr	r1, [sp, #4]
 801928c:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 8019290:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 8019294:	4259      	negs	r1, r3
 8019296:	4159      	adcs	r1, r3
 8019298:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801929c:	e7eb      	b.n	8019276 <__swhatbuf_r+0x24>

0801929e <__smakebuf_r>:
 801929e:	898b      	ldrh	r3, [r1, #12]
 80192a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80192a2:	079d      	lsls	r5, r3, #30
 80192a4:	4606      	mov	r6, r0
 80192a6:	460c      	mov	r4, r1
 80192a8:	d507      	bpl.n	80192ba <__smakebuf_r+0x1c>
 80192aa:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80192ae:	6023      	str	r3, [r4, #0]
 80192b0:	6123      	str	r3, [r4, #16]
 80192b2:	2301      	movs	r3, #1
 80192b4:	6163      	str	r3, [r4, #20]
 80192b6:	b002      	add	sp, #8
 80192b8:	bd70      	pop	{r4, r5, r6, pc}
 80192ba:	ab01      	add	r3, sp, #4
 80192bc:	466a      	mov	r2, sp
 80192be:	f7ff ffc8 	bl	8019252 <__swhatbuf_r>
 80192c2:	9900      	ldr	r1, [sp, #0]
 80192c4:	4605      	mov	r5, r0
 80192c6:	4630      	mov	r0, r6
 80192c8:	f7fe fe88 	bl	8017fdc <_malloc_r>
 80192cc:	b948      	cbnz	r0, 80192e2 <__smakebuf_r+0x44>
 80192ce:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80192d2:	059a      	lsls	r2, r3, #22
 80192d4:	d4ef      	bmi.n	80192b6 <__smakebuf_r+0x18>
 80192d6:	f023 0303 	bic.w	r3, r3, #3
 80192da:	f043 0302 	orr.w	r3, r3, #2
 80192de:	81a3      	strh	r3, [r4, #12]
 80192e0:	e7e3      	b.n	80192aa <__smakebuf_r+0xc>
 80192e2:	89a3      	ldrh	r3, [r4, #12]
 80192e4:	6020      	str	r0, [r4, #0]
 80192e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80192ea:	81a3      	strh	r3, [r4, #12]
 80192ec:	9b00      	ldr	r3, [sp, #0]
 80192ee:	6163      	str	r3, [r4, #20]
 80192f0:	9b01      	ldr	r3, [sp, #4]
 80192f2:	6120      	str	r0, [r4, #16]
 80192f4:	b15b      	cbz	r3, 801930e <__smakebuf_r+0x70>
 80192f6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80192fa:	4630      	mov	r0, r6
 80192fc:	f000 f81e 	bl	801933c <_isatty_r>
 8019300:	b128      	cbz	r0, 801930e <__smakebuf_r+0x70>
 8019302:	89a3      	ldrh	r3, [r4, #12]
 8019304:	f023 0303 	bic.w	r3, r3, #3
 8019308:	f043 0301 	orr.w	r3, r3, #1
 801930c:	81a3      	strh	r3, [r4, #12]
 801930e:	89a3      	ldrh	r3, [r4, #12]
 8019310:	431d      	orrs	r5, r3
 8019312:	81a5      	strh	r5, [r4, #12]
 8019314:	e7cf      	b.n	80192b6 <__smakebuf_r+0x18>
	...

08019318 <_fstat_r>:
 8019318:	b538      	push	{r3, r4, r5, lr}
 801931a:	4d07      	ldr	r5, [pc, #28]	; (8019338 <_fstat_r+0x20>)
 801931c:	2300      	movs	r3, #0
 801931e:	4604      	mov	r4, r0
 8019320:	4608      	mov	r0, r1
 8019322:	4611      	mov	r1, r2
 8019324:	602b      	str	r3, [r5, #0]
 8019326:	f7ee ffe0 	bl	80082ea <_fstat>
 801932a:	1c43      	adds	r3, r0, #1
 801932c:	d102      	bne.n	8019334 <_fstat_r+0x1c>
 801932e:	682b      	ldr	r3, [r5, #0]
 8019330:	b103      	cbz	r3, 8019334 <_fstat_r+0x1c>
 8019332:	6023      	str	r3, [r4, #0]
 8019334:	bd38      	pop	{r3, r4, r5, pc}
 8019336:	bf00      	nop
 8019338:	200028f0 	.word	0x200028f0

0801933c <_isatty_r>:
 801933c:	b538      	push	{r3, r4, r5, lr}
 801933e:	4d06      	ldr	r5, [pc, #24]	; (8019358 <_isatty_r+0x1c>)
 8019340:	2300      	movs	r3, #0
 8019342:	4604      	mov	r4, r0
 8019344:	4608      	mov	r0, r1
 8019346:	602b      	str	r3, [r5, #0]
 8019348:	f7ee ffdf 	bl	800830a <_isatty>
 801934c:	1c43      	adds	r3, r0, #1
 801934e:	d102      	bne.n	8019356 <_isatty_r+0x1a>
 8019350:	682b      	ldr	r3, [r5, #0]
 8019352:	b103      	cbz	r3, 8019356 <_isatty_r+0x1a>
 8019354:	6023      	str	r3, [r4, #0]
 8019356:	bd38      	pop	{r3, r4, r5, pc}
 8019358:	200028f0 	.word	0x200028f0

0801935c <_malloc_usable_size_r>:
 801935c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8019360:	1f18      	subs	r0, r3, #4
 8019362:	2b00      	cmp	r3, #0
 8019364:	bfbc      	itt	lt
 8019366:	580b      	ldrlt	r3, [r1, r0]
 8019368:	18c0      	addlt	r0, r0, r3
 801936a:	4770      	bx	lr

0801936c <_init>:
 801936c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801936e:	bf00      	nop
 8019370:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8019372:	bc08      	pop	{r3}
 8019374:	469e      	mov	lr, r3
 8019376:	4770      	bx	lr

08019378 <_fini>:
 8019378:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801937a:	bf00      	nop
 801937c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801937e:	bc08      	pop	{r3}
 8019380:	469e      	mov	lr, r3
 8019382:	4770      	bx	lr
